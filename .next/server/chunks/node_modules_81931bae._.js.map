{"version":3,"sources":["../../../node_modules/%40stablelib/base64/base64.ts","../../../node_modules/fast-sha256/sha256.js","../../../node_modules/%40liveblocks/core/dist/index.js","../../../node_modules/next/dist/esm/build/templates/app-route.js","../../../app/api/liveblocks-auth/route.ts","../../../node_modules/%40liveblocks/node/dist/index.js"],"sourcesContent":["// Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\n\n/**\n * Package base64 implements Base64 encoding and decoding.\n */\n\n// Invalid character used in decoding to indicate\n// that the character to decode is out of range of\n// alphabet and cannot be decoded.\nconst INVALID_BYTE = 256;\n\n/**\n * Implements standard Base64 encoding.\n *\n * Operates in constant time.\n */\nexport class Coder {\n    // TODO(dchest): methods to encode chunk-by-chunk.\n\n    constructor(private _paddingCharacter = \"=\") { }\n\n    encodedLength(length: number): number {\n        if (!this._paddingCharacter) {\n            return (length * 8 + 5) / 6 | 0;\n        }\n        return (length + 2) / 3 * 4 | 0;\n    }\n\n    encode(data: Uint8Array): string {\n        let out = \"\";\n\n        let i = 0;\n        for (; i < data.length - 2; i += 3) {\n            let c = (data[i] << 16) | (data[i + 1] << 8) | (data[i + 2]);\n            out += this._encodeByte((c >>> 3 * 6) & 63);\n            out += this._encodeByte((c >>> 2 * 6) & 63);\n            out += this._encodeByte((c >>> 1 * 6) & 63);\n            out += this._encodeByte((c >>> 0 * 6) & 63);\n        }\n\n        const left = data.length - i;\n        if (left > 0) {\n            let c = (data[i] << 16) | (left === 2 ? data[i + 1] << 8 : 0);\n            out += this._encodeByte((c >>> 3 * 6) & 63);\n            out += this._encodeByte((c >>> 2 * 6) & 63);\n            if (left === 2) {\n                out += this._encodeByte((c >>> 1 * 6) & 63);\n            } else {\n                out += this._paddingCharacter || \"\";\n            }\n            out += this._paddingCharacter || \"\";\n        }\n\n        return out;\n    }\n\n    maxDecodedLength(length: number): number {\n        if (!this._paddingCharacter) {\n            return (length * 6 + 7) / 8 | 0;\n        }\n        return length / 4 * 3 | 0;\n    }\n\n    decodedLength(s: string): number {\n        return this.maxDecodedLength(s.length - this._getPaddingLength(s));\n    }\n\n    decode(s: string): Uint8Array {\n        if (s.length === 0) {\n            return new Uint8Array(0);\n        }\n        const paddingLength = this._getPaddingLength(s);\n        const length = s.length - paddingLength;\n        const out = new Uint8Array(this.maxDecodedLength(length));\n        let op = 0;\n        let i = 0;\n        let haveBad = 0;\n        let v0 = 0, v1 = 0, v2 = 0, v3 = 0;\n        for (; i < length - 4; i += 4) {\n            v0 = this._decodeChar(s.charCodeAt(i + 0));\n            v1 = this._decodeChar(s.charCodeAt(i + 1));\n            v2 = this._decodeChar(s.charCodeAt(i + 2));\n            v3 = this._decodeChar(s.charCodeAt(i + 3));\n            out[op++] = (v0 << 2) | (v1 >>> 4);\n            out[op++] = (v1 << 4) | (v2 >>> 2);\n            out[op++] = (v2 << 6) | v3;\n            haveBad |= v0 & INVALID_BYTE;\n            haveBad |= v1 & INVALID_BYTE;\n            haveBad |= v2 & INVALID_BYTE;\n            haveBad |= v3 & INVALID_BYTE;\n        }\n        if (i < length - 1) {\n            v0 = this._decodeChar(s.charCodeAt(i));\n            v1 = this._decodeChar(s.charCodeAt(i + 1));\n            out[op++] = (v0 << 2) | (v1 >>> 4);\n            haveBad |= v0 & INVALID_BYTE;\n            haveBad |= v1 & INVALID_BYTE;\n        }\n        if (i < length - 2) {\n            v2 = this._decodeChar(s.charCodeAt(i + 2));\n            out[op++] = (v1 << 4) | (v2 >>> 2);\n            haveBad |= v2 & INVALID_BYTE;\n        }\n        if (i < length - 3) {\n            v3 = this._decodeChar(s.charCodeAt(i + 3));\n            out[op++] = (v2 << 6) | v3;\n            haveBad |= v3 & INVALID_BYTE;\n        }\n        if (haveBad !== 0) {\n            throw new Error(\"Base64Coder: incorrect characters for decoding\");\n        }\n        return out;\n    }\n\n    // Standard encoding have the following encoded/decoded ranges,\n    // which we need to convert between.\n    //\n    // ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz 0123456789  +   /\n    // Index:   0 - 25                    26 - 51              52 - 61   62  63\n    // ASCII:  65 - 90                    97 - 122             48 - 57   43  47\n    //\n\n    // Encode 6 bits in b into a new character.\n    protected _encodeByte(b: number): string {\n        // Encoding uses constant time operations as follows:\n        //\n        // 1. Define comparison of A with B using (A - B) >>> 8:\n        //          if A > B, then result is positive integer\n        //          if A <= B, then result is 0\n        //\n        // 2. Define selection of C or 0 using bitwise AND: X & C:\n        //          if X == 0, then result is 0\n        //          if X != 0, then result is C\n        //\n        // 3. Start with the smallest comparison (b >= 0), which is always\n        //    true, so set the result to the starting ASCII value (65).\n        //\n        // 4. Continue comparing b to higher ASCII values, and selecting\n        //    zero if comparison isn't true, otherwise selecting a value\n        //    to add to result, which:\n        //\n        //          a) undoes the previous addition\n        //          b) provides new value to add\n        //\n        let result = b;\n        // b >= 0\n        result += 65;\n        // b > 25\n        result += ((25 - b) >>> 8) & ((0 - 65) - 26 + 97);\n        // b > 51\n        result += ((51 - b) >>> 8) & ((26 - 97) - 52 + 48);\n        // b > 61\n        result += ((61 - b) >>> 8) & ((52 - 48) - 62 + 43);\n        // b > 62\n        result += ((62 - b) >>> 8) & ((62 - 43) - 63 + 47);\n\n        return String.fromCharCode(result);\n    }\n\n    // Decode a character code into a byte.\n    // Must return 256 if character is out of alphabet range.\n    protected _decodeChar(c: number): number {\n        // Decoding works similar to encoding: using the same comparison\n        // function, but now it works on ranges: result is always incremented\n        // by value, but this value becomes zero if the range is not\n        // satisfied.\n        //\n        // Decoding starts with invalid value, 256, which is then\n        // subtracted when the range is satisfied. If none of the ranges\n        // apply, the function returns 256, which is then checked by\n        // the caller to throw error.\n        let result = INVALID_BYTE; // start with invalid character\n\n        // c == 43 (c > 42 and c < 44)\n        result += (((42 - c) & (c - 44)) >>> 8) & (-INVALID_BYTE + c - 43 + 62);\n        // c == 47 (c > 46 and c < 48)\n        result += (((46 - c) & (c - 48)) >>> 8) & (-INVALID_BYTE + c - 47 + 63);\n        // c > 47 and c < 58\n        result += (((47 - c) & (c - 58)) >>> 8) & (-INVALID_BYTE + c - 48 + 52);\n        // c > 64 and c < 91\n        result += (((64 - c) & (c - 91)) >>> 8) & (-INVALID_BYTE + c - 65 + 0);\n        // c > 96 and c < 123\n        result += (((96 - c) & (c - 123)) >>> 8) & (-INVALID_BYTE + c - 97 + 26);\n\n        return result;\n    }\n\n    private _getPaddingLength(s: string): number {\n        let paddingLength = 0;\n        if (this._paddingCharacter) {\n            for (let i = s.length - 1; i >= 0; i--) {\n                if (s[i] !== this._paddingCharacter) {\n                    break;\n                }\n                paddingLength++;\n            }\n            if (s.length < 4 || paddingLength > 2) {\n                throw new Error(\"Base64Coder: incorrect padding\");\n            }\n        }\n        return paddingLength;\n    }\n\n}\n\nconst stdCoder = new Coder();\n\nexport function encode(data: Uint8Array): string {\n    return stdCoder.encode(data);\n}\n\nexport function decode(s: string): Uint8Array {\n    return stdCoder.decode(s);\n}\n\n/**\n * Implements URL-safe Base64 encoding.\n * (Same as Base64, but '+' is replaced with '-', and '/' with '_').\n *\n * Operates in constant time.\n */\nexport class URLSafeCoder extends Coder {\n    // URL-safe encoding have the following encoded/decoded ranges:\n    //\n    // ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz 0123456789  -   _\n    // Index:   0 - 25                    26 - 51              52 - 61   62  63\n    // ASCII:  65 - 90                    97 - 122             48 - 57   45  95\n    //\n\n    protected _encodeByte(b: number): string {\n        let result = b;\n        // b >= 0\n        result += 65;\n        // b > 25\n        result += ((25 - b) >>> 8) & ((0 - 65) - 26 + 97);\n        // b > 51\n        result += ((51 - b) >>> 8) & ((26 - 97) - 52 + 48);\n        // b > 61\n        result += ((61 - b) >>> 8) & ((52 - 48) - 62 + 45);\n        // b > 62\n        result += ((62 - b) >>> 8) & ((62 - 45) - 63 + 95);\n\n        return String.fromCharCode(result);\n    }\n\n    protected _decodeChar(c: number): number {\n        let result = INVALID_BYTE;\n\n        // c == 45 (c > 44 and c < 46)\n        result += (((44 - c) & (c - 46)) >>> 8) & (-INVALID_BYTE + c - 45 + 62);\n        // c == 95 (c > 94 and c < 96)\n        result += (((94 - c) & (c - 96)) >>> 8) & (-INVALID_BYTE + c - 95 + 63);\n        // c > 47 and c < 58\n        result += (((47 - c) & (c - 58)) >>> 8) & (-INVALID_BYTE + c - 48 + 52);\n        // c > 64 and c < 91\n        result += (((64 - c) & (c - 91)) >>> 8) & (-INVALID_BYTE + c - 65 + 0);\n        // c > 96 and c < 123\n        result += (((96 - c) & (c - 123)) >>> 8) & (-INVALID_BYTE + c - 97 + 26);\n\n        return result;\n    }\n}\n\nconst urlSafeCoder = new URLSafeCoder();\n\nexport function encodeURLSafe(data: Uint8Array): string {\n    return urlSafeCoder.encode(data);\n}\n\nexport function decodeURLSafe(s: string): Uint8Array {\n    return urlSafeCoder.decode(s);\n}\n\n\nexport const encodedLength = (length: number) =>\n    stdCoder.encodedLength(length);\n\nexport const maxDecodedLength = (length: number) =>\n    stdCoder.maxDecodedLength(length);\n\nexport const decodedLength = (s: string) =>\n    stdCoder.decodedLength(s);\n","(function (root, factory) {\n    // Hack to make all exports of this module sha256 function object properties.\n    var exports = {};\n    factory(exports);\n    var sha256 = exports[\"default\"];\n    for (var k in exports) {\n        sha256[k] = exports[k];\n    }\n        \n    if (typeof module === 'object' && typeof module.exports === 'object') {\n        module.exports = sha256;\n    } else if (typeof define === 'function' && define.amd) {\n        define(function() { return sha256; }); \n    } else {\n        root.sha256 = sha256;\n    }\n})(this, function(exports) {\n\"use strict\";\nexports.__esModule = true;\n// SHA-256 (+ HMAC and PBKDF2) for JavaScript.\n//\n// Written in 2014-2016 by Dmitry Chestnykh.\n// Public domain, no warranty.\n//\n// Functions (accept and return Uint8Arrays):\n//\n//   sha256(message) -> hash\n//   sha256.hmac(key, message) -> mac\n//   sha256.pbkdf2(password, salt, rounds, dkLen) -> dk\n//\n//  Classes:\n//\n//   new sha256.Hash()\n//   new sha256.HMAC(key)\n//\nexports.digestLength = 32;\nexports.blockSize = 64;\n// SHA-256 constants\nvar K = new Uint32Array([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b,\n    0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01,\n    0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7,\n    0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,\n    0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152,\n    0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147,\n    0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc,\n    0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819,\n    0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08,\n    0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f,\n    0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,\n    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\nfunction hashBlocks(w, v, p, pos, len) {\n    var a, b, c, d, e, f, g, h, u, i, j, t1, t2;\n    while (len >= 64) {\n        a = v[0];\n        b = v[1];\n        c = v[2];\n        d = v[3];\n        e = v[4];\n        f = v[5];\n        g = v[6];\n        h = v[7];\n        for (i = 0; i < 16; i++) {\n            j = pos + i * 4;\n            w[i] = (((p[j] & 0xff) << 24) | ((p[j + 1] & 0xff) << 16) |\n                ((p[j + 2] & 0xff) << 8) | (p[j + 3] & 0xff));\n        }\n        for (i = 16; i < 64; i++) {\n            u = w[i - 2];\n            t1 = (u >>> 17 | u << (32 - 17)) ^ (u >>> 19 | u << (32 - 19)) ^ (u >>> 10);\n            u = w[i - 15];\n            t2 = (u >>> 7 | u << (32 - 7)) ^ (u >>> 18 | u << (32 - 18)) ^ (u >>> 3);\n            w[i] = (t1 + w[i - 7] | 0) + (t2 + w[i - 16] | 0);\n        }\n        for (i = 0; i < 64; i++) {\n            t1 = (((((e >>> 6 | e << (32 - 6)) ^ (e >>> 11 | e << (32 - 11)) ^\n                (e >>> 25 | e << (32 - 25))) + ((e & f) ^ (~e & g))) | 0) +\n                ((h + ((K[i] + w[i]) | 0)) | 0)) | 0;\n            t2 = (((a >>> 2 | a << (32 - 2)) ^ (a >>> 13 | a << (32 - 13)) ^\n                (a >>> 22 | a << (32 - 22))) + ((a & b) ^ (a & c) ^ (b & c))) | 0;\n            h = g;\n            g = f;\n            f = e;\n            e = (d + t1) | 0;\n            d = c;\n            c = b;\n            b = a;\n            a = (t1 + t2) | 0;\n        }\n        v[0] += a;\n        v[1] += b;\n        v[2] += c;\n        v[3] += d;\n        v[4] += e;\n        v[5] += f;\n        v[6] += g;\n        v[7] += h;\n        pos += 64;\n        len -= 64;\n    }\n    return pos;\n}\n// Hash implements SHA256 hash algorithm.\nvar Hash = /** @class */ (function () {\n    function Hash() {\n        this.digestLength = exports.digestLength;\n        this.blockSize = exports.blockSize;\n        // Note: Int32Array is used instead of Uint32Array for performance reasons.\n        this.state = new Int32Array(8); // hash state\n        this.temp = new Int32Array(64); // temporary state\n        this.buffer = new Uint8Array(128); // buffer for data to hash\n        this.bufferLength = 0; // number of bytes in buffer\n        this.bytesHashed = 0; // number of total bytes hashed\n        this.finished = false; // indicates whether the hash was finalized\n        this.reset();\n    }\n    // Resets hash state making it possible\n    // to re-use this instance to hash other data.\n    Hash.prototype.reset = function () {\n        this.state[0] = 0x6a09e667;\n        this.state[1] = 0xbb67ae85;\n        this.state[2] = 0x3c6ef372;\n        this.state[3] = 0xa54ff53a;\n        this.state[4] = 0x510e527f;\n        this.state[5] = 0x9b05688c;\n        this.state[6] = 0x1f83d9ab;\n        this.state[7] = 0x5be0cd19;\n        this.bufferLength = 0;\n        this.bytesHashed = 0;\n        this.finished = false;\n        return this;\n    };\n    // Cleans internal buffers and re-initializes hash state.\n    Hash.prototype.clean = function () {\n        for (var i = 0; i < this.buffer.length; i++) {\n            this.buffer[i] = 0;\n        }\n        for (var i = 0; i < this.temp.length; i++) {\n            this.temp[i] = 0;\n        }\n        this.reset();\n    };\n    // Updates hash state with the given data.\n    //\n    // Optionally, length of the data can be specified to hash\n    // fewer bytes than data.length.\n    //\n    // Throws error when trying to update already finalized hash:\n    // instance must be reset to use it again.\n    Hash.prototype.update = function (data, dataLength) {\n        if (dataLength === void 0) { dataLength = data.length; }\n        if (this.finished) {\n            throw new Error(\"SHA256: can't update because hash was finished.\");\n        }\n        var dataPos = 0;\n        this.bytesHashed += dataLength;\n        if (this.bufferLength > 0) {\n            while (this.bufferLength < 64 && dataLength > 0) {\n                this.buffer[this.bufferLength++] = data[dataPos++];\n                dataLength--;\n            }\n            if (this.bufferLength === 64) {\n                hashBlocks(this.temp, this.state, this.buffer, 0, 64);\n                this.bufferLength = 0;\n            }\n        }\n        if (dataLength >= 64) {\n            dataPos = hashBlocks(this.temp, this.state, data, dataPos, dataLength);\n            dataLength %= 64;\n        }\n        while (dataLength > 0) {\n            this.buffer[this.bufferLength++] = data[dataPos++];\n            dataLength--;\n        }\n        return this;\n    };\n    // Finalizes hash state and puts hash into out.\n    //\n    // If hash was already finalized, puts the same value.\n    Hash.prototype.finish = function (out) {\n        if (!this.finished) {\n            var bytesHashed = this.bytesHashed;\n            var left = this.bufferLength;\n            var bitLenHi = (bytesHashed / 0x20000000) | 0;\n            var bitLenLo = bytesHashed << 3;\n            var padLength = (bytesHashed % 64 < 56) ? 64 : 128;\n            this.buffer[left] = 0x80;\n            for (var i = left + 1; i < padLength - 8; i++) {\n                this.buffer[i] = 0;\n            }\n            this.buffer[padLength - 8] = (bitLenHi >>> 24) & 0xff;\n            this.buffer[padLength - 7] = (bitLenHi >>> 16) & 0xff;\n            this.buffer[padLength - 6] = (bitLenHi >>> 8) & 0xff;\n            this.buffer[padLength - 5] = (bitLenHi >>> 0) & 0xff;\n            this.buffer[padLength - 4] = (bitLenLo >>> 24) & 0xff;\n            this.buffer[padLength - 3] = (bitLenLo >>> 16) & 0xff;\n            this.buffer[padLength - 2] = (bitLenLo >>> 8) & 0xff;\n            this.buffer[padLength - 1] = (bitLenLo >>> 0) & 0xff;\n            hashBlocks(this.temp, this.state, this.buffer, 0, padLength);\n            this.finished = true;\n        }\n        for (var i = 0; i < 8; i++) {\n            out[i * 4 + 0] = (this.state[i] >>> 24) & 0xff;\n            out[i * 4 + 1] = (this.state[i] >>> 16) & 0xff;\n            out[i * 4 + 2] = (this.state[i] >>> 8) & 0xff;\n            out[i * 4 + 3] = (this.state[i] >>> 0) & 0xff;\n        }\n        return this;\n    };\n    // Returns the final hash digest.\n    Hash.prototype.digest = function () {\n        var out = new Uint8Array(this.digestLength);\n        this.finish(out);\n        return out;\n    };\n    // Internal function for use in HMAC for optimization.\n    Hash.prototype._saveState = function (out) {\n        for (var i = 0; i < this.state.length; i++) {\n            out[i] = this.state[i];\n        }\n    };\n    // Internal function for use in HMAC for optimization.\n    Hash.prototype._restoreState = function (from, bytesHashed) {\n        for (var i = 0; i < this.state.length; i++) {\n            this.state[i] = from[i];\n        }\n        this.bytesHashed = bytesHashed;\n        this.finished = false;\n        this.bufferLength = 0;\n    };\n    return Hash;\n}());\nexports.Hash = Hash;\n// HMAC implements HMAC-SHA256 message authentication algorithm.\nvar HMAC = /** @class */ (function () {\n    function HMAC(key) {\n        this.inner = new Hash();\n        this.outer = new Hash();\n        this.blockSize = this.inner.blockSize;\n        this.digestLength = this.inner.digestLength;\n        var pad = new Uint8Array(this.blockSize);\n        if (key.length > this.blockSize) {\n            (new Hash()).update(key).finish(pad).clean();\n        }\n        else {\n            for (var i = 0; i < key.length; i++) {\n                pad[i] = key[i];\n            }\n        }\n        for (var i = 0; i < pad.length; i++) {\n            pad[i] ^= 0x36;\n        }\n        this.inner.update(pad);\n        for (var i = 0; i < pad.length; i++) {\n            pad[i] ^= 0x36 ^ 0x5c;\n        }\n        this.outer.update(pad);\n        this.istate = new Uint32Array(8);\n        this.ostate = new Uint32Array(8);\n        this.inner._saveState(this.istate);\n        this.outer._saveState(this.ostate);\n        for (var i = 0; i < pad.length; i++) {\n            pad[i] = 0;\n        }\n    }\n    // Returns HMAC state to the state initialized with key\n    // to make it possible to run HMAC over the other data with the same\n    // key without creating a new instance.\n    HMAC.prototype.reset = function () {\n        this.inner._restoreState(this.istate, this.inner.blockSize);\n        this.outer._restoreState(this.ostate, this.outer.blockSize);\n        return this;\n    };\n    // Cleans HMAC state.\n    HMAC.prototype.clean = function () {\n        for (var i = 0; i < this.istate.length; i++) {\n            this.ostate[i] = this.istate[i] = 0;\n        }\n        this.inner.clean();\n        this.outer.clean();\n    };\n    // Updates state with provided data.\n    HMAC.prototype.update = function (data) {\n        this.inner.update(data);\n        return this;\n    };\n    // Finalizes HMAC and puts the result in out.\n    HMAC.prototype.finish = function (out) {\n        if (this.outer.finished) {\n            this.outer.finish(out);\n        }\n        else {\n            this.inner.finish(out);\n            this.outer.update(out, this.digestLength).finish(out);\n        }\n        return this;\n    };\n    // Returns message authentication code.\n    HMAC.prototype.digest = function () {\n        var out = new Uint8Array(this.digestLength);\n        this.finish(out);\n        return out;\n    };\n    return HMAC;\n}());\nexports.HMAC = HMAC;\n// Returns SHA256 hash of data.\nfunction hash(data) {\n    var h = (new Hash()).update(data);\n    var digest = h.digest();\n    h.clean();\n    return digest;\n}\nexports.hash = hash;\n// Function hash is both available as module.hash and as default export.\nexports[\"default\"] = hash;\n// Returns HMAC-SHA256 of data under the key.\nfunction hmac(key, data) {\n    var h = (new HMAC(key)).update(data);\n    var digest = h.digest();\n    h.clean();\n    return digest;\n}\nexports.hmac = hmac;\n// Fills hkdf buffer like this:\n// T(1) = HMAC-Hash(PRK, T(0) | info | 0x01)\nfunction fillBuffer(buffer, hmac, info, counter) {\n    // Counter is a byte value: check if it overflowed.\n    var num = counter[0];\n    if (num === 0) {\n        throw new Error(\"hkdf: cannot expand more\");\n    }\n    // Prepare HMAC instance for new data with old key.\n    hmac.reset();\n    // Hash in previous output if it was generated\n    // (i.e. counter is greater than 1).\n    if (num > 1) {\n        hmac.update(buffer);\n    }\n    // Hash in info if it exists.\n    if (info) {\n        hmac.update(info);\n    }\n    // Hash in the counter.\n    hmac.update(counter);\n    // Output result to buffer and clean HMAC instance.\n    hmac.finish(buffer);\n    // Increment counter inside typed array, this works properly.\n    counter[0]++;\n}\nvar hkdfSalt = new Uint8Array(exports.digestLength); // Filled with zeroes.\nfunction hkdf(key, salt, info, length) {\n    if (salt === void 0) { salt = hkdfSalt; }\n    if (length === void 0) { length = 32; }\n    var counter = new Uint8Array([1]);\n    // HKDF-Extract uses salt as HMAC key, and key as data.\n    var okm = hmac(salt, key);\n    // Initialize HMAC for expanding with extracted key.\n    // Ensure no collisions with `hmac` function.\n    var hmac_ = new HMAC(okm);\n    // Allocate buffer.\n    var buffer = new Uint8Array(hmac_.digestLength);\n    var bufpos = buffer.length;\n    var out = new Uint8Array(length);\n    for (var i = 0; i < length; i++) {\n        if (bufpos === buffer.length) {\n            fillBuffer(buffer, hmac_, info, counter);\n            bufpos = 0;\n        }\n        out[i] = buffer[bufpos++];\n    }\n    hmac_.clean();\n    buffer.fill(0);\n    counter.fill(0);\n    return out;\n}\nexports.hkdf = hkdf;\n// Derives a key from password and salt using PBKDF2-HMAC-SHA256\n// with the given number of iterations.\n//\n// The number of bytes returned is equal to dkLen.\n//\n// (For better security, avoid dkLen greater than hash length - 32 bytes).\nfunction pbkdf2(password, salt, iterations, dkLen) {\n    var prf = new HMAC(password);\n    var len = prf.digestLength;\n    var ctr = new Uint8Array(4);\n    var t = new Uint8Array(len);\n    var u = new Uint8Array(len);\n    var dk = new Uint8Array(dkLen);\n    for (var i = 0; i * len < dkLen; i++) {\n        var c = i + 1;\n        ctr[0] = (c >>> 24) & 0xff;\n        ctr[1] = (c >>> 16) & 0xff;\n        ctr[2] = (c >>> 8) & 0xff;\n        ctr[3] = (c >>> 0) & 0xff;\n        prf.reset();\n        prf.update(salt);\n        prf.update(ctr);\n        prf.finish(u);\n        for (var j = 0; j < len; j++) {\n            t[j] = u[j];\n        }\n        for (var j = 2; j <= iterations; j++) {\n            prf.reset();\n            prf.update(u).finish(u);\n            for (var k = 0; k < len; k++) {\n                t[k] ^= u[k];\n            }\n        }\n        for (var j = 0; j < len && i * len + j < dkLen; j++) {\n            dk[i * len + j] = t[j];\n        }\n    }\n    for (var i = 0; i < len; i++) {\n        t[i] = u[i] = 0;\n    }\n    for (var i = 0; i < 4; i++) {\n        ctr[i] = 0;\n    }\n    prf.clean();\n    return dk;\n}\nexports.pbkdf2 = pbkdf2;\n});\n","var __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// src/version.ts\nvar PKG_NAME = \"@liveblocks/core\";\nvar PKG_VERSION = \"3.14.0\";\nvar PKG_FORMAT = \"esm\";\n\n// src/dupe-detection.ts\nvar g = typeof globalThis !== \"undefined\" ? globalThis : typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : {};\nvar crossLinkedDocs = \"https://liveblocks.io/docs/errors/cross-linked\";\nvar dupesDocs = \"https://liveblocks.io/docs/errors/dupes\";\nvar SPACE = \" \";\nfunction error(msg) {\n  if (process.env.NODE_ENV === \"production\") {\n    console.error(msg);\n  } else {\n    throw new Error(msg);\n  }\n}\nfunction detectDupes(pkgName, pkgVersion, pkgFormat) {\n  const pkgId = Symbol.for(pkgName);\n  const pkgBuildInfo = pkgFormat ? `${pkgVersion || \"dev\"} (${pkgFormat})` : pkgVersion || \"dev\";\n  if (!g[pkgId]) {\n    g[pkgId] = pkgBuildInfo;\n  } else if (g[pkgId] === pkgBuildInfo) {\n  } else {\n    const msg = [\n      `Multiple copies of Liveblocks are being loaded in your project. This will cause issues! See ${dupesDocs + SPACE}`,\n      \"\",\n      \"Conflicts:\",\n      `- ${pkgName} ${g[pkgId]} (already loaded)`,\n      `- ${pkgName} ${pkgBuildInfo} (trying to load this now)`\n    ].join(\"\\n\");\n    error(msg);\n  }\n  if (pkgVersion && PKG_VERSION && pkgVersion !== PKG_VERSION) {\n    error(\n      [\n        `Cross-linked versions of Liveblocks found, which will cause issues! See ${crossLinkedDocs + SPACE}`,\n        \"\",\n        \"Conflicts:\",\n        `- ${PKG_NAME} is at ${PKG_VERSION}`,\n        `- ${pkgName} is at ${pkgVersion}`,\n        \"\",\n        \"Always upgrade all Liveblocks packages to the same version number.\"\n      ].join(\"\\n\")\n    );\n  }\n}\n\n// src/lib/EventSource.ts\nfunction makeEventSource() {\n  const _observers = /* @__PURE__ */ new Set();\n  function subscribe(callback) {\n    _observers.add(callback);\n    return () => _observers.delete(callback);\n  }\n  function subscribeOnce(callback) {\n    const unsub = subscribe((event) => {\n      unsub();\n      return callback(event);\n    });\n    return unsub;\n  }\n  async function waitUntil(predicate) {\n    let unsub;\n    return new Promise((res) => {\n      unsub = subscribe((event) => {\n        if (predicate === void 0 || predicate(event)) {\n          res(event);\n        }\n      });\n    }).finally(() => unsub?.());\n  }\n  function notify(event) {\n    let called = false;\n    for (const callback of _observers) {\n      callback(event);\n      called = true;\n    }\n    return called;\n  }\n  function count() {\n    return _observers.size;\n  }\n  return {\n    // Private/internal control over event emission\n    notify,\n    subscribe,\n    subscribeOnce,\n    count,\n    waitUntil,\n    dispose() {\n      _observers.clear();\n    },\n    // Publicly exposable subscription API\n    observable: {\n      subscribe,\n      subscribeOnce,\n      waitUntil\n    }\n  };\n}\nfunction makeBufferableEventSource() {\n  const eventSource2 = makeEventSource();\n  let _buffer = null;\n  function pause() {\n    _buffer = [];\n  }\n  function unpause() {\n    if (_buffer === null) {\n      return;\n    }\n    for (const event of _buffer) {\n      eventSource2.notify(event);\n    }\n    _buffer = null;\n  }\n  function notifyOrBuffer(event) {\n    if (_buffer !== null) {\n      _buffer.push(event);\n      return false;\n    } else {\n      return eventSource2.notify(event);\n    }\n  }\n  return {\n    ...eventSource2,\n    notify: notifyOrBuffer,\n    pause,\n    unpause,\n    dispose() {\n      eventSource2.dispose();\n      if (_buffer !== null) {\n        _buffer.length = 0;\n      }\n    }\n  };\n}\n\n// src/lib/freeze.ts\nvar freeze = process.env.NODE_ENV === \"production\" ? (\n  /* istanbul ignore next */\n  (x) => x\n) : Object.freeze;\n\n// src/lib/utils.ts\nfunction raise(msg) {\n  throw new Error(msg);\n}\nfunction entries(obj) {\n  return Object.entries(obj);\n}\nfunction keys(obj) {\n  return Object.keys(obj);\n}\nfunction values(obj) {\n  return Object.values(obj);\n}\nfunction create(obj, descriptors) {\n  if (typeof descriptors !== \"undefined\") {\n    return Object.create(obj, descriptors);\n  }\n  return Object.create(obj);\n}\nfunction mapValues(obj, mapFn) {\n  const result = {};\n  for (const pair of Object.entries(obj)) {\n    const key = pair[0];\n    if (key === \"__proto__\") {\n      continue;\n    }\n    const value = pair[1];\n    result[key] = mapFn(value, key);\n  }\n  return result;\n}\nfunction tryParseJson(rawMessage) {\n  try {\n    return JSON.parse(rawMessage);\n  } catch (e) {\n    return void 0;\n  }\n}\nfunction deepClone(value) {\n  return JSON.parse(JSON.stringify(value));\n}\nfunction b64decode(b64value) {\n  try {\n    const formattedValue = b64value.replace(/-/g, \"+\").replace(/_/g, \"/\");\n    const decodedValue = decodeURIComponent(\n      atob(formattedValue).split(\"\").map(function(c) {\n        return \"%\" + (\"00\" + c.charCodeAt(0).toString(16)).slice(-2);\n      }).join(\"\")\n    );\n    return decodedValue;\n  } catch (err) {\n    return atob(b64value);\n  }\n}\nfunction compact(items) {\n  return items.filter(\n    (item) => item !== null && item !== void 0\n  );\n}\nfunction compactObject(obj) {\n  const newObj = { ...obj };\n  Object.keys(obj).forEach((k) => {\n    const key = k;\n    if (newObj[key] === void 0) {\n      delete newObj[key];\n    }\n  });\n  return newObj;\n}\nfunction wait(millis) {\n  return new Promise((res) => setTimeout(res, millis));\n}\nasync function withTimeout(promise, millis, errmsg) {\n  let timerID;\n  const timer$ = new Promise((_, reject) => {\n    timerID = setTimeout(() => {\n      reject(new Error(errmsg));\n    }, millis);\n  });\n  return Promise.race([promise, timer$]).finally(() => clearTimeout(timerID));\n}\nfunction memoizeOnSuccess(factoryFn) {\n  let cached = null;\n  return () => {\n    if (cached === null) {\n      cached = factoryFn().catch((err) => {\n        setTimeout(() => {\n          cached = null;\n        }, 5e3);\n        throw err;\n      });\n    }\n    return cached;\n  };\n}\nfunction findLastIndex(arr, predicate) {\n  for (let i = arr.length - 1; i >= 0; i--) {\n    if (predicate(arr[i], i, arr)) {\n      return i;\n    }\n  }\n  return -1;\n}\nfunction partition(iterable, predicate) {\n  const good = [];\n  const bad = [];\n  let index = 0;\n  for (const item of iterable) {\n    if (predicate(item, index++)) {\n      good.push(item);\n    } else {\n      bad.push(item);\n    }\n  }\n  return [good, bad];\n}\n\n// src/lib/signals.ts\nvar kSinks = Symbol(\"kSinks\");\nvar kTrigger = Symbol(\"kTrigger\");\nvar signalsToTrigger = null;\nvar trackedReads = null;\nfunction batch(callback) {\n  if (signalsToTrigger !== null) {\n    callback();\n    return;\n  }\n  signalsToTrigger = /* @__PURE__ */ new Set();\n  try {\n    callback();\n  } finally {\n    for (const signal of signalsToTrigger) {\n      signal[kTrigger]();\n    }\n    signalsToTrigger = null;\n  }\n}\nfunction enqueueTrigger(signal) {\n  if (!signalsToTrigger) raise(\"Expected to be in an active batch\");\n  signalsToTrigger.add(signal);\n}\nfunction merge(target, patch) {\n  let updated = false;\n  const newValue = { ...target };\n  Object.keys(patch).forEach((k) => {\n    const key = k;\n    const val = patch[key];\n    if (newValue[key] !== val) {\n      if (val === void 0) {\n        delete newValue[key];\n      } else {\n        newValue[key] = val;\n      }\n      updated = true;\n    }\n  });\n  return updated ? newValue : target;\n}\nvar AbstractSignal = class {\n  /** @internal */\n  equals;\n  #eventSource;\n  /** @internal */\n  [kSinks];\n  constructor(equals) {\n    this.equals = equals ?? Object.is;\n    this.#eventSource = makeEventSource();\n    this[kSinks] = /* @__PURE__ */ new Set();\n    this.get = this.get.bind(this);\n    this.subscribe = this.subscribe.bind(this);\n    this.subscribeOnce = this.subscribeOnce.bind(this);\n  }\n  dispose() {\n    this.#eventSource.dispose();\n    this.#eventSource = \"(disposed)\";\n    this.equals = \"(disposed)\";\n  }\n  get hasWatchers() {\n    if (this.#eventSource.count() > 0) return true;\n    for (const sink of this[kSinks]) {\n      if (sink.hasWatchers) {\n        return true;\n      }\n    }\n    return false;\n  }\n  [kTrigger]() {\n    this.#eventSource.notify();\n    for (const sink of this[kSinks]) {\n      enqueueTrigger(sink);\n    }\n  }\n  subscribe(callback) {\n    if (this.#eventSource.count() === 0) {\n      this.get();\n    }\n    return this.#eventSource.subscribe(callback);\n  }\n  subscribeOnce(callback) {\n    const unsub = this.subscribe(() => {\n      unsub();\n      return callback();\n    });\n    return unsub;\n  }\n  waitUntil() {\n    throw new Error(\"waitUntil not supported on Signals\");\n  }\n  markSinksDirty() {\n    for (const sink of this[kSinks]) {\n      sink.markDirty();\n    }\n  }\n  addSink(sink) {\n    this[kSinks].add(sink);\n  }\n  removeSink(sink) {\n    this[kSinks].delete(sink);\n  }\n  asReadonly() {\n    return this;\n  }\n};\nvar Signal = class extends AbstractSignal {\n  #value;\n  constructor(value, equals) {\n    super(equals);\n    this.#value = freeze(value);\n  }\n  dispose() {\n    super.dispose();\n    this.#value = \"(disposed)\";\n  }\n  get() {\n    trackedReads?.add(this);\n    return this.#value;\n  }\n  set(newValue) {\n    batch(() => {\n      if (typeof newValue === \"function\") {\n        newValue = newValue(this.#value);\n      }\n      if (!this.equals(this.#value, newValue)) {\n        this.#value = freeze(newValue);\n        this.markSinksDirty();\n        enqueueTrigger(this);\n      }\n    });\n  }\n};\nvar PatchableSignal = class extends Signal {\n  constructor(data) {\n    super(freeze(compactObject(data)));\n  }\n  set() {\n    throw new Error(\"Don't call .set() directly, use .patch()\");\n  }\n  /**\n   * Patches the current object.\n   */\n  patch(patch) {\n    super.set((old) => merge(old, patch));\n  }\n};\nvar INITIAL = Symbol();\nvar DerivedSignal = class _DerivedSignal extends AbstractSignal {\n  #prevValue;\n  #dirty;\n  // When true, the value in #value may not be up-to-date and needs re-checking\n  #sources;\n  #deps;\n  #transform;\n  // prettier-ignore\n  static from(...args) {\n    const last = args.pop();\n    if (typeof last !== \"function\")\n      raise(\"Invalid .from() call, last argument expected to be a function\");\n    if (typeof args[args.length - 1] === \"function\") {\n      const equals = last;\n      const transform = args.pop();\n      return new _DerivedSignal(args, transform, equals);\n    } else {\n      const transform = last;\n      return new _DerivedSignal(args, transform);\n    }\n  }\n  constructor(deps, transform, equals) {\n    super(equals);\n    this.#dirty = true;\n    this.#prevValue = INITIAL;\n    this.#deps = deps;\n    this.#sources = /* @__PURE__ */ new Set();\n    this.#transform = transform;\n  }\n  dispose() {\n    for (const src of this.#sources) {\n      src.removeSink(this);\n    }\n    this.#prevValue = \"(disposed)\";\n    this.#sources = \"(disposed)\";\n    this.#deps = \"(disposed)\";\n    this.#transform = \"(disposed)\";\n  }\n  get isDirty() {\n    return this.#dirty;\n  }\n  #recompute() {\n    const oldTrackedReads = trackedReads;\n    let derived;\n    trackedReads = /* @__PURE__ */ new Set();\n    try {\n      derived = this.#transform(...this.#deps.map((p) => p.get()));\n    } finally {\n      const oldSources = this.#sources;\n      this.#sources = /* @__PURE__ */ new Set();\n      for (const sig of trackedReads) {\n        this.#sources.add(sig);\n        oldSources.delete(sig);\n      }\n      for (const oldSource of oldSources) {\n        oldSource.removeSink(this);\n      }\n      for (const newSource of this.#sources) {\n        newSource.addSink(this);\n      }\n      trackedReads = oldTrackedReads;\n    }\n    this.#dirty = false;\n    if (!this.equals(this.#prevValue, derived)) {\n      this.#prevValue = derived;\n      return true;\n    }\n    return false;\n  }\n  markDirty() {\n    if (!this.#dirty) {\n      this.#dirty = true;\n      this.markSinksDirty();\n    }\n  }\n  get() {\n    if (this.#dirty) {\n      this.#recompute();\n    }\n    trackedReads?.add(this);\n    return this.#prevValue;\n  }\n  /**\n   * Called by the Signal system if one or more of the dependent signals have\n   * changed. In the case of a DerivedSignal, we'll only want to re-evaluate\n   * the actual value if it's being watched, or any of their sinks are being\n   * watched actively.\n   */\n  [kTrigger]() {\n    if (!this.hasWatchers) {\n      return;\n    }\n    const updated = this.#recompute();\n    if (updated) {\n      super[kTrigger]();\n    }\n  }\n};\nvar MutableSignal = class extends AbstractSignal {\n  #state;\n  constructor(initialState) {\n    super();\n    this.#state = initialState;\n  }\n  dispose() {\n    super.dispose();\n    this.#state = \"(disposed)\";\n  }\n  get() {\n    trackedReads?.add(this);\n    return this.#state;\n  }\n  /**\n   * Invokes a callback function that is allowed to mutate the given state\n   * value. Do not change the value outside of the callback.\n   *\n   * If the callback explicitly returns `false`, it's assumed that the state\n   * was not changed.\n   */\n  mutate(callback) {\n    batch(() => {\n      const result = callback ? callback(this.#state) : true;\n      if (result !== null && typeof result === \"object\" && \"then\" in result) {\n        raise(\"MutableSignal.mutate() does not support async callbacks\");\n      }\n      if (result !== false) {\n        this.markSinksDirty();\n        enqueueTrigger(this);\n      }\n    });\n  }\n};\n\n// src/lib/SortedList.ts\nfunction bisectRight(arr, x, lt) {\n  let lo = 0;\n  let hi = arr.length;\n  while (lo < hi) {\n    const mid = lo + (hi - lo >> 1);\n    if (lt(x, arr[mid])) {\n      hi = mid;\n    } else {\n      lo = mid + 1;\n    }\n  }\n  return lo;\n}\nvar SortedList = class _SortedList {\n  #data;\n  #lt;\n  constructor(alreadySortedList, lt) {\n    this.#lt = lt;\n    this.#data = alreadySortedList;\n  }\n  /**\n   * Creates an empty SortedList with the given \"less than\" function.\n   */\n  static with(lt) {\n    return _SortedList.fromAlreadySorted([], lt);\n  }\n  static from(arr, lt) {\n    const sorted = new _SortedList([], lt);\n    for (const item of arr) {\n      sorted.add(item);\n    }\n    return sorted;\n  }\n  static fromAlreadySorted(alreadySorted, lt) {\n    return new _SortedList(alreadySorted, lt);\n  }\n  /**\n   * Clones the sorted list to a new instance.\n   */\n  clone() {\n    return new _SortedList(this.#data.slice(), this.#lt);\n  }\n  /**\n   * Adds a new item to the sorted list, such that it remains sorted.\n   * Returns the index where the item was inserted.\n   */\n  add(value) {\n    const idx = bisectRight(this.#data, value, this.#lt);\n    this.#data.splice(idx, 0, value);\n    return idx;\n  }\n  /**\n   * Removes all values from the sorted list, making it empty again.\n   * Returns whether the list was mutated or not.\n   */\n  clear() {\n    const hadData = this.#data.length > 0;\n    this.#data.length = 0;\n    return hadData;\n  }\n  /**\n   * Removes the first value matching the predicate.\n   * Returns whether the list was mutated or not.\n   */\n  removeBy(predicate, limit = Number.POSITIVE_INFINITY) {\n    let deleted = 0;\n    for (let i = 0; i < this.#data.length; i++) {\n      if (predicate(this.#data[i])) {\n        this.#data.splice(i, 1);\n        deleted++;\n        if (deleted >= limit) {\n          break;\n        } else {\n          i--;\n        }\n      }\n    }\n    return deleted > 0;\n  }\n  /**\n   * Removes the given value from the sorted list, if it exists. The given\n   * value must be `===` to one of the list items. Only the first entry will be\n   * removed if the element exists in the sorted list multiple times.\n   *\n   * Returns whether the list was mutated or not.\n   */\n  remove(value) {\n    const idx = this.#data.indexOf(value);\n    if (idx >= 0) {\n      this.#data.splice(idx, 1);\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Removes the item at the given index.\n   * Returns the removed item, or undefined if index is out of bounds.\n   */\n  removeAt(index) {\n    if (index < 0 || index >= this.#data.length) {\n      return void 0;\n    }\n    const [removed] = this.#data.splice(index, 1);\n    return removed;\n  }\n  /**\n   * Repositions an item to maintain sorted order after its sort key has\n   * been mutated in-place. For example:\n   *\n   *   const item = sorted.at(3);\n   *   item.updatedAt = new Date();  // mutate the item's sort key in-place\n   *   sorted.reposition(item);      // restore sorted order\n   *\n   * Returns the new index of the item. Throws if the item is not in the list.\n   *\n   * Semantically equivalent to remove(value) + add(value), but optimized\n   * to avoid array shifting when the item only moves a short distance.\n   */\n  reposition(value) {\n    const oldIdx = this.#data.indexOf(value);\n    if (oldIdx < 0) {\n      throw new Error(\"Cannot reposition item that is not in the list\");\n    }\n    const prev = this.#data[oldIdx - 1];\n    const next = this.#data[oldIdx + 1];\n    const validLeft = prev === void 0 || this.#lt(prev, value);\n    const validRight = next === void 0 || this.#lt(value, next);\n    if (validLeft && validRight) {\n      return oldIdx;\n    }\n    let newIdx = oldIdx;\n    while (newIdx > 0 && this.#lt(value, this.#data[newIdx - 1])) {\n      this.#data[newIdx] = this.#data[newIdx - 1];\n      newIdx--;\n    }\n    if (newIdx < oldIdx) {\n      this.#data[newIdx] = value;\n      return newIdx;\n    }\n    while (newIdx < this.#data.length - 1 && !this.#lt(value, this.#data[newIdx + 1])) {\n      this.#data[newIdx] = this.#data[newIdx + 1];\n      newIdx++;\n    }\n    if (newIdx !== oldIdx) {\n      this.#data[newIdx] = value;\n    }\n    return newIdx;\n  }\n  at(index) {\n    return this.#data[index];\n  }\n  get length() {\n    return this.#data.length;\n  }\n  *filter(predicate) {\n    for (const item of this.#data) {\n      if (predicate(item)) {\n        yield item;\n      }\n    }\n  }\n  // XXXX If we keep this, add unit tests. Or remove it.\n  *findAllRight(predicate) {\n    for (let i = this.#data.length - 1; i >= 0; i--) {\n      const item = this.#data[i];\n      if (predicate(item, i)) {\n        yield item;\n      }\n    }\n  }\n  [Symbol.iterator]() {\n    return this.#data[Symbol.iterator]();\n  }\n  *iterReversed() {\n    for (let i = this.#data.length - 1; i >= 0; i--) {\n      yield this.#data[i];\n    }\n  }\n  /** Finds the leftmost item that matches the predicate. */\n  find(predicate, start) {\n    const idx = this.findIndex(predicate, start);\n    return idx > -1 ? this.#data.at(idx) : void 0;\n  }\n  /** Finds the leftmost index that matches the predicate. */\n  findIndex(predicate, start = 0) {\n    for (let i = Math.max(0, start); i < this.#data.length; i++) {\n      if (predicate(this.#data[i], i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n  /** Finds the rightmost item that matches the predicate. */\n  findRight(predicate, start) {\n    const idx = this.findIndexRight(predicate, start);\n    return idx > -1 ? this.#data.at(idx) : void 0;\n  }\n  /** Finds the rightmost index that matches the predicate. */\n  findIndexRight(predicate, start = this.#data.length - 1) {\n    for (let i = Math.min(start, this.#data.length - 1); i >= 0; i--) {\n      if (predicate(this.#data[i], i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n  get rawArray() {\n    return this.#data;\n  }\n};\n\n// src/AiChatDB.ts\nvar AiChatDB = class {\n  #byId;\n  // A map of chat id to chat details\n  #chats;\n  // Sorted list of non-deleted chats, most recent first\n  signal;\n  constructor() {\n    this.#byId = /* @__PURE__ */ new Map();\n    this.#chats = SortedList.from([], (c1, c2) => {\n      const d2 = c2.lastMessageAt ?? c2.createdAt;\n      const d1 = c1.lastMessageAt ?? c1.createdAt;\n      return d2 < d1 ? true : d2 === d1 ? c2.id < c1.id : false;\n    });\n    this.signal = new MutableSignal(this);\n  }\n  getEvenIfDeleted(chatId) {\n    this.signal.get();\n    return this.#byId.get(chatId);\n  }\n  markDeleted(chatId) {\n    const chat = this.#byId.get(chatId);\n    if (chat === void 0 || chat.deletedAt !== void 0) return;\n    this.upsert({\n      ...chat,\n      deletedAt: (/* @__PURE__ */ new Date()).toISOString()\n    });\n  }\n  upsert(chat) {\n    this.signal.mutate(() => {\n      const existingThread = this.#byId.get(chat.id);\n      if (existingThread !== void 0) {\n        if (existingThread.deletedAt !== void 0) return false;\n        this.#chats.remove(existingThread);\n        this.#byId.delete(existingThread.id);\n      }\n      if (chat.deletedAt === void 0) {\n        this.#chats.add(chat);\n      }\n      this.#byId.set(chat.id, chat);\n      return true;\n    });\n  }\n  findMany(query) {\n    return Array.from(\n      this.#chats.filter((chat) => {\n        if (query.metadata === void 0) return true;\n        for (const [key, value] of Object.entries(query.metadata)) {\n          if (value === null) {\n            if (key in chat.metadata) return false;\n          } else if (typeof value === \"string\") {\n            if (chat.metadata[key] !== value) return false;\n          } else {\n            const chatValue = chat.metadata[key];\n            if (!Array.isArray(chatValue) || !value.every((v) => chatValue.includes(v))) {\n              return false;\n            }\n          }\n        }\n        return true;\n      })\n    );\n  }\n};\n\n// src/convert-plain-data.ts\nfunction convertToCommentData(data) {\n  const editedAt = data.editedAt ? new Date(data.editedAt) : void 0;\n  const createdAt = new Date(data.createdAt);\n  const reactions = data.reactions.map((reaction) => ({\n    ...reaction,\n    createdAt: new Date(reaction.createdAt)\n  }));\n  if (data.body) {\n    return {\n      ...data,\n      reactions,\n      createdAt,\n      editedAt\n    };\n  } else {\n    const deletedAt = new Date(data.deletedAt);\n    return {\n      ...data,\n      reactions,\n      createdAt,\n      editedAt,\n      deletedAt\n    };\n  }\n}\nfunction convertToThreadData(data) {\n  const createdAt = new Date(data.createdAt);\n  const updatedAt = new Date(data.updatedAt);\n  const comments = data.comments.map(\n    (comment) => convertToCommentData(comment)\n  );\n  return {\n    ...data,\n    createdAt,\n    updatedAt,\n    comments\n  };\n}\nfunction convertToCommentUserReaction(data) {\n  return {\n    ...data,\n    createdAt: new Date(data.createdAt)\n  };\n}\nfunction convertToInboxNotificationData(data) {\n  const notifiedAt = new Date(data.notifiedAt);\n  const readAt = data.readAt ? new Date(data.readAt) : null;\n  if (\"activities\" in data) {\n    const activities = data.activities.map((activity) => ({\n      ...activity,\n      createdAt: new Date(activity.createdAt)\n    }));\n    return {\n      ...data,\n      notifiedAt,\n      readAt,\n      activities\n    };\n  }\n  return {\n    ...data,\n    notifiedAt,\n    readAt\n  };\n}\nfunction convertToSubscriptionData(data) {\n  const createdAt = new Date(data.createdAt);\n  return {\n    ...data,\n    createdAt\n  };\n}\nfunction convertToUserSubscriptionData(data) {\n  const createdAt = new Date(data.createdAt);\n  return {\n    ...data,\n    createdAt\n  };\n}\nfunction convertToThreadDeleteInfo(data) {\n  const deletedAt = new Date(data.deletedAt);\n  return {\n    ...data,\n    deletedAt\n  };\n}\nfunction convertToInboxNotificationDeleteInfo(data) {\n  const deletedAt = new Date(data.deletedAt);\n  return {\n    ...data,\n    deletedAt\n  };\n}\nfunction convertToSubscriptionDeleteInfo(data) {\n  const deletedAt = new Date(data.deletedAt);\n  return {\n    ...data,\n    deletedAt\n  };\n}\nfunction convertToGroupData(data) {\n  const createdAt = new Date(data.createdAt);\n  const updatedAt = new Date(data.updatedAt);\n  const members = data.members.map((member) => ({\n    ...member,\n    addedAt: new Date(member.addedAt)\n  }));\n  return {\n    ...data,\n    createdAt,\n    updatedAt,\n    members\n  };\n}\n\n// src/lib/assert.ts\nfunction assertNever(_value, errmsg) {\n  throw new Error(errmsg);\n}\nfunction assert(condition, errmsg) {\n  if (process.env.NODE_ENV !== \"production\") {\n    if (!condition) {\n      const err = new Error(errmsg);\n      err.name = \"Assertion failure\";\n      throw err;\n    }\n  }\n}\nfunction nn(value, errmsg = \"Expected value to be non-nullable\") {\n  assert(value !== null && value !== void 0, errmsg);\n  return value;\n}\n\n// src/lib/fancy-console.ts\nvar fancy_console_exports = {};\n__export(fancy_console_exports, {\n  error: () => error2,\n  errorWithTitle: () => errorWithTitle,\n  warn: () => warn,\n  warnWithTitle: () => warnWithTitle\n});\nvar badge = \"background:#0e0d12;border-radius:9999px;color:#fff;padding:3px 7px;font-family:sans-serif;font-weight:600;\";\nvar bold = \"font-weight:600\";\nfunction wrap(method) {\n  return typeof window === \"undefined\" || process.env.NODE_ENV === \"test\" ? console[method] : (\n    /* istanbul ignore next */\n    (message, ...args) => console[method](\"%cLiveblocks\", badge, message, ...args)\n  );\n}\nvar warn = wrap(\"warn\");\nvar error2 = wrap(\"error\");\nfunction wrapWithTitle(method) {\n  return typeof window === \"undefined\" || process.env.NODE_ENV === \"test\" ? console[method] : (\n    /* istanbul ignore next */\n    (title, message, ...args) => console[method](\n      `%cLiveblocks%c ${title}`,\n      badge,\n      bold,\n      message,\n      ...args\n    )\n  );\n}\nvar warnWithTitle = wrapWithTitle(\"warn\");\nvar errorWithTitle = wrapWithTitle(\"error\");\n\n// src/lib/guards.ts\nfunction isDefined(value) {\n  return value !== null && value !== void 0;\n}\nfunction isPlainObject(blob) {\n  return blob !== null && typeof blob === \"object\" && Object.prototype.toString.call(blob) === \"[object Object]\";\n}\nfunction isStartsWithOperator(blob) {\n  return isPlainObject(blob) && typeof blob.startsWith === \"string\";\n}\nfunction isNumberOperator(blob) {\n  return isPlainObject(blob) && (typeof blob.lt === \"number\" || typeof blob.gt === \"number\" || typeof blob.lte === \"number\" || typeof blob.gte === \"number\");\n}\n\n// src/lib/autoRetry.ts\nvar HttpError = class _HttpError extends Error {\n  response;\n  details;\n  constructor(message, response, details) {\n    super(message);\n    this.name = \"HttpError\";\n    this.response = response;\n    this.details = details;\n  }\n  static async fromResponse(response) {\n    let bodyAsText;\n    try {\n      bodyAsText = await response.text();\n    } catch {\n    }\n    const bodyAsJson = bodyAsText ? tryParseJson(bodyAsText) : void 0;\n    let bodyAsJsonObject;\n    if (isPlainObject(bodyAsJson)) {\n      bodyAsJsonObject = bodyAsJson;\n    }\n    let message = \"\";\n    message ||= typeof bodyAsJsonObject?.message === \"string\" ? bodyAsJsonObject.message : \"\";\n    message ||= typeof bodyAsJsonObject?.error === \"string\" ? bodyAsJsonObject.error : \"\";\n    if (bodyAsJson === void 0) {\n      message ||= bodyAsText || \"\";\n    }\n    message ||= response.statusText;\n    let path;\n    try {\n      path = new URL(response.url).pathname;\n    } catch {\n    }\n    message += path !== void 0 ? ` (got status ${response.status} from ${path})` : ` (got status ${response.status})`;\n    const details = bodyAsJsonObject;\n    return new _HttpError(message, response, details);\n  }\n  /**\n   * Convenience accessor for response.status.\n   */\n  get status() {\n    return this.response.status;\n  }\n};\nvar DONT_RETRY_4XX = (x) => x instanceof HttpError && x.status >= 400 && x.status < 500;\nasync function autoRetry(promiseFn, maxTries, backoff, shouldStopRetrying = DONT_RETRY_4XX) {\n  const fallbackBackoff = backoff.length > 0 ? backoff[backoff.length - 1] : 0;\n  let attempt = 0;\n  while (true) {\n    attempt++;\n    try {\n      return await promiseFn();\n    } catch (err) {\n      if (shouldStopRetrying(err)) {\n        throw err;\n      }\n      if (attempt >= maxTries) {\n        throw new Error(`Failed after ${maxTries} attempts: ${String(err)}`);\n      }\n    }\n    const delay = backoff[attempt - 1] ?? fallbackBackoff;\n    warn(\n      `Attempt ${attempt} was unsuccessful. Retrying in ${delay} milliseconds.`\n    );\n    await wait(delay);\n  }\n}\n\n// src/lib/controlledPromise.ts\nfunction controlledPromise() {\n  let resolve;\n  let reject;\n  const promise = new Promise((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n  return [promise, resolve, reject];\n}\nfunction Promise_withResolvers() {\n  const [promise, resolve, reject] = controlledPromise();\n  return { promise, resolve, reject };\n}\n\n// src/lib/stringify.ts\nfunction replacer(_key, value) {\n  return value !== null && typeof value === \"object\" && !Array.isArray(value) ? Object.keys(value).sort().reduce((sorted, key) => {\n    sorted[key] = value[key];\n    return sorted;\n  }, {}) : value;\n}\nfunction stableStringify(value) {\n  return JSON.stringify(value, replacer);\n}\nfunction stringifyOrLog(value) {\n  try {\n    return JSON.stringify(value);\n  } catch (err) {\n    console.error(`Could not stringify: ${err.message}`);\n    console.error(value);\n    throw err;\n  }\n}\n\n// src/lib/batch.ts\nvar DEFAULT_SIZE = 50;\nvar BatchCall = class {\n  input;\n  resolve;\n  reject;\n  promise;\n  constructor(input) {\n    this.input = input;\n    const { promise, resolve, reject } = Promise_withResolvers();\n    this.promise = promise;\n    this.resolve = resolve;\n    this.reject = reject;\n  }\n};\nvar Batch = class {\n  #queue = [];\n  #callback;\n  #size;\n  #delay;\n  #delayTimeoutId;\n  error = false;\n  constructor(callback, options) {\n    this.#callback = callback;\n    this.#size = options.size ?? DEFAULT_SIZE;\n    this.#delay = options.delay;\n  }\n  #clearDelayTimeout() {\n    if (this.#delayTimeoutId !== void 0) {\n      clearTimeout(this.#delayTimeoutId);\n      this.#delayTimeoutId = void 0;\n    }\n  }\n  #schedule() {\n    if (this.#queue.length === this.#size) {\n      void this.#flush();\n    } else if (this.#queue.length === 1) {\n      this.#clearDelayTimeout();\n      this.#delayTimeoutId = setTimeout(() => void this.#flush(), this.#delay);\n    }\n  }\n  async #flush() {\n    if (this.#queue.length === 0) {\n      return;\n    }\n    const calls = this.#queue.splice(0);\n    const inputs = calls.map((call) => call.input);\n    try {\n      const results = await this.#callback(inputs);\n      this.error = false;\n      calls.forEach((call, index) => {\n        const result = results?.[index];\n        if (!Array.isArray(results)) {\n          call.reject(new Error(\"Callback must return an array.\"));\n        } else if (calls.length !== results.length) {\n          call.reject(\n            new Error(\n              `Callback must return an array of the same length as the number of provided items. Expected ${calls.length}, but got ${results.length}.`\n            )\n          );\n        } else if (result instanceof Error) {\n          call.reject(result);\n        } else {\n          call.resolve(result);\n        }\n      });\n    } catch (error3) {\n      this.error = true;\n      calls.forEach((call) => {\n        call.reject(error3);\n      });\n    }\n  }\n  get(input) {\n    const existingCall = this.#queue.find(\n      (call2) => stableStringify(call2.input) === stableStringify(input)\n    );\n    if (existingCall) {\n      return existingCall.promise;\n    }\n    const call = new BatchCall(input);\n    this.#queue.push(call);\n    this.#schedule();\n    return call.promise;\n  }\n  clear() {\n    this.#queue = [];\n    this.error = false;\n    this.#clearDelayTimeout();\n  }\n};\nfunction createBatchStore(batch2) {\n  const signal = new MutableSignal(/* @__PURE__ */ new Map());\n  function getCacheKey(args) {\n    return stableStringify(args);\n  }\n  function update(entryOrEntries) {\n    signal.mutate((cache) => {\n      if (Array.isArray(entryOrEntries)) {\n        for (const entry of entryOrEntries) {\n          cache.set(entry.key, entry.state);\n        }\n      } else {\n        cache.set(entryOrEntries.key, entryOrEntries.state);\n      }\n    });\n  }\n  function invalidate(inputs) {\n    signal.mutate((cache) => {\n      if (Array.isArray(inputs)) {\n        for (const input of inputs) {\n          cache.delete(getCacheKey(input));\n        }\n      } else {\n        cache.clear();\n      }\n    });\n  }\n  async function enqueue(input) {\n    const cacheKey = getCacheKey(input);\n    const cache = signal.get();\n    if (cache.has(cacheKey)) {\n      return;\n    }\n    try {\n      update({ key: cacheKey, state: { isLoading: true } });\n      const result = await batch2.get(input);\n      update({ key: cacheKey, state: { isLoading: false, data: result } });\n    } catch (error3) {\n      update({\n        key: cacheKey,\n        state: { isLoading: false, error: error3 }\n      });\n    }\n  }\n  function setData(entries2) {\n    update(\n      entries2.map((entry) => ({\n        key: getCacheKey(entry[0]),\n        state: { isLoading: false, data: entry[1] }\n      }))\n    );\n  }\n  function getItemState(input) {\n    const cacheKey = getCacheKey(input);\n    const cache = signal.get();\n    return cache.get(cacheKey);\n  }\n  function getData(input) {\n    const cacheKey = getCacheKey(input);\n    const cache = signal.get();\n    return cache.get(cacheKey)?.data;\n  }\n  function _cacheKeys() {\n    const cache = signal.get();\n    return [...cache.keys()];\n  }\n  return {\n    subscribe: signal.subscribe,\n    enqueue,\n    setData,\n    getItemState,\n    getData,\n    invalidate,\n    batch: batch2,\n    _cacheKeys\n  };\n}\n\n// src/lib/chunk.ts\nfunction chunk(array, size) {\n  const chunks = [];\n  for (let i = 0, j = array.length; i < j; i += size) {\n    chunks.push(array.slice(i, i + size));\n  }\n  return chunks;\n}\n\n// src/lib/nanoid.ts\nvar nanoid = (t = 21) => crypto.getRandomValues(new Uint8Array(t)).reduce(\n  (t2, e) => t2 += (e &= 63) < 36 ? e.toString(36) : e < 62 ? (e - 26).toString(36).toUpperCase() : e < 63 ? \"_\" : \"-\",\n  \"\"\n);\n\n// src/lib/createIds.ts\nvar THREAD_ID_PREFIX = \"th\";\nvar COMMENT_ID_PREFIX = \"cm\";\nvar COMMENT_ATTACHMENT_ID_PREFIX = \"at\";\nvar INBOX_NOTIFICATION_ID_PREFIX = \"in\";\nfunction createOptimisticId(prefix) {\n  return `${prefix}_${nanoid()}`;\n}\nfunction createThreadId() {\n  return createOptimisticId(THREAD_ID_PREFIX);\n}\nfunction createCommentId() {\n  return createOptimisticId(COMMENT_ID_PREFIX);\n}\nfunction createCommentAttachmentId() {\n  return createOptimisticId(COMMENT_ATTACHMENT_ID_PREFIX);\n}\nfunction createInboxNotificationId() {\n  return createOptimisticId(INBOX_NOTIFICATION_ID_PREFIX);\n}\n\n// src/lib/DefaultMap.ts\nvar DefaultMap = class extends Map {\n  #defaultFn;\n  /**\n   * If the default function is not provided to the constructor, it has to be\n   * provided in each .getOrCreate() call individually.\n   */\n  constructor(defaultFn, entries2) {\n    super(entries2);\n    this.#defaultFn = defaultFn;\n  }\n  /**\n   * Gets the value at the given key, or creates it.\n   *\n   * Difference from normal Map: if the key does not exist, it will be created\n   * on the fly using the factory function, and that value will get returned\n   * instead of `undefined`.\n   */\n  getOrCreate(key, defaultFn) {\n    if (super.has(key)) {\n      return super.get(key);\n    } else {\n      const fn = defaultFn ?? this.#defaultFn ?? raise(\"DefaultMap used without a factory function\");\n      const value = fn(key);\n      this.set(key, value);\n      return value;\n    }\n  }\n};\n\n// src/lib/objectToQuery.ts\nvar identifierRegex = /^[a-zA-Z_][a-zA-Z0-9_]*$/;\nfunction objectToQuery(obj) {\n  let filterList = [];\n  const entries2 = Object.entries(obj);\n  const keyValuePairs = [];\n  const keyValuePairsWithOperator = [];\n  const indexedKeys = [];\n  entries2.forEach(([key, value]) => {\n    if (!identifierRegex.test(key)) {\n      throw new Error(\"Key must only contain letters, numbers, _\");\n    }\n    if (isSimpleValue(value)) {\n      keyValuePairs.push([key, value]);\n    } else if (isPlainObject(value)) {\n      if (isStartsWithOperator(value) || isNumberOperator(value)) {\n        keyValuePairsWithOperator.push([key, value]);\n      } else {\n        indexedKeys.push([key, value]);\n      }\n    }\n  });\n  filterList = [\n    ...getFiltersFromKeyValuePairs(keyValuePairs),\n    ...getFiltersFromKeyValuePairsWithOperator(keyValuePairsWithOperator)\n  ];\n  indexedKeys.forEach(([key, value]) => {\n    const nestedEntries = Object.entries(value);\n    const nKeyValuePairs = [];\n    const nKeyValuePairsWithOperator = [];\n    nestedEntries.forEach(([nestedKey, nestedValue]) => {\n      if (isStringEmpty(nestedKey)) {\n        throw new Error(\"Key cannot be empty\");\n      }\n      if (isSimpleValue(nestedValue)) {\n        nKeyValuePairs.push([formatFilterKey(key, nestedKey), nestedValue]);\n      } else if (isStartsWithOperator(nestedValue) || isNumberOperator(nestedValue)) {\n        nKeyValuePairsWithOperator.push([\n          formatFilterKey(key, nestedKey),\n          nestedValue\n        ]);\n      }\n    });\n    filterList = [\n      ...filterList,\n      ...getFiltersFromKeyValuePairs(nKeyValuePairs),\n      ...getFiltersFromKeyValuePairsWithOperator(nKeyValuePairsWithOperator)\n    ];\n  });\n  return filterList.map(({ key, operator, value }) => `${key}${operator}${quote(value)}`).join(\" \");\n}\nvar getFiltersFromKeyValuePairs = (keyValuePairs) => {\n  const filters = [];\n  keyValuePairs.forEach(([key, value]) => {\n    filters.push({\n      key,\n      operator: \":\",\n      value\n    });\n  });\n  return filters;\n};\nvar getFiltersFromKeyValuePairsWithOperator = (keyValuePairsWithOperator) => {\n  const filters = [];\n  keyValuePairsWithOperator.forEach(([key, value]) => {\n    if (\"startsWith\" in value && typeof value.startsWith === \"string\") {\n      filters.push({\n        key,\n        operator: \"^\",\n        value: value.startsWith\n      });\n    }\n    if (\"lt\" in value && typeof value.lt === \"number\") {\n      filters.push({\n        key,\n        operator: \"<\",\n        value: value.lt\n      });\n    }\n    if (\"gt\" in value && typeof value.gt === \"number\") {\n      filters.push({\n        key,\n        operator: \">\",\n        value: value.gt\n      });\n    }\n    if (\"gte\" in value && typeof value.gte === \"number\") {\n      filters.push({\n        key,\n        operator: \">=\",\n        value: value.gte\n      });\n    }\n    if (\"lte\" in value && typeof value.lte === \"number\") {\n      filters.push({\n        key,\n        operator: \"<=\",\n        value: value.lte\n      });\n    }\n  });\n  return filters;\n};\nvar isSimpleValue = (value) => {\n  return typeof value === \"string\" || typeof value === \"number\" || typeof value === \"boolean\" || value === null;\n};\nvar formatFilterKey = (key, nestedKey) => {\n  if (nestedKey) {\n    return `${key}[${quote(nestedKey)}]`;\n  }\n  return key;\n};\nvar isStringEmpty = (value) => {\n  return !value || value.toString().trim() === \"\";\n};\nfunction quote(input) {\n  const result = JSON.stringify(input);\n  if (typeof input !== \"string\") {\n    return result;\n  }\n  if (result.includes(\"'\")) {\n    return result;\n  }\n  return `'${result.slice(1, -1).replace(/\\\\\"/g, '\"')}'`;\n}\n\n// src/lib/url.ts\nvar PLACEHOLDER_BASE_URL = \"https://localhost:9999\";\nvar ABSOLUTE_URL_REGEX = /^[a-zA-Z][a-zA-Z\\d+\\-.]*?:/;\nvar TRAILING_SLASH_URL_REGEX = /\\/(?:(?:\\?|#).*)?$/;\nfunction toURLSearchParams(params) {\n  const result = new URLSearchParams();\n  for (const [key, value] of Object.entries(params)) {\n    if (value !== void 0 && value !== null) {\n      result.set(key, value.toString());\n    }\n  }\n  return result;\n}\nfunction urljoin(baseUrl, path, params) {\n  const url2 = new URL(path, baseUrl);\n  if (params !== void 0) {\n    url2.search = (params instanceof URLSearchParams ? params : toURLSearchParams(params)).toString();\n  }\n  return url2.toString();\n}\nfunction url(strings, ...values2) {\n  return strings.reduce(\n    (result, str, i) => result + encodeURIComponent(values2[i - 1] ?? \"\") + str\n  );\n}\nfunction sanitizeUrl(url2) {\n  if (url2.startsWith(\"www.\")) {\n    url2 = \"https://\" + url2;\n  }\n  if (url2 === \"#\") {\n    return url2;\n  }\n  try {\n    const isAbsolute = ABSOLUTE_URL_REGEX.test(url2);\n    const urlObject = new URL(\n      url2,\n      isAbsolute ? void 0 : PLACEHOLDER_BASE_URL\n    );\n    if (urlObject.protocol !== \"http:\" && urlObject.protocol !== \"https:\") {\n      return null;\n    }\n    const hasTrailingSlash = TRAILING_SLASH_URL_REGEX.test(url2);\n    const sanitizedUrl = (\n      // 1. Origin, only for absolute URLs\n      (isAbsolute ? urlObject.origin : \"\") + // 2. Pathname, with a trailing slash if the original URL had one\n      (urlObject.pathname === \"/\" ? (\n        // 2.a. Domain-only URLs, they always have their pathname set to \"/\"\n        hasTrailingSlash ? \"/\" : \"\"\n      ) : (\n        // 2.b. URLs with a path\n        hasTrailingSlash && !urlObject.pathname.endsWith(\"/\") ? urlObject.pathname + \"/\" : urlObject.pathname\n      )) + // 3. Search params\n      urlObject.search + // 4. Hash\n      urlObject.hash\n    );\n    return sanitizedUrl !== \"\" ? sanitizedUrl : null;\n  } catch {\n    return null;\n  }\n}\nfunction generateUrl(url2, params, hash) {\n  const isAbsolute = ABSOLUTE_URL_REGEX.test(url2);\n  const urlObject = new URL(url2, isAbsolute ? void 0 : PLACEHOLDER_BASE_URL);\n  if (params !== void 0) {\n    for (const [param, value] of Object.entries(params)) {\n      if (value) {\n        urlObject.searchParams.set(param, String(value));\n      }\n    }\n  }\n  if (!urlObject.hash && hash !== void 0) {\n    urlObject.hash = `#${hash}`;\n  }\n  return isAbsolute ? urlObject.href : urlObject.href.replace(PLACEHOLDER_BASE_URL, \"\");\n}\nfunction isUrl(string) {\n  try {\n    new URL(string);\n    return true;\n  } catch (_) {\n    return false;\n  }\n}\n\n// src/api-client.ts\nfunction createApiClient({\n  baseUrl,\n  authManager,\n  currentUserId,\n  fetchPolyfill\n}) {\n  const httpClient = new HttpClient(baseUrl, fetchPolyfill);\n  async function getThreadsSince(options) {\n    const result = await httpClient.get(\n      url`/v2/c/rooms/${options.roomId}/threads/delta`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      }),\n      {\n        since: options.since.toISOString()\n      },\n      { signal: options.signal }\n    );\n    return {\n      threads: {\n        updated: result.data.map(convertToThreadData),\n        deleted: result.deletedThreads.map(convertToThreadDeleteInfo)\n      },\n      inboxNotifications: {\n        updated: result.inboxNotifications.map(convertToInboxNotificationData),\n        deleted: result.deletedInboxNotifications.map(\n          convertToInboxNotificationDeleteInfo\n        )\n      },\n      subscriptions: {\n        updated: result.subscriptions.map(convertToSubscriptionData),\n        deleted: result.deletedSubscriptions.map(\n          convertToSubscriptionDeleteInfo\n        )\n      },\n      requestedAt: new Date(result.meta.requestedAt),\n      permissionHints: result.meta.permissionHints\n    };\n  }\n  async function getThreads(options) {\n    let query;\n    if (options.query) {\n      query = objectToQuery(options.query);\n    }\n    const PAGE_SIZE = 50;\n    try {\n      const result = await httpClient.get(\n        url`/v2/c/rooms/${options.roomId}/threads`,\n        await authManager.getAuthValue({\n          requestedScope: \"comments:read\",\n          roomId: options.roomId\n        }),\n        {\n          cursor: options.cursor,\n          query,\n          limit: PAGE_SIZE\n        }\n      );\n      return {\n        threads: result.data.map(convertToThreadData),\n        inboxNotifications: result.inboxNotifications.map(\n          convertToInboxNotificationData\n        ),\n        subscriptions: result.subscriptions.map(convertToSubscriptionData),\n        nextCursor: result.meta.nextCursor,\n        requestedAt: new Date(result.meta.requestedAt),\n        permissionHints: result.meta.permissionHints\n      };\n    } catch (err) {\n      if (err instanceof HttpError && err.status === 404) {\n        return {\n          threads: [],\n          inboxNotifications: [],\n          subscriptions: [],\n          nextCursor: null,\n          //\n          // HACK\n          // requestedAt needs to be a *server* timestamp here. However, on\n          // this 404 error response, there is no such timestamp. So out of\n          // pure necessity we'll fall back to a local timestamp instead (and\n          // allow for a possible 6 hour clock difference between client and\n          // server).\n          //\n          requestedAt: new Date(Date.now() - 6 * 60 * 60 * 1e3),\n          permissionHints: {}\n        };\n      }\n      throw err;\n    }\n  }\n  async function searchComments(options, requestOptions) {\n    const result = await httpClient.get(\n      url`/v2/c/rooms/${options.roomId}/threads/comments/search`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      }),\n      {\n        text: options.query.text,\n        query: objectToQuery({\n          threadMetadata: options.query.threadMetadata,\n          threadResolved: options.query.threadResolved,\n          hasAttachments: options.query.hasAttachments,\n          hasMentions: options.query.hasMentions\n        })\n      },\n      { signal: requestOptions?.signal }\n    );\n    return result;\n  }\n  async function createThread(options) {\n    const commentId = options.commentId ?? createCommentId();\n    const threadId = options.threadId ?? createThreadId();\n    const thread = await httpClient.post(\n      url`/v2/c/rooms/${options.roomId}/threads`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      }),\n      {\n        id: threadId,\n        comment: {\n          id: commentId,\n          body: options.body,\n          metadata: options.commentMetadata,\n          attachmentIds: options.attachmentIds\n        },\n        metadata: options.metadata\n      }\n    );\n    return convertToThreadData(thread);\n  }\n  async function deleteThread(options) {\n    await httpClient.delete(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      })\n    );\n  }\n  async function getThread(options) {\n    const response = await httpClient.rawGet(\n      url`/v2/c/rooms/${options.roomId}/thread-with-notification/${options.threadId}`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      })\n    );\n    if (response.ok) {\n      const json = await response.json();\n      return {\n        thread: convertToThreadData(json.thread),\n        inboxNotification: json.inboxNotification ? convertToInboxNotificationData(json.inboxNotification) : void 0,\n        subscription: json.subscription ? convertToSubscriptionData(json.subscription) : void 0\n      };\n    } else if (response.status === 404) {\n      return {\n        thread: void 0,\n        inboxNotification: void 0,\n        subscription: void 0\n      };\n    } else {\n      throw new Error(\n        `There was an error while getting thread ${options.threadId}.`\n      );\n    }\n  }\n  async function editThreadMetadata(options) {\n    return await httpClient.post(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/metadata`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      }),\n      options.metadata\n    );\n  }\n  async function editCommentMetadata(options) {\n    return await httpClient.post(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/comments/${options.commentId}/metadata`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      }),\n      options.metadata\n    );\n  }\n  async function createComment(options) {\n    const commentId = options.commentId ?? createCommentId();\n    const comment = await httpClient.post(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/comments`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      }),\n      {\n        id: commentId,\n        body: options.body,\n        metadata: options.metadata,\n        attachmentIds: options.attachmentIds\n      }\n    );\n    return convertToCommentData(comment);\n  }\n  async function editComment(options) {\n    const comment = await httpClient.post(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/comments/${options.commentId}`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      }),\n      {\n        body: options.body,\n        attachmentIds: options.attachmentIds,\n        metadata: options.metadata\n      }\n    );\n    return convertToCommentData(comment);\n  }\n  async function deleteComment(options) {\n    await httpClient.delete(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/comments/${options.commentId}`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      })\n    );\n  }\n  async function addReaction(options) {\n    const reaction = await httpClient.post(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/comments/${options.commentId}/reactions`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      }),\n      { emoji: options.emoji }\n    );\n    return convertToCommentUserReaction(reaction);\n  }\n  async function removeReaction(options) {\n    await httpClient.delete(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/comments/${options.commentId}/reactions/${options.emoji}`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      })\n    );\n  }\n  async function markThreadAsResolved(options) {\n    await httpClient.post(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/mark-as-resolved`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      })\n    );\n  }\n  async function markThreadAsUnresolved(options) {\n    await httpClient.post(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/mark-as-unresolved`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      })\n    );\n  }\n  async function subscribeToThread(options) {\n    const subscription = await httpClient.post(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/subscribe`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      })\n    );\n    return convertToSubscriptionData(subscription);\n  }\n  async function unsubscribeFromThread(options) {\n    await httpClient.post(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/unsubscribe`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      })\n    );\n  }\n  async function uploadAttachment(options) {\n    const roomId = options.roomId;\n    const abortSignal = options.signal;\n    const attachment = options.attachment;\n    const abortError = abortSignal ? new DOMException(\n      `Upload of attachment ${options.attachment.id} was aborted.`,\n      \"AbortError\"\n    ) : void 0;\n    if (abortSignal?.aborted) {\n      throw abortError;\n    }\n    const handleRetryError = (err) => {\n      if (abortSignal?.aborted) {\n        throw abortError;\n      }\n      if (err instanceof HttpError && err.status === 413) {\n        throw err;\n      }\n      return false;\n    };\n    const ATTACHMENT_PART_SIZE = 5 * 1024 * 1024;\n    const RETRY_ATTEMPTS = 10;\n    const RETRY_DELAYS = [\n      2e3,\n      2e3,\n      2e3,\n      2e3,\n      2e3,\n      2e3,\n      2e3,\n      2e3,\n      2e3,\n      2e3\n    ];\n    function splitFileIntoParts(file) {\n      const parts = [];\n      let start = 0;\n      while (start < file.size) {\n        const end = Math.min(start + ATTACHMENT_PART_SIZE, file.size);\n        parts.push({\n          partNumber: parts.length + 1,\n          part: file.slice(start, end)\n        });\n        start = end;\n      }\n      return parts;\n    }\n    if (attachment.size <= ATTACHMENT_PART_SIZE) {\n      return autoRetry(\n        async () => httpClient.putBlob(\n          url`/v2/c/rooms/${roomId}/attachments/${attachment.id}/upload/${encodeURIComponent(attachment.name)}`,\n          await authManager.getAuthValue({\n            requestedScope: \"comments:read\",\n            roomId\n          }),\n          attachment.file,\n          { fileSize: attachment.size },\n          { signal: abortSignal }\n        ),\n        RETRY_ATTEMPTS,\n        RETRY_DELAYS,\n        handleRetryError\n      );\n    } else {\n      let uploadId;\n      const uploadedParts = [];\n      const createMultiPartUpload = await autoRetry(\n        async () => httpClient.post(\n          url`/v2/c/rooms/${roomId}/attachments/${attachment.id}/multipart/${encodeURIComponent(attachment.name)}`,\n          await authManager.getAuthValue({\n            requestedScope: \"comments:read\",\n            roomId\n          }),\n          void 0,\n          { signal: abortSignal },\n          { fileSize: attachment.size }\n        ),\n        RETRY_ATTEMPTS,\n        RETRY_DELAYS,\n        handleRetryError\n      );\n      try {\n        uploadId = createMultiPartUpload.uploadId;\n        const parts = splitFileIntoParts(attachment.file);\n        if (abortSignal?.aborted) {\n          throw abortError;\n        }\n        const batches = chunk(parts, 5);\n        for (const parts2 of batches) {\n          const uploadedPartsPromises = [];\n          for (const { part, partNumber } of parts2) {\n            uploadedPartsPromises.push(\n              autoRetry(\n                async () => httpClient.putBlob(\n                  url`/v2/c/rooms/${roomId}/attachments/${attachment.id}/multipart/${createMultiPartUpload.uploadId}/${String(partNumber)}`,\n                  await authManager.getAuthValue({\n                    requestedScope: \"comments:read\",\n                    roomId\n                  }),\n                  part,\n                  void 0,\n                  { signal: abortSignal }\n                ),\n                RETRY_ATTEMPTS,\n                RETRY_DELAYS,\n                handleRetryError\n              )\n            );\n          }\n          uploadedParts.push(...await Promise.all(uploadedPartsPromises));\n        }\n        if (abortSignal?.aborted) {\n          throw abortError;\n        }\n        const sortedUploadedParts = uploadedParts.sort(\n          (a, b) => a.partNumber - b.partNumber\n        );\n        return httpClient.post(\n          url`/v2/c/rooms/${roomId}/attachments/${attachment.id}/multipart/${uploadId}/complete`,\n          await authManager.getAuthValue({\n            requestedScope: \"comments:read\",\n            roomId\n          }),\n          { parts: sortedUploadedParts },\n          { signal: abortSignal }\n        );\n      } catch (error3) {\n        if (uploadId && error3?.name && (error3.name === \"AbortError\" || error3.name === \"TimeoutError\")) {\n          try {\n            await httpClient.rawDelete(\n              url`/v2/c/rooms/${roomId}/attachments/${attachment.id}/multipart/${uploadId}`,\n              await authManager.getAuthValue({\n                requestedScope: \"comments:read\",\n                roomId\n              })\n            );\n          } catch (error4) {\n          }\n        }\n        throw error3;\n      }\n    }\n  }\n  const attachmentUrlsBatchStoresByRoom = new DefaultMap((roomId) => {\n    const batch2 = new Batch(\n      async (batchedAttachmentIds) => {\n        const attachmentIds = batchedAttachmentIds.flat();\n        const { urls } = await httpClient.post(\n          url`/v2/c/rooms/${roomId}/attachments/presigned-urls`,\n          await authManager.getAuthValue({\n            requestedScope: \"comments:read\",\n            roomId\n          }),\n          { attachmentIds }\n        );\n        return urls.map(\n          (url2) => url2 ?? new Error(\"There was an error while getting this attachment's URL\")\n        );\n      },\n      { delay: 50 }\n    );\n    return createBatchStore(batch2);\n  });\n  function getOrCreateAttachmentUrlsStore(roomId) {\n    return attachmentUrlsBatchStoresByRoom.getOrCreate(roomId);\n  }\n  function getAttachmentUrl(options) {\n    const batch2 = getOrCreateAttachmentUrlsStore(options.roomId).batch;\n    return batch2.get(options.attachmentId);\n  }\n  async function uploadChatAttachment(options) {\n    const { chatId, attachment, signal } = options;\n    const userId = currentUserId.get();\n    if (userId === void 0) {\n      throw new Error(\"Attachment upload requires an authenticated user.\");\n    }\n    const ATTACHMENT_PART_SIZE = 5 * 1024 * 1024;\n    if (options.attachment.file.size <= ATTACHMENT_PART_SIZE) {\n      await httpClient.putBlob(\n        url`/v2/c/chats/${chatId}/attachments/${attachment.id}/upload/${encodeURIComponent(attachment.file.name)}`,\n        await authManager.getAuthValue({ requestedScope: \"comments:read\" }),\n        attachment.file,\n        { fileSize: attachment.file.size },\n        { signal }\n      );\n    } else {\n      const multipartUpload = await httpClient.post(\n        url`/v2/c/chats/${chatId}/attachments/${attachment.id}/multipart/${encodeURIComponent(attachment.file.name)}`,\n        await authManager.getAuthValue({ requestedScope: \"comments:read\" }),\n        void 0,\n        { signal },\n        { fileSize: attachment.file.size }\n      );\n      try {\n        const uploadedParts = [];\n        const parts = [];\n        let start = 0;\n        while (start < attachment.file.size) {\n          const end = Math.min(\n            start + ATTACHMENT_PART_SIZE,\n            attachment.file.size\n          );\n          parts.push({\n            number: parts.length + 1,\n            part: attachment.file.slice(start, end)\n          });\n          start = end;\n        }\n        uploadedParts.push(\n          ...await Promise.all(\n            parts.map(async ({ number, part }) => {\n              return await httpClient.putBlob(\n                url`/v2/c/chats/${chatId}/attachments/${attachment.id}/multipart/${multipartUpload.uploadId}/${String(number)}`,\n                await authManager.getAuthValue({\n                  requestedScope: \"comments:read\"\n                }),\n                part,\n                void 0,\n                { signal }\n              );\n            })\n          )\n        );\n        await httpClient.post(\n          url`/v2/c/chats/${chatId}/attachments/${attachment.id}/multipart/${multipartUpload.uploadId}/complete`,\n          await authManager.getAuthValue({ requestedScope: \"comments:read\" }),\n          { parts: uploadedParts.sort((a, b) => a.number - b.number) },\n          { signal }\n        );\n      } catch (err) {\n        try {\n          await httpClient.delete(\n            url`/v2/c/chats/${chatId}/attachments/${attachment.id}/multipart/${multipartUpload.uploadId}`,\n            await authManager.getAuthValue({ requestedScope: \"comments:read\" })\n          );\n        } catch (err2) {\n        }\n        throw err;\n      }\n    }\n  }\n  const attachmentUrlsBatchStoresByChat = new DefaultMap((chatId) => {\n    const batch2 = new Batch(\n      async (batchedAttachmentIds) => {\n        const attachmentIds = batchedAttachmentIds.flat();\n        const { urls } = await httpClient.post(\n          url`/v2/c/chats/${chatId}/attachments/presigned-urls`,\n          await authManager.getAuthValue({\n            requestedScope: \"comments:read\"\n          }),\n          { attachmentIds }\n        );\n        return urls.map(\n          (url2) => url2 ?? new Error(\"There was an error while getting this attachment's URL\")\n        );\n      },\n      { delay: 50 }\n    );\n    return createBatchStore(batch2);\n  });\n  function getOrCreateChatAttachmentUrlsStore(chatId) {\n    return attachmentUrlsBatchStoresByChat.getOrCreate(chatId);\n  }\n  function getChatAttachmentUrl(options) {\n    const batch2 = getOrCreateChatAttachmentUrlsStore(options.chatId).batch;\n    return batch2.get(options.attachmentId);\n  }\n  async function getSubscriptionSettings(options) {\n    return httpClient.get(\n      url`/v2/c/rooms/${options.roomId}/subscription-settings`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      }),\n      void 0,\n      {\n        signal: options.signal\n      }\n    );\n  }\n  async function updateSubscriptionSettings(options) {\n    return httpClient.post(\n      url`/v2/c/rooms/${options.roomId}/subscription-settings`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      }),\n      options.settings\n    );\n  }\n  const markAsReadBatchesByRoom = new DefaultMap(\n    (roomId) => new Batch(\n      async (batchedInboxNotificationIds) => {\n        const inboxNotificationIds = batchedInboxNotificationIds.flat();\n        await httpClient.post(\n          url`/v2/c/rooms/${roomId}/inbox-notifications/read`,\n          await authManager.getAuthValue({\n            requestedScope: \"comments:read\",\n            roomId\n          }),\n          { inboxNotificationIds }\n        );\n        return inboxNotificationIds;\n      },\n      { delay: 50 }\n    )\n  );\n  async function markRoomInboxNotificationAsRead(options) {\n    const batch2 = markAsReadBatchesByRoom.getOrCreate(options.roomId);\n    return batch2.get(options.inboxNotificationId);\n  }\n  async function createTextMention(options) {\n    if (options.mention.kind !== \"user\" && options.mention.kind !== \"group\") {\n      return assertNever(options.mention, \"Unexpected mention kind\");\n    }\n    await httpClient.rawPost(\n      url`/v2/c/rooms/${options.roomId}/text-mentions`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      }),\n      {\n        userId: options.mention.kind === \"user\" ? options.mention.id : void 0,\n        groupId: options.mention.kind === \"group\" ? options.mention.id : void 0,\n        userIds: options.mention.kind === \"group\" ? options.mention.userIds : void 0,\n        mentionId: options.mentionId\n      }\n    );\n  }\n  async function deleteTextMention(options) {\n    await httpClient.rawDelete(\n      url`/v2/c/rooms/${options.roomId}/text-mentions/${options.mentionId}`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      })\n    );\n  }\n  async function getTextVersion(options) {\n    return httpClient.rawGet(\n      url`/v2/c/rooms/${options.roomId}/y-version/${options.versionId}`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      })\n    );\n  }\n  async function createTextVersion(options) {\n    await httpClient.rawPost(\n      url`/v2/c/rooms/${options.roomId}/version`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      })\n    );\n  }\n  async function reportTextEditor(options) {\n    await httpClient.rawPost(\n      url`/v2/c/rooms/${options.roomId}/text-metadata`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      }),\n      {\n        type: options.type,\n        rootKey: options.rootKey\n      }\n    );\n  }\n  async function executeContextualPrompt(options) {\n    const result = await httpClient.post(\n      url`/v2/c/rooms/${options.roomId}/ai/contextual-prompt`,\n      await authManager.getAuthValue({\n        requestedScope: \"room:read\",\n        roomId: options.roomId\n      }),\n      {\n        prompt: options.prompt,\n        context: {\n          beforeSelection: options.context.beforeSelection,\n          selection: options.context.selection,\n          afterSelection: options.context.afterSelection\n        },\n        previous: options.previous\n      },\n      { signal: options.signal }\n    );\n    if (!result || result.content.length === 0) {\n      throw new Error(\"No content returned from server\");\n    }\n    return result.content[0].text;\n  }\n  async function listTextVersions(options) {\n    const result = await httpClient.get(\n      url`/v2/c/rooms/${options.roomId}/versions`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      })\n    );\n    return {\n      versions: result.versions.map(({ createdAt, ...version }) => {\n        return {\n          createdAt: new Date(createdAt),\n          ...version\n        };\n      }),\n      requestedAt: new Date(result.meta.requestedAt)\n    };\n  }\n  async function listTextVersionsSince(options) {\n    const result = await httpClient.get(\n      url`/v2/c/rooms/${options.roomId}/versions/delta`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      }),\n      { since: options.since.toISOString() },\n      { signal: options.signal }\n    );\n    return {\n      versions: result.versions.map(({ createdAt, ...version }) => {\n        return {\n          createdAt: new Date(createdAt),\n          ...version\n        };\n      }),\n      requestedAt: new Date(result.meta.requestedAt)\n    };\n  }\n  async function streamStorage(options) {\n    const result = await httpClient.rawGet(\n      url`/v2/c/rooms/${options.roomId}/storage`,\n      await authManager.getAuthValue({\n        requestedScope: \"room:read\",\n        roomId: options.roomId\n      })\n    );\n    return await result.json();\n  }\n  async function getInboxNotifications(options) {\n    const PAGE_SIZE = 50;\n    let query;\n    if (options?.query) {\n      query = objectToQuery(options.query);\n    }\n    const json = await httpClient.get(\n      url`/v2/c/inbox-notifications`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" }),\n      {\n        cursor: options?.cursor,\n        limit: PAGE_SIZE,\n        query\n      }\n    );\n    const groups = json.groups.map(convertToGroupData);\n    groupsStore.setData(groups.map((group) => [group.id, group]));\n    return {\n      inboxNotifications: json.inboxNotifications.map(\n        convertToInboxNotificationData\n      ),\n      threads: json.threads.map(convertToThreadData),\n      subscriptions: json.subscriptions.map(convertToSubscriptionData),\n      nextCursor: json.meta.nextCursor,\n      requestedAt: new Date(json.meta.requestedAt)\n    };\n  }\n  async function getInboxNotificationsSince(options) {\n    let query;\n    if (options?.query) {\n      query = objectToQuery(options.query);\n    }\n    const json = await httpClient.get(\n      url`/v2/c/inbox-notifications/delta`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" }),\n      { since: options.since.toISOString(), query },\n      { signal: options.signal }\n    );\n    return {\n      inboxNotifications: {\n        updated: json.inboxNotifications.map(convertToInboxNotificationData),\n        deleted: json.deletedInboxNotifications.map(\n          convertToInboxNotificationDeleteInfo\n        )\n      },\n      threads: {\n        updated: json.threads.map(convertToThreadData),\n        deleted: json.deletedThreads.map(convertToThreadDeleteInfo)\n      },\n      subscriptions: {\n        updated: json.subscriptions.map(convertToSubscriptionData),\n        deleted: json.deletedSubscriptions.map(convertToSubscriptionDeleteInfo)\n      },\n      requestedAt: new Date(json.meta.requestedAt)\n    };\n  }\n  async function getUnreadInboxNotificationsCount(options) {\n    let query;\n    if (options?.query) {\n      query = objectToQuery(options.query);\n    }\n    const { count } = await httpClient.get(\n      url`/v2/c/inbox-notifications/count`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" }),\n      { query },\n      { signal: options?.signal }\n    );\n    return count;\n  }\n  async function markAllInboxNotificationsAsRead() {\n    await httpClient.post(\n      url`/v2/c/inbox-notifications/read`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" }),\n      {\n        inboxNotificationIds: \"all\"\n      }\n    );\n  }\n  async function markInboxNotificationsAsRead(inboxNotificationIds) {\n    await httpClient.post(\n      url`/v2/c/inbox-notifications/read`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" }),\n      {\n        inboxNotificationIds\n      }\n    );\n  }\n  const batchedMarkInboxNotificationsAsRead = new Batch(\n    async (batchedInboxNotificationIds) => {\n      const inboxNotificationIds = batchedInboxNotificationIds.flat();\n      await markInboxNotificationsAsRead(inboxNotificationIds);\n      return inboxNotificationIds;\n    },\n    { delay: 50 }\n  );\n  async function markInboxNotificationAsRead(inboxNotificationId) {\n    await batchedMarkInboxNotificationsAsRead.get(inboxNotificationId);\n  }\n  async function deleteAllInboxNotifications() {\n    await httpClient.delete(\n      url`/v2/c/inbox-notifications`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" })\n    );\n  }\n  async function deleteInboxNotification(inboxNotificationId) {\n    await httpClient.delete(\n      url`/v2/c/inbox-notifications/${inboxNotificationId}`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" })\n    );\n  }\n  async function getNotificationSettings(options) {\n    return httpClient.get(\n      url`/v2/c/notification-settings`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" }),\n      void 0,\n      { signal: options?.signal }\n    );\n  }\n  async function updateNotificationSettings(settings) {\n    return httpClient.post(\n      url`/v2/c/notification-settings`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" }),\n      settings\n    );\n  }\n  async function getUserThreads_experimental(options) {\n    let query;\n    if (options?.query) {\n      query = objectToQuery(options.query);\n    }\n    const PAGE_SIZE = 50;\n    const json = await httpClient.get(\n      url`/v2/c/threads`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" }),\n      {\n        cursor: options?.cursor,\n        query,\n        limit: PAGE_SIZE\n      }\n    );\n    return {\n      threads: json.threads.map(convertToThreadData),\n      inboxNotifications: json.inboxNotifications.map(\n        convertToInboxNotificationData\n      ),\n      subscriptions: json.subscriptions.map(convertToSubscriptionData),\n      nextCursor: json.meta.nextCursor,\n      requestedAt: new Date(json.meta.requestedAt),\n      permissionHints: json.meta.permissionHints\n    };\n  }\n  async function getUserThreadsSince_experimental(options) {\n    const json = await httpClient.get(\n      url`/v2/c/threads/delta`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" }),\n      { since: options.since.toISOString() },\n      { signal: options.signal }\n    );\n    return {\n      threads: {\n        updated: json.threads.map(convertToThreadData),\n        deleted: json.deletedThreads.map(convertToThreadDeleteInfo)\n      },\n      inboxNotifications: {\n        updated: json.inboxNotifications.map(convertToInboxNotificationData),\n        deleted: json.deletedInboxNotifications.map(\n          convertToInboxNotificationDeleteInfo\n        )\n      },\n      subscriptions: {\n        updated: json.subscriptions.map(convertToSubscriptionData),\n        deleted: json.deletedSubscriptions.map(convertToSubscriptionDeleteInfo)\n      },\n      requestedAt: new Date(json.meta.requestedAt),\n      permissionHints: json.meta.permissionHints\n    };\n  }\n  const batchedGetGroups = new Batch(\n    async (batchedGroupIds) => {\n      const groupIds = batchedGroupIds.flat();\n      const { groups: plainGroups } = await httpClient.post(\n        url`/v2/c/groups/find`,\n        await authManager.getAuthValue({\n          requestedScope: \"comments:read\"\n        }),\n        { groupIds }\n      );\n      const groups = /* @__PURE__ */ new Map();\n      for (const group of plainGroups) {\n        groups.set(group.id, convertToGroupData(group));\n      }\n      return groupIds.map((groupId) => groups.get(groupId));\n    },\n    { delay: 50 }\n  );\n  const groupsStore = createBatchStore(batchedGetGroups);\n  function getGroup(groupId) {\n    return batchedGetGroups.get(groupId);\n  }\n  async function getUrlMetadata(_url) {\n    const { metadata } = await httpClient.get(\n      url`/v2/c/urls/metadata`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" }),\n      { url: _url }\n    );\n    return metadata;\n  }\n  return {\n    // Room threads\n    getThreads,\n    getThreadsSince,\n    searchComments,\n    createThread,\n    getThread,\n    deleteThread,\n    editThreadMetadata,\n    createComment,\n    editComment,\n    editCommentMetadata,\n    deleteComment,\n    addReaction,\n    removeReaction,\n    markThreadAsResolved,\n    markThreadAsUnresolved,\n    subscribeToThread,\n    unsubscribeFromThread,\n    markRoomInboxNotificationAsRead,\n    // Room subscription settings\n    getSubscriptionSettings,\n    updateSubscriptionSettings,\n    // Room text editor\n    createTextMention,\n    deleteTextMention,\n    getTextVersion,\n    createTextVersion,\n    reportTextEditor,\n    listTextVersions,\n    listTextVersionsSince,\n    // Room attachments\n    getAttachmentUrl,\n    uploadAttachment,\n    getOrCreateAttachmentUrlsStore,\n    // User attachments\n    uploadChatAttachment,\n    getOrCreateChatAttachmentUrlsStore,\n    getChatAttachmentUrl,\n    // Room storage\n    streamStorage,\n    // Notifications\n    getInboxNotifications,\n    getInboxNotificationsSince,\n    getUnreadInboxNotificationsCount,\n    markAllInboxNotificationsAsRead,\n    markInboxNotificationAsRead,\n    deleteAllInboxNotifications,\n    deleteInboxNotification,\n    getNotificationSettings,\n    updateNotificationSettings,\n    // User threads\n    getUserThreads_experimental,\n    getUserThreadsSince_experimental,\n    // Groups\n    groupsStore,\n    getGroup,\n    // AI\n    executeContextualPrompt,\n    // URL metadata\n    getUrlMetadata\n  };\n}\nfunction getBearerTokenFromAuthValue(authValue) {\n  if (authValue.type === \"public\") {\n    return authValue.publicApiKey;\n  } else {\n    return authValue.token.raw;\n  }\n}\nvar HttpClient = class {\n  #baseUrl;\n  #fetchPolyfill;\n  constructor(baseUrl, fetchPolyfill) {\n    this.#baseUrl = baseUrl;\n    this.#fetchPolyfill = fetchPolyfill;\n  }\n  // ------------------------------------------------------------------\n  // Public methods\n  // ------------------------------------------------------------------\n  /**\n   * Constructs and makes the HTTP request, but does not handle the response.\n   *\n   * This is what .rawFetch() does:     This method!\n   *   1. Set Content-Type header\n   *   2. Set Authorization header\n   *   3. Call the callback to obtain the `authValue` to use in the Authorization header\n   *\n   * This is what .fetch() does ON TOP of that:\n   *   4. Parse response body as Json\n   *   5. ...but silently return `{}` if that parsing fails\n   *   6. Throw HttpError if response is an error\n   */\n  async #rawFetch(endpoint, authValue, options, params) {\n    if (!endpoint.startsWith(\"/v2/c/\")) {\n      raise(\"This client can only be used to make /v2/c/* requests\");\n    }\n    const url2 = urljoin(this.#baseUrl, endpoint, params);\n    const response = await this.#fetchPolyfill(url2, {\n      ...options,\n      headers: {\n        // These headers are default, but can be overriden by custom headers\n        \"Content-Type\": \"application/json; charset=utf-8\",\n        // Possible header overrides\n        ...options?.headers,\n        // Cannot be overriden by custom headers\n        Authorization: `Bearer ${getBearerTokenFromAuthValue(authValue)}`,\n        \"X-LB-Client\": PKG_VERSION || \"dev\"\n      }\n    });\n    const xwarn = response.headers.get(\"X-LB-Warn\");\n    if (xwarn) {\n      const method = options?.method?.toUpperCase() ?? \"GET\";\n      const msg = `${xwarn} (${method} ${endpoint})`;\n      if (response.ok) {\n        warn(msg);\n      } else {\n        error2(msg);\n      }\n    }\n    return response;\n  }\n  /**\n   * Constructs, makes the HTTP request, and handles the response by parsing\n   * JSON and/or throwing an HttpError if it failed.\n   *\n   * This is what .rawFetch() does:\n   *   1. Set Content-Type header\n   *   2. Set Authorization header\n   *   3. Call the callback to obtain the `authValue` to use in the Authorization header\n   *\n   * This is what .fetch() does ON TOP of that:    This method!\n   *   4. Parse response body as Json\n   *   5. ...but silently return `{}` if that parsing fails ()\n   *   6. Throw HttpError if response is an error\n   */\n  async #fetch(endpoint, authValue, options, params) {\n    const response = await this.#rawFetch(endpoint, authValue, options, params);\n    if (!response.ok) {\n      throw await HttpError.fromResponse(response);\n    }\n    let body;\n    try {\n      body = await response.json();\n    } catch {\n      body = {};\n    }\n    return body;\n  }\n  /**\n   * Makes a GET request and returns the raw response.\n   * Won't throw if the reponse is a non-2xx.\n   * @deprecated Ideally, use .get() instead.\n   */\n  async rawGet(endpoint, authValue, params, options) {\n    return await this.#rawFetch(endpoint, authValue, options, params);\n  }\n  /**\n   * Makes a POST request and returns the raw response.\n   * Won't throw if the reponse is a non-2xx.\n   * @deprecated Ideally, use .post() instead.\n   */\n  async rawPost(endpoint, authValue, body) {\n    return await this.#rawFetch(endpoint, authValue, {\n      method: \"POST\",\n      body: stringifyOrLog(body)\n    });\n  }\n  /**\n   * Makes a DELETE request and returns the raw response.\n   * Won't throw if the reponse is a non-2xx.\n   * @deprecated Ideally, use .delete() instead.\n   */\n  async rawDelete(endpoint, authValue) {\n    return await this.#rawFetch(endpoint, authValue, { method: \"DELETE\" });\n  }\n  /**\n   * Makes a GET request, and return the JSON response.\n   * Will throw if the reponse is a non-2xx.\n   */\n  async get(endpoint, authValue, params, options) {\n    return await this.#fetch(endpoint, authValue, options, params);\n  }\n  /**\n   * Makes a POST request, and return the JSON response.\n   * Will throw if the reponse is a non-2xx.\n   */\n  async post(endpoint, authValue, body, options, params) {\n    return await this.#fetch(\n      endpoint,\n      authValue,\n      {\n        ...options,\n        method: \"POST\",\n        body: stringifyOrLog(body)\n      },\n      params\n    );\n  }\n  /**\n   * Makes a DELETE request, and return the JSON response.\n   * Will throw if the reponse is a non-2xx.\n   */\n  async delete(endpoint, authValue) {\n    return await this.#fetch(endpoint, authValue, { method: \"DELETE\" });\n  }\n  /**\n   * Makes a PUT request for a Blob body, and return the JSON response.\n   * Will throw if the reponse is a non-2xx.\n   */\n  async putBlob(endpoint, authValue, blob, params, options) {\n    return await this.#fetch(\n      endpoint,\n      authValue,\n      {\n        ...options,\n        method: \"PUT\",\n        headers: {\n          \"Content-Type\": \"application/octet-stream\"\n        },\n        body: blob\n      },\n      params\n    );\n  }\n};\n\n// src/lib/fsm.ts\nfunction distance(state1, state2) {\n  if (state1 === state2) {\n    return [0, 0];\n  }\n  const chunks1 = state1.split(\".\");\n  const chunks2 = state2.split(\".\");\n  const minLen = Math.min(chunks1.length, chunks2.length);\n  let shared = 0;\n  for (; shared < minLen; shared++) {\n    if (chunks1[shared] !== chunks2[shared]) {\n      break;\n    }\n  }\n  const up = chunks1.length - shared;\n  const down = chunks2.length - shared;\n  return [up, down];\n}\nfunction patterns(targetState, levels) {\n  const parts = targetState.split(\".\");\n  if (levels < 1 || levels > parts.length + 1) {\n    throw new Error(\"Invalid number of levels\");\n  }\n  const result = [];\n  if (levels > parts.length) {\n    result.push(\"*\");\n  }\n  for (let i = parts.length - levels + 1; i < parts.length; i++) {\n    const slice = parts.slice(0, i);\n    if (slice.length > 0) {\n      result.push(slice.join(\".\") + \".*\");\n    }\n  }\n  result.push(targetState);\n  return result;\n}\nvar SafeContext = class {\n  #curr;\n  constructor(initialContext) {\n    this.#curr = initialContext;\n  }\n  get current() {\n    return this.#curr;\n  }\n  /**\n   * Call a callback function that allows patching of the context, by\n   * calling `context.patch()`. Patching is only allowed for the duration\n   * of this window.\n   */\n  allowPatching(callback) {\n    const self = this;\n    let allowed = true;\n    const patchableContext = {\n      ...this.#curr,\n      patch(patch) {\n        if (allowed) {\n          self.#curr = Object.assign({}, self.#curr, patch);\n          for (const pair of Object.entries(patch)) {\n            const [key, value] = pair;\n            if (key !== \"patch\") {\n              this[key] = value;\n            }\n          }\n        } else {\n          throw new Error(\"Can no longer patch stale context\");\n        }\n      }\n    };\n    callback(patchableContext);\n    allowed = false;\n    return;\n  }\n};\nvar nextId = 1;\nvar FSM = class {\n  id;\n  // Indicates whether this state machine is still being configured, has\n  // started, or has terminated\n  #runningState;\n  #currentContext;\n  #states;\n  #currentStateOrNull;\n  #allowedTransitions;\n  #eventHub;\n  events;\n  //\n  // The cleanup stack is a stack of (optional) callback functions that will\n  // be run when exiting the current state. If a state (or state group) does\n  // not have an exit handler, then the entry for that level may be\n  // `undefined`, but there will be an explicit entry in the stack for it.\n  //\n  // This will always be true:\n  //\n  //   cleanupStack.length == currentState.split('.').length + 1\n  //\n  // Each stack level represents a different state \"group\".\n  //\n  // For example, if you are in a state named `foo.bar.qux`, then the stack\n  // will contain the exit handler for `foo.bar.qux` (at the top), then\n  // `foo.bar.*`, then `foo.*`, and finally, `*`.\n  //\n  #cleanupStack;\n  //\n  // The entry times stack tracks when each state level was entered, using\n  // performance.now() timestamps. This parallels the cleanup stack structure.\n  //\n  // For example, if you are in state `foo.bar.qux`, the stack contains:\n  // [timestamp for *, timestamp for foo.*, timestamp for foo.bar.*, timestamp for foo.bar.qux]\n  //\n  #entryTimesStack;\n  #enterFns;\n  // Used to provide better error messages\n  #knownEventTypes;\n  /**\n   * Returns the initial state, which is defined by the first call made to\n   * .addState().\n   */\n  get #initialState() {\n    const result = this.#states.values()[Symbol.iterator]().next();\n    if (result.done) {\n      throw new Error(\"No states defined yet\");\n    } else {\n      return result.value;\n    }\n  }\n  get currentState() {\n    if (this.#currentStateOrNull === null) {\n      if (this.#runningState === 0 /* NOT_STARTED_YET */) {\n        throw new Error(\"Not started yet\");\n      } else {\n        throw new Error(\"Already stopped\");\n      }\n    }\n    return this.#currentStateOrNull;\n  }\n  /**\n   * Starts the machine by entering the initial state.\n   */\n  start() {\n    if (this.#runningState !== 0 /* NOT_STARTED_YET */) {\n      throw new Error(\"State machine has already started\");\n    }\n    this.#runningState = 1 /* STARTED */;\n    this.#currentStateOrNull = this.#initialState;\n    this.#enter(null);\n    return this;\n  }\n  /**\n   * Stops the state machine. Stopping the state machine will call exit\n   * handlers for the current state, but not enter a new state.\n   */\n  stop() {\n    if (this.#runningState !== 1 /* STARTED */) {\n      throw new Error(\"Cannot stop a state machine that hasn't started yet\");\n    }\n    this.#exit(null);\n    this.#runningState = 2 /* STOPPED */;\n    this.#currentStateOrNull = null;\n  }\n  constructor(initialContext) {\n    this.id = nextId++;\n    this.#runningState = 0 /* NOT_STARTED_YET */;\n    this.#currentStateOrNull = null;\n    this.#states = /* @__PURE__ */ new Set();\n    this.#enterFns = /* @__PURE__ */ new Map();\n    this.#cleanupStack = [];\n    this.#entryTimesStack = [];\n    this.#knownEventTypes = /* @__PURE__ */ new Set();\n    this.#allowedTransitions = /* @__PURE__ */ new Map();\n    this.#currentContext = new SafeContext(initialContext);\n    this.#eventHub = {\n      didReceiveEvent: makeEventSource(),\n      willTransition: makeEventSource(),\n      didIgnoreEvent: makeEventSource(),\n      willExitState: makeEventSource(),\n      didEnterState: makeEventSource(),\n      didExitState: makeEventSource()\n    };\n    this.events = {\n      didReceiveEvent: this.#eventHub.didReceiveEvent.observable,\n      willTransition: this.#eventHub.willTransition.observable,\n      didIgnoreEvent: this.#eventHub.didIgnoreEvent.observable,\n      willExitState: this.#eventHub.willExitState.observable,\n      didEnterState: this.#eventHub.didEnterState.observable,\n      didExitState: this.#eventHub.didExitState.observable\n    };\n  }\n  get context() {\n    return this.#currentContext.current;\n  }\n  /**\n   * Define an explicit finite state in the state machine.\n   */\n  addState(state) {\n    if (this.#runningState !== 0 /* NOT_STARTED_YET */) {\n      throw new Error(\"Already started\");\n    }\n    this.#states.add(state);\n    return this;\n  }\n  onEnter(nameOrPattern, enterFn) {\n    if (this.#runningState !== 0 /* NOT_STARTED_YET */) {\n      throw new Error(\"Already started\");\n    } else if (this.#enterFns.has(nameOrPattern)) {\n      throw new Error(\n        // TODO We _currently_ don't support multiple .onEnters() for the same\n        // state, but this is not a fundamental limitation. Just not\n        // implemented yet. If we wanted to, we could make this an array.\n        `enter/exit function for ${nameOrPattern} already exists`\n      );\n    }\n    this.#enterFns.set(nameOrPattern, enterFn);\n    return this;\n  }\n  /**\n   * Defines a promise-based state. When the state is entered, the promise is\n   * created. When the promise resolves, the machine will transition to the\n   * provided `onOK` target state. When the promise rejects, the machine will\n   * transition to the `onError` target state.\n   *\n   * Optionally, a `maxTimeout` can be set. If the timeout happens before the\n   * promise is settled, then the machine will also transition to the `onError`\n   * target state.\n   *\n   * @param stateOrPattern  The state name, or state group pattern name.\n   * @param promiseFn       The callback to be invoked when the state is entered.\n   * @param onOK            The state to transition to when the promise resolves.\n   * @param onError         The state to transition to when the promise\n   *                        rejects, or when the timeout happens before the\n   *                        promise has been settled.\n   * @param maxTimeout      Optional timeout in milliseconds.\n   *\n   * When the promise callback function is invoked, it's provided with an\n   * AbortSignal (2nd argument).\n   * If a state transition happens while the promise is pending (for example,\n   * an event, or a timeout happens), then an abort signal will be used to\n   * indicate this. Implementers can use this abort signal to terminate the\n   * in-flight promise, or ignore its results, etc.\n   */\n  onEnterAsync(nameOrPattern, promiseFn, onOK, onError, maxTimeout) {\n    return this.onEnter(nameOrPattern, () => {\n      const abortController = new AbortController();\n      const signal = abortController.signal;\n      const timeoutId = maxTimeout ? setTimeout(() => {\n        const reason = new Error(\"Timed out\");\n        this.#transition({ type: \"ASYNC_ERROR\", reason }, onError);\n      }, maxTimeout) : void 0;\n      let done = false;\n      void promiseFn(this.#currentContext.current, signal).then(\n        // On OK\n        (data) => {\n          if (!signal.aborted) {\n            done = true;\n            this.#transition({ type: \"ASYNC_OK\", data }, onOK);\n          }\n        },\n        // On Error\n        (reason) => {\n          if (!signal.aborted) {\n            done = true;\n            this.#transition({ type: \"ASYNC_ERROR\", reason }, onError);\n          }\n        }\n      );\n      return () => {\n        clearTimeout(timeoutId);\n        if (!done) {\n          abortController.abort();\n        }\n      };\n    });\n  }\n  #getStatesMatching(nameOrPattern) {\n    const matches = [];\n    if (nameOrPattern === \"*\") {\n      for (const state of this.#states) {\n        matches.push(state);\n      }\n    } else if (nameOrPattern.endsWith(\".*\")) {\n      const prefix = nameOrPattern.slice(0, -1);\n      for (const state of this.#states) {\n        if (state.startsWith(prefix)) {\n          matches.push(state);\n        }\n      }\n    } else {\n      const name = nameOrPattern;\n      if (this.#states.has(name)) {\n        matches.push(name);\n      }\n    }\n    if (matches.length === 0) {\n      throw new Error(`No states match ${JSON.stringify(nameOrPattern)}`);\n    }\n    return matches;\n  }\n  /**\n   * Define all allowed outgoing transitions for a state.\n   *\n   * The targets for each event can be defined as a function which returns the\n   * next state to transition to. These functions can look at the `event` or\n   * `context` params to conditionally decide which next state to transition\n   * to.\n   *\n   * If you set it to `null`, then the transition will be explicitly forbidden\n   * and throw an error. If you don't define a target for a transition, then\n   * such events will get ignored.\n   */\n  addTransitions(nameOrPattern, mapping) {\n    if (this.#runningState !== 0 /* NOT_STARTED_YET */) {\n      throw new Error(\"Already started\");\n    }\n    for (const srcState of this.#getStatesMatching(nameOrPattern)) {\n      let map = this.#allowedTransitions.get(srcState);\n      if (map === void 0) {\n        map = /* @__PURE__ */ new Map();\n        this.#allowedTransitions.set(srcState, map);\n      }\n      for (const [type, target_] of Object.entries(mapping)) {\n        if (map.has(type)) {\n          throw new Error(\n            `Trying to set transition \"${type}\" on \"${srcState}\" (via \"${nameOrPattern}\"), but a transition already exists there.`\n          );\n        }\n        const target = target_;\n        this.#knownEventTypes.add(type);\n        if (target !== void 0) {\n          const targetFn = typeof target === \"function\" ? target : () => target;\n          map.set(type, targetFn);\n        }\n      }\n    }\n    return this;\n  }\n  /**\n   * Like `.addTransition()`, but takes an (anonymous) transition whenever the\n   * timer fires.\n   *\n   * @param stateOrPattern  The state name, or state group pattern name.\n   * @param after           Number of milliseconds after which to take the\n   *                        transition. If in the mean time, another transition\n   *                        is taken, the timer will get cancelled.\n   * @param target          The target state to go to.\n   */\n  addTimedTransition(stateOrPattern, after2, target) {\n    return this.onEnter(stateOrPattern, () => {\n      const ms = typeof after2 === \"function\" ? after2(this.#currentContext.current) : after2;\n      const timeoutID = setTimeout(() => {\n        this.#transition({ type: \"TIMER\" }, target);\n      }, ms);\n      return () => {\n        clearTimeout(timeoutID);\n      };\n    });\n  }\n  #getTargetFn(eventName) {\n    return this.#allowedTransitions.get(this.currentState)?.get(eventName);\n  }\n  /**\n   * Exits the current state, and executes any necessary cleanup functions.\n   * Call this before changing the current state to the next state.\n   *\n   * @param levels Defines how many \"levels\" of nesting will be\n   * exited. For example, if you transition from `foo.bar.qux` to\n   * `foo.bar.baz`, then the level is 1. But if you transition from\n   * `foo.bar.qux` to `bla.bla`, then the level is 3.\n   * If `null`, it will exit all levels.\n   */\n  #exit(levels) {\n    this.#eventHub.willExitState.notify(this.currentState);\n    const now2 = performance.now();\n    const parts = this.currentState.split(\".\");\n    this.#currentContext.allowPatching((patchableContext) => {\n      levels = levels ?? this.#cleanupStack.length;\n      for (let i = 0; i < levels; i++) {\n        this.#cleanupStack.pop()?.(patchableContext);\n        const entryTime = this.#entryTimesStack.pop();\n        if (entryTime !== void 0 && // ...but avoid computing state names if nobody is listening\n        this.#eventHub.didExitState.count() > 0) {\n          const depth = this.#entryTimesStack.length;\n          if (depth === 0) continue;\n          const state = depth === parts.length ? this.currentState : `${parts.slice(0, depth).join(\".\")}.*`;\n          this.#eventHub.didExitState.notify({\n            state,\n            durationMs: now2 - entryTime\n          });\n        }\n      }\n    });\n  }\n  /**\n   * Enters the current state, and executes any necessary onEnter handlers.\n   * Call this directly _after_ setting the current state to the next state.\n   */\n  #enter(levels) {\n    const enterPatterns = patterns(\n      this.currentState,\n      levels ?? this.currentState.split(\".\").length + 1\n    );\n    const now2 = performance.now();\n    this.#currentContext.allowPatching((patchableContext) => {\n      for (const pattern of enterPatterns) {\n        const enterFn = this.#enterFns.get(pattern);\n        const cleanupFn = enterFn?.(patchableContext);\n        if (typeof cleanupFn === \"function\") {\n          this.#cleanupStack.push(cleanupFn);\n        } else {\n          this.#cleanupStack.push(null);\n        }\n        this.#entryTimesStack.push(now2);\n      }\n    });\n    this.#eventHub.didEnterState.notify(this.currentState);\n  }\n  /**\n   * Sends an event to the machine, which may cause an internal state\n   * transition to happen. When that happens, will trigger side effects.\n   */\n  send(event) {\n    if (!this.#knownEventTypes.has(event.type)) {\n      throw new Error(`Invalid event ${JSON.stringify(event.type)}`);\n    }\n    if (this.#runningState === 2 /* STOPPED */) {\n      return;\n    }\n    const targetFn = this.#getTargetFn(event.type);\n    if (targetFn !== void 0) {\n      return this.#transition(event, targetFn);\n    } else {\n      this.#eventHub.didIgnoreEvent.notify(event);\n    }\n  }\n  #transition(event, target) {\n    this.#eventHub.didReceiveEvent.notify(event);\n    const oldState = this.currentState;\n    const targetFn = typeof target === \"function\" ? target : () => target;\n    const nextTarget = targetFn(event, this.#currentContext.current);\n    let nextState;\n    let effects = void 0;\n    if (nextTarget === null) {\n      this.#eventHub.didIgnoreEvent.notify(event);\n      return;\n    }\n    if (typeof nextTarget === \"string\") {\n      nextState = nextTarget;\n    } else {\n      nextState = nextTarget.target;\n      effects = Array.isArray(nextTarget.effect) ? nextTarget.effect : [nextTarget.effect];\n    }\n    if (!this.#states.has(nextState)) {\n      throw new Error(`Invalid next state name: ${JSON.stringify(nextState)}`);\n    }\n    this.#eventHub.willTransition.notify({ from: oldState, to: nextState });\n    const [up, down] = distance(this.currentState, nextState);\n    if (up > 0) {\n      this.#exit(up);\n    }\n    this.#currentStateOrNull = nextState;\n    if (effects !== void 0) {\n      const effectsToRun = effects;\n      this.#currentContext.allowPatching((patchableContext) => {\n        for (const effect of effectsToRun) {\n          if (typeof effect === \"function\") {\n            effect(patchableContext, event);\n          } else {\n            patchableContext.patch(effect);\n          }\n        }\n      });\n    }\n    if (down > 0) {\n      this.#enter(down);\n    }\n  }\n};\n\n// src/protocol/ServerMsg.ts\nvar ServerMsgCode = Object.freeze({\n  // For Presence\n  UPDATE_PRESENCE: 100,\n  USER_JOINED: 101,\n  USER_LEFT: 102,\n  BROADCASTED_EVENT: 103,\n  ROOM_STATE: 104,\n  // For Storage\n  STORAGE_STATE_V7: 200,\n  // Only sent in V7\n  STORAGE_CHUNK: 210,\n  // Used in V8+\n  STORAGE_STREAM_END: 211,\n  // Used in V8+\n  UPDATE_STORAGE: 201,\n  // For Yjs Docs\n  UPDATE_YDOC: 300,\n  // For Comments\n  THREAD_CREATED: 400,\n  THREAD_DELETED: 407,\n  THREAD_METADATA_UPDATED: 401,\n  THREAD_UPDATED: 408,\n  COMMENT_CREATED: 402,\n  COMMENT_EDITED: 403,\n  COMMENT_DELETED: 404,\n  COMMENT_REACTION_ADDED: 405,\n  COMMENT_REACTION_REMOVED: 406,\n  COMMENT_METADATA_UPDATED: 409,\n  // Error codes\n  REJECT_STORAGE_OP: 299\n  // Sent if a mutation was not allowed on the server (i.e. due to permissions, limit exceeded, etc)\n});\n\n// src/types/IWebSocket.ts\nvar WebsocketCloseCodes = /* @__PURE__ */ ((WebsocketCloseCodes2) => {\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"CLOSE_NORMAL\"] = 1e3] = \"CLOSE_NORMAL\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"CLOSE_ABNORMAL\"] = 1006] = \"CLOSE_ABNORMAL\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"UNEXPECTED_CONDITION\"] = 1011] = \"UNEXPECTED_CONDITION\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"TRY_AGAIN_LATER\"] = 1013] = \"TRY_AGAIN_LATER\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"INVALID_MESSAGE_FORMAT\"] = 4e3] = \"INVALID_MESSAGE_FORMAT\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"NOT_ALLOWED\"] = 4001] = \"NOT_ALLOWED\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_MESSAGES_PER_SECONDS\"] = 4002] = \"MAX_NUMBER_OF_MESSAGES_PER_SECONDS\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS\"] = 4003] = \"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP\"] = 4004] = \"MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM\"] = 4005] = \"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"ROOM_ID_UPDATED\"] = 4006] = \"ROOM_ID_UPDATED\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"KICKED\"] = 4100] = \"KICKED\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"TOKEN_EXPIRED\"] = 4109] = \"TOKEN_EXPIRED\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"CLOSE_WITHOUT_RETRY\"] = 4999] = \"CLOSE_WITHOUT_RETRY\";\n  return WebsocketCloseCodes2;\n})(WebsocketCloseCodes || {});\nfunction shouldDisconnect(code) {\n  return code === 4999 /* CLOSE_WITHOUT_RETRY */ || code >= 4e3 && code < 4100;\n}\nfunction shouldReauth(code) {\n  return code >= 4100 && code < 4200;\n}\nfunction shouldRetryWithoutReauth(code) {\n  return code === 1013 /* TRY_AGAIN_LATER */ || code >= 4200 && code < 4300;\n}\n\n// src/connection.ts\nfunction isIdle(status) {\n  return status === \"initial\" || status === \"disconnected\";\n}\nfunction toNewConnectionStatus(machine) {\n  const state = machine.currentState;\n  switch (state) {\n    case \"@ok.connected\":\n    case \"@ok.awaiting-pong\":\n      return \"connected\";\n    case \"@idle.initial\":\n      return \"initial\";\n    case \"@auth.busy\":\n    case \"@auth.backoff\":\n    case \"@connecting.busy\":\n    case \"@connecting.backoff\":\n    case \"@idle.zombie\":\n      return machine.context.successCount > 0 ? \"reconnecting\" : \"connecting\";\n    case \"@idle.failed\":\n      return \"disconnected\";\n    // istanbul ignore next\n    default:\n      return assertNever(state, \"Unknown state\");\n  }\n}\nvar BACKOFF_DELAYS = [250, 500, 1e3, 2e3, 4e3, 8e3, 1e4];\nvar RESET_DELAY = BACKOFF_DELAYS[0] - 1;\nvar BACKOFF_DELAYS_SLOW = [2e3, 3e4, 6e4, 3e5];\nvar HEARTBEAT_INTERVAL = 3e4;\nvar PONG_TIMEOUT = 2e3;\nvar AUTH_TIMEOUT = 1e4;\nvar SOCKET_CONNECT_TIMEOUT = 2e4;\nvar StopRetrying = class extends Error {\n  constructor(reason) {\n    super(reason);\n  }\n};\nfunction nextBackoffDelay(currentDelay, delays) {\n  return delays.find((delay) => delay > currentDelay) ?? delays[delays.length - 1];\n}\nfunction increaseBackoffDelay(context) {\n  context.patch({\n    backoffDelay: nextBackoffDelay(context.backoffDelay, BACKOFF_DELAYS)\n  });\n}\nfunction increaseBackoffDelayAggressively(context) {\n  context.patch({\n    backoffDelay: nextBackoffDelay(context.backoffDelay, BACKOFF_DELAYS_SLOW)\n  });\n}\nfunction resetSuccessCount(context) {\n  context.patch({ successCount: 0 });\n}\nfunction log(level, message) {\n  const logger = level === 2 /* ERROR */ ? error2 : level === 1 /* WARN */ ? warn : (\n    /* black hole */\n    () => {\n    }\n  );\n  return () => {\n    logger(message);\n  };\n}\nfunction logPrematureErrorOrCloseEvent(e) {\n  const conn = \"Connection to Liveblocks websocket server\";\n  return (ctx) => {\n    if (isCloseEvent(e)) {\n      warn(\n        `${conn} closed prematurely (code: ${e.code}). Retrying in ${ctx.backoffDelay}ms.`\n      );\n    } else {\n      warn(`${conn} could not be established.`, e);\n    }\n  };\n}\nfunction logCloseEvent(event) {\n  const details = [`code: ${event.code}`];\n  if (event.reason) {\n    details.push(`reason: ${event.reason}`);\n  }\n  return (ctx) => {\n    warn(\n      `Connection to Liveblocks websocket server closed (${details.join(\", \")}). Retrying in ${ctx.backoffDelay}ms.`\n    );\n  };\n}\nvar logPermanentClose = log(\n  1 /* WARN */,\n  \"Connection to WebSocket closed permanently. Won't retry.\"\n);\nfunction isCloseEvent(error3) {\n  return !(error3 instanceof Error) && error3.type === \"close\";\n}\nfunction enableTracing(machine) {\n  function log2(...args) {\n    warn(`[FSM #${machine.id}]`, ...args);\n  }\n  const unsubs = [\n    machine.events.didReceiveEvent.subscribe((e) => log2(`Event ${e.type}`)),\n    machine.events.willTransition.subscribe(\n      ({ from, to }) => log2(\"Transitioning\", from, \"\\u2192\", to)\n    ),\n    machine.events.didExitState.subscribe(\n      ({ state, durationMs }) => log2(`Exited ${state} after ${durationMs.toFixed(0)}ms`)\n    ),\n    machine.events.didIgnoreEvent.subscribe(\n      (e) => log2(\"Ignored event\", e.type, e, \"(current state won't handle it)\")\n    )\n  ];\n  return () => {\n    for (const unsub of unsubs) {\n      unsub();\n    }\n  };\n}\nfunction defineConnectivityEvents(machine) {\n  const statusDidChange = makeEventSource();\n  const didConnect = makeEventSource();\n  const didDisconnect = makeEventSource();\n  let lastStatus = null;\n  const unsubscribe = machine.events.didEnterState.subscribe(() => {\n    const currStatus = toNewConnectionStatus(machine);\n    if (currStatus !== lastStatus) {\n      statusDidChange.notify(currStatus);\n    }\n    if (lastStatus === \"connected\" && currStatus !== \"connected\") {\n      didDisconnect.notify();\n    } else if (lastStatus !== \"connected\" && currStatus === \"connected\") {\n      didConnect.notify();\n    }\n    lastStatus = currStatus;\n  });\n  return {\n    statusDidChange: statusDidChange.observable,\n    didConnect: didConnect.observable,\n    didDisconnect: didDisconnect.observable,\n    unsubscribe\n  };\n}\nvar assign = (patch) => (ctx) => ctx.patch(patch);\nfunction createConnectionStateMachine(delegates, options) {\n  const onMessage = makeBufferableEventSource();\n  onMessage.pause();\n  const onConnectionError = makeEventSource();\n  function fireErrorEvent(message, code) {\n    return () => {\n      onConnectionError.notify({ message, code });\n    };\n  }\n  const initialContext = {\n    successCount: 0,\n    authValue: null,\n    socket: null,\n    backoffDelay: RESET_DELAY\n  };\n  const machine = new FSM(initialContext).addState(\"@idle.initial\").addState(\"@idle.failed\").addState(\"@idle.zombie\").addState(\"@auth.busy\").addState(\"@auth.backoff\").addState(\"@connecting.busy\").addState(\"@connecting.backoff\").addState(\"@ok.connected\").addState(\"@ok.awaiting-pong\");\n  machine.addTransitions(\"*\", {\n    RECONNECT: {\n      target: \"@auth.backoff\",\n      effect: [increaseBackoffDelay, resetSuccessCount]\n    },\n    DISCONNECT: \"@idle.initial\"\n  });\n  machine.onEnter(\"@idle.*\", resetSuccessCount).addTransitions(\"@idle.*\", {\n    CONNECT: (_, ctx) => (\n      // If we still have a known authValue, try to reconnect to the socket directly,\n      // otherwise, try to obtain a new authValue\n      ctx.authValue !== null ? \"@connecting.busy\" : \"@auth.busy\"\n    )\n  });\n  machine.addTransitions(\"@auth.backoff\", {\n    NAVIGATOR_ONLINE: {\n      target: \"@auth.busy\",\n      effect: assign({ backoffDelay: RESET_DELAY })\n    }\n  }).addTimedTransition(\n    \"@auth.backoff\",\n    (ctx) => ctx.backoffDelay,\n    \"@auth.busy\"\n  ).onEnterAsync(\n    \"@auth.busy\",\n    () => withTimeout(\n      delegates.authenticate(),\n      AUTH_TIMEOUT,\n      \"Timed out during auth\"\n    ),\n    // On successful authentication\n    (okEvent) => ({\n      target: \"@connecting.busy\",\n      effect: assign({\n        authValue: okEvent.data\n      })\n    }),\n    // Auth failed\n    (failedEvent) => {\n      if (failedEvent.reason instanceof StopRetrying) {\n        return {\n          target: \"@idle.failed\",\n          effect: [\n            log(2 /* ERROR */, failedEvent.reason.message),\n            fireErrorEvent(failedEvent.reason.message, -1)\n          ]\n        };\n      }\n      return {\n        target: \"@auth.backoff\",\n        effect: [\n          increaseBackoffDelay,\n          log(\n            2 /* ERROR */,\n            `Authentication failed: ${failedEvent.reason instanceof Error ? failedEvent.reason.message : String(failedEvent.reason)}`\n          )\n        ]\n      };\n    }\n  );\n  const onSocketError = (event) => machine.send({ type: \"EXPLICIT_SOCKET_ERROR\", event });\n  const onSocketClose = (event) => machine.send({ type: \"EXPLICIT_SOCKET_CLOSE\", event });\n  const onSocketMessage = (event) => event.data === \"pong\" ? machine.send({ type: \"PONG\" }) : onMessage.notify(event);\n  function teardownSocket(socket) {\n    if (socket) {\n      socket.removeEventListener(\"error\", onSocketError);\n      socket.removeEventListener(\"close\", onSocketClose);\n      socket.removeEventListener(\"message\", onSocketMessage);\n      socket.close();\n    }\n  }\n  machine.addTransitions(\"@connecting.backoff\", {\n    NAVIGATOR_ONLINE: {\n      target: \"@connecting.busy\",\n      effect: assign({ backoffDelay: RESET_DELAY })\n    }\n  }).addTimedTransition(\n    \"@connecting.backoff\",\n    (ctx) => ctx.backoffDelay,\n    \"@connecting.busy\"\n  ).onEnterAsync(\n    \"@connecting.busy\",\n    //\n    // Use the \"createSocket\" delegate function (provided to the\n    // ManagedSocket) to create the actual WebSocket connection instance.\n    // Then, set up all the necessary event listeners, and wait for the\n    // \"open\" event to occur.\n    //\n    // When the \"open\" event happens, we're ready to transition to the\n    // OK state. This is done by resolving the Promise.\n    //\n    async (ctx, signal) => {\n      const socketEpoch = performance.now();\n      let socketOpenAt = null;\n      let capturedPrematureEvent = null;\n      let unconfirmedSocket = null;\n      const connect$ = new Promise(\n        (resolve, rej) => {\n          if (ctx.authValue === null) {\n            throw new Error(\"No auth authValue\");\n          }\n          const socket = delegates.createSocket(ctx.authValue);\n          unconfirmedSocket = socket;\n          function reject(event) {\n            capturedPrematureEvent = event;\n            socket.removeEventListener(\"message\", onSocketMessage);\n            rej(event);\n          }\n          const [actor$, didReceiveActor] = controlledPromise();\n          if (!options.waitForActorId) {\n            didReceiveActor();\n          }\n          function waitForActorId(event) {\n            const serverMsg = tryParseJson(event.data);\n            if (serverMsg?.type === ServerMsgCode.ROOM_STATE) {\n              if (options.enableDebugLogging && socketOpenAt !== null) {\n                const elapsed = performance.now() - socketOpenAt;\n                warn(\n                  `[FSM #${machine.id}] Socket open \\u2192 ROOM_STATE: ${elapsed.toFixed(0)}ms`\n                );\n              }\n              didReceiveActor();\n            }\n          }\n          socket.addEventListener(\"message\", onSocketMessage);\n          if (options.waitForActorId) {\n            socket.addEventListener(\"message\", waitForActorId);\n          }\n          socket.addEventListener(\"error\", reject);\n          socket.addEventListener(\"close\", reject);\n          socket.addEventListener(\"open\", () => {\n            socketOpenAt = performance.now();\n            if (options.enableDebugLogging) {\n              const elapsed = socketOpenAt - socketEpoch;\n              warn(\n                `[FSM #${machine.id}] Socket epoch \\u2192 open: ${elapsed.toFixed(0)}ms`\n              );\n            }\n            socket.addEventListener(\"error\", onSocketError);\n            socket.addEventListener(\"close\", onSocketClose);\n            const unsub = () => {\n              socket.removeEventListener(\"error\", reject);\n              socket.removeEventListener(\"close\", reject);\n              socket.removeEventListener(\"message\", waitForActorId);\n            };\n            void actor$.then(() => {\n              resolve([socket, unsub]);\n            });\n          });\n        }\n      );\n      return withTimeout(\n        connect$,\n        SOCKET_CONNECT_TIMEOUT,\n        \"Timed out during websocket connection\"\n      ).then(\n        //\n        // Part 3:\n        // By now, our \"open\" event has fired, and the promise has been\n        // resolved. Two possible scenarios:\n        //\n        // 1. The happy path. Most likely.\n        // 2. Uh-oh. A premature close/error event has been observed. Let's\n        //    reject the promise after all.\n        //\n        // Any close/error event that will get scheduled after this point\n        // onwards, will be caught in the OK state, and dealt with\n        // accordingly.\n        //\n        ([socket, unsub]) => {\n          unsub();\n          if (signal.aborted) {\n            throw new Error(\"Aborted\");\n          }\n          if (capturedPrematureEvent) {\n            throw capturedPrematureEvent;\n          }\n          return socket;\n        }\n      ).catch((e) => {\n        teardownSocket(unconfirmedSocket);\n        throw e;\n      });\n    },\n    // Only transition to OK state after a successfully opened WebSocket connection\n    (okEvent) => ({\n      target: \"@ok.connected\",\n      effect: assign({\n        socket: okEvent.data,\n        backoffDelay: RESET_DELAY\n      })\n    }),\n    // If the WebSocket connection cannot be established\n    (failure) => {\n      const err = failure.reason;\n      if (err instanceof StopRetrying) {\n        return {\n          target: \"@idle.failed\",\n          effect: [\n            log(2 /* ERROR */, err.message),\n            fireErrorEvent(err.message, -1)\n          ]\n        };\n      }\n      if (isCloseEvent(err)) {\n        if (err.code === 4109 /* TOKEN_EXPIRED */) {\n          return \"@auth.busy\";\n        }\n        if (shouldRetryWithoutReauth(err.code)) {\n          return {\n            target: \"@connecting.backoff\",\n            effect: [\n              increaseBackoffDelayAggressively,\n              logPrematureErrorOrCloseEvent(err)\n            ]\n          };\n        }\n        if (shouldDisconnect(err.code)) {\n          return {\n            target: \"@idle.failed\",\n            effect: [\n              log(2 /* ERROR */, err.reason),\n              fireErrorEvent(err.reason, err.code)\n            ]\n          };\n        }\n      }\n      return {\n        target: \"@auth.backoff\",\n        effect: [increaseBackoffDelay, logPrematureErrorOrCloseEvent(err)]\n      };\n    }\n  );\n  const sendHeartbeat = {\n    target: \"@ok.awaiting-pong\",\n    effect: (ctx) => {\n      ctx.socket?.send(\"ping\");\n    }\n  };\n  const maybeHeartbeat = () => {\n    const doc = typeof document !== \"undefined\" ? document : void 0;\n    const canZombie = doc?.visibilityState === \"hidden\" && delegates.canZombie();\n    return canZombie ? \"@idle.zombie\" : sendHeartbeat;\n  };\n  machine.addTimedTransition(\"@ok.connected\", HEARTBEAT_INTERVAL, maybeHeartbeat).addTransitions(\"@ok.connected\", {\n    NAVIGATOR_OFFLINE: maybeHeartbeat,\n    // Don't take the browser's word for it when it says it's offline. Do a ping/pong to make sure.\n    WINDOW_GOT_FOCUS: sendHeartbeat\n  });\n  machine.addTransitions(\"@idle.zombie\", {\n    WINDOW_GOT_FOCUS: \"@connecting.backoff\"\n    // When in zombie state, the client will try to wake up automatically when the window regains focus\n  });\n  machine.onEnter(\"@ok.*\", (ctx) => {\n    ctx.patch({ successCount: ctx.successCount + 1 });\n    const timerID = setTimeout(\n      // On the next tick, start delivering all messages that have already\n      // been received, and continue synchronous delivery of all future\n      // incoming messages.\n      onMessage.unpause,\n      0\n    );\n    return (ctx2) => {\n      teardownSocket(ctx2.socket);\n      ctx2.patch({ socket: null });\n      clearTimeout(timerID);\n      onMessage.pause();\n    };\n  }).addTransitions(\"@ok.awaiting-pong\", { PONG: \"@ok.connected\" }).addTimedTransition(\"@ok.awaiting-pong\", PONG_TIMEOUT, {\n    target: \"@connecting.busy\",\n    // Log implicit connection loss and drop the current open socket\n    effect: log(\n      1 /* WARN */,\n      \"Received no pong from server, assume implicit connection loss.\"\n    )\n  }).addTransitions(\"@ok.*\", {\n    // When a socket receives an error, this can cause the closing of the\n    // socket, or not. So always check to see if the socket is still OPEN or\n    // not. When still OPEN, don't transition.\n    EXPLICIT_SOCKET_ERROR: (_, context) => {\n      if (context.socket?.readyState === 1) {\n        return null;\n      }\n      return {\n        target: \"@connecting.backoff\",\n        effect: increaseBackoffDelay\n      };\n    },\n    EXPLICIT_SOCKET_CLOSE: (e) => {\n      if (shouldDisconnect(e.event.code)) {\n        return {\n          target: \"@idle.failed\",\n          effect: [\n            logPermanentClose,\n            fireErrorEvent(e.event.reason, e.event.code)\n          ]\n        };\n      }\n      if (shouldReauth(e.event.code)) {\n        if (e.event.code === 4109 /* TOKEN_EXPIRED */) {\n          return \"@auth.busy\";\n        } else {\n          return {\n            target: \"@auth.backoff\",\n            effect: [increaseBackoffDelay, logCloseEvent(e.event)]\n          };\n        }\n      }\n      if (shouldRetryWithoutReauth(e.event.code)) {\n        return {\n          target: \"@connecting.backoff\",\n          effect: [increaseBackoffDelayAggressively, logCloseEvent(e.event)]\n        };\n      }\n      return {\n        target: \"@connecting.backoff\",\n        effect: [increaseBackoffDelay, logCloseEvent(e.event)]\n      };\n    }\n  });\n  if (typeof document !== \"undefined\") {\n    const doc = typeof document !== \"undefined\" ? document : void 0;\n    const win = typeof window !== \"undefined\" ? window : void 0;\n    const root = win ?? doc;\n    machine.onEnter(\"*\", (ctx) => {\n      function onNetworkOffline() {\n        machine.send({ type: \"NAVIGATOR_OFFLINE\" });\n      }\n      function onNetworkBackOnline() {\n        machine.send({ type: \"NAVIGATOR_ONLINE\" });\n      }\n      function onVisibilityChange() {\n        if (doc?.visibilityState === \"visible\") {\n          machine.send({ type: \"WINDOW_GOT_FOCUS\" });\n        }\n      }\n      win?.addEventListener(\"online\", onNetworkBackOnline);\n      win?.addEventListener(\"offline\", onNetworkOffline);\n      root?.addEventListener(\"visibilitychange\", onVisibilityChange);\n      return () => {\n        root?.removeEventListener(\"visibilitychange\", onVisibilityChange);\n        win?.removeEventListener(\"online\", onNetworkBackOnline);\n        win?.removeEventListener(\"offline\", onNetworkOffline);\n        teardownSocket(ctx.socket);\n      };\n    });\n  }\n  const cleanups = [];\n  const { statusDidChange, didConnect, didDisconnect, unsubscribe } = defineConnectivityEvents(machine);\n  cleanups.push(unsubscribe);\n  if (options.enableDebugLogging) {\n    cleanups.push(enableTracing(machine));\n  }\n  machine.start();\n  return {\n    machine,\n    cleanups,\n    // Observable events that will be emitted by this machine\n    events: {\n      statusDidChange,\n      didConnect,\n      didDisconnect,\n      onMessage: onMessage.observable,\n      onConnectionError: onConnectionError.observable\n    }\n  };\n}\nvar ManagedSocket = class {\n  #machine;\n  #cleanups;\n  events;\n  constructor(delegates, enableDebugLogging = false, waitForActorId = true) {\n    const { machine, events, cleanups } = createConnectionStateMachine(\n      delegates,\n      { waitForActorId, enableDebugLogging }\n    );\n    this.#machine = machine;\n    this.events = events;\n    this.#cleanups = cleanups;\n  }\n  getStatus() {\n    try {\n      return toNewConnectionStatus(this.#machine);\n    } catch {\n      return \"initial\";\n    }\n  }\n  /**\n   * Returns the current auth authValue.\n   */\n  get authValue() {\n    return this.#machine.context.authValue;\n  }\n  /**\n   * Call this method to try to connect to a WebSocket. This only has an effect\n   * if the machine is idle at the moment, otherwise this is a no-op.\n   */\n  connect() {\n    this.#machine.send({ type: \"CONNECT\" });\n  }\n  /**\n   * If idle, will try to connect. Otherwise, it will attempt to reconnect to\n   * the socket, potentially obtaining a new authValue first, if needed.\n   */\n  reconnect() {\n    this.#machine.send({ type: \"RECONNECT\" });\n  }\n  /**\n   * Call this method to disconnect from the current WebSocket. Is going to be\n   * a no-op if there is no active connection.\n   */\n  disconnect() {\n    this.#machine.send({ type: \"DISCONNECT\" });\n  }\n  /**\n   * Call this to stop the machine and run necessary cleanup functions. After\n   * calling destroy(), you can no longer use this instance. Call this before\n   * letting the instance get garbage collected.\n   */\n  destroy() {\n    this.#machine.stop();\n    let cleanup;\n    while (cleanup = this.#cleanups.pop()) {\n      cleanup();\n    }\n  }\n  /**\n   * Safely send a message to the current WebSocket connection. Will emit a log\n   * message if this is somehow impossible.\n   */\n  send(data) {\n    const socket = this.#machine.context?.socket;\n    if (socket === null) {\n      warn(\"Cannot send: not connected yet\", data);\n    } else if (socket.readyState !== 1) {\n      warn(\"Cannot send: WebSocket no longer open\", data);\n    } else {\n      socket.send(data);\n    }\n  }\n  /**\n   * NOTE: Used by the E2E app only, to simulate explicit events.\n   * Not ideal to keep exposed :(\n   */\n  _privateSendMachineEvent(event) {\n    this.#machine.send(event);\n  }\n};\n\n// src/internal.ts\nvar kInternal = Symbol();\n\n// src/lib/IncrementalJsonParser.ts\nvar EMPTY_OBJECT = Object.freeze({});\nvar NULL_KEYWORD_CHARS = Array.from(new Set(\"null\"));\nvar TRUE_KEYWORD_CHARS = Array.from(new Set(\"true\"));\nvar FALSE_KEYWORD_CHARS = Array.from(new Set(\"false\"));\nvar ALL_KEYWORD_CHARS = Array.from(new Set(\"nulltruefalse\"));\nfunction stripChar(str, chars) {\n  const lastChar = str[str.length - 1];\n  if (chars.includes(lastChar)) {\n    return str.slice(0, -1);\n  }\n  return str;\n}\nvar IncrementalJsonParser = class {\n  // Input\n  #sourceText = \"\";\n  // Output\n  #cachedJson;\n  /** How much we've already parsed */\n  #scanIndex = 0;\n  /** Whether the last char processed was a backslash */\n  #escaped = false;\n  /**\n   * Start position of the last unterminated string, -1 if we're not inside\n   * a string currently.\n   *\n   * Example: '{\"a\": \"foo'\n   *                 ^\n   */\n  #lastUnterminatedString = -1;\n  /**\n   * Start position of the last fully terminated string we've seen.\n   *\n   * Example: '{\"a\": \"foo'\n   *            ^\n   */\n  #lastTerminatedString = -1;\n  /** The bracket stack of expected closing chars. For input '{\"a\": [\"foo', the stack would be ['}', ']']. */\n  #stack = [];\n  constructor(text = \"\") {\n    this.append(text);\n  }\n  get source() {\n    return this.#sourceText;\n  }\n  get json() {\n    if (this.#cachedJson === void 0) {\n      this.#cachedJson = this.#parse();\n    }\n    return this.#cachedJson;\n  }\n  /** Whether we're currently inside an unterminated string, e.g. '{\"hello' */\n  get #inString() {\n    return this.#lastUnterminatedString >= 0;\n  }\n  append(delta) {\n    if (delta) {\n      if (this.#sourceText === \"\") {\n        delta = delta.trimStart();\n      }\n      this.#sourceText += delta;\n      this.#cachedJson = void 0;\n    }\n  }\n  #autocompleteTail(output) {\n    if (this.#inString) {\n      return \"\";\n    }\n    const lastChar = output.charAt(output.length - 1);\n    if (lastChar === \"\") return \"\";\n    if (lastChar === \"-\") {\n      return \"0\";\n    }\n    if (!ALL_KEYWORD_CHARS.includes(lastChar)) return \"\";\n    if (NULL_KEYWORD_CHARS.includes(lastChar)) {\n      if (output.endsWith(\"nul\")) return \"l\";\n      if (output.endsWith(\"nu\")) return \"ll\";\n      if (output.endsWith(\"n\")) return \"ull\";\n    }\n    if (TRUE_KEYWORD_CHARS.includes(lastChar)) {\n      if (output.endsWith(\"tru\")) return \"e\";\n      if (output.endsWith(\"tr\")) return \"ue\";\n      if (output.endsWith(\"t\")) return \"rue\";\n    }\n    if (FALSE_KEYWORD_CHARS.includes(lastChar)) {\n      if (output.endsWith(\"fals\")) return \"e\";\n      if (output.endsWith(\"fal\")) return \"se\";\n      if (output.endsWith(\"fa\")) return \"lse\";\n      if (output.endsWith(\"f\")) return \"alse\";\n    }\n    return \"\";\n  }\n  /**\n   * Updates the internal parsing state by processing any new content\n   * that has been appended since the last parse. This updates the state with\n   * facts only. Any interpretation is left to the #parse() method.\n   */\n  #catchup() {\n    const newContent = this.#sourceText.slice(this.#scanIndex);\n    for (let i = 0; i < newContent.length; i++) {\n      const ch = newContent[i];\n      const absolutePos = this.#scanIndex + i;\n      if (this.#inString) {\n        if (this.#escaped) {\n          this.#escaped = false;\n        } else if (ch === \"\\\\\") {\n          this.#escaped = true;\n        } else if (ch === '\"') {\n          this.#lastTerminatedString = this.#lastUnterminatedString;\n          this.#lastUnterminatedString = -1;\n        }\n      } else {\n        if (ch === '\"') {\n          this.#lastUnterminatedString = absolutePos;\n        } else if (ch === \"{\") {\n          this.#stack.push(\"}\");\n        } else if (ch === \"[\") {\n          this.#stack.push(\"]\");\n        } else if (ch === \"}\" && this.#stack.length > 0 && this.#stack[this.#stack.length - 1] === \"}\") {\n          this.#stack.pop();\n        } else if (ch === \"]\" && this.#stack.length > 0 && this.#stack[this.#stack.length - 1] === \"]\") {\n          this.#stack.pop();\n        }\n      }\n    }\n    this.#scanIndex = this.#sourceText.length;\n  }\n  #parse() {\n    this.#catchup();\n    let result = this.#sourceText;\n    if (result.charAt(0) !== \"{\") {\n      return EMPTY_OBJECT;\n    }\n    if (result.endsWith(\"}\")) {\n      const quickCheck = tryParseJson(result);\n      if (quickCheck) {\n        return quickCheck;\n      }\n    }\n    if (this.#inString) {\n      if (this.#escaped) {\n        result = result.slice(0, -1);\n      }\n      result += '\"';\n    }\n    result = result.trimEnd();\n    result = stripChar(result, \",.\");\n    result = result + this.#autocompleteTail(result);\n    const suffix = this.#stack.reduceRight((acc, ch) => acc + ch, \"\");\n    {\n      const attempt = tryParseJson(result + suffix);\n      if (attempt) {\n        return attempt;\n      }\n    }\n    if (this.#inString) {\n      result = result.slice(0, this.#lastUnterminatedString);\n    } else {\n      result = stripChar(result, \":\");\n      if (result.endsWith('\"')) {\n        result = result.slice(0, this.#lastTerminatedString);\n      }\n    }\n    result = stripChar(result, \",\");\n    result += suffix;\n    return tryParseJson(result) ?? EMPTY_OBJECT;\n  }\n};\n\n// src/lib/shallow.ts\nfunction shallowArray(xs, ys) {\n  if (xs.length !== ys.length) {\n    return false;\n  }\n  for (let i = 0; i < xs.length; i++) {\n    if (!Object.is(xs[i], ys[i])) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction shallowObj(objA, objB) {\n  if (!isPlainObject(objA) || !isPlainObject(objB)) {\n    return false;\n  }\n  const keysA = Object.keys(objA);\n  if (keysA.length !== Object.keys(objB).length) {\n    return false;\n  }\n  return keysA.every(\n    (key) => Object.prototype.hasOwnProperty.call(objB, key) && Object.is(objA[key], objB[key])\n  );\n}\nfunction shallow(a, b) {\n  if (Object.is(a, b)) {\n    return true;\n  }\n  const isArrayA = Array.isArray(a);\n  const isArrayB = Array.isArray(b);\n  if (isArrayA || isArrayB) {\n    if (!isArrayA || !isArrayB) {\n      return false;\n    }\n    return shallowArray(a, b);\n  }\n  return shallowObj(a, b);\n}\nfunction shallow2(a, b) {\n  if (!isPlainObject(a) || !isPlainObject(b)) {\n    return shallow(a, b);\n  }\n  const keysA = Object.keys(a);\n  if (keysA.length !== Object.keys(b).length) {\n    return false;\n  }\n  return keysA.every(\n    (key) => Object.prototype.hasOwnProperty.call(b, key) && shallow(a[key], b[key])\n  );\n}\n\n// src/lib/TreePool.ts\nvar TreePool = class {\n  #_items;\n  #_childrenOf;\n  #_sorted;\n  #_primaryKey;\n  #_parentKeyFn;\n  #_lt;\n  constructor(primaryKey, parentKey, lt) {\n    this.#_primaryKey = primaryKey;\n    this.#_parentKeyFn = parentKey;\n    this.#_lt = lt;\n    this.#_items = /* @__PURE__ */ new Map();\n    this.#_childrenOf = new DefaultMap(() => /* @__PURE__ */ new Set());\n    this.#_sorted = SortedList.with(lt);\n  }\n  get(id) {\n    return this.#_items.get(id);\n  }\n  getOrThrow(id) {\n    return this.get(id) ?? raise(`Item with id ${id} not found`);\n  }\n  get sorted() {\n    return this.#_sorted;\n  }\n  getParentId(id) {\n    const item = this.getOrThrow(id);\n    return this.#_parentKeyFn(item);\n  }\n  getParent(id) {\n    const parentId = this.getParentId(id);\n    return parentId ? this.getOrThrow(parentId) : null;\n  }\n  getChildren(id) {\n    const childIds = this.#_childrenOf.get(id);\n    if (!childIds) return [];\n    return Array.from(childIds).map(\n      (id2) => this.#_items.get(id2)\n      // eslint-disable-line no-restricted-syntax\n    );\n  }\n  *walkUp(id, predicate) {\n    const includeSelf = true;\n    let nodeId = id;\n    do {\n      const item = this.getOrThrow(nodeId);\n      if (includeSelf || nodeId !== id) {\n        if (!predicate || predicate(item)) {\n          yield item;\n        }\n      }\n      nodeId = this.#_parentKeyFn(item);\n    } while (nodeId !== null);\n  }\n  // XXXX Generalize\n  *walkLeft(id, predicate) {\n    const self = this.getOrThrow(id);\n    const siblings = SortedList.from(this.getSiblings(id), this.#_lt);\n    for (const sibling of siblings.iterReversed()) {\n      if (this.#_lt(self, sibling)) continue;\n      if (!predicate || predicate(sibling)) {\n        yield sibling;\n      }\n    }\n  }\n  // XXXX Generalize\n  *walkRight(id, predicate) {\n    const self = this.getOrThrow(id);\n    const siblings = SortedList.from(this.getSiblings(id), this.#_lt);\n    for (const sibling of siblings) {\n      if (this.#_lt(sibling, self)) continue;\n      if (!predicate || predicate(sibling)) {\n        yield sibling;\n      }\n    }\n  }\n  // XXXX Generalize\n  *walkDown(id, predicate) {\n    const children = SortedList.from(this.getChildren(id), this.#_lt).rawArray;\n    for (let i = children.length - 1; i >= 0; i--) {\n      const child = children[i];\n      yield* this.walkDown(\n        this.#_primaryKey(child),\n        predicate\n        // \"depth-first\",\n        // true\n      );\n      if (!predicate || predicate(child)) {\n        yield child;\n      }\n    }\n  }\n  /** Returns all siblings, not including the item itself. */\n  getSiblings(id) {\n    const self = this.getOrThrow(id);\n    const parentId = this.getParentId(id);\n    return this.getChildren(parentId).filter((item) => item !== self);\n  }\n  [Symbol.iterator]() {\n    return this.#_sorted[Symbol.iterator]();\n  }\n  upsert(item) {\n    const pk = this.#_primaryKey(item);\n    const existing = this.#_items.get(pk);\n    if (existing) {\n      if (this.#_parentKeyFn(existing) !== this.#_parentKeyFn(item)) {\n        throw new Error(\n          \"Cannot upsert parent ID changes that change the tree structure. Remove the entry first, and recreate it\"\n        );\n      }\n      this.#_sorted.remove(existing);\n    }\n    this.#_items.set(pk, item);\n    this.#_sorted.add(item);\n    const parentId = this.#_parentKeyFn(item);\n    this.#_childrenOf.getOrCreate(parentId).add(pk);\n  }\n  remove(pk) {\n    const item = this.#_items.get(pk);\n    if (!item) return false;\n    const childIds = this.#_childrenOf.get(pk);\n    if (childIds) {\n      throw new Error(\n        `Cannot remove item '${pk}' while it still has children. Remove children first.`\n      );\n    }\n    const parentId = this.#_parentKeyFn(item);\n    const siblings = this.#_childrenOf.get(parentId);\n    if (siblings) {\n      siblings.delete(pk);\n      if (siblings.size === 0) {\n        this.#_childrenOf.delete(parentId);\n      }\n    }\n    this.#_sorted.remove(item);\n    this.#_childrenOf.delete(pk);\n    this.#_items.delete(pk);\n    return true;\n  }\n  clear() {\n    if (this.#_items.size === 0) return false;\n    this.#_childrenOf.clear();\n    this.#_items.clear();\n    this.#_sorted.clear();\n    return true;\n  }\n};\n\n// src/ai.ts\nvar DEFAULT_REQUEST_TIMEOUT = 4e3;\nfunction defineAiTool() {\n  return (def) => {\n    return def;\n  };\n}\nvar KnowledgeStack = class {\n  #_layers;\n  #stack;\n  //                 /                \\\n  //      knowledge key               \"layer\" key\n  //      (random, or optionally      (one entry per mounted component)\n  //       set by user)\n  #_cache;\n  constructor() {\n    this.#_layers = /* @__PURE__ */ new Set();\n    this.#stack = new DefaultMap(\n      () => /* @__PURE__ */ new Map()\n    );\n    this.#_cache = void 0;\n  }\n  // Typically a useId()\n  registerLayer(uniqueLayerId) {\n    const layerKey = uniqueLayerId;\n    if (this.#_layers.has(layerKey))\n      raise(`Layer '${layerKey}' already exists, provide a unique layer id`);\n    this.#_layers.add(layerKey);\n    return layerKey;\n  }\n  deregisterLayer(layerKey) {\n    this.#_layers.delete(layerKey);\n    let deleted = false;\n    for (const [key, knowledge] of this.#stack) {\n      if (knowledge.delete(layerKey)) {\n        deleted = true;\n      }\n      if (knowledge.size === 0)\n        this.#stack.delete(key);\n    }\n    if (deleted) {\n      this.invalidate();\n    }\n  }\n  get() {\n    return this.#_cache ??= this.#recompute();\n  }\n  invalidate() {\n    this.#_cache = void 0;\n  }\n  #recompute() {\n    return Array.from(this.#stack.values()).flatMap(\n      (layer) => (\n        // Return only the last item (returns [] when empty)\n        Array.from(layer.values()).slice(-1).filter(isDefined)\n      )\n    );\n  }\n  updateKnowledge(layerKey, key, data) {\n    if (!this.#_layers.has(layerKey)) raise(`Unknown layer key: ${layerKey}`);\n    this.#stack.getOrCreate(key).set(layerKey, data);\n    this.invalidate();\n  }\n};\nfunction createStore_forKnowledge() {\n  const knowledgeByChatId = new DefaultMap(\n    (_chatId) => new KnowledgeStack()\n  );\n  function getKnowledgeStack(chatId) {\n    return knowledgeByChatId.getOrCreate(chatId ?? kWILDCARD);\n  }\n  function getKnowledgeForChat(chatId) {\n    const globalKnowledge = knowledgeByChatId.getOrCreate(kWILDCARD).get();\n    const scopedKnowledge = knowledgeByChatId.get(chatId)?.get() ?? [];\n    return [...globalKnowledge, ...scopedKnowledge];\n  }\n  return {\n    getKnowledgeStack,\n    getKnowledgeForChat\n  };\n}\nfunction now() {\n  return (/* @__PURE__ */ new Date()).toISOString();\n}\nvar kWILDCARD = Symbol(\"*\");\nfunction createStore_forTools() {\n  const toolsByChatId\\u03A3 = new DefaultMap(\n    (_chatId) => {\n      return new DefaultMap((_name) => {\n        return new Signal(void 0);\n      });\n    }\n  );\n  const globalOrScopedTool\\u03A3 = new DefaultMap((nameAndChat) => {\n    const [name, chatId] = tryParseJson(nameAndChat);\n    return DerivedSignal.from(() => {\n      return (\n        // A tool that's registered and scoped to a specific chat ID...\n        (chatId !== void 0 ? toolsByChatId\\u03A3.getOrCreate(chatId).getOrCreate(name) : void 0)?.get() ?? // ...or a globally registered tool\n        toolsByChatId\\u03A3.getOrCreate(kWILDCARD).getOrCreate(name).get()\n      );\n    });\n  });\n  function getTool\\u03A3(name, chatId) {\n    const key = JSON.stringify(chatId !== void 0 ? [name, chatId] : [name]);\n    return globalOrScopedTool\\u03A3.getOrCreate(key);\n  }\n  function registerTool(name, tool, chatId) {\n    if (!tool.execute && !tool.render) {\n      throw new Error(\n        \"A tool definition must have an execute() function, a render() function, or both.\"\n      );\n    }\n    const key = chatId ?? kWILDCARD;\n    toolsByChatId\\u03A3.getOrCreate(key).getOrCreate(name).set(tool);\n    return () => unregisterTool(key, name);\n  }\n  function unregisterTool(chatId, name) {\n    const tools = toolsByChatId\\u03A3.get(chatId);\n    if (tools === void 0) return;\n    const tool = tools.get(name);\n    if (tool === void 0) return;\n    tool.set(void 0);\n  }\n  function getToolDescriptions(chatId) {\n    const globalTools\\u03A3 = toolsByChatId\\u03A3.get(kWILDCARD);\n    const scopedTools\\u03A3 = toolsByChatId\\u03A3.get(chatId);\n    return Array.from([\n      ...globalTools\\u03A3?.entries() ?? [],\n      ...scopedTools\\u03A3?.entries() ?? []\n    ]).flatMap(([name, tool\\u03A3]) => {\n      const tool = tool\\u03A3.get();\n      return tool && (tool.enabled ?? true) ? [{ name, description: tool.description, parameters: tool.parameters }] : [];\n    });\n  }\n  return {\n    getToolDescriptions,\n    getTool\\u03A3,\n    registerTool\n  };\n}\nfunction createStore_forChatMessages(toolsStore, setToolResultFn) {\n  const myMessages = /* @__PURE__ */ new Set();\n  const handledInvocations = /* @__PURE__ */ new Set();\n  const messagePoolByChatId\\u03A3 = new DefaultMap(\n    (_chatId) => new MutableSignal(\n      new TreePool(\n        (x) => x.id,\n        (x) => x.parentId,\n        (x, y) => x.createdAt < y.createdAt\n      )\n    )\n  );\n  const generatingMessages\\u03A3 = new MutableSignal(\n    /* @__PURE__ */ new Map()\n  );\n  function createOptimistically(chatId, role, parentId, third) {\n    const id = `ms_${nanoid()}`;\n    const createdAt = now();\n    if (role === \"user\") {\n      const content = third;\n      upsert({\n        id,\n        chatId,\n        role,\n        parentId,\n        createdAt,\n        content,\n        _optimistic: true\n      });\n    } else {\n      const copilotId = third;\n      upsert({\n        id,\n        chatId,\n        role,\n        parentId,\n        createdAt,\n        status: \"generating\",\n        contentSoFar: [],\n        copilotId,\n        _optimistic: true\n      });\n    }\n    return id;\n  }\n  function upsertMany(messages) {\n    batch(() => {\n      for (const message of messages) {\n        upsert(message);\n      }\n    });\n  }\n  function remove(chatId, messageId) {\n    const chatMsgs\\u03A3 = messagePoolByChatId\\u03A3.get(chatId);\n    if (!chatMsgs\\u03A3) return;\n    const existing = chatMsgs\\u03A3.get().get(messageId);\n    if (!existing || existing.deletedAt) return;\n    if (existing.role === \"assistant\" && existing.status !== \"completed\") {\n      upsert({ ...existing, deletedAt: now(), contentSoFar: [] });\n    } else {\n      upsert({ ...existing, deletedAt: now(), content: [] });\n    }\n  }\n  function removeByChatId(chatId) {\n    const chatMsgs\\u03A3 = messagePoolByChatId\\u03A3.get(chatId);\n    if (chatMsgs\\u03A3 === void 0) return;\n    chatMsgs\\u03A3.mutate((pool) => pool.clear());\n  }\n  function upsert(message) {\n    batch(() => {\n      const chatMsgs\\u03A3 = messagePoolByChatId\\u03A3.getOrCreate(message.chatId);\n      chatMsgs\\u03A3.mutate((pool) => pool.upsert(message));\n      if (message.role === \"assistant\" && message.status === \"generating\") {\n        generatingMessages\\u03A3.mutate((lut) => {\n          lut.set(message.id, structuredClone(message));\n        });\n      } else {\n        generatingMessages\\u03A3.mutate((lut) => {\n          lut.delete(message.id);\n        });\n      }\n      if (message.role === \"assistant\" && message.status === \"awaiting-tool\") {\n        if (myMessages.has(message.id)) {\n          for (const toolInvocation of message.contentSoFar.filter(\n            (part) => part.type === \"tool-invocation\" && part.stage === \"executing\"\n          )) {\n            if (!handledInvocations.has(toolInvocation.invocationId)) {\n              handledInvocations.add(toolInvocation.invocationId);\n            } else {\n              continue;\n            }\n            const executeFn = toolsStore.getTool\\u03A3(toolInvocation.name, message.chatId).get()?.execute;\n            if (executeFn) {\n              (async () => {\n                const result = await executeFn(toolInvocation.args, {\n                  name: toolInvocation.name,\n                  invocationId: toolInvocation.invocationId\n                });\n                return await setToolResultFn(\n                  message.chatId,\n                  message.id,\n                  toolInvocation.invocationId,\n                  result ?? { data: {} },\n                  { copilotId: message.copilotId }\n                  // TODO: Should we pass the other generation options (tools, knowledge) as well?\n                );\n              })().catch((err) => {\n                error2(\n                  `Error trying to respond to tool-call: ${String(err)} (in execute())`\n                );\n              });\n            }\n          }\n        }\n      } else {\n        if (message.role === \"assistant\" && message.status === \"generating\") {\n        } else {\n          myMessages.delete(message.id);\n        }\n      }\n    });\n  }\n  function addDelta(messageId, delta) {\n    generatingMessages\\u03A3.mutate((lut) => {\n      const message = lut.get(messageId);\n      if (message === void 0) return false;\n      patchContentWithDelta(message.contentSoFar, delta);\n      lut.set(messageId, message);\n      return true;\n    });\n  }\n  function* iterGeneratingMessages() {\n    for (const chatMsgs\\u03A3 of messagePoolByChatId\\u03A3.values()) {\n      for (const m of chatMsgs\\u03A3.get()) {\n        if (m.role === \"assistant\" && m.status === \"generating\" && !m._optimistic) {\n          yield m;\n        }\n      }\n    }\n  }\n  function failAllPending() {\n    batch(() => {\n      generatingMessages\\u03A3.mutate((lut) => {\n        let deleted = false;\n        for (const [k, v] of lut) {\n          if (!v._optimistic) {\n            lut.delete(k);\n            deleted = true;\n          }\n        }\n        return deleted;\n      });\n      upsertMany(\n        Array.from(iterGeneratingMessages()).map(\n          (message) => ({\n            ...message,\n            status: \"failed\",\n            errorReason: \"Lost connection\"\n          })\n        )\n      );\n    });\n  }\n  function getMessageById(messageId) {\n    for (const messages\\u03A3 of messagePoolByChatId\\u03A3.values()) {\n      const message = messages\\u03A3.get().get(messageId);\n      if (message) {\n        return message;\n      }\n    }\n    return void 0;\n  }\n  function first(iterable) {\n    const result = iterable.next();\n    return result.done ? void 0 : result.value;\n  }\n  function selectBranch(pool, preferredBranch) {\n    function isAlive(message2) {\n      if (!message2.deletedAt) {\n        return true;\n      }\n      for (const _ of pool.walkDown(message2.id, (m) => !m.deletedAt)) {\n        return true;\n      }\n      return false;\n    }\n    function selectSpine(leaf) {\n      const spine = [];\n      let lastVisitedMessage = null;\n      for (const message2 of pool.walkUp(leaf.id)) {\n        const prev = first(pool.walkLeft(message2.id, isAlive))?.id ?? null;\n        const next = first(pool.walkRight(message2.id, isAlive))?.id ?? null;\n        if (!message2.deletedAt || prev || next) {\n          const node = {\n            ...message2,\n            navigation: { parent: null, prev, next }\n          };\n          if (lastVisitedMessage !== null) {\n            lastVisitedMessage.navigation.parent = node.id;\n          }\n          lastVisitedMessage = node;\n          spine.push(node);\n        }\n      }\n      return spine.reverse();\n    }\n    function fallback() {\n      const latest = pool.sorted.findRight((m) => !m.deletedAt);\n      return latest ? selectSpine(latest) : [];\n    }\n    if (preferredBranch === null) {\n      return fallback();\n    }\n    const message = pool.get(preferredBranch);\n    if (!message) {\n      return fallback();\n    }\n    for (const current of pool.walkUp(message.id)) {\n      for (const desc of pool.walkDown(current.id, (m) => !m.deletedAt)) {\n        return selectSpine(desc);\n      }\n      if (!current.deletedAt) {\n        return selectSpine(current);\n      }\n    }\n    return fallback();\n  }\n  const immutableMessagesByBranch = new DefaultMap((chatId) => {\n    return new DefaultMap((branchId) => {\n      const messages\\u03A3 = DerivedSignal.from(() => {\n        const pool = messagePoolByChatId\\u03A3.getOrCreate(chatId).get();\n        return selectBranch(pool, branchId);\n      }, shallow2);\n      return DerivedSignal.from(() => {\n        const generatingMessages = generatingMessages\\u03A3.get();\n        return messages\\u03A3.get().map((message) => {\n          if (message.role !== \"assistant\" || message.status !== \"generating\") {\n            return message;\n          }\n          const generatingMessage = generatingMessages.get(message.id);\n          if (generatingMessage === void 0) return message;\n          return {\n            ...message,\n            contentSoFar: generatingMessage.contentSoFar\n          };\n        });\n      }, shallow);\n    });\n  });\n  function getChatMessagesForBranch\\u03A3(chatId, branch) {\n    return immutableMessagesByBranch.getOrCreate(chatId).getOrCreate(branch || null);\n  }\n  function getLastUsedCopilotId(chatId) {\n    const pool = messagePoolByChatId\\u03A3.getOrCreate(chatId).get();\n    const latest = pool.sorted.findRight(\n      (m) => m.role === \"assistant\" && !m.deletedAt\n    );\n    return latest?.copilotId;\n  }\n  return {\n    // Readers\n    getMessageById,\n    getChatMessagesForBranch\\u03A3,\n    getLastUsedCopilotId,\n    // Mutations\n    createOptimistically,\n    upsert,\n    upsertMany,\n    remove,\n    removeByChatId,\n    addDelta,\n    failAllPending,\n    markMine(messageId) {\n      myMessages.add(messageId);\n    },\n    /**\n     * Iterates over all my auto-executing messages.\n     *\n     * These are messages that match all these conditions:\n     * - The message is an assistant message\n     * - The message is owned by this client (\"mine\")\n     * - The message is currently in \"awaiting-tool\" status\n     * - The message has at least one tool invocation in \"executing\" stage\n     * - The tool invocation has an execute() function defined\n     */\n    *getAutoExecutingMessageIds() {\n      for (const messageId of myMessages) {\n        const message = getMessageById(messageId);\n        if (message?.role === \"assistant\" && message.status === \"awaiting-tool\") {\n          const isAutoExecuting = message.contentSoFar.some((part) => {\n            if (part.type === \"tool-invocation\" && part.stage === \"executing\") {\n              const tool = toolsStore.getTool\\u03A3(part.name, message.chatId).get();\n              return typeof tool?.execute === \"function\";\n            }\n            return false;\n          });\n          if (isAutoExecuting) {\n            yield message.id;\n          }\n        }\n      }\n    }\n  };\n}\nfunction createStore_forUserAiChats() {\n  const chatsDB = new AiChatDB();\n  function upsertMany(chats) {\n    batch(() => {\n      for (const chat of chats) {\n        chatsDB.upsert(chat);\n      }\n    });\n  }\n  function upsert(chat) {\n    chatsDB.upsert(chat);\n  }\n  function markDeleted(chatId) {\n    chatsDB.markDeleted(chatId);\n  }\n  function getChatById(chatId) {\n    return chatsDB.getEvenIfDeleted(chatId);\n  }\n  function findMany(query) {\n    return chatsDB.signal.get().findMany(query);\n  }\n  return {\n    getChatById,\n    findMany,\n    // Mutations\n    upsert,\n    upsertMany,\n    markDeleted\n  };\n}\nfunction createAi(config) {\n  const managedSocket = new ManagedSocket(\n    config.delegates,\n    config.enableDebugLogging,\n    false\n    // AI doesn't have actors (yet, but it will)\n  );\n  const chatsStore = createStore_forUserAiChats();\n  const toolsStore = createStore_forTools();\n  const knowledgeStore = createStore_forKnowledge();\n  const messagesStore = createStore_forChatMessages(toolsStore, setToolResult);\n  const context = {\n    staticSessionInfoSig: new Signal(null),\n    dynamicSessionInfoSig: new Signal(null),\n    pendingCmds: /* @__PURE__ */ new Map(),\n    chatsStore,\n    messagesStore,\n    toolsStore,\n    knowledgeStore\n  };\n  const status\\u03A3 = new Signal(\"initial\");\n  const DELTA_THROTTLE = 25;\n  let pendingDeltas = [];\n  let deltaBatchTimer = null;\n  function flushPendingDeltas() {\n    const currentQueue = pendingDeltas;\n    pendingDeltas = [];\n    if (deltaBatchTimer !== null) {\n      clearTimeout(deltaBatchTimer);\n      deltaBatchTimer = null;\n    }\n    batch(() => {\n      for (const { id, delta } of currentQueue) {\n        context.messagesStore.addDelta(id, delta);\n      }\n    });\n  }\n  function enqueueDelta(id, delta) {\n    pendingDeltas.push({ id, delta });\n    if (deltaBatchTimer === null) {\n      deltaBatchTimer = setTimeout(flushPendingDeltas, DELTA_THROTTLE);\n    }\n  }\n  let lastTokenKey;\n  function onStatusDidChange(newStatus) {\n    const authValue = managedSocket.authValue;\n    if (authValue !== null) {\n      const tokenKey = getBearerTokenFromAuthValue(authValue);\n      if (tokenKey !== lastTokenKey) {\n        lastTokenKey = tokenKey;\n        if (authValue.type === \"secret\") {\n          const token = authValue.token.parsed;\n          context.staticSessionInfoSig.set({\n            userId: token.uid,\n            userInfo: token.ui\n          });\n        } else {\n          context.staticSessionInfoSig.set({\n            userId: void 0,\n            userInfo: void 0\n          });\n        }\n      }\n    }\n    status\\u03A3.set(newStatus);\n  }\n  let _connectionLossTimerId;\n  let _hasLostConnection = false;\n  function handleConnectionLossEvent(newStatus) {\n    if (newStatus === \"reconnecting\") {\n      _connectionLossTimerId = setTimeout(() => {\n        _hasLostConnection = true;\n      }, config.lostConnectionTimeout);\n    } else {\n      clearTimeout(_connectionLossTimerId);\n      if (_hasLostConnection) {\n        _hasLostConnection = false;\n      }\n    }\n  }\n  function onDidConnect() {\n  }\n  function onDidDisconnect() {\n    flushPendingDeltas();\n  }\n  function handleServerMessage(event) {\n    if (typeof event.data !== \"string\")\n      return;\n    const msg = tryParseJson(event.data);\n    if (!msg)\n      return;\n    const cmdId = \"cmdId\" in msg ? msg.cmdId : msg.event === \"cmd-failed\" ? msg.failedCmdId : void 0;\n    const pendingCmd = context.pendingCmds.get(cmdId);\n    if (cmdId && !pendingCmd) {\n      warn(\"Ignoring unexpected command response. Already timed out, or not for us?\", msg);\n      return;\n    }\n    if (\"event\" in msg) {\n      if (msg.event === \"delta\") {\n        const { id, delta } = msg;\n        enqueueDelta(id, delta);\n      } else {\n        batch(() => {\n          flushPendingDeltas();\n          switch (msg.event) {\n            case \"cmd-failed\":\n              pendingCmd?.reject(new Error(msg.error));\n              break;\n            case \"settle\": {\n              context.messagesStore.upsert(msg.message);\n              break;\n            }\n            case \"warning\":\n              warn(msg.message);\n              break;\n            case \"error\":\n              error2(msg.error);\n              break;\n            case \"rebooted\":\n              context.messagesStore.failAllPending();\n              break;\n            case \"sync\":\n              for (const m of msg[\"-messages\"] ?? []) {\n                context.messagesStore.remove(m.chatId, m.id);\n              }\n              for (const chatId of msg[\"-chats\"] ?? []) {\n                context.chatsStore.markDeleted(chatId);\n                context.messagesStore.removeByChatId(chatId);\n              }\n              for (const chatId of msg.clear ?? []) {\n                context.messagesStore.removeByChatId(chatId);\n              }\n              if (msg.chats) {\n                context.chatsStore.upsertMany(msg.chats);\n              }\n              if (msg.messages) {\n                context.messagesStore.upsertMany(msg.messages);\n              }\n              break;\n            default:\n              return assertNever(msg, \"Unhandled case\");\n          }\n        });\n      }\n    } else {\n      switch (msg.cmd) {\n        case \"get-chats\":\n          context.chatsStore.upsertMany(msg.chats);\n          break;\n        case \"get-or-create-chat\":\n          context.chatsStore.upsert(msg.chat);\n          break;\n        case \"delete-chat\":\n          context.chatsStore.markDeleted(msg.chatId);\n          context.messagesStore.removeByChatId(msg.chatId);\n          break;\n        case \"get-message-tree\":\n          context.chatsStore.upsert(msg.chat);\n          context.messagesStore.upsertMany(msg.messages);\n          break;\n        case \"delete-message\":\n          context.messagesStore.remove(msg.chatId, msg.messageId);\n          break;\n        case \"clear-chat\":\n          context.messagesStore.removeByChatId(msg.chatId);\n          break;\n        case \"ask-in-chat\":\n          if (msg.sourceMessage) {\n            context.messagesStore.upsert(msg.sourceMessage);\n          }\n          context.messagesStore.upsert(msg.targetMessage);\n          break;\n        case \"abort-ai\":\n          break;\n        case \"set-tool-result\":\n          if (msg.ok) {\n            context.messagesStore.upsert(msg.message);\n          }\n          break;\n        default:\n          return assertNever(msg, \"Unhandled case\");\n      }\n    }\n    pendingCmd?.resolve(msg);\n  }\n  managedSocket.events.onMessage.subscribe(handleServerMessage);\n  managedSocket.events.statusDidChange.subscribe(onStatusDidChange);\n  managedSocket.events.statusDidChange.subscribe(handleConnectionLossEvent);\n  managedSocket.events.didConnect.subscribe(onDidConnect);\n  managedSocket.events.didDisconnect.subscribe(onDidDisconnect);\n  managedSocket.events.onConnectionError.subscribe(({ message, code }) => {\n    if (process.env.NODE_ENV !== \"production\") {\n      error2(\n        `Connection to websocket server closed. Reason: ${message} (code: ${code}).`\n      );\n    }\n  });\n  function connectInitially() {\n    if (managedSocket.getStatus() === \"initial\") {\n      managedSocket.connect();\n    }\n  }\n  async function sendClientMsgWithResponse(msg) {\n    connectInitially();\n    if (managedSocket.getStatus() !== \"connected\") {\n      await managedSocket.events.didConnect.waitUntil();\n    }\n    const { promise, resolve, reject } = Promise_withResolvers();\n    const abortSignal = AbortSignal.timeout(DEFAULT_REQUEST_TIMEOUT);\n    abortSignal.addEventListener(\"abort\", () => reject(abortSignal.reason), {\n      once: true\n    });\n    const cmdId = nanoid(7);\n    context.pendingCmds.set(cmdId, { resolve, reject });\n    sendClientMsg({ ...msg, cmdId });\n    return promise.finally(() => {\n      context.pendingCmds.delete(cmdId);\n    }).catch((err) => {\n      error2(err.message);\n      throw err;\n    });\n  }\n  function sendClientMsg(msg) {\n    managedSocket.send(\n      JSON.stringify({\n        ...msg\n      })\n    );\n  }\n  function getChats(options = {}) {\n    return sendClientMsgWithResponse({\n      cmd: \"get-chats\",\n      cursor: options.cursor,\n      query: options.query\n    });\n  }\n  function getOrCreateChat(id, options) {\n    return sendClientMsgWithResponse({\n      cmd: \"get-or-create-chat\",\n      id,\n      options\n    });\n  }\n  function getMessageTree(chatId) {\n    return sendClientMsgWithResponse({\n      cmd: \"get-message-tree\",\n      chatId\n    });\n  }\n  async function setToolResult(chatId, messageId, invocationId, result, options) {\n    const knowledge = context.knowledgeStore.getKnowledgeForChat(chatId);\n    const tools = context.toolsStore.getToolDescriptions(chatId);\n    const resp = await sendClientMsgWithResponse({\n      cmd: \"set-tool-result\",\n      chatId,\n      messageId,\n      invocationId,\n      result,\n      generationOptions: {\n        copilotId: options?.copilotId,\n        stream: options?.stream,\n        timeout: options?.timeout,\n        // Knowledge and tools aren't coming from the options, but retrieved\n        // from the global context\n        knowledge: knowledge.length > 0 ? knowledge : void 0,\n        tools: tools.length > 0 ? tools : void 0\n      }\n    });\n    if (resp.ok) {\n      messagesStore.markMine(resp.message.id);\n    }\n  }\n  function handleBeforeUnload() {\n    for (const messageId of context.messagesStore.getAutoExecutingMessageIds()) {\n      sendClientMsgWithResponse({ cmd: \"abort-ai\", messageId }).catch(() => {\n      });\n    }\n  }\n  const win = typeof window !== \"undefined\" ? window : void 0;\n  win?.addEventListener(\"beforeunload\", handleBeforeUnload, { once: true });\n  return Object.defineProperty(\n    {\n      [kInternal]: {\n        context\n      },\n      connectInitially,\n      // reconnect: () => managedSocket.reconnect(),\n      disconnect: () => managedSocket.disconnect(),\n      getChats,\n      getOrCreateChat,\n      deleteChat: (chatId) => {\n        return sendClientMsgWithResponse({ cmd: \"delete-chat\", chatId });\n      },\n      getMessageTree,\n      deleteMessage: (chatId, messageId) => sendClientMsgWithResponse({ cmd: \"delete-message\", chatId, messageId }),\n      clearChat: (chatId) => sendClientMsgWithResponse({ cmd: \"clear-chat\", chatId }),\n      askUserMessageInChat: async (chatId, userMessage, targetMessageId, options) => {\n        const knowledge = context.knowledgeStore.getKnowledgeForChat(chatId);\n        const requestKnowledge = options?.knowledge || [];\n        const combinedKnowledge = [...knowledge, ...requestKnowledge];\n        const tools = context.toolsStore.getToolDescriptions(chatId);\n        messagesStore.markMine(targetMessageId);\n        const resp = await sendClientMsgWithResponse({\n          cmd: \"ask-in-chat\",\n          chatId,\n          sourceMessage: userMessage,\n          targetMessageId,\n          generationOptions: {\n            copilotId: options?.copilotId,\n            stream: options?.stream,\n            timeout: options?.timeout,\n            // Combine global knowledge with request-specific knowledge\n            knowledge: combinedKnowledge.length > 0 ? combinedKnowledge : void 0,\n            tools: tools.length > 0 ? tools : void 0\n          }\n        });\n        return resp;\n      },\n      abort: (messageId) => sendClientMsgWithResponse({ cmd: \"abort-ai\", messageId }),\n      setToolResult,\n      getStatus: () => managedSocket.getStatus(),\n      signals: {\n        getChatMessagesForBranch\\u03A3: context.messagesStore.getChatMessagesForBranch\\u03A3,\n        getTool\\u03A3: context.toolsStore.getTool\\u03A3,\n        status\\u03A3\n      },\n      getChatById: context.chatsStore.getChatById,\n      queryChats: context.chatsStore.findMany,\n      getLastUsedCopilotId: context.messagesStore.getLastUsedCopilotId,\n      registerKnowledgeLayer: (uniqueLayerId, chatId) => {\n        const stack = context.knowledgeStore.getKnowledgeStack(chatId);\n        const layerKey = stack.registerLayer(uniqueLayerId);\n        const deregister = () => stack.deregisterLayer(layerKey);\n        return {\n          layerKey,\n          deregister\n        };\n      },\n      updateKnowledge: (layerKey, data, key, chatId) => {\n        context.knowledgeStore.getKnowledgeStack(chatId).updateKnowledge(layerKey, key ?? nanoid(), data);\n      },\n      registerTool: context.toolsStore.registerTool\n    },\n    kInternal,\n    { enumerable: false }\n  );\n}\nfunction makeCreateSocketDelegateForAi(baseUrl, WebSocketPolyfill) {\n  return (authValue) => {\n    const ws = WebSocketPolyfill ?? (typeof WebSocket === \"undefined\" ? void 0 : WebSocket);\n    if (ws === void 0) {\n      throw new StopRetrying(\n        \"To use Liveblocks client in a non-DOM environment, you need to provide a WebSocket polyfill.\"\n      );\n    }\n    const url2 = new URL(baseUrl);\n    url2.protocol = url2.protocol === \"http:\" ? \"ws\" : \"wss\";\n    url2.pathname = \"/ai/v7\";\n    if (authValue.type === \"secret\") {\n      url2.searchParams.set(\"tok\", authValue.token.raw);\n    } else if (authValue.type === \"public\") {\n      throw new Error(\"Public key not supported with AI Copilots\");\n    } else {\n      return assertNever(authValue, \"Unhandled case\");\n    }\n    url2.searchParams.set(\"version\", PKG_VERSION || \"dev\");\n    return new ws(url2.toString());\n  };\n}\nfunction replaceOrAppend(content, newItem, keyFn, now2) {\n  const existingIndex = findLastIndex(\n    content,\n    (item) => item.type === newItem.type && keyFn(item) === keyFn(newItem)\n  );\n  if (existingIndex > -1) {\n    content[existingIndex] = newItem;\n  } else {\n    closePart(content[content.length - 1], now2);\n    content.push(newItem);\n  }\n}\nfunction closePart(prevPart, endedAt) {\n  if (prevPart?.type === \"reasoning\") {\n    prevPart.endedAt ??= endedAt;\n  }\n}\nfunction patchContentWithDelta(content, delta) {\n  if (delta === null)\n    return;\n  const parts = content.filter(\n    (part) => part.type !== \"sources\"\n  );\n  const sources = content.filter((part) => part.type === \"sources\").flatMap((part) => part.sources);\n  const now2 = (/* @__PURE__ */ new Date()).toISOString();\n  const lastPart = parts[parts.length - 1];\n  switch (delta.type) {\n    case \"text-delta\":\n      if (lastPart?.type === \"text\") {\n        lastPart.text += delta.textDelta;\n      } else {\n        closePart(lastPart, now2);\n        parts.push({ type: \"text\", text: delta.textDelta });\n      }\n      break;\n    case \"reasoning-delta\":\n      if (lastPart?.type === \"reasoning\") {\n        lastPart.text += delta.textDelta;\n      } else {\n        closePart(lastPart, now2);\n        parts.push({\n          type: \"reasoning\",\n          text: delta.textDelta,\n          startedAt: now2\n        });\n      }\n      break;\n    case \"tool-stream\": {\n      const toolInvocation = createReceivingToolInvocation(\n        delta.invocationId,\n        delta.name\n      );\n      parts.push(toolInvocation);\n      break;\n    }\n    case \"tool-delta\": {\n      if (lastPart?.type === \"tool-invocation\" && lastPart.stage === \"receiving\") {\n        lastPart.__appendDelta?.(delta.delta);\n      }\n      break;\n    }\n    case \"tool-invocation\":\n      replaceOrAppend(parts, delta, (x) => x.invocationId, now2);\n      break;\n    case \"retrieval\":\n      replaceOrAppend(parts, delta, (x) => x.id, now2);\n      break;\n    case \"source\": {\n      sources.push(delta);\n      break;\n    }\n    default:\n      return assertNever(delta, \"Unhandled case\");\n  }\n  if (sources.length > 0) {\n    parts.push({\n      type: \"sources\",\n      sources\n    });\n  }\n  content.length = 0;\n  content.push(...parts);\n}\nfunction createReceivingToolInvocation(invocationId, name, partialArgsText = \"\") {\n  const parser = new IncrementalJsonParser(partialArgsText);\n  return {\n    type: \"tool-invocation\",\n    stage: \"receiving\",\n    invocationId,\n    name,\n    // --- Alternative implementation for FRONTEND only ------------------------\n    get partialArgsText() {\n      return parser.source;\n    },\n    // prettier-ignore\n    get partialArgs() {\n      return parser.json;\n    },\n    // prettier-ignore\n    __appendDelta(delta) {\n      parser.append(delta);\n    }\n    // prettier-ignore\n    // ------------------------------------------------------------------------\n  };\n}\n\n// src/protocol/AuthToken.ts\nvar Permission = /* @__PURE__ */ ((Permission2) => {\n  Permission2[\"Read\"] = \"room:read\";\n  Permission2[\"Write\"] = \"room:write\";\n  Permission2[\"PresenceWrite\"] = \"room:presence:write\";\n  Permission2[\"CommentsWrite\"] = \"comments:write\";\n  Permission2[\"CommentsRead\"] = \"comments:read\";\n  return Permission2;\n})(Permission || {});\nfunction canWriteStorage(scopes) {\n  return scopes.includes(\"room:write\" /* Write */);\n}\nfunction canComment(scopes) {\n  return scopes.includes(\"comments:write\" /* CommentsWrite */) || scopes.includes(\"room:write\" /* Write */);\n}\nfunction isValidAuthTokenPayload(data) {\n  return isPlainObject(data) && (data.k === \"acc\" /* ACCESS_TOKEN */ || data.k === \"id\" /* ID_TOKEN */);\n}\nfunction parseAuthToken(rawTokenString) {\n  const tokenParts = rawTokenString.split(\".\");\n  if (tokenParts.length !== 3) {\n    throw new Error(\"Authentication error: invalid JWT token\");\n  }\n  const payload = tryParseJson(b64decode(tokenParts[1]));\n  if (!(payload && isValidAuthTokenPayload(payload))) {\n    throw new Error(\n      \"Authentication error: expected a valid token but did not get one. Hint: if you are using a callback, ensure the room is passed when creating the token. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientCallback\"\n    );\n  }\n  return {\n    raw: rawTokenString,\n    parsed: payload\n  };\n}\n\n// src/auth-manager.ts\nvar NON_RETRY_STATUS_CODES = [\n  400,\n  401,\n  403,\n  404,\n  405,\n  410,\n  412,\n  414,\n  422,\n  431,\n  451\n];\nfunction createAuthManager(authOptions, onAuthenticate) {\n  const authentication = prepareAuthentication(authOptions);\n  const seenTokens = /* @__PURE__ */ new Set();\n  const tokens = [];\n  const expiryTimes = [];\n  const requestPromises = /* @__PURE__ */ new Map();\n  function reset() {\n    seenTokens.clear();\n    tokens.length = 0;\n    expiryTimes.length = 0;\n    requestPromises.clear();\n  }\n  function hasCorrespondingScopes(requestedScope, scopes) {\n    if (requestedScope === \"comments:read\") {\n      return scopes.includes(\"comments:read\" /* CommentsRead */) || scopes.includes(\"comments:write\" /* CommentsWrite */) || scopes.includes(\"room:read\" /* Read */) || scopes.includes(\"room:write\" /* Write */);\n    } else if (requestedScope === \"room:read\") {\n      return scopes.includes(\"room:read\" /* Read */) || scopes.includes(\"room:write\" /* Write */);\n    }\n    return false;\n  }\n  function getCachedToken(requestOptions) {\n    const now2 = Math.ceil(Date.now() / 1e3);\n    for (let i = tokens.length - 1; i >= 0; i--) {\n      const token = tokens[i];\n      const expiresAt = expiryTimes[i];\n      if (expiresAt <= now2) {\n        tokens.splice(i, 1);\n        expiryTimes.splice(i, 1);\n        continue;\n      }\n      if (token.parsed.k === \"id\" /* ID_TOKEN */) {\n        return token;\n      } else if (token.parsed.k === \"acc\" /* ACCESS_TOKEN */) {\n        if (!requestOptions.roomId && Object.entries(token.parsed.perms).length === 0) {\n          return token;\n        }\n        for (const [resource, scopes] of Object.entries(token.parsed.perms)) {\n          if (!requestOptions.roomId) {\n            if (resource.includes(\"*\") && hasCorrespondingScopes(requestOptions.requestedScope, scopes)) {\n              return token;\n            }\n          } else if (resource.includes(\"*\") && requestOptions.roomId.startsWith(resource.replace(\"*\", \"\")) || requestOptions.roomId === resource && hasCorrespondingScopes(requestOptions.requestedScope, scopes)) {\n            return token;\n          }\n        }\n      }\n    }\n    return void 0;\n  }\n  async function makeAuthRequest(options) {\n    const fetcher = authOptions.polyfills?.fetch ?? (typeof window === \"undefined\" ? void 0 : window.fetch);\n    if (authentication.type === \"private\") {\n      if (fetcher === void 0) {\n        throw new StopRetrying(\n          \"To use Liveblocks client in a non-DOM environment with a url as auth endpoint, you need to provide a fetch polyfill.\"\n        );\n      }\n      const response = await fetchAuthEndpoint(fetcher, authentication.url, {\n        room: options.roomId\n      });\n      const parsed = parseAuthToken(response.token);\n      if (seenTokens.has(parsed.raw)) {\n        throw new StopRetrying(\n          \"The same Liveblocks auth token was issued from the backend before. Caching Liveblocks tokens is not supported.\"\n        );\n      }\n      onAuthenticate?.(parsed.parsed);\n      return parsed;\n    }\n    if (authentication.type === \"custom\") {\n      const response = await authentication.callback(options.roomId);\n      if (response && typeof response === \"object\") {\n        if (typeof response.token === \"string\") {\n          const parsed = parseAuthToken(response.token);\n          onAuthenticate?.(parsed.parsed);\n          return parsed;\n        } else if (typeof response.error === \"string\") {\n          const reason = `Authentication failed: ${\"reason\" in response && typeof response.reason === \"string\" ? response.reason : \"Forbidden\"}`;\n          if (response.error === \"forbidden\") {\n            throw new StopRetrying(reason);\n          } else {\n            throw new Error(reason);\n          }\n        }\n      }\n      throw new Error(\n        'Your authentication callback function should return a token, but it did not. Hint: the return value should look like: { token: \"...\" }'\n      );\n    }\n    throw new Error(\n      \"Unexpected authentication type. Must be private or custom.\"\n    );\n  }\n  async function getAuthValue(requestOptions) {\n    if (authentication.type === \"public\") {\n      return { type: \"public\", publicApiKey: authentication.publicApiKey };\n    }\n    const cachedToken = getCachedToken(requestOptions);\n    if (cachedToken !== void 0) {\n      return { type: \"secret\", token: cachedToken };\n    }\n    let currentPromise;\n    if (requestOptions.roomId) {\n      currentPromise = requestPromises.get(requestOptions.roomId);\n      if (currentPromise === void 0) {\n        currentPromise = makeAuthRequest(requestOptions);\n        requestPromises.set(requestOptions.roomId, currentPromise);\n      }\n    } else {\n      currentPromise = requestPromises.get(\"liveblocks-user-token\");\n      if (currentPromise === void 0) {\n        currentPromise = makeAuthRequest(requestOptions);\n        requestPromises.set(\"liveblocks-user-token\", currentPromise);\n      }\n    }\n    try {\n      const token = await currentPromise;\n      const BUFFER = 30;\n      const expiresAt = Math.floor(Date.now() / 1e3) + (token.parsed.exp - token.parsed.iat) - BUFFER;\n      seenTokens.add(token.raw);\n      tokens.push(token);\n      expiryTimes.push(expiresAt);\n      return { type: \"secret\", token };\n    } finally {\n      if (requestOptions.roomId) {\n        requestPromises.delete(requestOptions.roomId);\n      } else {\n        requestPromises.delete(\"liveblocks-user-token\");\n      }\n    }\n  }\n  return {\n    reset,\n    getAuthValue\n  };\n}\nfunction prepareAuthentication(authOptions) {\n  const { publicApiKey, authEndpoint } = authOptions;\n  if (authEndpoint !== void 0 && publicApiKey !== void 0) {\n    throw new Error(\n      \"You cannot simultaneously use `publicApiKey` and `authEndpoint` options. Please pick one and leave the other option unspecified. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClient\"\n    );\n  }\n  if (typeof publicApiKey === \"string\") {\n    if (publicApiKey.startsWith(\"sk_\")) {\n      throw new Error(\n        \"Invalid `publicApiKey` option. The value you passed is a secret key, which should not be used from the client. Please only ever pass a public key here. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientPublicKey\"\n      );\n    } else if (!publicApiKey.startsWith(\"pk_\")) {\n      throw new Error(\n        \"Invalid key. Please use the public key format: pk_<public key>. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientPublicKey\"\n      );\n    }\n    return {\n      type: \"public\",\n      publicApiKey\n    };\n  }\n  if (typeof authEndpoint === \"string\") {\n    return {\n      type: \"private\",\n      url: authEndpoint\n    };\n  } else if (typeof authEndpoint === \"function\") {\n    return {\n      type: \"custom\",\n      callback: authEndpoint\n    };\n  } else if (authEndpoint !== void 0) {\n    throw new Error(\n      \"The `authEndpoint` option must be a string or a function. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientAuthEndpoint\"\n    );\n  }\n  throw new Error(\n    \"Invalid Liveblocks client options. Please provide either a `publicApiKey` or `authEndpoint` option. They cannot both be empty. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClient\"\n  );\n}\nasync function fetchAuthEndpoint(fetch, endpoint, body) {\n  const res = await fetch(endpoint, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\"\n    },\n    body: stringifyOrLog(body)\n  });\n  if (!res.ok) {\n    const reason = `${(await res.text()).trim() || \"reason not provided in auth response\"} (${res.status} returned by POST ${endpoint})`;\n    if (NON_RETRY_STATUS_CODES.includes(res.status)) {\n      throw new StopRetrying(`Unauthorized: ${reason}`);\n    } else {\n      throw new Error(`Failed to authenticate: ${reason}`);\n    }\n  }\n  let data;\n  try {\n    data = await res.json();\n  } catch (er) {\n    throw new Error(\n      `Expected a JSON response when doing a POST request on \"${endpoint}\". ${String(\n        er\n      )}`\n    );\n  }\n  if (!isPlainObject(data) || typeof data.token !== \"string\") {\n    throw new Error(\n      `Expected a JSON response of the form \\`{ token: \"...\" }\\` when doing a POST request on \"${endpoint}\", but got ${stringifyOrLog(\n        data\n      )}`\n    );\n  }\n  const { token } = data;\n  return { token };\n}\n\n// src/constants.ts\nvar DEFAULT_BASE_URL = \"https://api.liveblocks.io\";\nvar MENTION_CHARACTER = \"@\";\n\n// src/devtools/bridge.ts\nvar _bridgeActive = false;\nfunction activateBridge(allowed) {\n  _bridgeActive = allowed;\n}\nfunction sendToPanel(message, options) {\n  if (process.env.NODE_ENV === \"production\" || typeof window === \"undefined\") {\n    return;\n  }\n  const fullMsg = {\n    ...message,\n    source: \"liveblocks-devtools-client\"\n  };\n  if (!(options?.force || _bridgeActive)) {\n    return;\n  }\n  window.postMessage(fullMsg, \"*\");\n}\nvar eventSource = makeEventSource();\nif (process.env.NODE_ENV !== \"production\" && typeof window !== \"undefined\") {\n  window.addEventListener(\"message\", (event) => {\n    if (event.source === window && event.data?.source === \"liveblocks-devtools-panel\") {\n      eventSource.notify(event.data);\n    } else {\n    }\n  });\n}\nvar onMessageFromPanel = eventSource.observable;\n\n// src/devtools/index.ts\nvar VERSION = PKG_VERSION || \"dev\";\nvar _devtoolsSetupHasRun = false;\nfunction setupDevTools(getAllRooms) {\n  if (process.env.NODE_ENV === \"production\" || typeof window === \"undefined\") {\n    return;\n  }\n  if (_devtoolsSetupHasRun) {\n    return;\n  }\n  _devtoolsSetupHasRun = true;\n  onMessageFromPanel.subscribe((msg) => {\n    switch (msg.msg) {\n      // When a devtool panel sends an explicit \"connect\" message back to this\n      // live running client (in response to the \"wake-up-devtools\" message,\n      // or when the devtool panel is opened for the first time), it means that it's okay to\n      // start emitting messages.\n      // Before this explicit acknowledgement, any call to sendToPanel() will\n      // be a no-op.\n      case \"connect\": {\n        activateBridge(true);\n        for (const roomId of getAllRooms()) {\n          sendToPanel({\n            msg: \"room::available\",\n            roomId,\n            clientVersion: VERSION\n          });\n        }\n        break;\n      }\n    }\n  });\n  sendToPanel({ msg: \"wake-up-devtools\" }, { force: true });\n}\nvar unsubsByRoomId = /* @__PURE__ */ new Map();\nfunction stopSyncStream(roomId) {\n  const unsubs = unsubsByRoomId.get(roomId) ?? [];\n  unsubsByRoomId.delete(roomId);\n  for (const unsub of unsubs) {\n    unsub();\n  }\n}\nfunction startSyncStream(room) {\n  stopSyncStream(room.id);\n  fullSync(room);\n  unsubsByRoomId.set(room.id, [\n    // When the connection status changes\n    room.events.status.subscribe(() => partialSyncConnection(room)),\n    // When storage initializes, send the update\n    room.events.storageDidLoad.subscribeOnce(() => partialSyncStorage(room)),\n    // Any time storage updates, send the new storage root\n    room.events.storageBatch.subscribe(() => partialSyncStorage(room)),\n    // Any time \"me\" or \"others\" updates, send the new values accordingly\n    room.events.self.subscribe(() => partialSyncMe(room)),\n    room.events.others.subscribe(() => partialSyncOthers(room)),\n    // Any time ydoc is updated, forward the update\n    room.events.ydoc.subscribe((update) => syncYdocUpdate(room, update)),\n    // Any time a custom room event is received, forward it\n    room.events.customEvent.subscribe(\n      (eventData) => forwardEvent(room, eventData)\n    )\n  ]);\n}\nfunction syncYdocUpdate(room, update) {\n  sendToPanel({\n    msg: \"room::sync::ydoc\",\n    roomId: room.id,\n    update\n  });\n}\nvar loadedAt = Date.now();\nvar eventCounter = 0;\nfunction nextEventId() {\n  return `event-${loadedAt}-${eventCounter++}`;\n}\nfunction forwardEvent(room, eventData) {\n  sendToPanel({\n    msg: \"room::events::custom-event\",\n    roomId: room.id,\n    event: {\n      type: \"CustomEvent\",\n      id: nextEventId(),\n      key: \"Event\",\n      connectionId: eventData.connectionId,\n      payload: eventData.event\n    }\n  });\n}\nfunction partialSyncConnection(room) {\n  sendToPanel({\n    msg: \"room::sync::partial\",\n    roomId: room.id,\n    status: room.getStatus()\n  });\n}\nfunction partialSyncStorage(room) {\n  const root = room.getStorageSnapshot();\n  if (root) {\n    sendToPanel({\n      msg: \"room::sync::partial\",\n      roomId: room.id,\n      storage: root.toTreeNode(\"root\").payload\n    });\n  }\n}\nfunction partialSyncMe(room) {\n  const me = room[kInternal].getSelf_forDevTools();\n  if (me) {\n    sendToPanel({\n      msg: \"room::sync::partial\",\n      roomId: room.id,\n      me\n    });\n  }\n}\nfunction partialSyncOthers(room) {\n  const others = room[kInternal].getOthers_forDevTools();\n  if (others) {\n    sendToPanel({\n      msg: \"room::sync::partial\",\n      roomId: room.id,\n      others\n    });\n  }\n}\nfunction fullSync(room) {\n  const root = room.getStorageSnapshot();\n  const me = room[kInternal].getSelf_forDevTools();\n  const others = room[kInternal].getOthers_forDevTools();\n  room.fetchYDoc(\"\");\n  sendToPanel({\n    msg: \"room::sync::full\",\n    roomId: room.id,\n    status: room.getStatus(),\n    storage: root?.toTreeNode(\"root\").payload ?? null,\n    me,\n    others\n  });\n}\nvar roomChannelListeners = /* @__PURE__ */ new Map();\nfunction stopRoomChannelListener(roomId) {\n  const listener = roomChannelListeners.get(roomId);\n  roomChannelListeners.delete(roomId);\n  if (listener) {\n    listener();\n  }\n}\nfunction linkDevTools(roomId, room) {\n  if (process.env.NODE_ENV === \"production\" || typeof window === \"undefined\") {\n    return;\n  }\n  sendToPanel({ msg: \"room::available\", roomId, clientVersion: VERSION });\n  stopRoomChannelListener(roomId);\n  roomChannelListeners.set(\n    roomId,\n    // Returns the unsubscribe callback, that we store in the\n    // roomChannelListeners registry\n    onMessageFromPanel.subscribe((msg) => {\n      switch (msg.msg) {\n        // Sent by the devtool panel when it wants to receive the sync stream\n        // for a room\n        case \"room::subscribe\": {\n          if (msg.roomId === roomId) {\n            startSyncStream(room);\n          }\n          break;\n        }\n        case \"room::unsubscribe\": {\n          if (msg.roomId === roomId) {\n            stopSyncStream(roomId);\n          }\n          break;\n        }\n      }\n    })\n  );\n}\nfunction unlinkDevTools(roomId) {\n  if (process.env.NODE_ENV === \"production\" || typeof window === \"undefined\") {\n    return;\n  }\n  stopSyncStream(roomId);\n  stopRoomChannelListener(roomId);\n  sendToPanel({\n    msg: \"room::unavailable\",\n    roomId\n  });\n}\n\n// src/lib/warnings.ts\nvar _emittedWarnings = /* @__PURE__ */ new Set();\nfunction warnOnce(message, key = message) {\n  if (process.env.NODE_ENV !== \"production\") {\n    if (!_emittedWarnings.has(key)) {\n      _emittedWarnings.add(key);\n      warn(message);\n    }\n  }\n}\nfunction warnOnceIf(condition, message, key = message) {\n  if (typeof condition === \"function\" ? condition() : condition) {\n    warnOnce(message, key);\n  }\n}\n\n// src/protocol/NotificationSettings.ts\nvar kPlain = Symbol(\"notification-settings-plain\");\nfunction createNotificationSettings(plain) {\n  const channels = [\n    \"email\",\n    \"slack\",\n    \"teams\",\n    \"webPush\"\n  ];\n  const descriptors = {\n    [kPlain]: {\n      value: plain,\n      enumerable: false\n    }\n  };\n  for (const channel of channels) {\n    descriptors[channel] = {\n      enumerable: true,\n      /**\n       * In the TypeScript standard library definitions, the built-in interface for a property descriptor\n       * does not include a specialized type for the this context in the getter or setter functions.\n       * As a result, both the get and set methods implicitly have this: any.\n       * The reason is that property descriptors in JavaScript are used across various objects with\n       * no enforced shape for this. And so the standard library definitions have to remain as broad as possible\n       * to support any valid JavaScript usage (e.g `Object.defineProperty`).\n       *\n       * So we can safely tells that this getter is typed as `this: NotificationSettings` because we're\n       * creating a well known shaped object  `NotificationSettings`.\n       */\n      get() {\n        const value = this[kPlain][channel];\n        if (typeof value === \"undefined\") {\n          error2(\n            `In order to use the '${channel}' channel, please set up your project first. For more information: https://liveblocks.io/docs/errors/enable-a-notification-channel`\n          );\n          return null;\n        }\n        return value;\n      }\n    };\n  }\n  return create(null, descriptors);\n}\nfunction patchNotificationSettings(existing, patch) {\n  const outcoming = createNotificationSettings({\n    ...existing[kPlain]\n  });\n  for (const channel of keys(patch)) {\n    const updates = patch[channel];\n    if (updates !== void 0) {\n      const kindUpdates = Object.fromEntries(\n        entries(updates).filter(([, value]) => value !== void 0)\n      );\n      outcoming[kPlain][channel] = {\n        ...outcoming[kPlain][channel],\n        ...kindUpdates\n      };\n    }\n  }\n  return outcoming;\n}\nfunction isNotificationChannelEnabled(settings) {\n  return settings !== null ? values(settings).every((enabled) => enabled === true) : false;\n}\n\n// src/brand.ts\nvar OFFSET = \"12px\";\nvar injectBrandBadge = (badgeLocation = \"bottom-right\") => {\n  if (typeof document === \"undefined\") {\n    return;\n  }\n  if (document.getElementById(\"liveblocks-badge\")) {\n    return;\n  }\n  const badgeDiv = document.createElement(\"div\");\n  badgeDiv.id = \"liveblocks-badge\";\n  badgeDiv.style.position = \"fixed\";\n  badgeDiv.style.opacity = \"0\";\n  badgeDiv.style.transition = \"opacity 300ms\";\n  badgeDiv.style.zIndex = \"9999\";\n  switch (badgeLocation) {\n    case \"top-right\":\n      badgeDiv.style.top = OFFSET;\n      badgeDiv.style.right = OFFSET;\n      break;\n    case \"bottom-right\":\n      badgeDiv.style.bottom = OFFSET;\n      badgeDiv.style.right = OFFSET;\n      break;\n    case \"bottom-left\":\n      badgeDiv.style.bottom = OFFSET;\n      badgeDiv.style.left = OFFSET;\n      break;\n    case \"top-left\":\n      badgeDiv.style.top = OFFSET;\n      badgeDiv.style.left = OFFSET;\n      break;\n  }\n  badgeDiv.onmouseenter = () => {\n    const hideButton2 = document.getElementById(\"liveblocks-badge-hide-button\");\n    if (hideButton2) {\n      hideButton2.style.opacity = \"0.3\";\n    }\n  };\n  badgeDiv.onmouseleave = () => {\n    const hideButton2 = document.getElementById(\"liveblocks-badge-hide-button\");\n    if (hideButton2) {\n      hideButton2.style.opacity = \"0\";\n    }\n  };\n  const link = document.createElement(\"a\");\n  link.href = \"https://lblcks.io/badge\";\n  link.target = \"_blank\";\n  link.rel = \"noopener noreferrer\";\n  link.title = \"Liveblocks\";\n  const svg = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n  svg.setAttribute(\"width\", \"111\");\n  svg.setAttribute(\"height\", \"38\");\n  svg.setAttribute(\"viewBox\", \"0 0 111 38\");\n  svg.setAttribute(\"fill\", \"none\");\n  const rect1 = document.createElementNS(\"http://www.w3.org/2000/svg\", \"rect\");\n  rect1.setAttribute(\"x\", \"1\");\n  rect1.setAttribute(\"y\", \"1\");\n  rect1.setAttribute(\"width\", \"109\");\n  rect1.setAttribute(\"height\", \"36\");\n  rect1.setAttribute(\"rx\", \"8\");\n  rect1.setAttribute(\"fill\", \"white\");\n  svg.appendChild(rect1);\n  const rect2 = document.createElementNS(\"http://www.w3.org/2000/svg\", \"rect\");\n  rect2.setAttribute(\"x\", \"0.5\");\n  rect2.setAttribute(\"y\", \"0.5\");\n  rect2.setAttribute(\"width\", \"110\");\n  rect2.setAttribute(\"height\", \"37\");\n  rect2.setAttribute(\"rx\", \"8.5\");\n  rect2.setAttribute(\"stroke\", \"black\");\n  rect2.setAttribute(\"stroke-opacity\", \"0.1\");\n  svg.appendChild(rect2);\n  const path1 = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n  path1.setAttribute(\n    \"d\",\n    \"M39.8256 18.0832H38L38.0005 28.9009H39.8256V18.0832ZM43.213 21.1757H41.3879V28.9009H43.213V21.1757ZM43.213 18H41.3879V19.9688H43.213V18ZM45.8916 21.1757H43.9302L46.6915 28.9009H48.7283L51.4896 21.1757H49.5581L48.4039 24.8348C48.3739 24.93 48.2657 25.3024 48.0795 25.9511L47.7099 27.1959C47.4914 26.406 47.2626 25.6189 47.0237 24.8348L45.8916 21.1757ZM58.9659 23.59C58.8147 23.0721 58.5934 22.6317 58.3014 22.2694C57.9743 21.8628 57.5598 21.5482 57.0571 21.3268C56.5589 21.1004 56.0058 20.9877 55.3973 20.9877C54.2407 20.9877 53.3152 21.3495 52.6212 22.0735C52.275 22.4476 52.0103 22.8896 51.844 23.3715C51.6731 23.8691 51.5876 24.4199 51.5876 25.0233C51.5876 26.3157 51.9322 27.3142 52.6217 28.0184C53.3203 28.7323 54.2509 29.0894 55.4125 29.0894C56.4083 29.0894 57.2151 28.8658 57.8342 28.4181C58.453 27.9704 58.8628 27.3068 59.0638 26.4266L57.2834 26.2908C57.198 26.7685 57.0016 27.1257 56.6948 27.3618C56.3879 27.5933 55.9555 27.7093 55.3973 27.7093C54.1201 27.7093 53.4663 26.9899 53.4363 25.5514H59.1844L59.1922 25.295C59.1922 24.6763 59.1165 24.108 58.9659 23.59ZM53.8434 23.0471C54.1654 22.5943 54.6834 22.3679 55.3973 22.3679C55.7443 22.3679 56.0363 22.4155 56.2725 22.5111C56.509 22.6067 56.7128 22.7601 56.8837 22.9713C57.0167 23.1352 57.1189 23.3218 57.1855 23.5221C57.2605 23.731 57.3062 23.9493 57.3213 24.1708H53.451C53.4964 23.7231 53.6271 23.3484 53.8434 23.0471ZM66.2836 21.4779C65.7656 21.1406 65.1673 20.9724 64.4885 20.9724H64.4875C63.995 20.9724 63.5449 21.0727 63.1374 21.2742C62.7364 21.4696 62.3931 21.7659 62.1412 22.1341V18.0832H60.316V28.9009H62.1416V27.8373C62.373 28.2195 62.7008 28.5342 63.0921 28.7499C63.4996 28.9763 63.9497 29.0894 64.4422 29.0894C65.1266 29.0894 65.7324 28.9259 66.2614 28.5992C66.7891 28.2726 67.1989 27.8045 67.4905 27.1959C67.7871 26.5823 67.9359 25.8634 67.9359 25.0386C67.9359 24.2337 67.7895 23.5248 67.4984 22.9113C67.2115 22.2926 66.8066 21.8148 66.2836 21.4779ZM65.5064 27.0828C65.2148 27.5254 64.7172 27.7463 64.0125 27.7463C63.3786 27.7463 62.9013 27.5175 62.5797 27.0601C62.2576 26.6026 62.0968 25.9336 62.0968 25.0534C62.0968 24.2032 62.24 23.5397 62.5265 23.0619C62.8185 22.579 63.3088 22.3378 63.9978 22.3378C64.7019 22.3378 65.2023 22.5592 65.499 23.0013C65.7961 23.4389 65.944 24.1181 65.944 25.0386C65.944 25.9585 65.7985 26.6401 65.5064 27.0828ZM70.901 18.0832H69.0754V28.9009H70.901V18.0832ZM73.8582 28.6066C74.452 28.9286 75.1558 29.0894 75.9708 29.0894C76.7554 29.0894 77.4444 28.9208 78.0377 28.5844C78.6268 28.2569 79.1068 27.7637 79.4183 27.1659C79.745 26.5523 79.9086 25.843 79.9086 25.0386C79.9086 24.2642 79.7478 23.5697 79.4257 22.9565C79.117 22.3516 78.6404 21.8487 78.0529 21.508C77.4592 21.161 76.7652 20.9872 75.9708 20.9872C75.171 20.9872 74.4719 21.161 73.8735 21.508C73.2876 21.8472 72.811 22.3471 72.5002 22.9486C72.1837 23.5572 72.0252 24.254 72.0252 25.0386C72.0252 25.8735 72.181 26.5948 72.4929 27.2033C72.7962 27.798 73.2722 28.2871 73.8582 28.6066ZM77.4869 27.0906C77.18 27.5231 76.6746 27.7393 75.9708 27.7393C75.493 27.7393 75.1082 27.6437 74.8166 27.4524C74.5246 27.2565 74.3134 26.9621 74.1826 26.5699C74.0518 26.1725 73.9867 25.6619 73.9867 25.0381C73.9867 24.1029 74.1401 23.419 74.4469 22.9866C74.7588 22.5541 75.2667 22.3378 75.9708 22.3378C76.6699 22.3378 77.1727 22.5541 77.4795 22.9866C77.7914 23.419 77.9471 24.1029 77.9471 25.0386C77.9471 25.9738 77.7937 26.6576 77.4869 27.0906ZM82.3982 28.6066C82.9869 28.9286 83.6883 29.0894 84.5033 29.0894C85.1369 29.0894 85.7029 28.9791 86.2005 28.7577C86.6989 28.5364 87.1031 28.2272 87.4152 27.8299C87.7279 27.4249 87.9329 26.9471 88.0109 26.4414L86.2534 26.2607C86.1328 26.7431 85.9316 27.1031 85.6497 27.3392C85.3683 27.5757 84.9857 27.694 84.5033 27.694C84.0103 27.694 83.6232 27.5933 83.3413 27.3918C83.0598 27.1858 82.8635 26.8919 82.7531 26.5093C82.6422 26.1221 82.5872 25.6318 82.5872 25.0386C82.5872 24.455 82.6422 23.9722 82.7531 23.59C82.8635 23.2028 83.0571 22.9062 83.3339 22.6997C83.6157 22.4884 84.0053 22.3831 84.5033 22.3831C85.0362 22.3831 85.4312 22.5314 85.6877 22.8281C85.949 23.1196 86.1354 23.5193 86.2456 24.0276L87.9735 23.718C87.8078 22.8932 87.4326 22.232 86.8491 21.7344C86.2708 21.2363 85.489 20.9877 84.5033 20.9877C83.6985 20.9877 83.0021 21.1587 82.4134 21.5006C81.8322 21.8351 81.3625 22.3337 81.0633 22.9339C80.7514 23.5424 80.5952 24.2439 80.5952 25.0386C80.5952 25.8781 80.7486 26.6026 81.0554 27.2112C81.3673 27.8197 81.8151 28.285 82.3982 28.6066ZM90.8104 26.0343L91.6627 25.2192L93.9257 28.9009H96.0308L92.8999 24.0498L95.9328 21.1757H93.5634L90.8104 23.9976V18.0832H88.9845V28.9009H90.8104V26.0343ZM97.6304 28.8103C98.1436 28.9965 98.7142 29.0894 99.3428 29.0894C100.303 29.0894 101.095 28.8981 101.719 28.5165C102.348 28.1339 102.663 27.5101 102.663 26.6451C102.663 26.0818 102.516 25.6392 102.225 25.3176C101.933 24.9905 101.586 24.7566 101.184 24.6157C100.786 24.4702 100.245 24.3219 99.562 24.1707C99.1642 24.0853 98.8502 24.0049 98.6188 23.9295C98.3873 23.8538 98.201 23.7558 98.0604 23.6352C97.925 23.5141 97.8567 23.3584 97.8567 23.1676C97.8567 22.8858 97.9824 22.6723 98.2338 22.5263C98.4853 22.3803 98.7973 22.3073 99.1694 22.3073C99.6619 22.3073 100.047 22.4255 100.324 22.6621C100.605 22.8987 100.756 23.2531 100.776 23.7258L102.466 23.4467C102.385 22.5817 102.046 21.9556 101.447 21.568C100.854 21.1812 100.095 20.9872 99.1694 20.9872C98.6258 20.9872 98.1236 21.0699 97.6607 21.2362C97.2029 21.397 96.8335 21.6511 96.5517 21.9986C96.27 22.3451 96.1294 22.7827 96.1294 23.3109C96.1294 23.7988 96.25 24.1934 96.4911 24.4951C96.7368 24.8001 97.0527 25.0408 97.4118 25.1965C97.7838 25.3578 98.2512 25.5112 98.8147 25.6567L99.2828 25.7699C99.5949 25.844 99.9044 25.9295 100.211 26.0264C100.421 26.092 100.595 26.1826 100.731 26.2981C100.867 26.4136 100.935 26.5647 100.935 26.7509C100.935 27.0776 100.799 27.3294 100.527 27.505C100.261 27.6815 99.8708 27.7693 99.3583 27.7693C98.8347 27.7693 98.4176 27.6385 98.1055 27.377C97.7941 27.1154 97.6355 26.7384 97.6304 26.2454L95.9109 26.4413C95.9302 27.0351 96.094 27.5304 96.4009 27.9278C96.7129 28.3252 97.1223 28.619 97.6304 28.8103Z\"\n  );\n  path1.setAttribute(\"fill\", \"black\");\n  svg.appendChild(path1);\n  const path2 = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n  path2.setAttribute(\n    \"d\",\n    \"M37.6392 15V9.18182H39.7131C40.1657 9.18182 40.5407 9.2642 40.8381 9.42898C41.1354 9.59375 41.358 9.81913 41.5057 10.1051C41.6534 10.3892 41.7273 10.7093 41.7273 11.0653C41.7273 11.4233 41.6525 11.7453 41.5028 12.0312C41.3551 12.3153 41.1316 12.5407 40.8324 12.7074C40.535 12.8722 40.161 12.9545 39.7102 12.9545H38.2841V12.2102H39.6307C39.9167 12.2102 40.1487 12.161 40.3267 12.0625C40.5047 11.9621 40.6354 11.8258 40.7188 11.6534C40.8021 11.4811 40.8438 11.285 40.8438 11.0653C40.8438 10.8456 40.8021 10.6506 40.7188 10.4801C40.6354 10.3097 40.5038 10.1761 40.3239 10.0795C40.1458 9.98295 39.911 9.93466 39.6193 9.93466H38.517V15H37.6392ZM44.4716 15.0881C44.0625 15.0881 43.7055 14.9943 43.4006 14.8068C43.0956 14.6193 42.8589 14.357 42.6903 14.0199C42.5218 13.6828 42.4375 13.2888 42.4375 12.8381C42.4375 12.3854 42.5218 11.9896 42.6903 11.6506C42.8589 11.3116 43.0956 11.0483 43.4006 10.8608C43.7055 10.6733 44.0625 10.5795 44.4716 10.5795C44.8807 10.5795 45.2377 10.6733 45.5426 10.8608C45.8475 11.0483 46.0843 11.3116 46.2528 11.6506C46.4214 11.9896 46.5057 12.3854 46.5057 12.8381C46.5057 13.2888 46.4214 13.6828 46.2528 14.0199C46.0843 14.357 45.8475 14.6193 45.5426 14.8068C45.2377 14.9943 44.8807 15.0881 44.4716 15.0881ZM44.4744 14.375C44.7396 14.375 44.9593 14.3049 45.1335 14.1648C45.3078 14.0246 45.4366 13.8381 45.5199 13.6051C45.6051 13.3722 45.6477 13.1155 45.6477 12.8352C45.6477 12.5568 45.6051 12.3011 45.5199 12.0682C45.4366 11.8333 45.3078 11.6449 45.1335 11.5028C44.9593 11.3608 44.7396 11.2898 44.4744 11.2898C44.2074 11.2898 43.9858 11.3608 43.8097 11.5028C43.6354 11.6449 43.5057 11.8333 43.4205 12.0682C43.3371 12.3011 43.2955 12.5568 43.2955 12.8352C43.2955 13.1155 43.3371 13.3722 43.4205 13.6051C43.5057 13.8381 43.6354 14.0246 43.8097 14.1648C43.9858 14.3049 44.2074 14.375 44.4744 14.375ZM48.267 15L46.983 10.6364H47.8608L48.7159 13.8409H48.7585L49.6165 10.6364H50.4943L51.3466 13.8267H51.3892L52.2386 10.6364H53.1165L51.8352 15H50.9688L50.0824 11.8494H50.017L49.1307 15H48.267ZM55.6705 15.0881C55.2405 15.0881 54.8703 14.9962 54.5597 14.8125C54.2509 14.6269 54.0123 14.3665 53.8438 14.0312C53.6771 13.6941 53.5938 13.2992 53.5938 12.8466C53.5938 12.3996 53.6771 12.0057 53.8438 11.6648C54.0123 11.3239 54.2472 11.0578 54.5483 10.8665C54.8513 10.6752 55.2055 10.5795 55.6108 10.5795C55.857 10.5795 56.0956 10.6203 56.3267 10.7017C56.5578 10.7831 56.7652 10.911 56.9489 11.0852C57.1326 11.2595 57.2775 11.4858 57.3835 11.7642C57.4896 12.0407 57.5426 12.3769 57.5426 12.7727V13.0739H54.0739V12.4375H56.7102C56.7102 12.214 56.6648 12.0161 56.5739 11.8438C56.483 11.6695 56.3551 11.5322 56.1903 11.4318C56.0275 11.3314 55.8362 11.2812 55.6165 11.2812C55.3778 11.2812 55.1695 11.34 54.9915 11.4574C54.8153 11.5729 54.679 11.7244 54.5824 11.9119C54.4877 12.0975 54.4403 12.2992 54.4403 12.517V13.0142C54.4403 13.3059 54.4915 13.554 54.5938 13.7585C54.6979 13.9631 54.8428 14.1193 55.0284 14.2273C55.214 14.3333 55.4309 14.3864 55.679 14.3864C55.84 14.3864 55.9867 14.3636 56.1193 14.3182C56.2519 14.2708 56.3665 14.2008 56.4631 14.108C56.5597 14.0152 56.6335 13.9006 56.6847 13.7642L57.4886 13.9091C57.4242 14.1458 57.3087 14.3532 57.142 14.5312C56.9773 14.7074 56.7699 14.8447 56.5199 14.9432C56.2718 15.0398 55.9886 15.0881 55.6705 15.0881ZM58.4851 15V10.6364H59.3061V11.3295H59.3516C59.4311 11.0947 59.5713 10.91 59.772 10.7756C59.9747 10.6392 60.2038 10.571 60.4595 10.571C60.5125 10.571 60.575 10.5729 60.647 10.5767C60.7209 10.5805 60.7786 10.5852 60.8203 10.5909V11.4034C60.7862 11.3939 60.7256 11.3835 60.6385 11.3722C60.5514 11.3589 60.4643 11.3523 60.3771 11.3523C60.1764 11.3523 59.9974 11.3949 59.8402 11.4801C59.6849 11.5634 59.5618 11.6799 59.4709 11.8295C59.38 11.9773 59.3345 12.1458 59.3345 12.3352V15H58.4851ZM63.2798 15.0881C62.8499 15.0881 62.4796 14.9962 62.169 14.8125C61.8603 14.6269 61.6217 14.3665 61.4531 14.0312C61.2865 13.6941 61.2031 13.2992 61.2031 12.8466C61.2031 12.3996 61.2865 12.0057 61.4531 11.6648C61.6217 11.3239 61.8565 11.0578 62.1577 10.8665C62.4607 10.6752 62.8149 10.5795 63.2202 10.5795C63.4664 10.5795 63.705 10.6203 63.9361 10.7017C64.1671 10.7831 64.3745 10.911 64.5582 11.0852C64.742 11.2595 64.8868 11.4858 64.9929 11.7642C65.099 12.0407 65.152 12.3769 65.152 12.7727V13.0739H61.6832V12.4375H64.3196C64.3196 12.214 64.2741 12.0161 64.1832 11.8438C64.0923 11.6695 63.9645 11.5322 63.7997 11.4318C63.6368 11.3314 63.4455 11.2812 63.2259 11.2812C62.9872 11.2812 62.7789 11.34 62.6009 11.4574C62.4247 11.5729 62.2884 11.7244 62.1918 11.9119C62.0971 12.0975 62.0497 12.2992 62.0497 12.517V13.0142C62.0497 13.3059 62.1009 13.554 62.2031 13.7585C62.3073 13.9631 62.4522 14.1193 62.6378 14.2273C62.8234 14.3333 63.0402 14.3864 63.2884 14.3864C63.4493 14.3864 63.5961 14.3636 63.7287 14.3182C63.8613 14.2708 63.9759 14.2008 64.0724 14.108C64.169 14.0152 64.2429 13.9006 64.294 13.7642L65.098 13.9091C65.0336 14.1458 64.9181 14.3532 64.7514 14.5312C64.5866 14.7074 64.3793 14.8447 64.1293 14.9432C63.8812 15.0398 63.598 15.0881 63.2798 15.0881ZM67.728 15.0852C67.3757 15.0852 67.0613 14.9953 66.7848 14.8153C66.5102 14.6335 66.2943 14.375 66.1371 14.0398C65.9818 13.7027 65.9041 13.2983 65.9041 12.8267C65.9041 12.3551 65.9827 11.9517 66.1399 11.6165C66.299 11.2812 66.5168 11.0246 66.7933 10.8466C67.0698 10.6686 67.3833 10.5795 67.7337 10.5795C68.0045 10.5795 68.2223 10.625 68.3871 10.7159C68.5537 10.8049 68.6825 10.9091 68.7734 11.0284C68.8662 11.1477 68.9382 11.2528 68.9893 11.3438H69.0405V9.18182H69.8899V15H69.0604V14.321H68.9893C68.9382 14.4138 68.8643 14.5199 68.7678 14.6392C68.6731 14.7585 68.5424 14.8627 68.3757 14.9517C68.209 15.0407 67.9931 15.0852 67.728 15.0852ZM67.9155 14.3608C68.1598 14.3608 68.3662 14.2964 68.5348 14.1676C68.7053 14.0369 68.834 13.8561 68.9212 13.625C69.0102 13.3939 69.0547 13.125 69.0547 12.8182C69.0547 12.5152 69.0111 12.25 68.924 12.0227C68.8369 11.7955 68.709 11.6184 68.5405 11.4915C68.3719 11.3646 68.1636 11.3011 67.9155 11.3011C67.6598 11.3011 67.4467 11.3674 67.2763 11.5C67.1058 11.6326 66.977 11.8134 66.8899 12.0426C66.8047 12.2718 66.7621 12.5303 66.7621 12.8182C66.7621 13.1098 66.8056 13.3722 66.8928 13.6051C66.9799 13.8381 67.1087 14.0227 67.2791 14.1591C67.4515 14.2936 67.6636 14.3608 67.9155 14.3608ZM73.2876 15V9.18182H74.1371V11.3438H74.1882C74.2375 11.2528 74.3085 11.1477 74.4013 11.0284C74.4941 10.9091 74.6229 10.8049 74.7876 10.7159C74.9524 10.625 75.1702 10.5795 75.4411 10.5795C75.7933 10.5795 76.1077 10.6686 76.3842 10.8466C76.6607 11.0246 76.8776 11.2812 77.0348 11.6165C77.1939 11.9517 77.2734 12.3551 77.2734 12.8267C77.2734 13.2983 77.1948 13.7027 77.0376 14.0398C76.8804 14.375 76.6645 14.6335 76.3899 14.8153C76.1153 14.9953 75.8018 15.0852 75.4496 15.0852C75.1844 15.0852 74.9676 15.0407 74.799 14.9517C74.6323 14.8627 74.5017 14.7585 74.407 14.6392C74.3123 14.5199 74.2393 14.4138 74.1882 14.321H74.1172V15H73.2876ZM74.12 12.8182C74.12 13.125 74.1645 13.3939 74.2536 13.625C74.3426 13.8561 74.4714 14.0369 74.6399 14.1676C74.8085 14.2964 75.0149 14.3608 75.2592 14.3608C75.513 14.3608 75.7251 14.2936 75.8956 14.1591C76.0661 14.0227 76.1948 13.8381 76.282 13.6051C76.371 13.3722 76.4155 13.1098 76.4155 12.8182C76.4155 12.5303 76.3719 12.2718 76.2848 12.0426C76.1996 11.8134 76.0708 11.6326 75.8984 11.5C75.728 11.3674 75.5149 11.3011 75.2592 11.3011C75.013 11.3011 74.8047 11.3646 74.6342 11.4915C74.4657 11.6184 74.3378 11.7955 74.2507 12.0227C74.1636 12.25 74.12 12.5152 74.12 12.8182ZM78.6158 16.6364C78.4889 16.6364 78.3733 16.6259 78.2692 16.6051C78.165 16.5862 78.0874 16.5653 78.0362 16.5426L78.2408 15.8466C78.3961 15.8883 78.5343 15.9063 78.6555 15.9006C78.7768 15.8949 78.8838 15.8494 78.9766 15.7642C79.0713 15.679 79.1546 15.5398 79.2266 15.3466L79.3317 15.0568L77.7351 10.6364H78.6442L79.7493 14.0227H79.7947L80.8999 10.6364H81.8118L80.0135 15.5824C79.9302 15.8097 79.8241 16.0019 79.6953 16.1591C79.5665 16.3182 79.4131 16.4375 79.2351 16.517C79.0571 16.5966 78.8506 16.6364 78.6158 16.6364Z\"\n  );\n  path2.setAttribute(\"fill\", \"black\");\n  path2.setAttribute(\"fill-opacity\", \"0.5\");\n  svg.appendChild(path2);\n  const rect3 = document.createElementNS(\"http://www.w3.org/2000/svg\", \"rect\");\n  rect3.setAttribute(\"x\", \"7\");\n  rect3.setAttribute(\"y\", \"7\");\n  rect3.setAttribute(\"width\", \"24\");\n  rect3.setAttribute(\"height\", \"24\");\n  rect3.setAttribute(\"rx\", \"3\");\n  rect3.setAttribute(\"fill\", \"black\");\n  svg.appendChild(rect3);\n  const path3 = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n  path3.setAttribute(\"fill-rule\", \"evenodd\");\n  path3.setAttribute(\"clip-rule\", \"evenodd\");\n  path3.setAttribute(\n    \"d\",\n    \"M22.0455 15H12.2273L15.1364 17.9091V21.9091L22.0455 15Z\"\n  );\n  path3.setAttribute(\"fill\", \"white\");\n  svg.appendChild(path3);\n  const path4 = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n  path4.setAttribute(\"fill-rule\", \"evenodd\");\n  path4.setAttribute(\"clip-rule\", \"evenodd\");\n  path4.setAttribute(\n    \"d\",\n    \"M16.9546 22.9999H26.7728L23.8637 20.0908V16.0908L16.9546 22.9999Z\"\n  );\n  path4.setAttribute(\"fill\", \"white\");\n  svg.appendChild(path4);\n  link.appendChild(svg);\n  badgeDiv.appendChild(link);\n  const hideButton = document.createElement(\"button\");\n  hideButton.id = \"liveblocks-badge-hide-button\";\n  hideButton.style.position = \"absolute\";\n  hideButton.style.top = \"0\";\n  hideButton.style.right = \"0\";\n  hideButton.style.border = \"none\";\n  hideButton.style.padding = \"0\";\n  hideButton.style.margin = \"0\";\n  hideButton.style.background = \"none\";\n  hideButton.style.font = \"inherit\";\n  hideButton.style.cursor = \"pointer\";\n  hideButton.style.outline = \"none\";\n  hideButton.style.setProperty(\"-webkit-appearance\", \"none\");\n  hideButton.style.setProperty(\"-moz-appearance\", \"none\");\n  hideButton.style.setProperty(\"appearance\", \"none\");\n  hideButton.style.opacity = \"0\";\n  hideButton.onclick = () => {\n    const badge2 = document.getElementById(\"liveblocks-badge\");\n    if (badge2) {\n      badge2.style.display = \"none\";\n    }\n  };\n  hideButton.onmouseenter = () => {\n    hideButton.style.opacity = \"0.5\";\n  };\n  hideButton.onmouseleave = () => {\n    hideButton.style.opacity = \"0.3\";\n  };\n  const hideSvg = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n  hideSvg.setAttribute(\"width\", \"18\");\n  hideSvg.setAttribute(\"height\", \"18\");\n  hideSvg.setAttribute(\"viewBox\", \"0 0 18 18\");\n  hideSvg.setAttribute(\"fill\", \"none\");\n  const hidePath = document.createElementNS(\n    \"http://www.w3.org/2000/svg\",\n    \"path\"\n  );\n  hidePath.setAttribute(\"d\", \"M6 6L9 9M12 12L9 9M9 9L12 6M9 9L6 12\");\n  hidePath.setAttribute(\"stroke\", \"black\");\n  hideSvg.appendChild(hidePath);\n  hideButton.appendChild(hideSvg);\n  badgeDiv.appendChild(hideButton);\n  document.body.appendChild(badgeDiv);\n  requestAnimationFrame(() => {\n    requestAnimationFrame(() => {\n      badgeDiv.style.opacity = \"1\";\n    });\n  });\n};\n\n// src/lib/position.ts\nvar MIN_CODE = 32;\nvar MAX_CODE = 126;\nvar NUM_DIGITS = MAX_CODE - MIN_CODE + 1;\nvar ZERO = nthDigit(0);\nvar ONE = nthDigit(1);\nvar ZERO_NINE = ZERO + nthDigit(-1);\nfunction nthDigit(n) {\n  const code = MIN_CODE + (n < 0 ? NUM_DIGITS + n : n);\n  if (code < MIN_CODE || code > MAX_CODE) {\n    throw new Error(`Invalid n value: ${n}`);\n  }\n  return String.fromCharCode(code);\n}\nfunction makePosition(x, y) {\n  if (x !== void 0 && y !== void 0) {\n    return between(x, y);\n  } else if (x !== void 0) {\n    return after(x);\n  } else if (y !== void 0) {\n    return before(y);\n  } else {\n    return ONE;\n  }\n}\nfunction before(pos) {\n  const lastIndex = pos.length - 1;\n  for (let i = 0; i <= lastIndex; i++) {\n    const code = pos.charCodeAt(i);\n    if (code <= MIN_CODE) {\n      continue;\n    }\n    if (i === lastIndex) {\n      if (code === MIN_CODE + 1) {\n        return pos.substring(0, i) + ZERO_NINE;\n      } else {\n        return pos.substring(0, i) + String.fromCharCode(code - 1);\n      }\n    } else {\n      return pos.substring(0, i + 1);\n    }\n  }\n  return ONE;\n}\nvar VIEWPORT_START = 2;\nvar VIEWPORT_STEP = 3;\nfunction after(pos) {\n  for (let i = 0; i < pos.length; i++) {\n    const code = pos.charCodeAt(i);\n    if (code < MIN_CODE || code > MAX_CODE) {\n      return pos + ONE;\n    }\n  }\n  while (pos.length > 1 && pos.charCodeAt(pos.length - 1) === MIN_CODE) {\n    pos = pos.slice(0, -1);\n  }\n  if (pos.length === 0 || pos === ZERO) {\n    return ONE;\n  }\n  let viewport = VIEWPORT_START;\n  if (pos.length > VIEWPORT_START) {\n    viewport = VIEWPORT_START + Math.ceil((pos.length - VIEWPORT_START) / VIEWPORT_STEP) * VIEWPORT_STEP;\n  }\n  const result = incrementWithinViewport(pos, viewport);\n  if (result !== null) {\n    return result;\n  }\n  viewport += VIEWPORT_STEP;\n  const extendedResult = incrementWithinViewport(pos, viewport);\n  if (extendedResult !== null) {\n    return extendedResult;\n  }\n  return pos + ONE;\n}\nfunction incrementWithinViewport(pos, viewport) {\n  const digits = [];\n  for (let i = 0; i < viewport; i++) {\n    if (i < pos.length) {\n      digits.push(pos.charCodeAt(i) - MIN_CODE);\n    } else {\n      digits.push(0);\n    }\n  }\n  let carry = 1;\n  for (let i = viewport - 1; i >= 0 && carry; i--) {\n    const sum = digits[i] + carry;\n    if (sum >= NUM_DIGITS) {\n      digits[i] = 0;\n      carry = 1;\n    } else {\n      digits[i] = sum;\n      carry = 0;\n    }\n  }\n  if (carry) {\n    return null;\n  }\n  let result = \"\";\n  for (const d of digits) {\n    result += String.fromCharCode(d + MIN_CODE);\n  }\n  while (result.length > 1 && result.charCodeAt(result.length - 1) === MIN_CODE) {\n    result = result.slice(0, -1);\n  }\n  return result;\n}\nfunction between(lo, hi) {\n  if (lo < hi) {\n    return _between(lo, hi);\n  } else if (lo > hi) {\n    return _between(hi, lo);\n  } else {\n    throw new Error(\"Cannot compute value between two equal positions\");\n  }\n}\nfunction _between(lo, hi) {\n  let index = 0;\n  const loLen = lo.length;\n  const hiLen = hi.length;\n  while (true) {\n    const loCode = index < loLen ? lo.charCodeAt(index) : MIN_CODE;\n    const hiCode = index < hiLen ? hi.charCodeAt(index) : MAX_CODE;\n    if (loCode === hiCode) {\n      index++;\n      continue;\n    }\n    if (hiCode - loCode === 1) {\n      const size = index + 1;\n      let prefix = lo.substring(0, size);\n      if (prefix.length < size) {\n        prefix += ZERO.repeat(size - prefix.length);\n      }\n      const suffix = lo.substring(size);\n      const nines = \"\";\n      return prefix + _between(suffix, nines);\n    } else {\n      return takeN(lo, index) + String.fromCharCode(hiCode + loCode >> 1);\n    }\n  }\n}\nfunction takeN(pos, n) {\n  return n < pos.length ? pos.substring(0, n) : pos + ZERO.repeat(n - pos.length);\n}\nvar MIN_NON_ZERO_CODE = MIN_CODE + 1;\nfunction isPos(str) {\n  if (str === \"\") {\n    return false;\n  }\n  const lastIdx = str.length - 1;\n  const last = str.charCodeAt(lastIdx);\n  if (last < MIN_NON_ZERO_CODE || last > MAX_CODE) {\n    return false;\n  }\n  for (let i = 0; i < lastIdx; i++) {\n    const code = str.charCodeAt(i);\n    if (code < MIN_CODE || code > MAX_CODE) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction convertToPos(str) {\n  const codes = [];\n  for (let i = 0; i < str.length; i++) {\n    const code = str.charCodeAt(i);\n    codes.push(code < MIN_CODE ? MIN_CODE : code > MAX_CODE ? MAX_CODE : code);\n  }\n  while (codes.length > 0 && codes[codes.length - 1] === MIN_CODE) {\n    codes.length--;\n  }\n  return codes.length > 0 ? String.fromCharCode(...codes) : (\n    // Edge case: the str was a 0-only string, which is invalid. Default back to .1\n    ONE\n  );\n}\nfunction asPos(str) {\n  return isPos(str) ? str : convertToPos(str);\n}\n\n// src/protocol/Op.ts\nvar OpCode = Object.freeze({\n  INIT: 0,\n  SET_PARENT_KEY: 1,\n  CREATE_LIST: 2,\n  UPDATE_OBJECT: 3,\n  CREATE_OBJECT: 4,\n  DELETE_CRDT: 5,\n  DELETE_OBJECT_KEY: 6,\n  CREATE_MAP: 7,\n  CREATE_REGISTER: 8\n});\nfunction isIgnoredOp(op) {\n  return op.type === OpCode.DELETE_CRDT && op.id === \"ACK\";\n}\n\n// src/crdts/AbstractCrdt.ts\nfunction createManagedPool(roomId, options) {\n  const {\n    getCurrentConnectionId,\n    onDispatch,\n    isStorageWritable = () => true\n  } = options;\n  let clock = 0;\n  let opClock = 0;\n  const nodes = /* @__PURE__ */ new Map();\n  return {\n    roomId,\n    nodes,\n    getNode: (id) => nodes.get(id),\n    addNode: (id, node) => void nodes.set(id, node),\n    deleteNode: (id) => void nodes.delete(id),\n    generateId: () => `${getCurrentConnectionId()}:${clock++}`,\n    generateOpId: () => `${getCurrentConnectionId()}:${opClock++}`,\n    dispatch(ops, reverse, storageUpdates) {\n      onDispatch?.(ops, reverse, storageUpdates);\n    },\n    assertStorageIsWritable: () => {\n      if (!isStorageWritable()) {\n        throw new Error(\n          \"Cannot write to storage with a read only user, please ensure the user has write permissions\"\n        );\n      }\n    }\n  };\n}\nfunction crdtAsLiveNode(value) {\n  return value;\n}\nfunction HasParent(node, key, pos = asPos(key)) {\n  return Object.freeze({ type: \"HasParent\", node, key, pos });\n}\nvar NoParent = Object.freeze({ type: \"NoParent\" });\nfunction Orphaned(oldKey, oldPos = asPos(oldKey)) {\n  return Object.freeze({ type: \"Orphaned\", oldKey, oldPos });\n}\nvar AbstractCrdt = class {\n  //                  ^^^^^^^^^^^^ TODO: Make this an interface\n  #pool;\n  #id;\n  #parent = NoParent;\n  /** @internal */\n  _getParentKeyOrThrow() {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        return this.parent.key;\n      case \"NoParent\":\n        throw new Error(\"Parent key is missing\");\n      case \"Orphaned\":\n        return this.parent.oldKey;\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n  /** @internal */\n  get _parentPos() {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        return this.parent.pos;\n      case \"NoParent\":\n        throw new Error(\"Parent key is missing\");\n      case \"Orphaned\":\n        return this.parent.oldPos;\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n  /** @internal */\n  get _pool() {\n    return this.#pool;\n  }\n  get roomId() {\n    return this.#pool ? this.#pool.roomId : null;\n  }\n  /** @internal */\n  get _id() {\n    return this.#id;\n  }\n  /** @internal */\n  get parent() {\n    return this.#parent;\n  }\n  /** @internal */\n  get _parentKey() {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        return this.parent.key;\n      case \"NoParent\":\n        return null;\n      case \"Orphaned\":\n        return this.parent.oldKey;\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n  /** @internal */\n  _apply(op, _isLocal) {\n    switch (op.type) {\n      case OpCode.DELETE_CRDT: {\n        if (this.parent.type === \"HasParent\") {\n          return this.parent.node._detachChild(crdtAsLiveNode(this));\n        }\n        return { modified: false };\n      }\n    }\n    return { modified: false };\n  }\n  /** @internal */\n  _setParentLink(newParentNode, newParentKey) {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        if (this.parent.node !== newParentNode) {\n          throw new Error(\"Cannot set parent: node already has a parent\");\n        } else {\n          this.#parent = HasParent(newParentNode, newParentKey);\n          return;\n        }\n      case \"Orphaned\":\n      case \"NoParent\": {\n        this.#parent = HasParent(newParentNode, newParentKey);\n        return;\n      }\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n  /** @internal */\n  _attach(id, pool) {\n    if (this.#id || this.#pool) {\n      throw new Error(\"Cannot attach node: already attached\");\n    }\n    pool.addNode(id, crdtAsLiveNode(this));\n    this.#id = id;\n    this.#pool = pool;\n  }\n  /** @internal */\n  _detach() {\n    if (this.#pool && this.#id) {\n      this.#pool.deleteNode(this.#id);\n    }\n    switch (this.parent.type) {\n      case \"HasParent\": {\n        this.#parent = Orphaned(this.parent.key, this.parent.pos);\n        break;\n      }\n      case \"NoParent\": {\n        this.#parent = NoParent;\n        break;\n      }\n      case \"Orphaned\": {\n        break;\n      }\n      default:\n        assertNever(this.parent, \"Unknown state\");\n    }\n    this.#pool = void 0;\n  }\n  /**\n   * Serializes this CRDT and all its children into a list of creation ops\n   * with opIds. Used for forward operations that will be sent over the wire\n   * immediately. Each op gets a unique opId for server acknowledgement.\n   *\n   * @internal\n   */\n  _toOpsWithOpId(parentId, parentKey, pool) {\n    return this._toOps(parentId, parentKey).map((op) => ({\n      opId: pool.generateOpId(),\n      ...op\n    }));\n  }\n  /** This caches the result of the last .toImmutable() call for this Live node. */\n  #cachedImmutable;\n  #cachedTreeNodeKey;\n  /** This caches the result of the last .toTreeNode() call for this Live node. */\n  #cachedTreeNode;\n  /**\n   * @internal\n   *\n   * Clear the Immutable cache, so that the next call to `.toImmutable()` will\n   * recompute the equivalent Immutable value again.  Call this after every\n   * mutation to the Live node.\n   */\n  invalidate() {\n    if (this.#cachedImmutable !== void 0 || this.#cachedTreeNode !== void 0) {\n      this.#cachedImmutable = void 0;\n      this.#cachedTreeNode = void 0;\n      if (this.parent.type === \"HasParent\") {\n        this.parent.node.invalidate();\n      }\n    }\n  }\n  /**\n   * @internal\n   *\n   * Return an snapshot of this Live tree for use in DevTools.\n   */\n  toTreeNode(key) {\n    if (this.#cachedTreeNode === void 0 || this.#cachedTreeNodeKey !== key) {\n      this.#cachedTreeNodeKey = key;\n      this.#cachedTreeNode = this._toTreeNode(key);\n    }\n    return this.#cachedTreeNode;\n  }\n  /**\n   * Return an immutable snapshot of this Live node and its children.\n   */\n  toImmutable() {\n    if (this.#cachedImmutable === void 0) {\n      this.#cachedImmutable = this._toImmutable();\n    }\n    return this.#cachedImmutable;\n  }\n};\n\n// src/protocol/StorageNode.ts\nvar CrdtType = Object.freeze({\n  OBJECT: 0,\n  LIST: 1,\n  MAP: 2,\n  REGISTER: 3\n});\nfunction isRootStorageNode(node) {\n  return node[0] === \"root\";\n}\nfunction isObjectStorageNode(node) {\n  return node[1].type === CrdtType.OBJECT;\n}\nfunction isListStorageNode(node) {\n  return node[1].type === CrdtType.LIST;\n}\nfunction isMapStorageNode(node) {\n  return node[1].type === CrdtType.MAP;\n}\nfunction isRegisterStorageNode(node) {\n  return node[1].type === CrdtType.REGISTER;\n}\nfunction isCompactRootNode(node) {\n  return node[0] === \"root\";\n}\nfunction* compactNodesToNodeStream(compactNodes) {\n  for (const cnode of compactNodes) {\n    if (isCompactRootNode(cnode)) {\n      yield [cnode[0], { type: CrdtType.OBJECT, data: cnode[1] }];\n      continue;\n    }\n    switch (cnode[1]) {\n      case CrdtType.OBJECT:\n        yield [cnode[0], { type: CrdtType.OBJECT, parentId: cnode[2], parentKey: cnode[3], data: cnode[4] }];\n        break;\n      case CrdtType.LIST:\n        yield [cnode[0], { type: CrdtType.LIST, parentId: cnode[2], parentKey: cnode[3] }];\n        break;\n      case CrdtType.MAP:\n        yield [cnode[0], { type: CrdtType.MAP, parentId: cnode[2], parentKey: cnode[3] }];\n        break;\n      case CrdtType.REGISTER:\n        yield [cnode[0], { type: CrdtType.REGISTER, parentId: cnode[2], parentKey: cnode[3], data: cnode[4] }];\n        break;\n      default:\n    }\n  }\n}\nfunction* nodeStreamToCompactNodes(nodes) {\n  for (const node of nodes) {\n    if (isObjectStorageNode(node)) {\n      if (isRootStorageNode(node)) {\n        const id = node[0];\n        const crdt = node[1];\n        yield [id, crdt.data];\n      } else {\n        const id = node[0];\n        const crdt = node[1];\n        yield [id, CrdtType.OBJECT, crdt.parentId, crdt.parentKey, crdt.data];\n      }\n    } else if (isListStorageNode(node)) {\n      const id = node[0];\n      const crdt = node[1];\n      yield [id, CrdtType.LIST, crdt.parentId, crdt.parentKey];\n    } else if (isMapStorageNode(node)) {\n      const id = node[0];\n      const crdt = node[1];\n      yield [id, CrdtType.MAP, crdt.parentId, crdt.parentKey];\n    } else if (isRegisterStorageNode(node)) {\n      const id = node[0];\n      const crdt = node[1];\n      yield [id, CrdtType.REGISTER, crdt.parentId, crdt.parentKey, crdt.data];\n    } else {\n    }\n  }\n}\n\n// src/crdts/LiveRegister.ts\nvar LiveRegister = class _LiveRegister extends AbstractCrdt {\n  #data;\n  constructor(data) {\n    super();\n    this.#data = data;\n  }\n  get data() {\n    return this.#data;\n  }\n  /** @internal */\n  static _deserialize([id, item], _parentToChildren, pool) {\n    const register = new _LiveRegister(item.data);\n    register._attach(id, pool);\n    return register;\n  }\n  /** @internal */\n  _toOps(parentId, parentKey) {\n    if (this._id === void 0) {\n      throw new Error(\n        \"Cannot serialize register if parentId or parentKey is undefined\"\n      );\n    }\n    return [\n      {\n        type: OpCode.CREATE_REGISTER,\n        id: this._id,\n        parentId,\n        parentKey,\n        data: this.data\n      }\n    ];\n  }\n  /** @internal */\n  _serialize() {\n    if (this.parent.type !== \"HasParent\") {\n      throw new Error(\"Cannot serialize LiveRegister if parent is missing\");\n    }\n    return {\n      type: CrdtType.REGISTER,\n      parentId: nn(this.parent.node._id, \"Parent node expected to have ID\"),\n      parentKey: this.parent.key,\n      data: this.data\n    };\n  }\n  /** @internal */\n  _attachChild(_op) {\n    throw new Error(\"Method not implemented.\");\n  }\n  /** @internal */\n  _detachChild(_crdt) {\n    throw new Error(\"Method not implemented.\");\n  }\n  /** @internal */\n  _apply(op, isLocal) {\n    return super._apply(op, isLocal);\n  }\n  /** @internal */\n  _toTreeNode(key) {\n    return {\n      type: \"Json\",\n      id: this._id ?? nanoid(),\n      key,\n      payload: this.#data\n    };\n  }\n  /** @internal */\n  _toImmutable() {\n    return this.#data;\n  }\n  clone() {\n    return deepClone(this.data);\n  }\n};\n\n// src/crdts/LiveList.ts\nfunction childNodeLt(a, b) {\n  return a._parentPos < b._parentPos;\n}\nvar LiveList = class _LiveList extends AbstractCrdt {\n  #items;\n  #implicitlyDeletedItems;\n  #unacknowledgedSets;\n  constructor(items) {\n    super();\n    this.#implicitlyDeletedItems = /* @__PURE__ */ new WeakSet();\n    this.#unacknowledgedSets = /* @__PURE__ */ new Map();\n    const nodes = [];\n    let lastPos;\n    for (const item of items) {\n      const pos = makePosition(lastPos);\n      const node = lsonToLiveNode(item);\n      node._setParentLink(this, pos);\n      nodes.push(node);\n      lastPos = pos;\n    }\n    this.#items = SortedList.fromAlreadySorted(nodes, childNodeLt);\n  }\n  /** @internal */\n  static _deserialize([id, _], parentToChildren, pool) {\n    const list = new _LiveList([]);\n    list._attach(id, pool);\n    const children = parentToChildren.get(id);\n    if (children === void 0) {\n      return list;\n    }\n    for (const node of children) {\n      const crdt = node[1];\n      const child = deserialize(node, parentToChildren, pool);\n      child._setParentLink(list, crdt.parentKey);\n      list.#insert(child);\n    }\n    return list;\n  }\n  /**\n   * @internal\n   * This function assumes that the resulting ops will be sent to the server if they have an 'opId'\n   * so we mutate _unacknowledgedSets to avoid potential flickering\n   * https://github.com/liveblocks/liveblocks/pull/1177\n   *\n   * This is quite unintuitive and should disappear as soon as\n   * we introduce an explicit LiveList.Set operation\n   */\n  _toOps(parentId, parentKey) {\n    if (this._id === void 0) {\n      throw new Error(\"Cannot serialize item is not attached\");\n    }\n    const ops = [];\n    const op = {\n      id: this._id,\n      type: OpCode.CREATE_LIST,\n      parentId,\n      parentKey\n    };\n    ops.push(op);\n    for (const item of this.#items) {\n      const parentKey2 = item._getParentKeyOrThrow();\n      const childOps = HACK_addIntentAndDeletedIdToOperation(\n        item._toOps(this._id, parentKey2),\n        void 0\n      );\n      for (const childOp of childOps) {\n        ops.push(childOp);\n      }\n    }\n    return ops;\n  }\n  /**\n   * Inserts a new child into the list in the correct location (binary search\n   * finds correct position efficiently). Returns the insertion index.\n   */\n  #insert(childNode) {\n    const index = this.#items.add(childNode);\n    this.invalidate();\n    return index;\n  }\n  /**\n   * Updates an item's position and repositions it in the sorted list.\n   * Encapsulates the remove -> mutate -> add cycle needed when changing sort keys.\n   *\n   * IMPORTANT: Item must exist in this list. List count remains unchanged.\n   */\n  #updateItemPosition(item, newKey) {\n    item._setParentLink(this, newKey);\n    this.#items.reposition(item);\n    this.invalidate();\n  }\n  /**\n   * Updates an item's position by index. Safer than #updateItemPosition when you have\n   * an index, as it ensures the item exists and is from this list.\n   */\n  #updateItemPositionAt(index, newKey) {\n    const item = nn(this.#items.at(index));\n    this.#updateItemPosition(item, newKey);\n  }\n  /** @internal */\n  _indexOfPosition(position) {\n    return this.#items.findIndex(\n      (item) => item._getParentKeyOrThrow() === position\n    );\n  }\n  /** @internal */\n  _attach(id, pool) {\n    super._attach(id, pool);\n    for (const item of this.#items) {\n      item._attach(pool.generateId(), pool);\n    }\n  }\n  /** @internal */\n  _detach() {\n    super._detach();\n    for (const item of this.#items) {\n      item._detach();\n    }\n  }\n  #applySetRemote(op) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const { id, parentKey: key } = op;\n    const child = creationOpToLiveNode(op);\n    child._attach(id, this._pool);\n    child._setParentLink(this, key);\n    const deletedId = op.deletedId;\n    const indexOfItemWithSamePosition = this._indexOfPosition(key);\n    if (indexOfItemWithSamePosition !== -1) {\n      const itemWithSamePosition = nn(\n        this.#items.removeAt(indexOfItemWithSamePosition)\n      );\n      if (itemWithSamePosition._id === deletedId) {\n        itemWithSamePosition._detach();\n        this.#items.add(child);\n        return {\n          modified: makeUpdate(this, [\n            setDelta(indexOfItemWithSamePosition, child)\n          ]),\n          reverse: []\n        };\n      } else {\n        this.#implicitlyDeletedItems.add(itemWithSamePosition);\n        this.#items.remove(itemWithSamePosition);\n        this.#items.add(child);\n        const delta = [\n          setDelta(indexOfItemWithSamePosition, child)\n        ];\n        const deleteDelta2 = this.#detachItemAssociatedToSetOperation(\n          op.deletedId\n        );\n        if (deleteDelta2) {\n          delta.push(deleteDelta2);\n        }\n        return {\n          modified: makeUpdate(this, delta),\n          reverse: []\n        };\n      }\n    } else {\n      const updates = [];\n      const deleteDelta2 = this.#detachItemAssociatedToSetOperation(\n        op.deletedId\n      );\n      if (deleteDelta2) {\n        updates.push(deleteDelta2);\n      }\n      this.#insert(child);\n      updates.push(insertDelta(this._indexOfPosition(key), child));\n      return {\n        reverse: [],\n        modified: makeUpdate(this, updates)\n      };\n    }\n  }\n  #applySetAck(op) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const delta = [];\n    const deletedDelta = this.#detachItemAssociatedToSetOperation(op.deletedId);\n    if (deletedDelta) {\n      delta.push(deletedDelta);\n    }\n    const unacknowledgedOpId = this.#unacknowledgedSets.get(op.parentKey);\n    if (unacknowledgedOpId !== void 0) {\n      if (unacknowledgedOpId !== op.opId) {\n        return delta.length === 0 ? { modified: false } : { modified: makeUpdate(this, delta), reverse: [] };\n      } else {\n        this.#unacknowledgedSets.delete(op.parentKey);\n      }\n    }\n    const indexOfItemWithSamePosition = this._indexOfPosition(op.parentKey);\n    const existingItem = this.#items.find((item) => item._id === op.id);\n    if (existingItem !== void 0) {\n      if (existingItem._parentKey === op.parentKey) {\n        return {\n          modified: delta.length > 0 ? makeUpdate(this, delta) : false,\n          reverse: []\n        };\n      }\n      if (indexOfItemWithSamePosition !== -1) {\n        const itemAtPosition = nn(\n          this.#items.removeAt(indexOfItemWithSamePosition)\n        );\n        this.#implicitlyDeletedItems.add(itemAtPosition);\n        delta.push(deleteDelta(indexOfItemWithSamePosition, itemAtPosition));\n      }\n      const prevIndex = this.#items.findIndex((item) => item === existingItem);\n      this.#updateItemPosition(existingItem, op.parentKey);\n      const newIndex = this.#items.findIndex((item) => item === existingItem);\n      if (newIndex !== prevIndex) {\n        delta.push(moveDelta(prevIndex, newIndex, existingItem));\n      }\n      return {\n        modified: delta.length > 0 ? makeUpdate(this, delta) : false,\n        reverse: []\n      };\n    } else {\n      const orphan = this._pool.getNode(op.id);\n      if (orphan && this.#implicitlyDeletedItems.has(orphan)) {\n        orphan._setParentLink(this, op.parentKey);\n        this.#implicitlyDeletedItems.delete(orphan);\n        const recreatedItemIndex = this.#insert(orphan);\n        return {\n          modified: makeUpdate(this, [\n            // If there is an item at this position, update is a set, else it's an insert\n            indexOfItemWithSamePosition === -1 ? insertDelta(recreatedItemIndex, orphan) : setDelta(recreatedItemIndex, orphan),\n            ...delta\n          ]),\n          reverse: []\n        };\n      } else {\n        if (indexOfItemWithSamePosition !== -1) {\n          nn(this.#items.removeAt(indexOfItemWithSamePosition));\n        }\n        const { newItem, newIndex } = this.#createAttachItemAndSort(\n          op,\n          op.parentKey\n        );\n        return {\n          modified: makeUpdate(this, [\n            // If there is an item at this position, update is a set, else it's an insert\n            indexOfItemWithSamePosition === -1 ? insertDelta(newIndex, newItem) : setDelta(newIndex, newItem),\n            ...delta\n          ]),\n          reverse: []\n        };\n      }\n    }\n  }\n  /**\n   * Returns the update delta of the deletion or null\n   */\n  #detachItemAssociatedToSetOperation(deletedId) {\n    if (deletedId === void 0 || this._pool === void 0) {\n      return null;\n    }\n    const deletedItem = this._pool.getNode(deletedId);\n    if (deletedItem === void 0) {\n      return null;\n    }\n    const result = this._detachChild(deletedItem);\n    if (result.modified === false) {\n      return null;\n    }\n    return result.modified.updates[0];\n  }\n  #applyRemoteInsert(op) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const key = asPos(op.parentKey);\n    const existingItemIndex = this._indexOfPosition(key);\n    if (existingItemIndex !== -1) {\n      this.#shiftItemPosition(existingItemIndex, key);\n    }\n    const { newItem, newIndex } = this.#createAttachItemAndSort(op, key);\n    return {\n      modified: makeUpdate(this, [insertDelta(newIndex, newItem)]),\n      reverse: []\n    };\n  }\n  #applyInsertAck(op) {\n    const existingItem = this.#items.find((item) => item._id === op.id);\n    const key = asPos(op.parentKey);\n    const itemIndexAtPosition = this._indexOfPosition(key);\n    if (existingItem) {\n      if (existingItem._parentKey === key) {\n        return {\n          modified: false\n        };\n      } else {\n        const oldPositionIndex = this.#items.findIndex(\n          (item) => item === existingItem\n        );\n        if (itemIndexAtPosition !== -1) {\n          this.#shiftItemPosition(itemIndexAtPosition, key);\n        }\n        this.#updateItemPosition(existingItem, key);\n        const newIndex = this._indexOfPosition(key);\n        if (newIndex === oldPositionIndex) {\n          return { modified: false };\n        }\n        return {\n          modified: makeUpdate(this, [\n            moveDelta(oldPositionIndex, newIndex, existingItem)\n          ]),\n          reverse: []\n        };\n      }\n    } else {\n      const orphan = nn(this._pool).getNode(op.id);\n      if (orphan && this.#implicitlyDeletedItems.has(orphan)) {\n        orphan._setParentLink(this, key);\n        this.#implicitlyDeletedItems.delete(orphan);\n        this.#insert(orphan);\n        const newIndex = this._indexOfPosition(key);\n        return {\n          modified: makeUpdate(this, [insertDelta(newIndex, orphan)]),\n          reverse: []\n        };\n      } else {\n        if (itemIndexAtPosition !== -1) {\n          this.#shiftItemPosition(itemIndexAtPosition, key);\n        }\n        const { newItem, newIndex } = this.#createAttachItemAndSort(op, key);\n        return {\n          modified: makeUpdate(this, [insertDelta(newIndex, newItem)]),\n          reverse: []\n        };\n      }\n    }\n  }\n  #applyInsertUndoRedo(op) {\n    const { id, parentKey: key } = op;\n    const child = creationOpToLiveNode(op);\n    if (this._pool?.getNode(id) !== void 0) {\n      return { modified: false };\n    }\n    child._attach(id, nn(this._pool));\n    child._setParentLink(this, key);\n    const existingItemIndex = this._indexOfPosition(key);\n    let newKey = key;\n    if (existingItemIndex !== -1) {\n      const before2 = this.#items.at(existingItemIndex)?._parentPos;\n      const after2 = this.#items.at(existingItemIndex + 1)?._parentPos;\n      newKey = makePosition(before2, after2);\n      child._setParentLink(this, newKey);\n    }\n    this.#insert(child);\n    const newIndex = this._indexOfPosition(newKey);\n    return {\n      modified: makeUpdate(this, [insertDelta(newIndex, child)]),\n      reverse: [{ type: OpCode.DELETE_CRDT, id }]\n    };\n  }\n  #applySetUndoRedo(op) {\n    const { id, parentKey: key } = op;\n    const child = creationOpToLiveNode(op);\n    if (this._pool?.getNode(id) !== void 0) {\n      return { modified: false };\n    }\n    this.#unacknowledgedSets.set(key, nn(op.opId));\n    const indexOfItemWithSameKey = this._indexOfPosition(key);\n    child._attach(id, nn(this._pool));\n    child._setParentLink(this, key);\n    const newKey = key;\n    if (indexOfItemWithSameKey !== -1) {\n      const existingItem = this.#items.at(indexOfItemWithSameKey);\n      existingItem._detach();\n      this.#items.remove(existingItem);\n      this.#items.add(child);\n      const reverse = HACK_addIntentAndDeletedIdToOperation(\n        existingItem._toOps(nn(this._id), key),\n        op.id\n      );\n      const delta = [setDelta(indexOfItemWithSameKey, child)];\n      const deletedDelta = this.#detachItemAssociatedToSetOperation(\n        op.deletedId\n      );\n      if (deletedDelta) {\n        delta.push(deletedDelta);\n      }\n      return {\n        modified: makeUpdate(this, delta),\n        reverse\n      };\n    } else {\n      this.#insert(child);\n      this.#detachItemAssociatedToSetOperation(op.deletedId);\n      const newIndex = this._indexOfPosition(newKey);\n      return {\n        reverse: [{ type: OpCode.DELETE_CRDT, id }],\n        modified: makeUpdate(this, [insertDelta(newIndex, child)])\n      };\n    }\n  }\n  /** @internal */\n  _attachChild(op, source) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    let result;\n    if (op.intent === \"set\") {\n      if (source === 1 /* THEIRS */) {\n        result = this.#applySetRemote(op);\n      } else if (source === 2 /* OURS */) {\n        result = this.#applySetAck(op);\n      } else {\n        result = this.#applySetUndoRedo(op);\n      }\n    } else {\n      if (source === 1 /* THEIRS */) {\n        result = this.#applyRemoteInsert(op);\n      } else if (source === 2 /* OURS */) {\n        result = this.#applyInsertAck(op);\n      } else {\n        result = this.#applyInsertUndoRedo(op);\n      }\n    }\n    if (result.modified !== false) {\n      this.invalidate();\n    }\n    return result;\n  }\n  /** @internal */\n  _detachChild(child) {\n    if (child) {\n      const parentKey = nn(child._parentKey);\n      const reverse = child._toOps(nn(this._id), parentKey);\n      const indexToDelete = this.#items.findIndex((item) => item === child);\n      if (indexToDelete === -1) {\n        return {\n          modified: false\n        };\n      }\n      const previousNode = this.#items.at(indexToDelete);\n      this.#items.remove(child);\n      this.invalidate();\n      child._detach();\n      return {\n        modified: makeUpdate(this, [deleteDelta(indexToDelete, previousNode)]),\n        reverse\n      };\n    }\n    return { modified: false };\n  }\n  #applySetChildKeyRemote(newKey, child) {\n    if (this.#implicitlyDeletedItems.has(child)) {\n      this.#implicitlyDeletedItems.delete(child);\n      child._setParentLink(this, newKey);\n      const newIndex = this.#insert(child);\n      return {\n        modified: makeUpdate(this, [insertDelta(newIndex, child)]),\n        reverse: []\n      };\n    }\n    const previousKey = child._parentKey;\n    if (newKey === previousKey) {\n      return {\n        modified: false\n      };\n    }\n    const existingItemIndex = this._indexOfPosition(newKey);\n    if (existingItemIndex === -1) {\n      const previousIndex = this.#items.findIndex((item) => item === child);\n      this.#updateItemPosition(child, newKey);\n      const newIndex = this.#items.findIndex((item) => item === child);\n      if (newIndex === previousIndex) {\n        return {\n          modified: false\n        };\n      }\n      return {\n        modified: makeUpdate(this, [moveDelta(previousIndex, newIndex, child)]),\n        reverse: []\n      };\n    } else {\n      this.#updateItemPositionAt(\n        existingItemIndex,\n        makePosition(newKey, this.#items.at(existingItemIndex + 1)?._parentPos)\n      );\n      const previousIndex = this.#items.findIndex((item) => item === child);\n      this.#updateItemPosition(child, newKey);\n      const newIndex = this.#items.findIndex((item) => item === child);\n      if (newIndex === previousIndex) {\n        return {\n          modified: false\n        };\n      }\n      return {\n        modified: makeUpdate(this, [moveDelta(previousIndex, newIndex, child)]),\n        reverse: []\n      };\n    }\n  }\n  #applySetChildKeyAck(newKey, child) {\n    const previousKey = nn(child._parentKey);\n    if (this.#implicitlyDeletedItems.has(child)) {\n      const existingItemIndex = this._indexOfPosition(newKey);\n      this.#implicitlyDeletedItems.delete(child);\n      if (existingItemIndex !== -1) {\n        const existingItem = this.#items.at(existingItemIndex);\n        existingItem._setParentLink(\n          this,\n          makePosition(\n            newKey,\n            this.#items.at(existingItemIndex + 1)?._parentPos\n          )\n        );\n        this.#items.reposition(existingItem);\n      }\n      child._setParentLink(this, newKey);\n      const newIndex = this.#insert(child);\n      return {\n        modified: makeUpdate(this, [insertDelta(newIndex, child)]),\n        reverse: []\n      };\n    } else {\n      if (newKey === previousKey) {\n        return {\n          modified: false\n        };\n      }\n      const previousIndex = this.#items.findIndex((item) => item === child);\n      const existingItemIndex = this._indexOfPosition(newKey);\n      if (existingItemIndex !== -1) {\n        this.#updateItemPositionAt(\n          existingItemIndex,\n          makePosition(\n            newKey,\n            this.#items.at(existingItemIndex + 1)?._parentPos\n          )\n        );\n      }\n      this.#updateItemPosition(child, newKey);\n      const newIndex = this.#items.findIndex((item) => item === child);\n      if (previousIndex === newIndex) {\n        return {\n          modified: false\n        };\n      } else {\n        return {\n          modified: makeUpdate(this, [\n            moveDelta(previousIndex, newIndex, child)\n          ]),\n          reverse: []\n        };\n      }\n    }\n  }\n  #applySetChildKeyUndoRedo(newKey, child) {\n    const previousKey = nn(child._parentKey);\n    const previousIndex = this.#items.findIndex((item) => item === child);\n    const existingItemIndex = this._indexOfPosition(newKey);\n    let actualNewKey = newKey;\n    if (existingItemIndex !== -1) {\n      actualNewKey = makePosition(\n        newKey,\n        this.#items.at(existingItemIndex + 1)?._parentPos\n      );\n    }\n    this.#updateItemPosition(child, actualNewKey);\n    const newIndex = this.#items.findIndex((item) => item === child);\n    if (previousIndex === newIndex) {\n      return {\n        modified: false\n      };\n    }\n    return {\n      modified: makeUpdate(this, [moveDelta(previousIndex, newIndex, child)]),\n      reverse: [\n        {\n          type: OpCode.SET_PARENT_KEY,\n          id: nn(child._id),\n          parentKey: previousKey\n        }\n      ]\n    };\n  }\n  /** @internal */\n  _setChildKey(newKey, child, source) {\n    if (source === 1 /* THEIRS */) {\n      return this.#applySetChildKeyRemote(newKey, child);\n    } else if (source === 2 /* OURS */) {\n      return this.#applySetChildKeyAck(newKey, child);\n    } else {\n      return this.#applySetChildKeyUndoRedo(newKey, child);\n    }\n  }\n  /** @internal */\n  _apply(op, isLocal) {\n    return super._apply(op, isLocal);\n  }\n  /** @internal */\n  _serialize() {\n    if (this.parent.type !== \"HasParent\") {\n      throw new Error(\"Cannot serialize LiveList if parent is missing\");\n    }\n    return {\n      type: CrdtType.LIST,\n      parentId: nn(this.parent.node._id, \"Parent node expected to have ID\"),\n      parentKey: this.parent.key\n    };\n  }\n  /**\n   * Returns the number of elements.\n   */\n  get length() {\n    return this.#items.length;\n  }\n  /**\n   * Adds one element to the end of the LiveList.\n   * @param element The element to add to the end of the LiveList.\n   */\n  push(element) {\n    this._pool?.assertStorageIsWritable();\n    return this.insert(element, this.length);\n  }\n  /**\n   * Inserts one element at a specified index.\n   * @param element The element to insert.\n   * @param index The index at which you want to insert the element.\n   */\n  insert(element, index) {\n    this._pool?.assertStorageIsWritable();\n    if (index < 0 || index > this.#items.length) {\n      throw new Error(\n        `Cannot insert list item at index \"\u001d${index}\". index should be between 0 and ${this.#items.length}`\n      );\n    }\n    const before2 = this.#items.at(index - 1)?._parentPos;\n    const after2 = this.#items.at(index)?._parentPos;\n    const position = makePosition(before2, after2);\n    const value = lsonToLiveNode(element);\n    value._setParentLink(this, position);\n    this.#insert(value);\n    if (this._pool && this._id) {\n      const id = this._pool.generateId();\n      value._attach(id, this._pool);\n      this._pool.dispatch(\n        value._toOpsWithOpId(this._id, position, this._pool),\n        [{ type: OpCode.DELETE_CRDT, id }],\n        /* @__PURE__ */ new Map([\n          [this._id, makeUpdate(this, [insertDelta(index, value)])]\n        ])\n      );\n    }\n  }\n  /**\n   * Move one element from one index to another.\n   * @param index The index of the element to move\n   * @param targetIndex The index where the element should be after moving.\n   */\n  move(index, targetIndex) {\n    this._pool?.assertStorageIsWritable();\n    if (targetIndex < 0) {\n      throw new Error(\"targetIndex cannot be less than 0\");\n    }\n    if (targetIndex >= this.#items.length) {\n      throw new Error(\n        \"targetIndex cannot be greater or equal than the list length\"\n      );\n    }\n    if (index < 0) {\n      throw new Error(\"index cannot be less than 0\");\n    }\n    if (index >= this.#items.length) {\n      throw new Error(\"index cannot be greater or equal than the list length\");\n    }\n    let beforePosition = null;\n    let afterPosition = null;\n    if (index < targetIndex) {\n      afterPosition = targetIndex === this.#items.length - 1 ? void 0 : this.#items.at(targetIndex + 1)?._parentPos;\n      beforePosition = this.#items.at(targetIndex)._parentPos;\n    } else {\n      afterPosition = this.#items.at(targetIndex)._parentPos;\n      beforePosition = targetIndex === 0 ? void 0 : this.#items.at(targetIndex - 1)?._parentPos;\n    }\n    const position = makePosition(beforePosition, afterPosition);\n    const item = this.#items.at(index);\n    const previousPosition = item._getParentKeyOrThrow();\n    this.#updateItemPositionAt(index, position);\n    if (this._pool && this._id) {\n      const storageUpdates = /* @__PURE__ */ new Map([\n        [this._id, makeUpdate(this, [moveDelta(index, targetIndex, item)])]\n      ]);\n      this._pool.dispatch(\n        [\n          {\n            type: OpCode.SET_PARENT_KEY,\n            id: nn(item._id),\n            opId: this._pool.generateOpId(),\n            parentKey: position\n          }\n        ],\n        [\n          {\n            type: OpCode.SET_PARENT_KEY,\n            id: nn(item._id),\n            parentKey: previousPosition\n          }\n        ],\n        storageUpdates\n      );\n    }\n  }\n  /**\n   * Deletes an element at the specified index\n   * @param index The index of the element to delete\n   */\n  delete(index) {\n    this._pool?.assertStorageIsWritable();\n    if (index < 0 || index >= this.#items.length) {\n      throw new Error(\n        `Cannot delete list item at index \"${index}\". index should be between 0 and ${this.#items.length - 1}`\n      );\n    }\n    const item = this.#items.at(index);\n    item._detach();\n    this.#items.remove(item);\n    this.invalidate();\n    if (this._pool) {\n      const childRecordId = item._id;\n      if (childRecordId) {\n        const storageUpdates = /* @__PURE__ */ new Map();\n        storageUpdates.set(\n          nn(this._id),\n          makeUpdate(this, [deleteDelta(index, item)])\n        );\n        this._pool.dispatch(\n          [\n            {\n              id: childRecordId,\n              opId: this._pool.generateOpId(),\n              type: OpCode.DELETE_CRDT\n            }\n          ],\n          item._toOps(nn(this._id), item._getParentKeyOrThrow()),\n          storageUpdates\n        );\n      }\n    }\n  }\n  clear() {\n    this._pool?.assertStorageIsWritable();\n    if (this._pool) {\n      const ops = [];\n      const reverseOps = [];\n      const updateDelta = [];\n      for (const item of this.#items) {\n        item._detach();\n        const childId = item._id;\n        if (childId) {\n          ops.push({\n            type: OpCode.DELETE_CRDT,\n            id: childId,\n            opId: this._pool.generateOpId()\n          });\n          reverseOps.push(\n            ...item._toOps(nn(this._id), item._getParentKeyOrThrow())\n          );\n          updateDelta.push(deleteDelta(0, item));\n        }\n      }\n      this.#items.clear();\n      this.invalidate();\n      const storageUpdates = /* @__PURE__ */ new Map();\n      storageUpdates.set(nn(this._id), makeUpdate(this, updateDelta));\n      this._pool.dispatch(ops, reverseOps, storageUpdates);\n    } else {\n      for (const item of this.#items) {\n        item._detach();\n      }\n      this.#items.clear();\n      this.invalidate();\n    }\n  }\n  set(index, item) {\n    this._pool?.assertStorageIsWritable();\n    if (index < 0 || index >= this.#items.length) {\n      throw new Error(\n        `Cannot set list item at index \"\u001d${index}\". index should be between 0 and ${this.#items.length - 1}`\n      );\n    }\n    const existingItem = this.#items.at(index);\n    const position = existingItem._getParentKeyOrThrow();\n    const existingId = existingItem._id;\n    existingItem._detach();\n    const value = lsonToLiveNode(item);\n    value._setParentLink(this, position);\n    this.#items.remove(existingItem);\n    this.#items.add(value);\n    this.invalidate();\n    if (this._pool && this._id) {\n      const id = this._pool.generateId();\n      value._attach(id, this._pool);\n      const storageUpdates = /* @__PURE__ */ new Map();\n      storageUpdates.set(this._id, makeUpdate(this, [setDelta(index, value)]));\n      const ops = HACK_addIntentAndDeletedIdToOperation(\n        value._toOpsWithOpId(this._id, position, this._pool),\n        existingId\n      );\n      this.#unacknowledgedSets.set(position, nn(ops[0].opId));\n      const reverseOps = HACK_addIntentAndDeletedIdToOperation(\n        existingItem._toOps(this._id, position),\n        id\n      );\n      this._pool.dispatch(ops, reverseOps, storageUpdates);\n    }\n  }\n  /**\n   * Returns an Array of all the elements in the LiveList.\n   */\n  toArray() {\n    return Array.from(this.#items, (entry) => liveNodeToLson(entry));\n  }\n  /**\n   * Tests whether all elements pass the test implemented by the provided function.\n   * @param predicate Function to test for each element, taking two arguments (the element and its index).\n   * @returns true if the predicate function returns a truthy value for every element. Otherwise, false.\n   */\n  every(predicate) {\n    return this.toArray().every(predicate);\n  }\n  /**\n   * Creates an array with all elements that pass the test implemented by the provided function.\n   * @param predicate Function to test each element of the LiveList. Return a value that coerces to true to keep the element, or to false otherwise.\n   * @returns An array with the elements that pass the test.\n   */\n  filter(predicate) {\n    return this.toArray().filter(predicate);\n  }\n  /**\n   * Returns the first element that satisfies the provided testing function.\n   * @param predicate Function to execute on each value.\n   * @returns The value of the first element in the LiveList that satisfies the provided testing function. Otherwise, undefined is returned.\n   */\n  find(predicate) {\n    return this.toArray().find(predicate);\n  }\n  /**\n   * Returns the index of the first element in the LiveList that satisfies the provided testing function.\n   * @param predicate Function to execute on each value until the function returns true, indicating that the satisfying element was found.\n   * @returns The index of the first element in the LiveList that passes the test. Otherwise, -1.\n   */\n  findIndex(predicate) {\n    return this.toArray().findIndex(predicate);\n  }\n  /**\n   * Executes a provided function once for each element.\n   * @param callbackfn Function to execute on each element.\n   */\n  forEach(callbackfn) {\n    return this.toArray().forEach(callbackfn);\n  }\n  /**\n   * Get the element at the specified index.\n   * @param index The index on the element to get.\n   * @returns The element at the specified index or undefined.\n   */\n  get(index) {\n    if (index < 0 || index >= this.#items.length) {\n      return void 0;\n    }\n    const item = this.#items.at(index);\n    return item ? liveNodeToLson(item) : void 0;\n  }\n  /**\n   * Returns the first index at which a given element can be found in the LiveList, or -1 if it is not present.\n   * @param searchElement Element to locate.\n   * @param fromIndex The index to start the search at.\n   * @returns The first index of the element in the LiveList; -1 if not found.\n   */\n  indexOf(searchElement, fromIndex) {\n    return this.toArray().indexOf(searchElement, fromIndex);\n  }\n  /**\n   * Returns the last index at which a given element can be found in the LiveList, or -1 if it is not present. The LiveLsit is searched backwards, starting at fromIndex.\n   * @param searchElement Element to locate.\n   * @param fromIndex The index at which to start searching backwards.\n   * @returns\n   */\n  lastIndexOf(searchElement, fromIndex) {\n    return this.toArray().lastIndexOf(searchElement, fromIndex);\n  }\n  /**\n   * Creates an array populated with the results of calling a provided function on every element.\n   * @param callback Function that is called for every element.\n   * @returns An array with each element being the result of the callback function.\n   */\n  map(callback) {\n    const result = [];\n    let i = 0;\n    for (const entry of this.#items) {\n      result.push(\n        callback(\n          liveNodeToLson(entry),\n          //                    ^^^^^^^^\n          //                    FIXME! This isn't safe.\n          i\n        )\n      );\n      i++;\n    }\n    return result;\n  }\n  /**\n   * Tests whether at least one element in the LiveList passes the test implemented by the provided function.\n   * @param predicate Function to test for each element.\n   * @returns true if the callback function returns a truthy value for at least one element. Otherwise, false.\n   */\n  some(predicate) {\n    return this.toArray().some(predicate);\n  }\n  [Symbol.iterator]() {\n    return new LiveListIterator(this.#items);\n  }\n  #createAttachItemAndSort(op, key) {\n    const newItem = creationOpToLiveNode(op);\n    newItem._attach(op.id, nn(this._pool));\n    newItem._setParentLink(this, key);\n    this.#insert(newItem);\n    const newIndex = this._indexOfPosition(key);\n    return { newItem, newIndex };\n  }\n  #shiftItemPosition(index, key) {\n    const shiftedPosition = makePosition(\n      key,\n      this.#items.length > index + 1 ? this.#items.at(index + 1)?._parentPos : void 0\n    );\n    this.#updateItemPositionAt(index, shiftedPosition);\n  }\n  /** @internal */\n  _toTreeNode(key) {\n    const payload = [];\n    let index = 0;\n    for (const item of this.#items) {\n      payload.push(item.toTreeNode(index.toString()));\n      index++;\n    }\n    return {\n      type: \"LiveList\",\n      id: this._id ?? nanoid(),\n      key,\n      payload\n    };\n  }\n  toImmutable() {\n    return super.toImmutable();\n  }\n  /** @internal */\n  _toImmutable() {\n    const result = Array.from(this.#items, (node) => node.toImmutable());\n    return process.env.NODE_ENV === \"production\" ? result : Object.freeze(result);\n  }\n  clone() {\n    return new _LiveList(\n      Array.from(this.#items, (item) => item.clone())\n    );\n  }\n};\nvar LiveListIterator = class {\n  #innerIterator;\n  constructor(items) {\n    this.#innerIterator = items[Symbol.iterator]();\n  }\n  [Symbol.iterator]() {\n    return this;\n  }\n  next() {\n    const result = this.#innerIterator.next();\n    if (result.done) {\n      return {\n        done: true,\n        value: void 0\n      };\n    }\n    const value = liveNodeToLson(result.value);\n    return { value };\n  }\n};\nfunction makeUpdate(liveList, deltaUpdates) {\n  return {\n    node: liveList,\n    type: \"LiveList\",\n    updates: deltaUpdates\n  };\n}\nfunction setDelta(index, item) {\n  return {\n    index,\n    type: \"set\",\n    item: item instanceof LiveRegister ? item.data : item\n  };\n}\nfunction deleteDelta(index, deletedNode) {\n  return {\n    type: \"delete\",\n    index,\n    deletedItem: deletedNode instanceof LiveRegister ? deletedNode.data : deletedNode\n  };\n}\nfunction insertDelta(index, item) {\n  return {\n    index,\n    type: \"insert\",\n    item: item instanceof LiveRegister ? item.data : item\n  };\n}\nfunction moveDelta(previousIndex, index, item) {\n  return {\n    type: \"move\",\n    index,\n    item: item instanceof LiveRegister ? item.data : item,\n    previousIndex\n  };\n}\nfunction HACK_addIntentAndDeletedIdToOperation(ops, deletedId) {\n  return ops.map((op, index) => {\n    if (index === 0) {\n      const firstOp = op;\n      return {\n        ...firstOp,\n        intent: \"set\",\n        deletedId\n      };\n    } else {\n      return op;\n    }\n  });\n}\n\n// src/crdts/LiveMap.ts\nvar LiveMap = class _LiveMap extends AbstractCrdt {\n  #map;\n  #unacknowledgedSet;\n  constructor(entries2) {\n    super();\n    this.#unacknowledgedSet = /* @__PURE__ */ new Map();\n    if (entries2) {\n      const mappedEntries = [];\n      for (const [key, value] of entries2) {\n        const node = lsonToLiveNode(value);\n        node._setParentLink(this, key);\n        mappedEntries.push([key, node]);\n      }\n      this.#map = new Map(mappedEntries);\n    } else {\n      this.#map = /* @__PURE__ */ new Map();\n    }\n  }\n  /** @internal */\n  _toOps(parentId, parentKey) {\n    if (this._id === void 0) {\n      throw new Error(\"Cannot serialize item is not attached\");\n    }\n    const ops = [];\n    const op = {\n      id: this._id,\n      type: OpCode.CREATE_MAP,\n      parentId,\n      parentKey\n    };\n    ops.push(op);\n    for (const [key, value] of this.#map) {\n      for (const childOp of value._toOps(this._id, key)) {\n        ops.push(childOp);\n      }\n    }\n    return ops;\n  }\n  /** @internal */\n  static _deserialize([id, _item], parentToChildren, pool) {\n    const map = new _LiveMap();\n    map._attach(id, pool);\n    const children = parentToChildren.get(id);\n    if (children === void 0) {\n      return map;\n    }\n    for (const node of children) {\n      const crdt = node[1];\n      const child = deserialize(node, parentToChildren, pool);\n      child._setParentLink(map, crdt.parentKey);\n      map.#map.set(crdt.parentKey, child);\n      map.invalidate();\n    }\n    return map;\n  }\n  /** @internal */\n  _attach(id, pool) {\n    super._attach(id, pool);\n    for (const [_key, value] of this.#map) {\n      if (isLiveNode(value)) {\n        value._attach(pool.generateId(), pool);\n      }\n    }\n  }\n  /** @internal */\n  _attachChild(op, source) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const { id, parentKey, opId } = op;\n    const key = parentKey;\n    const child = creationOpToLiveNode(op);\n    if (this._pool.getNode(id) !== void 0) {\n      return { modified: false };\n    }\n    if (source === 2 /* OURS */) {\n      const lastUpdateOpId = this.#unacknowledgedSet.get(key);\n      if (lastUpdateOpId === opId) {\n        this.#unacknowledgedSet.delete(key);\n        return { modified: false };\n      } else if (lastUpdateOpId !== void 0) {\n        return { modified: false };\n      }\n    } else if (source === 1 /* THEIRS */) {\n      this.#unacknowledgedSet.delete(key);\n    }\n    const previousValue = this.#map.get(key);\n    let reverse;\n    if (previousValue) {\n      const thisId = nn(this._id);\n      reverse = previousValue._toOps(thisId, key);\n      previousValue._detach();\n    } else {\n      reverse = [{ type: OpCode.DELETE_CRDT, id }];\n    }\n    child._setParentLink(this, key);\n    child._attach(id, this._pool);\n    this.#map.set(key, child);\n    this.invalidate();\n    return {\n      modified: {\n        node: this,\n        type: \"LiveMap\",\n        updates: { [key]: { type: \"update\" } }\n      },\n      reverse\n    };\n  }\n  /** @internal */\n  _detach() {\n    super._detach();\n    for (const item of this.#map.values()) {\n      item._detach();\n    }\n  }\n  /** @internal */\n  _detachChild(child) {\n    const id = nn(this._id);\n    const parentKey = nn(child._parentKey);\n    const reverse = child._toOps(id, parentKey);\n    for (const [key, value] of this.#map) {\n      if (value === child) {\n        this.#map.delete(key);\n        this.invalidate();\n      }\n    }\n    child._detach();\n    const storageUpdate = {\n      node: this,\n      type: \"LiveMap\",\n      updates: {\n        [parentKey]: {\n          type: \"delete\",\n          deletedItem: liveNodeToLson(child)\n        }\n      }\n    };\n    return { modified: storageUpdate, reverse };\n  }\n  /** @internal */\n  _serialize() {\n    if (this.parent.type !== \"HasParent\") {\n      throw new Error(\"Cannot serialize LiveMap if parent is missing\");\n    }\n    return {\n      type: CrdtType.MAP,\n      parentId: nn(this.parent.node._id, \"Parent node expected to have ID\"),\n      parentKey: this.parent.key\n    };\n  }\n  /**\n   * Returns a specified element from the LiveMap.\n   * @param key The key of the element to return.\n   * @returns The element associated with the specified key, or undefined if the key can't be found in the LiveMap.\n   */\n  get(key) {\n    const value = this.#map.get(key);\n    if (value === void 0) {\n      return void 0;\n    }\n    return liveNodeToLson(value);\n  }\n  /**\n   * Adds or updates an element with a specified key and a value.\n   * @param key The key of the element to add. Should be a string.\n   * @param value The value of the element to add. Should be serializable to JSON.\n   */\n  set(key, value) {\n    this._pool?.assertStorageIsWritable();\n    const oldValue = this.#map.get(key);\n    if (oldValue) {\n      oldValue._detach();\n    }\n    const item = lsonToLiveNode(value);\n    item._setParentLink(this, key);\n    this.#map.set(key, item);\n    this.invalidate();\n    if (this._pool && this._id) {\n      const id = this._pool.generateId();\n      item._attach(id, this._pool);\n      const storageUpdates = /* @__PURE__ */ new Map();\n      storageUpdates.set(this._id, {\n        node: this,\n        type: \"LiveMap\",\n        updates: { [key]: { type: \"update\" } }\n      });\n      const ops = item._toOpsWithOpId(this._id, key, this._pool);\n      this.#unacknowledgedSet.set(key, nn(ops[0].opId));\n      this._pool.dispatch(\n        ops,\n        oldValue ? oldValue._toOps(this._id, key) : [{ type: OpCode.DELETE_CRDT, id }],\n        storageUpdates\n      );\n    }\n  }\n  /**\n   * Returns the number of elements in the LiveMap.\n   */\n  get size() {\n    return this.#map.size;\n  }\n  /**\n   * Returns a boolean indicating whether an element with the specified key exists or not.\n   * @param key The key of the element to test for presence.\n   */\n  has(key) {\n    return this.#map.has(key);\n  }\n  /**\n   * Removes the specified element by key.\n   * @param key The key of the element to remove.\n   * @returns true if an element existed and has been removed, or false if the element does not exist.\n   */\n  delete(key) {\n    this._pool?.assertStorageIsWritable();\n    const item = this.#map.get(key);\n    if (item === void 0) {\n      return false;\n    }\n    item._detach();\n    this.#map.delete(key);\n    this.invalidate();\n    if (this._pool && item._id) {\n      const thisId = nn(this._id);\n      const storageUpdates = /* @__PURE__ */ new Map();\n      storageUpdates.set(thisId, {\n        node: this,\n        type: \"LiveMap\",\n        updates: {\n          [key]: {\n            type: \"delete\",\n            deletedItem: liveNodeToLson(item)\n          }\n        }\n      });\n      this._pool.dispatch(\n        [\n          {\n            type: OpCode.DELETE_CRDT,\n            id: item._id,\n            opId: this._pool.generateOpId()\n          }\n        ],\n        item._toOps(thisId, key),\n        storageUpdates\n      );\n    }\n    return true;\n  }\n  /**\n   * Returns a new Iterator object that contains the [key, value] pairs for each element.\n   */\n  entries() {\n    const innerIterator = this.#map.entries();\n    return {\n      [Symbol.iterator]() {\n        return this;\n      },\n      next() {\n        const iteratorValue = innerIterator.next();\n        if (iteratorValue.done) {\n          return {\n            done: true,\n            value: void 0\n          };\n        }\n        const entry = iteratorValue.value;\n        const key = entry[0];\n        const value = liveNodeToLson(iteratorValue.value[1]);\n        return {\n          value: [key, value]\n        };\n      }\n    };\n  }\n  /**\n   * Same function object as the initial value of the entries method.\n   */\n  [Symbol.iterator]() {\n    return this.entries();\n  }\n  /**\n   * Returns a new Iterator object that contains the keys for each element.\n   */\n  keys() {\n    return this.#map.keys();\n  }\n  /**\n   * Returns a new Iterator object that contains the values for each element.\n   */\n  values() {\n    const innerIterator = this.#map.values();\n    return {\n      [Symbol.iterator]() {\n        return this;\n      },\n      next() {\n        const iteratorValue = innerIterator.next();\n        if (iteratorValue.done) {\n          return {\n            done: true,\n            value: void 0\n          };\n        }\n        const value = liveNodeToLson(iteratorValue.value);\n        return { value };\n      }\n    };\n  }\n  /**\n   * Executes a provided function once per each key/value pair in the Map object, in insertion order.\n   * @param callback Function to execute for each entry in the map.\n   */\n  forEach(callback) {\n    for (const entry of this) {\n      callback(entry[1], entry[0], this);\n    }\n  }\n  /** @internal */\n  _toTreeNode(key) {\n    return {\n      type: \"LiveMap\",\n      id: this._id ?? nanoid(),\n      key,\n      payload: Array.from(this.#map.entries()).map(\n        ([key2, val]) => val.toTreeNode(key2)\n      )\n    };\n  }\n  toImmutable() {\n    return super.toImmutable();\n  }\n  /** @internal */\n  _toImmutable() {\n    const result = /* @__PURE__ */ new Map();\n    for (const [key, value] of this.#map) {\n      result.set(key, value.toImmutable());\n    }\n    return freeze(result);\n  }\n  clone() {\n    return new _LiveMap(\n      Array.from(this.#map).map(([key, node]) => [key, node.clone()])\n    );\n  }\n};\n\n// src/crdts/LiveObject.ts\nvar MAX_LIVE_OBJECT_SIZE = 128 * 1024;\nvar LiveObject = class _LiveObject extends AbstractCrdt {\n  #map;\n  /**\n   * Tracks unacknowledged local changes per property to preserve optimistic\n   * updates. Maps property keys to their pending operation IDs.\n   *\n   * INVARIANT: Only locally-generated opIds are ever stored here. Remote opIds\n   * are only compared against (to detect ACKs), never stored.\n   *\n   * When a local change is made, the opId is stored here. When a remote op\n   * arrives for the same key:\n   * - If no entry exists  apply remote op\n   * - If opId matches  it's an ACK, clear the entry\n   * - If opId differs  ignore remote op to preserve optimistic update\n   */\n  #unackedOpsByKey;\n  /**\n   * Enable or disable detection of too large LiveObjects.\n   * When enabled, throws an error if LiveObject static data exceeds 128KB, which\n   * is the maximum value the server will be able to accept.\n   * By default, this behavior is disabled to avoid the runtime performance\n   * overhead on every LiveObject.set() or LiveObject.update() call.\n   *\n   * @experimental\n   */\n  static detectLargeObjects = false;\n  static #buildRootAndParentToChildren(nodes) {\n    const parentToChildren = /* @__PURE__ */ new Map();\n    let root = null;\n    for (const node of nodes) {\n      if (isRootStorageNode(node)) {\n        root = node[1];\n      } else {\n        const crdt = node[1];\n        const children = parentToChildren.get(crdt.parentId);\n        if (children !== void 0) {\n          children.push(node);\n        } else {\n          parentToChildren.set(crdt.parentId, [node]);\n        }\n      }\n    }\n    if (root === null) {\n      throw new Error(\"Root can't be null\");\n    }\n    return [root, parentToChildren];\n  }\n  /** @private Do not use this API directly */\n  static _fromItems(nodes, pool) {\n    const [root, parentToChildren] = _LiveObject.#buildRootAndParentToChildren(nodes);\n    return _LiveObject._deserialize(\n      [\"root\", root],\n      parentToChildren,\n      pool\n    );\n  }\n  constructor(obj = {}) {\n    super();\n    this.#unackedOpsByKey = /* @__PURE__ */ new Map();\n    const o = compactObject(obj);\n    for (const key of Object.keys(o)) {\n      const value = o[key];\n      if (isLiveNode(value)) {\n        value._setParentLink(this, key);\n      }\n    }\n    this.#map = new Map(Object.entries(o));\n  }\n  /** @internal */\n  _toOps(parentId, parentKey) {\n    if (this._id === void 0) {\n      throw new Error(\"Cannot serialize item is not attached\");\n    }\n    const ops = [];\n    const op = {\n      type: OpCode.CREATE_OBJECT,\n      id: this._id,\n      parentId,\n      parentKey,\n      data: {}\n    };\n    ops.push(op);\n    for (const [key, value] of this.#map) {\n      if (isLiveNode(value)) {\n        for (const childOp of value._toOps(this._id, key)) {\n          ops.push(childOp);\n        }\n      } else {\n        op.data[key] = value;\n      }\n    }\n    return ops;\n  }\n  /** @internal */\n  static _deserialize([id, item], parentToChildren, pool) {\n    const liveObj = new _LiveObject(item.data);\n    liveObj._attach(id, pool);\n    return this._deserializeChildren(liveObj, parentToChildren, pool);\n  }\n  /** @internal */\n  static _deserializeChildren(liveObj, parentToChildren, pool) {\n    const children = parentToChildren.get(nn(liveObj._id));\n    if (children === void 0) {\n      return liveObj;\n    }\n    for (const node of children) {\n      const child = deserializeToLson(node, parentToChildren, pool);\n      const crdt = node[1];\n      if (isLiveStructure(child)) {\n        child._setParentLink(liveObj, crdt.parentKey);\n      }\n      liveObj.#map.set(crdt.parentKey, child);\n      liveObj.invalidate();\n    }\n    return liveObj;\n  }\n  /** @internal */\n  _attach(id, pool) {\n    super._attach(id, pool);\n    for (const [_key, value] of this.#map) {\n      if (isLiveNode(value)) {\n        value._attach(pool.generateId(), pool);\n      }\n    }\n  }\n  /** @internal */\n  _attachChild(op, source) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const { id, opId, parentKey: key } = op;\n    const child = creationOpToLson(op);\n    if (this._pool.getNode(id) !== void 0) {\n      if (this.#unackedOpsByKey.get(key) === opId) {\n        this.#unackedOpsByKey.delete(key);\n      }\n      return { modified: false };\n    }\n    if (source === 0 /* LOCAL */) {\n      this.#unackedOpsByKey.set(key, nn(opId));\n    } else if (this.#unackedOpsByKey.get(key) === void 0) {\n    } else if (this.#unackedOpsByKey.get(key) === opId) {\n      this.#unackedOpsByKey.delete(key);\n      return { modified: false };\n    } else {\n      return { modified: false };\n    }\n    const thisId = nn(this._id);\n    const previousValue = this.#map.get(key);\n    let reverse;\n    if (isLiveNode(previousValue)) {\n      reverse = previousValue._toOps(thisId, key);\n      previousValue._detach();\n    } else if (previousValue === void 0) {\n      reverse = [{ type: OpCode.DELETE_OBJECT_KEY, id: thisId, key }];\n    } else {\n      reverse = [\n        {\n          type: OpCode.UPDATE_OBJECT,\n          id: thisId,\n          data: { [key]: previousValue }\n        }\n      ];\n    }\n    this.#map.set(key, child);\n    this.invalidate();\n    if (isLiveStructure(child)) {\n      child._setParentLink(this, key);\n      child._attach(id, this._pool);\n    }\n    return {\n      reverse,\n      modified: {\n        node: this,\n        type: \"LiveObject\",\n        updates: { [key]: { type: \"update\" } }\n      }\n    };\n  }\n  /** @internal */\n  _detachChild(child) {\n    if (child) {\n      const id = nn(this._id);\n      const parentKey = nn(child._parentKey);\n      const reverse = child._toOps(id, parentKey);\n      for (const [key, value] of this.#map) {\n        if (value === child) {\n          this.#map.delete(key);\n          this.invalidate();\n        }\n      }\n      child._detach();\n      const storageUpdate = {\n        node: this,\n        type: \"LiveObject\",\n        updates: {\n          [parentKey]: { type: \"delete\" }\n        }\n      };\n      return { modified: storageUpdate, reverse };\n    }\n    return { modified: false };\n  }\n  /** @internal */\n  _detach() {\n    super._detach();\n    for (const value of this.#map.values()) {\n      if (isLiveNode(value)) {\n        value._detach();\n      }\n    }\n  }\n  /** @internal */\n  _apply(op, isLocal) {\n    if (op.type === OpCode.UPDATE_OBJECT) {\n      return this.#applyUpdate(op, isLocal);\n    } else if (op.type === OpCode.DELETE_OBJECT_KEY) {\n      return this.#applyDeleteObjectKey(op, isLocal);\n    }\n    return super._apply(op, isLocal);\n  }\n  /** @internal */\n  _serialize() {\n    const data = {};\n    for (const [key, value] of this.#map) {\n      if (!isLiveNode(value)) {\n        data[key] = value;\n      }\n    }\n    if (this.parent.type === \"HasParent\" && this.parent.node._id) {\n      return {\n        type: CrdtType.OBJECT,\n        parentId: this.parent.node._id,\n        parentKey: this.parent.key,\n        data\n      };\n    } else {\n      return {\n        type: CrdtType.OBJECT,\n        data\n      };\n    }\n  }\n  #applyUpdate(op, isLocal) {\n    let isModified = false;\n    const id = nn(this._id);\n    const reverse = [];\n    const reverseUpdate = {\n      type: OpCode.UPDATE_OBJECT,\n      id,\n      data: {}\n    };\n    for (const key in op.data) {\n      const oldValue = this.#map.get(key);\n      if (isLiveNode(oldValue)) {\n        for (const childOp of oldValue._toOps(id, key)) {\n          reverse.push(childOp);\n        }\n        oldValue._detach();\n      } else if (oldValue !== void 0) {\n        reverseUpdate.data[key] = oldValue;\n      } else if (oldValue === void 0) {\n        reverse.push({ type: OpCode.DELETE_OBJECT_KEY, id, key });\n      }\n    }\n    const updateDelta = {};\n    for (const key in op.data) {\n      const value = op.data[key];\n      if (value === void 0) {\n        continue;\n      }\n      if (isLocal) {\n        this.#unackedOpsByKey.set(key, nn(op.opId));\n      } else if (this.#unackedOpsByKey.get(key) === void 0) {\n        isModified = true;\n      } else if (this.#unackedOpsByKey.get(key) === op.opId) {\n        this.#unackedOpsByKey.delete(key);\n        continue;\n      } else {\n        continue;\n      }\n      const oldValue = this.#map.get(key);\n      if (isLiveNode(oldValue)) {\n        oldValue._detach();\n      }\n      isModified = true;\n      updateDelta[key] = { type: \"update\" };\n      this.#map.set(key, value);\n      this.invalidate();\n    }\n    if (Object.keys(reverseUpdate.data).length !== 0) {\n      reverse.unshift(reverseUpdate);\n    }\n    return isModified ? {\n      modified: {\n        node: this,\n        type: \"LiveObject\",\n        updates: updateDelta\n      },\n      reverse\n    } : { modified: false };\n  }\n  #applyDeleteObjectKey(op, isLocal) {\n    const key = op.key;\n    const oldValue = this.#map.get(key);\n    if (oldValue === void 0) {\n      return { modified: false };\n    }\n    if (!isLocal && this.#unackedOpsByKey.get(key) !== void 0) {\n      return { modified: false };\n    }\n    const id = nn(this._id);\n    let reverse = [];\n    if (isLiveNode(oldValue)) {\n      reverse = oldValue._toOps(id, op.key);\n      oldValue._detach();\n    } else if (oldValue !== void 0) {\n      reverse = [\n        {\n          type: OpCode.UPDATE_OBJECT,\n          id,\n          data: { [key]: oldValue }\n        }\n      ];\n    }\n    this.#map.delete(key);\n    this.invalidate();\n    return {\n      modified: {\n        node: this,\n        type: \"LiveObject\",\n        updates: {\n          [op.key]: { type: \"delete\", deletedItem: oldValue }\n        }\n      },\n      reverse\n    };\n  }\n  /**\n   * Transform the LiveObject into a javascript object\n   */\n  toObject() {\n    return Object.fromEntries(this.#map);\n  }\n  /**\n   * Adds or updates a property with a specified key and a value.\n   * @param key The key of the property to add\n   * @param value The value of the property to add\n   */\n  set(key, value) {\n    this._pool?.assertStorageIsWritable();\n    this.update({ [key]: value });\n  }\n  /**\n   * Returns a specified property from the LiveObject.\n   * @param key The key of the property to get\n   */\n  get(key) {\n    return this.#map.get(key);\n  }\n  /**\n   * Deletes a key from the LiveObject\n   * @param key The key of the property to delete\n   */\n  delete(key) {\n    this._pool?.assertStorageIsWritable();\n    const keyAsString = key;\n    const oldValue = this.#map.get(keyAsString);\n    if (oldValue === void 0) {\n      return;\n    }\n    if (this._pool === void 0 || this._id === void 0) {\n      if (isLiveNode(oldValue)) {\n        oldValue._detach();\n      }\n      this.#map.delete(keyAsString);\n      this.invalidate();\n      return;\n    }\n    let reverse;\n    if (isLiveNode(oldValue)) {\n      oldValue._detach();\n      reverse = oldValue._toOps(this._id, keyAsString);\n    } else {\n      reverse = [\n        {\n          type: OpCode.UPDATE_OBJECT,\n          data: { [keyAsString]: oldValue },\n          id: this._id\n        }\n      ];\n    }\n    this.#map.delete(keyAsString);\n    this.invalidate();\n    const storageUpdates = /* @__PURE__ */ new Map();\n    storageUpdates.set(this._id, {\n      node: this,\n      type: \"LiveObject\",\n      updates: {\n        [key]: { type: \"delete\", deletedItem: oldValue }\n      }\n    });\n    this._pool.dispatch(\n      [\n        {\n          type: OpCode.DELETE_OBJECT_KEY,\n          key: keyAsString,\n          id: this._id,\n          opId: this._pool.generateOpId()\n        }\n      ],\n      reverse,\n      storageUpdates\n    );\n  }\n  /**\n   * Adds or updates multiple properties at once with an object.\n   * @param patch The object used to overrides properties\n   */\n  update(patch) {\n    this._pool?.assertStorageIsWritable();\n    if (_LiveObject.detectLargeObjects) {\n      const data = {};\n      for (const [key, value] of this.#map) {\n        if (!isLiveNode(value)) {\n          data[key] = value;\n        }\n      }\n      for (const key of Object.keys(patch)) {\n        const value = patch[key];\n        if (value === void 0) continue;\n        if (!isLiveNode(value)) {\n          data[key] = value;\n        }\n      }\n      const jsonString = JSON.stringify(data);\n      const upperBoundSize = jsonString.length * 4;\n      if (upperBoundSize > MAX_LIVE_OBJECT_SIZE) {\n        const preciseSize = new TextEncoder().encode(jsonString).length;\n        if (preciseSize > MAX_LIVE_OBJECT_SIZE) {\n          throw new Error(\n            `LiveObject size exceeded limit: ${preciseSize} bytes > ${MAX_LIVE_OBJECT_SIZE} bytes. See https://liveblocks.io/docs/platform/limits#Liveblocks-Storage-limits`\n          );\n        }\n      }\n    }\n    if (this._pool === void 0 || this._id === void 0) {\n      for (const key in patch) {\n        const newValue = patch[key];\n        if (newValue === void 0) {\n          continue;\n        }\n        const oldValue = this.#map.get(key);\n        if (isLiveNode(oldValue)) {\n          oldValue._detach();\n        }\n        if (isLiveNode(newValue)) {\n          newValue._setParentLink(this, key);\n        }\n        this.#map.set(key, newValue);\n        this.invalidate();\n      }\n      return;\n    }\n    const ops = [];\n    const reverseOps = [];\n    const opId = this._pool.generateOpId();\n    const updatedProps = {};\n    const reverseUpdateOp = {\n      id: this._id,\n      type: OpCode.UPDATE_OBJECT,\n      data: {}\n    };\n    const updateDelta = {};\n    for (const key in patch) {\n      const newValue = patch[key];\n      if (newValue === void 0) {\n        continue;\n      }\n      const oldValue = this.#map.get(key);\n      if (isLiveNode(oldValue)) {\n        for (const childOp of oldValue._toOps(this._id, key)) {\n          reverseOps.push(childOp);\n        }\n        oldValue._detach();\n      } else if (oldValue === void 0) {\n        reverseOps.push({ type: OpCode.DELETE_OBJECT_KEY, id: this._id, key });\n      } else {\n        reverseUpdateOp.data[key] = oldValue;\n      }\n      if (isLiveNode(newValue)) {\n        newValue._setParentLink(this, key);\n        newValue._attach(this._pool.generateId(), this._pool);\n        const newAttachChildOps = newValue._toOpsWithOpId(\n          this._id,\n          key,\n          this._pool\n        );\n        const createCrdtOp = newAttachChildOps.find(\n          (op) => op.parentId === this._id\n        );\n        if (createCrdtOp) {\n          this.#unackedOpsByKey.set(key, nn(createCrdtOp.opId));\n        }\n        for (const childOp of newAttachChildOps) {\n          ops.push(childOp);\n        }\n      } else {\n        updatedProps[key] = newValue;\n        this.#unackedOpsByKey.set(key, opId);\n      }\n      this.#map.set(key, newValue);\n      this.invalidate();\n      updateDelta[key] = { type: \"update\" };\n    }\n    if (Object.keys(reverseUpdateOp.data).length !== 0) {\n      reverseOps.unshift(reverseUpdateOp);\n    }\n    if (Object.keys(updatedProps).length !== 0) {\n      ops.unshift({\n        opId,\n        id: this._id,\n        type: OpCode.UPDATE_OBJECT,\n        data: updatedProps\n      });\n    }\n    const storageUpdates = /* @__PURE__ */ new Map();\n    storageUpdates.set(this._id, {\n      node: this,\n      type: \"LiveObject\",\n      updates: updateDelta\n    });\n    this._pool.dispatch(ops, reverseOps, storageUpdates);\n  }\n  toImmutable() {\n    return super.toImmutable();\n  }\n  /** @internal */\n  toTreeNode(key) {\n    return super.toTreeNode(key);\n  }\n  /** @internal */\n  _toTreeNode(key) {\n    const nodeId = this._id ?? nanoid();\n    return {\n      type: \"LiveObject\",\n      id: nodeId,\n      key,\n      payload: Array.from(this.#map.entries()).map(\n        ([key2, value]) => isLiveNode(value) ? value.toTreeNode(key2) : { type: \"Json\", id: `${nodeId}:${key2}`, key: key2, payload: value }\n      )\n    };\n  }\n  /** @internal */\n  _toImmutable() {\n    const result = {};\n    for (const [key, val] of this.#map) {\n      result[key] = isLiveStructure(val) ? val.toImmutable() : val;\n    }\n    return process.env.NODE_ENV === \"production\" ? result : Object.freeze(result);\n  }\n  clone() {\n    return new _LiveObject(\n      Object.fromEntries(\n        Array.from(this.#map).map(([key, value]) => [\n          key,\n          isLiveStructure(value) ? value.clone() : deepClone(value)\n        ])\n      )\n    );\n  }\n};\n\n// src/crdts/liveblocks-helpers.ts\nfunction creationOpToLiveNode(op) {\n  return lsonToLiveNode(creationOpToLson(op));\n}\nfunction creationOpToLson(op) {\n  switch (op.type) {\n    case OpCode.CREATE_REGISTER:\n      return op.data;\n    case OpCode.CREATE_OBJECT:\n      return new LiveObject(op.data);\n    case OpCode.CREATE_MAP:\n      return new LiveMap();\n    case OpCode.CREATE_LIST:\n      return new LiveList([]);\n    default:\n      return assertNever(op, \"Unknown creation Op\");\n  }\n}\nfunction isSameNodeOrChildOf(node, parent) {\n  if (node === parent) {\n    return true;\n  }\n  if (node.parent.type === \"HasParent\") {\n    return isSameNodeOrChildOf(node.parent.node, parent);\n  }\n  return false;\n}\nfunction deserialize(node, parentToChildren, pool) {\n  if (isObjectStorageNode(node)) {\n    return LiveObject._deserialize(node, parentToChildren, pool);\n  } else if (isListStorageNode(node)) {\n    return LiveList._deserialize(node, parentToChildren, pool);\n  } else if (isMapStorageNode(node)) {\n    return LiveMap._deserialize(node, parentToChildren, pool);\n  } else if (isRegisterStorageNode(node)) {\n    return LiveRegister._deserialize(node, parentToChildren, pool);\n  } else {\n    throw new Error(\"Unexpected CRDT type\");\n  }\n}\nfunction deserializeToLson(node, parentToChildren, pool) {\n  if (isObjectStorageNode(node)) {\n    return LiveObject._deserialize(node, parentToChildren, pool);\n  } else if (isListStorageNode(node)) {\n    return LiveList._deserialize(node, parentToChildren, pool);\n  } else if (isMapStorageNode(node)) {\n    return LiveMap._deserialize(node, parentToChildren, pool);\n  } else if (isRegisterStorageNode(node)) {\n    return node[1].data;\n  } else {\n    throw new Error(\"Unexpected CRDT type\");\n  }\n}\nfunction isLiveStructure(value) {\n  return isLiveList(value) || isLiveMap(value) || isLiveObject(value);\n}\nfunction isLiveNode(value) {\n  return isLiveStructure(value) || isLiveRegister(value);\n}\nfunction isLiveList(value) {\n  return value instanceof LiveList;\n}\nfunction isLiveMap(value) {\n  return value instanceof LiveMap;\n}\nfunction isLiveObject(value) {\n  return value instanceof LiveObject;\n}\nfunction isLiveRegister(value) {\n  return value instanceof LiveRegister;\n}\nfunction cloneLson(value) {\n  return value === void 0 ? void 0 : isLiveStructure(value) ? value.clone() : deepClone(value);\n}\nfunction liveNodeToLson(obj) {\n  if (obj instanceof LiveRegister) {\n    return obj.data;\n  } else if (obj instanceof LiveList || obj instanceof LiveMap || obj instanceof LiveObject) {\n    return obj;\n  } else {\n    return assertNever(obj, \"Unknown AbstractCrdt\");\n  }\n}\nfunction lsonToLiveNode(value) {\n  if (value instanceof LiveObject || value instanceof LiveMap || value instanceof LiveList) {\n    return value;\n  } else {\n    return new LiveRegister(value);\n  }\n}\nfunction getTreesDiffOperations(currentItems, newItems) {\n  const ops = [];\n  currentItems.forEach((_, id) => {\n    if (!newItems.get(id)) {\n      ops.push({ type: OpCode.DELETE_CRDT, id });\n    }\n  });\n  newItems.forEach((crdt, id) => {\n    const currentCrdt = currentItems.get(id);\n    if (currentCrdt) {\n      if (crdt.type === CrdtType.OBJECT) {\n        if (currentCrdt.type !== CrdtType.OBJECT || stringifyOrLog(crdt.data) !== stringifyOrLog(currentCrdt.data)) {\n          ops.push({\n            type: OpCode.UPDATE_OBJECT,\n            id,\n            data: crdt.data\n          });\n        }\n      }\n      if (crdt.parentKey !== currentCrdt.parentKey) {\n        ops.push({\n          type: OpCode.SET_PARENT_KEY,\n          id,\n          parentKey: nn(crdt.parentKey, \"Parent key must not be missing\")\n        });\n      }\n    } else {\n      switch (crdt.type) {\n        case CrdtType.REGISTER:\n          ops.push({\n            type: OpCode.CREATE_REGISTER,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey,\n            data: crdt.data\n          });\n          break;\n        case CrdtType.LIST:\n          ops.push({\n            type: OpCode.CREATE_LIST,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey\n          });\n          break;\n        case CrdtType.OBJECT:\n          if (crdt.parentId === void 0 || crdt.parentKey === void 0) {\n            throw new Error(\n              \"Internal error. Cannot serialize storage root into an operation\"\n            );\n          }\n          ops.push({\n            type: OpCode.CREATE_OBJECT,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey,\n            data: crdt.data\n          });\n          break;\n        case CrdtType.MAP:\n          ops.push({\n            type: OpCode.CREATE_MAP,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey\n          });\n          break;\n      }\n    }\n  });\n  return ops;\n}\nfunction mergeObjectStorageUpdates(first, second) {\n  const updates = first.updates;\n  for (const [key, value] of entries(second.updates)) {\n    updates[key] = value;\n  }\n  return {\n    ...second,\n    updates\n  };\n}\nfunction mergeMapStorageUpdates(first, second) {\n  const updates = first.updates;\n  for (const [key, value] of entries(second.updates)) {\n    updates[key] = value;\n  }\n  return {\n    ...second,\n    updates\n  };\n}\nfunction mergeListStorageUpdates(first, second) {\n  const updates = first.updates;\n  return {\n    ...second,\n    updates: updates.concat(second.updates)\n  };\n}\nfunction mergeStorageUpdates(first, second) {\n  if (first === void 0) {\n    return second;\n  }\n  if (first.type === \"LiveObject\" && second.type === \"LiveObject\") {\n    return mergeObjectStorageUpdates(first, second);\n  } else if (first.type === \"LiveMap\" && second.type === \"LiveMap\") {\n    return mergeMapStorageUpdates(first, second);\n  } else if (first.type === \"LiveList\" && second.type === \"LiveList\") {\n    return mergeListStorageUpdates(first, second);\n  } else {\n  }\n  return second;\n}\nfunction isPlain(value) {\n  const type = typeof value;\n  return value === void 0 || value === null || type === \"string\" || type === \"boolean\" || type === \"number\" || Array.isArray(value) || isPlainObject(value);\n}\nfunction findNonSerializableValue(value, path = \"\") {\n  if (!isPlain) {\n    return {\n      path: path || \"root\",\n      value\n    };\n  }\n  if (typeof value !== \"object\" || value === null) {\n    return false;\n  }\n  for (const [key, nestedValue] of Object.entries(value)) {\n    const nestedPath = path ? path + \".\" + key : key;\n    if (!isPlain(nestedValue)) {\n      return {\n        path: nestedPath,\n        value: nestedValue\n      };\n    }\n    if (typeof nestedValue === \"object\") {\n      const nonSerializableNestedValue = findNonSerializableValue(\n        nestedValue,\n        nestedPath\n      );\n      if (nonSerializableNestedValue) {\n        return nonSerializableNestedValue;\n      }\n    }\n  }\n  return false;\n}\n\n// src/lib/Deque.ts\nvar Deque = class {\n  #data;\n  #front;\n  #back;\n  #size;\n  constructor() {\n    this.#data = {};\n    this.#front = 0;\n    this.#back = 1;\n    this.#size = 0;\n  }\n  get length() {\n    return this.#size;\n  }\n  *[Symbol.iterator]() {\n    const size = this.#size;\n    const front = this.#front;\n    for (let i = 0; i < size; i++) {\n      yield this.#data[front + i];\n    }\n  }\n  push(value) {\n    const values2 = Array.isArray(value) ? value : [value];\n    if (this.#back > Number.MAX_SAFE_INTEGER - values2.length - 1)\n      raise(\"Deque full\");\n    for (const value2 of values2) {\n      this.#data[this.#back++ - 1] = value2;\n    }\n    this.#size += values2.length;\n  }\n  pop() {\n    if (this.#size < 1) return void 0;\n    this.#back--;\n    const value = this.#data[this.#back - 1];\n    delete this.#data[this.#back - 1];\n    this.#size--;\n    return value;\n  }\n  pushLeft(value) {\n    const values2 = Array.isArray(value) ? value : [value];\n    if (this.#front < Number.MIN_SAFE_INTEGER + values2.length)\n      raise(\"Deque full\");\n    for (let i = values2.length - 1; i >= 0; i--) {\n      this.#data[--this.#front] = values2[i];\n    }\n    this.#size += values2.length;\n  }\n  popLeft() {\n    if (this.#size < 1) return void 0;\n    const value = this.#data[this.#front];\n    delete this.#data[this.#front];\n    this.#front++;\n    this.#size--;\n    return value;\n  }\n};\n\n// src/lib/Json.ts\nfunction isJsonScalar(data) {\n  return data === null || typeof data === \"string\" || typeof data === \"number\" || typeof data === \"boolean\";\n}\nfunction isJsonArray(data) {\n  return Array.isArray(data);\n}\nfunction isJsonObject(data) {\n  return !isJsonScalar(data) && !isJsonArray(data);\n}\n\n// src/lib/stopwatch.ts\nfunction makeStopWatch() {\n  let startTime = 0;\n  let lastLapTime = 0;\n  let laps;\n  function start() {\n    laps = [];\n    startTime = performance.now();\n    lastLapTime = startTime;\n  }\n  function lap(now2 = performance.now()) {\n    laps.push(now2 - lastLapTime);\n    lastLapTime = now2;\n  }\n  function stop() {\n    const endTime = performance.now();\n    lap(endTime);\n    const total = endTime - startTime;\n    return { total, laps };\n  }\n  return { start, lap, stop };\n}\n\n// src/protocol/ClientMsg.ts\nvar ClientMsgCode = Object.freeze({\n  // For Presence\n  UPDATE_PRESENCE: 100,\n  BROADCAST_EVENT: 103,\n  // For Storage\n  FETCH_STORAGE: 200,\n  UPDATE_STORAGE: 201,\n  // For Yjs support\n  FETCH_YDOC: 300,\n  UPDATE_YDOC: 301\n});\n\n// src/refs/ManagedOthers.ts\nfunction makeUser(conn, presence) {\n  const { connectionId, id, info } = conn;\n  const canWrite = canWriteStorage(conn.scopes);\n  return freeze(\n    compactObject({\n      connectionId,\n      id,\n      info,\n      canWrite,\n      canComment: canComment(conn.scopes),\n      isReadOnly: !canWrite,\n      // Deprecated, kept for backward-compatibility\n      presence\n    })\n  );\n}\nvar ManagedOthers = class {\n  // Track mutable state internally, but signal to the outside when the\n  // observable derived state changes only\n  #internal;\n  #userCache;\n  // The \"clean\" signal that is exposed to the outside world\n  signal;\n  constructor() {\n    this.#internal = new MutableSignal({\n      connections: /* @__PURE__ */ new Map(),\n      presences: /* @__PURE__ */ new Map()\n    });\n    this.signal = DerivedSignal.from(\n      this.#internal,\n      (_ignore) => compact(\n        Array.from(this.#internal.get().presences.keys()).map(\n          (connectionId) => this.getUser(Number(connectionId))\n        )\n      )\n    );\n    this.#userCache = /* @__PURE__ */ new Map();\n  }\n  // Shorthand for .signal.get()\n  get() {\n    return this.signal.get();\n  }\n  connectionIds() {\n    return this.#internal.get().connections.keys();\n  }\n  clearOthers() {\n    this.#internal.mutate((state) => {\n      state.connections.clear();\n      state.presences.clear();\n      this.#userCache.clear();\n    });\n  }\n  #_getUser(connectionId) {\n    const state = this.#internal.get();\n    const conn = state.connections.get(connectionId);\n    const presence = state.presences.get(connectionId);\n    if (conn !== void 0 && presence !== void 0) {\n      return makeUser(conn, presence);\n    }\n    return void 0;\n  }\n  getUser(connectionId) {\n    const cachedUser = this.#userCache.get(connectionId);\n    if (cachedUser) {\n      return cachedUser;\n    }\n    const computedUser = this.#_getUser(connectionId);\n    if (computedUser) {\n      this.#userCache.set(connectionId, computedUser);\n      return computedUser;\n    }\n    return void 0;\n  }\n  #invalidateUser(connectionId) {\n    this.#userCache.delete(connectionId);\n  }\n  /**\n   * Records a known connection. This records the connection ID and the\n   * associated metadata.\n   */\n  setConnection(connectionId, metaUserId, metaUserInfo, scopes) {\n    this.#internal.mutate((state) => {\n      state.connections.set(\n        connectionId,\n        freeze({\n          connectionId,\n          id: metaUserId,\n          info: metaUserInfo,\n          scopes\n        })\n      );\n      if (!state.presences.has(connectionId)) {\n        return false;\n      }\n      return this.#invalidateUser(connectionId);\n    });\n  }\n  /**\n   * Removes a known connectionId. Removes both the connection's metadata and\n   * the presence information.\n   */\n  removeConnection(connectionId) {\n    this.#internal.mutate((state) => {\n      state.connections.delete(connectionId);\n      state.presences.delete(connectionId);\n      this.#invalidateUser(connectionId);\n    });\n  }\n  /**\n   * Stores a new user from a full presence update. If the user already exists,\n   * its known presence data is overwritten.\n   */\n  setOther(connectionId, presence) {\n    this.#internal.mutate((state) => {\n      state.presences.set(connectionId, freeze(compactObject(presence)));\n      if (!state.connections.has(connectionId)) {\n        return false;\n      }\n      return this.#invalidateUser(connectionId);\n    });\n  }\n  /**\n   * Patches the presence data for an existing \"other\". If we don't know the\n   * initial presence data for this user yet, discard this patch and await the\n   * full .setOther() call first.\n   */\n  patchOther(connectionId, patch) {\n    this.#internal.mutate((state) => {\n      const oldPresence = state.presences.get(connectionId);\n      if (oldPresence === void 0) {\n        return false;\n      }\n      const newPresence = merge(oldPresence, patch);\n      if (oldPresence === newPresence) {\n        return false;\n      }\n      state.presences.set(connectionId, freeze(newPresence));\n      return this.#invalidateUser(connectionId);\n    });\n  }\n};\n\n// src/types/LiveblocksError.ts\nvar LiveblocksError = class _LiveblocksError extends Error {\n  context;\n  constructor(message, context, cause) {\n    super(message, { cause });\n    this.context = context;\n    this.name = \"LiveblocksError\";\n  }\n  /** Convenience accessor for error.context.roomId (if available) */\n  get roomId() {\n    return this.context.roomId;\n  }\n  /** @internal Use `context.code` instead, to enable type narrowing */\n  get code() {\n    return this.context.code;\n  }\n  /**\n   * Creates a LiveblocksError from a generic error, by attaching Liveblocks\n   * contextual information like room ID, thread ID, etc.\n   */\n  static from(context, cause) {\n    return new _LiveblocksError(\n      defaultMessageFromContext(context),\n      context,\n      cause\n    );\n  }\n};\nfunction defaultMessageFromContext(context) {\n  switch (context.type) {\n    case \"ROOM_CONNECTION_ERROR\": {\n      switch (context.code) {\n        case 4001:\n          return \"Not allowed to connect to the room\";\n        case 4005:\n          return \"Room is already full\";\n        case 4006:\n          return \"Kicked out of the room, because the room ID changed\";\n        default:\n          return \"Could not connect to the room\";\n      }\n    }\n    case \"AI_CONNECTION_ERROR\": {\n      switch (context.code) {\n        case 4001:\n          return \"Not allowed to connect to ai\";\n        default:\n          return \"Could not connect to the room\";\n      }\n    }\n    case \"CREATE_THREAD_ERROR\":\n      return \"Could not create new thread\";\n    case \"DELETE_THREAD_ERROR\":\n      return \"Could not delete thread\";\n    case \"EDIT_THREAD_METADATA_ERROR\":\n      return \"Could not edit thread metadata\";\n    case \"EDIT_COMMENT_METADATA_ERROR\":\n      return \"Could not edit comment metadata\";\n    case \"MARK_THREAD_AS_RESOLVED_ERROR\":\n      return \"Could not mark thread as resolved\";\n    case \"MARK_THREAD_AS_UNRESOLVED_ERROR\":\n      return \"Could not mark thread as unresolved\";\n    case \"SUBSCRIBE_TO_THREAD_ERROR\":\n      return \"Could not subscribe to thread\";\n    case \"UNSUBSCRIBE_FROM_THREAD_ERROR\":\n      return \"Could not unsubscribe from thread\";\n    case \"CREATE_COMMENT_ERROR\":\n      return \"Could not create new comment\";\n    case \"EDIT_COMMENT_ERROR\":\n      return \"Could not edit comment\";\n    case \"DELETE_COMMENT_ERROR\":\n      return \"Could not delete comment\";\n    case \"ADD_REACTION_ERROR\":\n      return \"Could not add reaction\";\n    case \"REMOVE_REACTION_ERROR\":\n      return \"Could not remove reaction\";\n    case \"MARK_INBOX_NOTIFICATION_AS_READ_ERROR\":\n      return \"Could not mark inbox notification as read\";\n    case \"DELETE_INBOX_NOTIFICATION_ERROR\":\n      return \"Could not delete inbox notification\";\n    case \"MARK_ALL_INBOX_NOTIFICATIONS_AS_READ_ERROR\":\n      return \"Could not mark all inbox notifications as read\";\n    case \"DELETE_ALL_INBOX_NOTIFICATIONS_ERROR\":\n      return \"Could not delete all inbox notifications\";\n    case \"UPDATE_ROOM_SUBSCRIPTION_SETTINGS_ERROR\":\n      return \"Could not update room subscription settings\";\n    case \"UPDATE_NOTIFICATION_SETTINGS_ERROR\":\n      return \"Could not update notification settings\";\n    case \"LARGE_MESSAGE_ERROR\":\n      return \"Could not send large message\";\n    default:\n      return assertNever(context, \"Unhandled case\");\n  }\n}\n\n// src/room.ts\nfunction makeIdFactory(connectionId) {\n  let count = 0;\n  return () => `${connectionId}:${count++}`;\n}\nfunction userToTreeNode(key, user) {\n  return {\n    type: \"User\",\n    id: `${user.connectionId}`,\n    key,\n    payload: {\n      connectionId: user.connectionId,\n      id: user.id,\n      info: user.info,\n      presence: user.presence,\n      isReadOnly: !user.canWrite\n    }\n  };\n}\nfunction installBackgroundTabSpy() {\n  const doc = typeof document !== \"undefined\" ? document : void 0;\n  const inBackgroundSince = { current: null };\n  function onVisibilityChange() {\n    if (doc?.visibilityState === \"hidden\") {\n      inBackgroundSince.current = inBackgroundSince.current ?? Date.now();\n    } else {\n      inBackgroundSince.current = null;\n    }\n  }\n  doc?.addEventListener(\"visibilitychange\", onVisibilityChange);\n  const unsub = () => {\n    doc?.removeEventListener(\"visibilitychange\", onVisibilityChange);\n  };\n  return [inBackgroundSince, unsub];\n}\nfunction makeNodeMapBuffer() {\n  let map = /* @__PURE__ */ new Map();\n  return {\n    /** Append a \"page\" of nodes to the current NodeMap buffer. */\n    append(chunk2) {\n      for (const [id, node] of chunk2) {\n        map.set(id, node);\n      }\n    },\n    /** Return the contents of the current NodeMap buffer, and create a fresh new one. */\n    take() {\n      const result = map;\n      map = /* @__PURE__ */ new Map();\n      return result;\n    }\n  };\n}\nfunction createRoom(options, config) {\n  const roomId = config.roomId;\n  const initialPresence = options.initialPresence;\n  const initialStorage = options.initialStorage;\n  const httpClient = config.roomHttpClient;\n  const [inBackgroundSince, uninstallBgTabSpy] = installBackgroundTabSpy();\n  const delegates = {\n    ...config.delegates,\n    // A connection is allowed to go into \"zombie state\" only if all of the\n    // following conditions apply:\n    //\n    // - The `backgroundKeepAliveTimeout` client option is configured\n    // - The browser window has been in the background for at least\n    //   `backgroundKeepAliveTimeout` milliseconds\n    // - There are no pending changes\n    //\n    canZombie() {\n      return config.backgroundKeepAliveTimeout !== void 0 && inBackgroundSince.current !== null && Date.now() > inBackgroundSince.current + config.backgroundKeepAliveTimeout && getStorageStatus() !== \"synchronizing\";\n    }\n  };\n  const managedSocket = new ManagedSocket(\n    delegates,\n    config.enableDebugLogging\n  );\n  const context = {\n    buffer: {\n      flushTimerID: void 0,\n      lastFlushedAt: 0,\n      presenceUpdates: (\n        // Queue up the initial presence message as a Full Presence update\n        {\n          type: \"full\",\n          data: initialPresence\n        }\n      ),\n      messages: [],\n      storageOperations: []\n    },\n    staticSessionInfoSig: new Signal(null),\n    dynamicSessionInfoSig: new Signal(null),\n    myPresence: new PatchableSignal(initialPresence),\n    others: new ManagedOthers(),\n    initialStorage,\n    idFactory: null,\n    // The Yjs provider associated to this room\n    yjsProvider: void 0,\n    yjsProviderDidChange: makeEventSource(),\n    // Storage\n    pool: createManagedPool(roomId, {\n      getCurrentConnectionId,\n      onDispatch,\n      isStorageWritable\n    }),\n    root: void 0,\n    undoStack: [],\n    redoStack: [],\n    pausedHistory: null,\n    activeBatch: null,\n    unacknowledgedOps: /* @__PURE__ */ new Map()\n  };\n  const nodeMapBuffer = makeNodeMapBuffer();\n  const stopwatch = config.enableDebugLogging ? makeStopWatch() : void 0;\n  let lastTokenKey;\n  function onStatusDidChange(newStatus) {\n    const authValue = managedSocket.authValue;\n    if (authValue !== null) {\n      const tokenKey = getBearerTokenFromAuthValue(authValue);\n      if (tokenKey !== lastTokenKey) {\n        lastTokenKey = tokenKey;\n        if (authValue.type === \"secret\") {\n          const token = authValue.token.parsed;\n          context.staticSessionInfoSig.set({\n            userId: token.uid,\n            userInfo: token.ui\n          });\n        } else {\n          context.staticSessionInfoSig.set({\n            userId: void 0,\n            userInfo: void 0\n          });\n        }\n      }\n    }\n    eventHub.status.notify(newStatus);\n    notifySelfChanged();\n  }\n  let _connectionLossTimerId;\n  let _hasLostConnection = false;\n  function handleConnectionLossEvent(newStatus) {\n    if (newStatus === \"reconnecting\") {\n      _connectionLossTimerId = setTimeout(() => {\n        eventHub.lostConnection.notify(\"lost\");\n        _hasLostConnection = true;\n        context.others.clearOthers();\n        notify({ others: [{ type: \"reset\" }] });\n      }, config.lostConnectionTimeout);\n    } else {\n      clearTimeout(_connectionLossTimerId);\n      if (_hasLostConnection) {\n        if (newStatus === \"disconnected\") {\n          eventHub.lostConnection.notify(\"failed\");\n        } else {\n          eventHub.lostConnection.notify(\"restored\");\n        }\n        _hasLostConnection = false;\n      }\n    }\n  }\n  function onDidConnect() {\n    context.buffer.presenceUpdates = {\n      type: \"full\",\n      data: (\n        // Because context.me.current is a readonly object, we'll have to\n        // make a copy here. Otherwise, type errors happen later when\n        // \"patching\" my presence.\n        { ...context.myPresence.get() }\n      )\n    };\n    if (_getStorage$ !== null) {\n      refreshStorage({ flush: false });\n    }\n    flushNowOrSoon();\n  }\n  function onDidDisconnect() {\n    clearTimeout(context.buffer.flushTimerID);\n  }\n  managedSocket.events.onMessage.subscribe(handleServerMessage);\n  managedSocket.events.statusDidChange.subscribe(onStatusDidChange);\n  managedSocket.events.statusDidChange.subscribe(handleConnectionLossEvent);\n  managedSocket.events.didConnect.subscribe(onDidConnect);\n  managedSocket.events.didDisconnect.subscribe(onDidDisconnect);\n  managedSocket.events.onConnectionError.subscribe(({ message, code }) => {\n    const type = \"ROOM_CONNECTION_ERROR\";\n    const err = new LiveblocksError(message, { type, code, roomId });\n    const didNotify = config.errorEventSource.notify(err);\n    if (!didNotify) {\n      if (process.env.NODE_ENV !== \"production\") {\n        error2(\n          `Connection to websocket server closed. Reason: ${message} (code: ${code}).`\n        );\n      }\n    }\n  });\n  function onDispatch(ops, reverse, storageUpdates) {\n    if (context.activeBatch) {\n      for (const op of ops) {\n        context.activeBatch.ops.push(op);\n      }\n      for (const [key, value] of storageUpdates) {\n        context.activeBatch.updates.storageUpdates.set(\n          key,\n          mergeStorageUpdates(\n            context.activeBatch.updates.storageUpdates.get(key),\n            value\n          )\n        );\n      }\n      context.activeBatch.reverseOps.pushLeft(reverse);\n    } else {\n      addToUndoStack(reverse);\n      context.redoStack.length = 0;\n      dispatchOps(ops);\n      notify({ storageUpdates });\n    }\n  }\n  function isStorageWritable() {\n    const scopes = context.dynamicSessionInfoSig.get()?.scopes;\n    return scopes !== void 0 ? canWriteStorage(scopes) : true;\n  }\n  const eventHub = {\n    status: makeEventSource(),\n    // New/recommended API\n    lostConnection: makeEventSource(),\n    customEvent: makeEventSource(),\n    self: makeEventSource(),\n    myPresence: makeEventSource(),\n    others: makeEventSource(),\n    storageBatch: makeEventSource(),\n    history: makeEventSource(),\n    storageDidLoad: makeEventSource(),\n    storageStatus: makeEventSource(),\n    ydoc: makeEventSource(),\n    comments: makeEventSource(),\n    roomWillDestroy: makeEventSource()\n  };\n  async function createTextMention(mentionId, mention) {\n    return httpClient.createTextMention({ roomId, mentionId, mention });\n  }\n  async function deleteTextMention(mentionId) {\n    return httpClient.deleteTextMention({ roomId, mentionId });\n  }\n  async function reportTextEditor(type, rootKey) {\n    await httpClient.reportTextEditor({ roomId, type, rootKey });\n  }\n  async function listTextVersions() {\n    return httpClient.listTextVersions({ roomId });\n  }\n  async function listTextVersionsSince(options2) {\n    return httpClient.listTextVersionsSince({\n      roomId,\n      since: options2.since,\n      signal: options2.signal\n    });\n  }\n  async function getTextVersion(versionId) {\n    return httpClient.getTextVersion({ roomId, versionId });\n  }\n  async function createTextVersion() {\n    return httpClient.createTextVersion({ roomId });\n  }\n  async function executeContextualPrompt(options2) {\n    return httpClient.executeContextualPrompt({\n      roomId,\n      ...options2\n    });\n  }\n  function sendMessages(messages) {\n    managedSocket.send(stringifyOrLog(messages));\n  }\n  const self = DerivedSignal.from(\n    context.staticSessionInfoSig,\n    context.dynamicSessionInfoSig,\n    context.myPresence,\n    (staticSession, dynamicSession, myPresence) => {\n      if (staticSession === null || dynamicSession === null) {\n        return null;\n      } else {\n        const canWrite = canWriteStorage(dynamicSession.scopes);\n        return {\n          connectionId: dynamicSession.actor,\n          id: staticSession.userId,\n          info: staticSession.userInfo,\n          presence: myPresence,\n          canWrite,\n          canComment: canComment(dynamicSession.scopes)\n        };\n      }\n    }\n  );\n  let _lastSelf;\n  function notifySelfChanged() {\n    const currSelf = self.get();\n    if (currSelf !== null && currSelf !== _lastSelf) {\n      eventHub.self.notify(currSelf);\n      _lastSelf = currSelf;\n    }\n  }\n  const selfAsTreeNode = DerivedSignal.from(\n    self,\n    (me) => me !== null ? userToTreeNode(\"Me\", me) : null\n  );\n  function createOrUpdateRootFromMessage(nodes) {\n    if (nodes.size === 0) {\n      throw new Error(\"Internal error: cannot load storage without items\");\n    }\n    if (context.root !== void 0) {\n      const currentItems = /* @__PURE__ */ new Map();\n      for (const [id, crdt] of context.pool.nodes) {\n        currentItems.set(id, crdt._serialize());\n      }\n      const ops = getTreesDiffOperations(currentItems, nodes);\n      const result = applyRemoteOps(ops);\n      notify(result.updates);\n    } else {\n      context.root = LiveObject._fromItems(\n        nodes,\n        context.pool\n      );\n    }\n    const canWrite = self.get()?.canWrite ?? true;\n    const stackSizeBefore = context.undoStack.length;\n    for (const key in context.initialStorage) {\n      if (context.root.get(key) === void 0) {\n        if (canWrite) {\n          context.root.set(key, cloneLson(context.initialStorage[key]));\n        } else {\n          warn(\n            `Attempted to populate missing storage key '${key}', but current user has no write access`\n          );\n        }\n      }\n    }\n    context.undoStack.length = stackSizeBefore;\n  }\n  function _addToRealUndoStack(frames) {\n    if (context.undoStack.length >= 50) {\n      context.undoStack.shift();\n    }\n    context.undoStack.push(frames);\n    onHistoryChange();\n  }\n  function addToUndoStack(frames) {\n    if (context.pausedHistory !== null) {\n      context.pausedHistory.pushLeft(frames);\n    } else {\n      _addToRealUndoStack(frames);\n    }\n  }\n  function notify(updates) {\n    const storageUpdates = updates.storageUpdates;\n    const othersUpdates = updates.others;\n    if (othersUpdates !== void 0 && othersUpdates.length > 0) {\n      const others = context.others.get();\n      for (const event of othersUpdates) {\n        eventHub.others.notify({ ...event, others });\n      }\n    }\n    if (updates.presence ?? false) {\n      notifySelfChanged();\n      eventHub.myPresence.notify(context.myPresence.get());\n    }\n    if (storageUpdates !== void 0 && storageUpdates.size > 0) {\n      const updates2 = Array.from(storageUpdates.values());\n      eventHub.storageBatch.notify(updates2);\n    }\n    notifyStorageStatus();\n  }\n  function getCurrentConnectionId() {\n    const info = context.dynamicSessionInfoSig.get();\n    if (info) {\n      return info.actor;\n    }\n    throw new Error(\n      \"Internal. Tried to get connection id but connection was never open\"\n    );\n  }\n  function applyLocalOps(frames) {\n    const [pframes, ops] = partition(\n      frames,\n      (f) => f.type === \"presence\"\n    );\n    const opsWithOpIds = ops.map(\n      (op) => op.opId === void 0 ? { ...op, opId: context.pool.generateOpId() } : op\n    );\n    const { reverse, updates } = applyOps(\n      pframes,\n      opsWithOpIds,\n      /* isLocal */\n      true\n    );\n    return { opsToEmit: opsWithOpIds, reverse, updates };\n  }\n  function applyRemoteOps(ops) {\n    return applyOps(\n      [],\n      ops,\n      /* isLocal */\n      false\n    );\n  }\n  function applyOps(pframes, ops, isLocal) {\n    const output = {\n      reverse: new Deque(),\n      storageUpdates: /* @__PURE__ */ new Map(),\n      presence: false\n    };\n    for (const pf of pframes) {\n      const reverse = {\n        type: \"presence\",\n        data: {}\n      };\n      for (const key in pf.data) {\n        reverse.data[key] = context.myPresence.get()[key];\n      }\n      context.myPresence.patch(pf.data);\n      if (context.buffer.presenceUpdates === null) {\n        context.buffer.presenceUpdates = { type: \"partial\", data: pf.data };\n      } else {\n        for (const key in pf.data) {\n          context.buffer.presenceUpdates.data[key] = pf.data[key];\n        }\n      }\n      output.reverse.pushLeft(reverse);\n      output.presence = true;\n    }\n    const createdNodeIds = /* @__PURE__ */ new Set();\n    for (const op of ops) {\n      let source;\n      if (isLocal) {\n        source = 0 /* LOCAL */;\n      } else if (op.opId !== void 0) {\n        context.unacknowledgedOps.delete(op.opId);\n        source = 2 /* OURS */;\n      } else {\n        source = 1 /* THEIRS */;\n      }\n      const applyOpResult = applyOp(op, source);\n      if (applyOpResult.modified) {\n        const nodeId = applyOpResult.modified.node._id;\n        if (!(nodeId && createdNodeIds.has(nodeId))) {\n          output.storageUpdates.set(\n            nn(applyOpResult.modified.node._id),\n            mergeStorageUpdates(\n              output.storageUpdates.get(nn(applyOpResult.modified.node._id)),\n              applyOpResult.modified\n            )\n          );\n          output.reverse.pushLeft(applyOpResult.reverse);\n        }\n        if (op.type === OpCode.CREATE_LIST || op.type === OpCode.CREATE_MAP || op.type === OpCode.CREATE_OBJECT) {\n          createdNodeIds.add(op.id);\n        }\n      }\n    }\n    return {\n      reverse: Array.from(output.reverse),\n      updates: {\n        storageUpdates: output.storageUpdates,\n        presence: output.presence\n      }\n    };\n  }\n  function applyOp(op, source) {\n    if (isIgnoredOp(op)) {\n      return { modified: false };\n    }\n    switch (op.type) {\n      case OpCode.DELETE_OBJECT_KEY:\n      case OpCode.UPDATE_OBJECT:\n      case OpCode.DELETE_CRDT: {\n        const node = context.pool.nodes.get(op.id);\n        if (node === void 0) {\n          return { modified: false };\n        }\n        return node._apply(op, source === 0 /* LOCAL */);\n      }\n      case OpCode.SET_PARENT_KEY: {\n        const node = context.pool.nodes.get(op.id);\n        if (node === void 0) {\n          return { modified: false };\n        }\n        if (node.parent.type === \"HasParent\" && isLiveList(node.parent.node)) {\n          return node.parent.node._setChildKey(\n            asPos(op.parentKey),\n            node,\n            source\n          );\n        }\n        return { modified: false };\n      }\n      case OpCode.CREATE_OBJECT:\n      case OpCode.CREATE_LIST:\n      case OpCode.CREATE_MAP:\n      case OpCode.CREATE_REGISTER: {\n        if (op.parentId === void 0) {\n          return { modified: false };\n        }\n        const parentNode = context.pool.nodes.get(op.parentId);\n        if (parentNode === void 0) {\n          return { modified: false };\n        }\n        return parentNode._attachChild(op, source);\n      }\n    }\n  }\n  function updatePresence(patch, options2) {\n    const oldValues = {};\n    if (context.buffer.presenceUpdates === null) {\n      context.buffer.presenceUpdates = {\n        type: \"partial\",\n        data: {}\n      };\n    }\n    for (const key in patch) {\n      const overrideValue = patch[key];\n      if (overrideValue === void 0) {\n        continue;\n      }\n      context.buffer.presenceUpdates.data[key] = overrideValue;\n      oldValues[key] = context.myPresence.get()[key];\n    }\n    context.myPresence.patch(patch);\n    if (context.activeBatch) {\n      if (options2?.addToHistory) {\n        context.activeBatch.reverseOps.pushLeft({\n          type: \"presence\",\n          data: oldValues\n        });\n      }\n      context.activeBatch.updates.presence = true;\n    } else {\n      flushNowOrSoon();\n      if (options2?.addToHistory) {\n        addToUndoStack([{ type: \"presence\", data: oldValues }]);\n      }\n      notify({ presence: true });\n    }\n  }\n  function onUpdatePresenceMessage(message) {\n    if (message.targetActor !== void 0) {\n      const oldUser = context.others.getUser(message.actor);\n      context.others.setOther(message.actor, message.data);\n      const newUser = context.others.getUser(message.actor);\n      if (oldUser === void 0 && newUser !== void 0) {\n        return { type: \"enter\", user: newUser };\n      }\n    } else {\n      context.others.patchOther(message.actor, message.data), message;\n    }\n    const user = context.others.getUser(message.actor);\n    if (user) {\n      return {\n        type: \"update\",\n        updates: message.data,\n        user\n      };\n    } else {\n      return void 0;\n    }\n  }\n  function onUserLeftMessage(message) {\n    const user = context.others.getUser(message.actor);\n    if (user) {\n      context.others.removeConnection(message.actor);\n      return { type: \"leave\", user };\n    }\n    return null;\n  }\n  function onRoomStateMessage(message) {\n    context.dynamicSessionInfoSig.set({\n      actor: message.actor,\n      nonce: message.nonce,\n      scopes: message.scopes,\n      meta: message.meta\n    });\n    context.idFactory = makeIdFactory(message.actor);\n    notifySelfChanged();\n    if (message.meta.showBrand === true) {\n      injectBrandBadge(config.badgeLocation ?? \"bottom-right\");\n    }\n    for (const connectionId of context.others.connectionIds()) {\n      const user = message.users[connectionId];\n      if (user === void 0) {\n        context.others.removeConnection(connectionId);\n      }\n    }\n    for (const key in message.users) {\n      const user = message.users[key];\n      const connectionId = Number(key);\n      context.others.setConnection(\n        connectionId,\n        user.id,\n        user.info,\n        user.scopes\n      );\n    }\n    return { type: \"reset\" };\n  }\n  function canUndo() {\n    return context.undoStack.length > 0;\n  }\n  function canRedo() {\n    return context.redoStack.length > 0;\n  }\n  function onHistoryChange() {\n    eventHub.history.notify({ canUndo: canUndo(), canRedo: canRedo() });\n  }\n  function onUserJoinedMessage(message) {\n    context.others.setConnection(\n      message.actor,\n      message.id,\n      message.info,\n      message.scopes\n    );\n    context.buffer.messages.push({\n      type: ClientMsgCode.UPDATE_PRESENCE,\n      data: context.myPresence.get(),\n      targetActor: message.actor\n    });\n    flushNowOrSoon();\n    const user = context.others.getUser(message.actor);\n    return user ? { type: \"enter\", user } : void 0;\n  }\n  function parseServerMessage(data) {\n    if (!isJsonObject(data)) {\n      return null;\n    }\n    return data;\n  }\n  function parseServerMessages(text) {\n    const data = tryParseJson(text);\n    if (data === void 0) {\n      return null;\n    } else if (isJsonArray(data)) {\n      return compact(data.map((item) => parseServerMessage(item)));\n    } else {\n      return compact([parseServerMessage(data)]);\n    }\n  }\n  function applyAndSendOfflineOps(unackedOps) {\n    if (unackedOps.size === 0) {\n      return;\n    }\n    const messages = [];\n    const inOps = Array.from(unackedOps.values());\n    const result = applyLocalOps(inOps);\n    messages.push({\n      type: ClientMsgCode.UPDATE_STORAGE,\n      ops: result.opsToEmit\n    });\n    notify(result.updates);\n    sendMessages(messages);\n  }\n  function handleServerMessage(event) {\n    if (typeof event.data !== \"string\") {\n      return;\n    }\n    const messages = parseServerMessages(event.data);\n    if (messages === null || messages.length === 0) {\n      return;\n    }\n    const updates = {\n      storageUpdates: /* @__PURE__ */ new Map(),\n      others: []\n    };\n    for (const message of messages) {\n      switch (message.type) {\n        case ServerMsgCode.USER_JOINED: {\n          const userJoinedUpdate = onUserJoinedMessage(message);\n          if (userJoinedUpdate) {\n            updates.others.push(userJoinedUpdate);\n          }\n          break;\n        }\n        case ServerMsgCode.UPDATE_PRESENCE: {\n          const othersPresenceUpdate = onUpdatePresenceMessage(message);\n          if (othersPresenceUpdate) {\n            updates.others.push(othersPresenceUpdate);\n          }\n          break;\n        }\n        case ServerMsgCode.BROADCASTED_EVENT: {\n          const others = context.others.get();\n          eventHub.customEvent.notify({\n            connectionId: message.actor,\n            user: message.actor < 0 ? null : others.find((u) => u.connectionId === message.actor) ?? null,\n            event: message.event\n          });\n          break;\n        }\n        case ServerMsgCode.USER_LEFT: {\n          const event2 = onUserLeftMessage(message);\n          if (event2) {\n            updates.others.push(event2);\n          }\n          break;\n        }\n        case ServerMsgCode.UPDATE_YDOC: {\n          eventHub.ydoc.notify(message);\n          break;\n        }\n        case ServerMsgCode.ROOM_STATE: {\n          updates.others.push(onRoomStateMessage(message));\n          break;\n        }\n        case ServerMsgCode.STORAGE_CHUNK:\n          stopwatch?.lap();\n          nodeMapBuffer.append(compactNodesToNodeStream(message.nodes));\n          break;\n        case ServerMsgCode.STORAGE_STREAM_END: {\n          const timing = stopwatch?.stop();\n          if (timing) {\n            const ms = (v) => `${v.toFixed(1)}ms`;\n            const rest = timing.laps.slice(1);\n            warn(\n              `Storage chunk arrival: ${[\n                `total=${ms(timing.total)}`,\n                `first=${ms(timing.laps[0])}`,\n                `rest.n=${rest.length}`,\n                `rest.avg=${ms(rest.reduce((a, b) => a + b, 0) / rest.length)}`,\n                `rest.max=${ms(rest.reduce((a, b) => Math.max(a, b), 0))}`\n              ].join(\", \")}`\n            );\n          }\n          processInitialStorage(nodeMapBuffer.take());\n          break;\n        }\n        case ServerMsgCode.UPDATE_STORAGE: {\n          const applyResult = applyRemoteOps(message.ops);\n          for (const [key, value] of applyResult.updates.storageUpdates) {\n            updates.storageUpdates.set(\n              key,\n              mergeStorageUpdates(updates.storageUpdates.get(key), value)\n            );\n          }\n          break;\n        }\n        // Receiving a RejectedOps message in the client means that the server is no\n        // longer in sync with the client. Trying to synchronize the client again by\n        // rolling back particular Ops may be hard/impossible. It's fine to not try and\n        // accept the out-of-sync reality and throw an error.\n        case ServerMsgCode.REJECT_STORAGE_OP: {\n          errorWithTitle(\n            \"Storage mutation rejection error\",\n            message.reason\n          );\n          if (process.env.NODE_ENV !== \"production\") {\n            throw new Error(\n              `Storage mutations rejected by server: ${message.reason}`\n            );\n          }\n          break;\n        }\n        case ServerMsgCode.THREAD_CREATED:\n        case ServerMsgCode.THREAD_DELETED:\n        case ServerMsgCode.THREAD_METADATA_UPDATED:\n        case ServerMsgCode.THREAD_UPDATED:\n        case ServerMsgCode.COMMENT_REACTION_ADDED:\n        case ServerMsgCode.COMMENT_REACTION_REMOVED:\n        case ServerMsgCode.COMMENT_CREATED:\n        case ServerMsgCode.COMMENT_EDITED:\n        case ServerMsgCode.COMMENT_DELETED:\n        case ServerMsgCode.COMMENT_METADATA_UPDATED: {\n          eventHub.comments.notify(message);\n          break;\n        }\n        case ServerMsgCode.STORAGE_STATE_V7:\n        // No longer used in V8\n        default:\n          break;\n      }\n    }\n    notify(updates);\n  }\n  function flushNowOrSoon() {\n    const storageOps = context.buffer.storageOperations;\n    if (storageOps.length > 0) {\n      for (const op of storageOps) {\n        context.unacknowledgedOps.set(op.opId, op);\n      }\n      notifyStorageStatus();\n    }\n    if (managedSocket.getStatus() !== \"connected\") {\n      context.buffer.storageOperations = [];\n      return;\n    }\n    const now2 = Date.now();\n    const elapsedMillis = now2 - context.buffer.lastFlushedAt;\n    if (elapsedMillis >= config.throttleDelay) {\n      const messagesToFlush = serializeBuffer();\n      if (messagesToFlush.length === 0) {\n        return;\n      }\n      sendMessages(messagesToFlush);\n      context.buffer = {\n        flushTimerID: void 0,\n        lastFlushedAt: now2,\n        messages: [],\n        storageOperations: [],\n        presenceUpdates: null\n      };\n    } else {\n      clearTimeout(context.buffer.flushTimerID);\n      context.buffer.flushTimerID = setTimeout(\n        flushNowOrSoon,\n        config.throttleDelay - elapsedMillis\n      );\n    }\n  }\n  function serializeBuffer() {\n    const messages = [];\n    if (context.buffer.presenceUpdates) {\n      messages.push(\n        context.buffer.presenceUpdates.type === \"full\" ? {\n          type: ClientMsgCode.UPDATE_PRESENCE,\n          // Populating the `targetActor` field turns this message into\n          // a Full Presence update message (not a patch), which will get\n          // interpreted by other clients as such.\n          targetActor: -1,\n          data: context.buffer.presenceUpdates.data\n        } : {\n          type: ClientMsgCode.UPDATE_PRESENCE,\n          data: context.buffer.presenceUpdates.data\n        }\n      );\n    }\n    for (const event of context.buffer.messages) {\n      messages.push(event);\n    }\n    if (context.buffer.storageOperations.length > 0) {\n      messages.push({\n        type: ClientMsgCode.UPDATE_STORAGE,\n        ops: context.buffer.storageOperations\n      });\n    }\n    return messages;\n  }\n  function updateYDoc(update, guid, isV2) {\n    const clientMsg = {\n      type: ClientMsgCode.UPDATE_YDOC,\n      update,\n      guid,\n      v2: isV2\n    };\n    context.buffer.messages.push(clientMsg);\n    eventHub.ydoc.notify(clientMsg);\n    flushNowOrSoon();\n  }\n  function broadcastEvent(event, options2 = {\n    shouldQueueEventIfNotReady: false\n  }) {\n    if (managedSocket.getStatus() !== \"connected\" && !options2.shouldQueueEventIfNotReady) {\n      return;\n    }\n    context.buffer.messages.push({\n      type: ClientMsgCode.BROADCAST_EVENT,\n      event\n    });\n    flushNowOrSoon();\n  }\n  function dispatchOps(ops) {\n    const { storageOperations } = context.buffer;\n    for (const op of ops) {\n      storageOperations.push(op);\n    }\n    flushNowOrSoon();\n  }\n  let _getStorage$ = null;\n  let _resolveStoragePromise = null;\n  function processInitialStorage(nodes) {\n    const unacknowledgedOps = new Map(context.unacknowledgedOps);\n    createOrUpdateRootFromMessage(nodes);\n    applyAndSendOfflineOps(unacknowledgedOps);\n    _resolveStoragePromise?.();\n    notifyStorageStatus();\n    eventHub.storageDidLoad.notify();\n  }\n  async function streamStorage() {\n    if (!managedSocket.authValue) return;\n    const nodes = new Map(\n      await httpClient.streamStorage({ roomId })\n    );\n    processInitialStorage(nodes);\n  }\n  function refreshStorage(options2) {\n    const messages = context.buffer.messages;\n    if (config.unstable_streamData) {\n      void streamStorage();\n    } else if (!messages.some((msg) => msg.type === ClientMsgCode.FETCH_STORAGE)) {\n      messages.push({ type: ClientMsgCode.FETCH_STORAGE });\n      nodeMapBuffer.take();\n      stopwatch?.start();\n    }\n    if (options2.flush) {\n      flushNowOrSoon();\n    }\n  }\n  function startLoadingStorage() {\n    if (_getStorage$ === null) {\n      refreshStorage({ flush: true });\n      _getStorage$ = new Promise((resolve) => {\n        _resolveStoragePromise = resolve;\n      });\n      notifyStorageStatus();\n    }\n    return _getStorage$;\n  }\n  function getStorageSnapshot() {\n    const root = context.root;\n    if (root !== void 0) {\n      return root;\n    } else {\n      void startLoadingStorage();\n      return null;\n    }\n  }\n  async function getStorage() {\n    if (context.root !== void 0) {\n      return Promise.resolve({\n        root: context.root\n      });\n    }\n    await startLoadingStorage();\n    return {\n      root: nn(context.root)\n    };\n  }\n  function fetchYDoc(vector, guid, isV2) {\n    if (!context.buffer.messages.find((m) => {\n      return m.type === ClientMsgCode.FETCH_YDOC && m.vector === vector && m.guid === guid && m.v2 === isV2;\n    })) {\n      context.buffer.messages.push({\n        type: ClientMsgCode.FETCH_YDOC,\n        vector,\n        guid,\n        v2: isV2\n      });\n    }\n    flushNowOrSoon();\n  }\n  function undo() {\n    if (context.activeBatch) {\n      throw new Error(\"undo is not allowed during a batch\");\n    }\n    const frames = context.undoStack.pop();\n    if (frames === void 0) {\n      return;\n    }\n    context.pausedHistory = null;\n    const result = applyLocalOps(frames);\n    notify(result.updates);\n    context.redoStack.push(result.reverse);\n    onHistoryChange();\n    for (const op of result.opsToEmit) {\n      context.buffer.storageOperations.push(op);\n    }\n    flushNowOrSoon();\n  }\n  function redo() {\n    if (context.activeBatch) {\n      throw new Error(\"redo is not allowed during a batch\");\n    }\n    const frames = context.redoStack.pop();\n    if (frames === void 0) {\n      return;\n    }\n    context.pausedHistory = null;\n    const result = applyLocalOps(frames);\n    notify(result.updates);\n    context.undoStack.push(result.reverse);\n    onHistoryChange();\n    for (const op of result.opsToEmit) {\n      context.buffer.storageOperations.push(op);\n    }\n    flushNowOrSoon();\n  }\n  function clear() {\n    context.undoStack.length = 0;\n    context.redoStack.length = 0;\n  }\n  function batch2(callback) {\n    if (context.activeBatch) {\n      return callback();\n    }\n    let returnValue = void 0;\n    context.activeBatch = {\n      ops: [],\n      updates: {\n        storageUpdates: /* @__PURE__ */ new Map(),\n        presence: false,\n        others: []\n      },\n      reverseOps: new Deque()\n    };\n    try {\n      returnValue = callback();\n    } finally {\n      const currentBatch = context.activeBatch;\n      context.activeBatch = null;\n      if (currentBatch.reverseOps.length > 0) {\n        addToUndoStack(Array.from(currentBatch.reverseOps));\n      }\n      if (currentBatch.ops.length > 0) {\n        context.redoStack.length = 0;\n      }\n      if (currentBatch.ops.length > 0) {\n        dispatchOps(currentBatch.ops);\n      }\n      notify(currentBatch.updates);\n      flushNowOrSoon();\n    }\n    return returnValue;\n  }\n  function pauseHistory() {\n    if (context.pausedHistory === null) {\n      context.pausedHistory = new Deque();\n    }\n  }\n  function resumeHistory() {\n    const frames = context.pausedHistory;\n    context.pausedHistory = null;\n    if (frames !== null && frames.length > 0) {\n      _addToRealUndoStack(Array.from(frames));\n    }\n  }\n  const syncSourceForStorage = config.createSyncSource();\n  function getStorageStatus() {\n    if (context.root === void 0) {\n      return _getStorage$ === null ? \"not-loaded\" : \"loading\";\n    } else {\n      return context.unacknowledgedOps.size === 0 ? \"synchronized\" : \"synchronizing\";\n    }\n  }\n  let _lastStorageStatus = getStorageStatus();\n  function notifyStorageStatus() {\n    const storageStatus = getStorageStatus();\n    if (_lastStorageStatus !== storageStatus) {\n      _lastStorageStatus = storageStatus;\n      eventHub.storageStatus.notify(storageStatus);\n    }\n    syncSourceForStorage.setSyncStatus(\n      storageStatus === \"synchronizing\" ? \"synchronizing\" : \"synchronized\"\n    );\n  }\n  function isPresenceReady() {\n    return self.get() !== null;\n  }\n  async function waitUntilPresenceReady() {\n    while (!isPresenceReady()) {\n      const { promise, resolve } = Promise_withResolvers();\n      const unsub1 = events.self.subscribeOnce(resolve);\n      const unsub2 = events.status.subscribeOnce(resolve);\n      await promise;\n      unsub1();\n      unsub2();\n    }\n  }\n  function isStorageReady() {\n    return getStorageSnapshot() !== null;\n  }\n  async function waitUntilStorageReady() {\n    while (!isStorageReady()) {\n      await getStorage();\n    }\n  }\n  const others_forDevTools = DerivedSignal.from(\n    context.others.signal,\n    (others) => others.map((other, index) => userToTreeNode(`Other ${index}`, other))\n  );\n  const events = {\n    status: eventHub.status.observable,\n    lostConnection: eventHub.lostConnection.observable,\n    customEvent: eventHub.customEvent.observable,\n    others: eventHub.others.observable,\n    self: eventHub.self.observable,\n    myPresence: eventHub.myPresence.observable,\n    storageBatch: eventHub.storageBatch.observable,\n    history: eventHub.history.observable,\n    storageDidLoad: eventHub.storageDidLoad.observable,\n    storageStatus: eventHub.storageStatus.observable,\n    ydoc: eventHub.ydoc.observable,\n    comments: eventHub.comments.observable,\n    roomWillDestroy: eventHub.roomWillDestroy.observable\n  };\n  async function getThreadsSince(options2) {\n    return httpClient.getThreadsSince({\n      roomId,\n      since: options2.since,\n      signal: options2.signal\n    });\n  }\n  async function getThreads(options2) {\n    return httpClient.getThreads({\n      roomId,\n      query: options2?.query,\n      cursor: options2?.cursor\n    });\n  }\n  async function getThread(threadId) {\n    return httpClient.getThread({ roomId, threadId });\n  }\n  async function createThread(options2) {\n    return httpClient.createThread({\n      roomId,\n      threadId: options2.threadId,\n      commentId: options2.commentId,\n      metadata: options2.metadata,\n      body: options2.body,\n      commentMetadata: options2.commentMetadata,\n      attachmentIds: options2.attachmentIds\n    });\n  }\n  async function deleteThread(threadId) {\n    return httpClient.deleteThread({ roomId, threadId });\n  }\n  async function editThreadMetadata({\n    metadata,\n    threadId\n  }) {\n    return httpClient.editThreadMetadata({ roomId, threadId, metadata });\n  }\n  async function editCommentMetadata({\n    threadId,\n    commentId,\n    metadata\n  }) {\n    return httpClient.editCommentMetadata({\n      roomId,\n      threadId,\n      commentId,\n      metadata\n    });\n  }\n  async function markThreadAsResolved(threadId) {\n    return httpClient.markThreadAsResolved({ roomId, threadId });\n  }\n  async function markThreadAsUnresolved(threadId) {\n    return httpClient.markThreadAsUnresolved({\n      roomId,\n      threadId\n    });\n  }\n  async function subscribeToThread(threadId) {\n    return httpClient.subscribeToThread({ roomId, threadId });\n  }\n  async function unsubscribeFromThread(threadId) {\n    return httpClient.unsubscribeFromThread({ roomId, threadId });\n  }\n  async function createComment(options2) {\n    return httpClient.createComment({\n      roomId,\n      threadId: options2.threadId,\n      commentId: options2.commentId,\n      body: options2.body,\n      metadata: options2.metadata,\n      attachmentIds: options2.attachmentIds\n    });\n  }\n  async function editComment(options2) {\n    return httpClient.editComment({\n      roomId,\n      threadId: options2.threadId,\n      commentId: options2.commentId,\n      body: options2.body,\n      metadata: options2.metadata,\n      attachmentIds: options2.attachmentIds\n    });\n  }\n  async function deleteComment({\n    threadId,\n    commentId\n  }) {\n    return httpClient.deleteComment({ roomId, threadId, commentId });\n  }\n  async function addReaction({\n    threadId,\n    commentId,\n    emoji\n  }) {\n    return httpClient.addReaction({ roomId, threadId, commentId, emoji });\n  }\n  async function removeReaction({\n    threadId,\n    commentId,\n    emoji\n  }) {\n    return await httpClient.removeReaction({\n      roomId,\n      threadId,\n      commentId,\n      emoji\n    });\n  }\n  function prepareAttachment(file) {\n    return {\n      type: \"localAttachment\",\n      status: \"idle\",\n      id: createCommentAttachmentId(),\n      name: file.name,\n      size: file.size,\n      mimeType: file.type,\n      file\n    };\n  }\n  async function uploadAttachment(attachment, options2 = {}) {\n    return httpClient.uploadAttachment({\n      roomId,\n      attachment,\n      signal: options2.signal\n    });\n  }\n  function getAttachmentUrl(attachmentId) {\n    return httpClient.getAttachmentUrl({ roomId, attachmentId });\n  }\n  function getSubscriptionSettings(options2) {\n    return httpClient.getSubscriptionSettings({\n      roomId,\n      signal: options2?.signal\n    });\n  }\n  function updateSubscriptionSettings(settings) {\n    return httpClient.updateSubscriptionSettings({ roomId, settings });\n  }\n  async function markInboxNotificationAsRead(inboxNotificationId) {\n    await httpClient.markRoomInboxNotificationAsRead({\n      roomId,\n      inboxNotificationId\n    });\n  }\n  const syncSourceForYjs = config.createSyncSource();\n  function yjsStatusDidChange(status) {\n    return syncSourceForYjs.setSyncStatus(\n      status === \"synchronizing\" || status === \"loading\" ? \"synchronizing\" : \"synchronized\"\n    );\n  }\n  return Object.defineProperty(\n    {\n      [kInternal]: {\n        get presenceBuffer() {\n          return deepClone(context.buffer.presenceUpdates?.data ?? null);\n        },\n        // prettier-ignore\n        get undoStack() {\n          return deepClone(context.undoStack);\n        },\n        // prettier-ignore\n        get nodeCount() {\n          return context.pool.nodes.size;\n        },\n        // prettier-ignore\n        getYjsProvider() {\n          return context.yjsProvider;\n        },\n        setYjsProvider(newProvider) {\n          context.yjsProvider?.off(\"status\", yjsStatusDidChange);\n          context.yjsProvider = newProvider;\n          newProvider?.on(\"status\", yjsStatusDidChange);\n          context.yjsProviderDidChange.notify();\n        },\n        yjsProviderDidChange: context.yjsProviderDidChange.observable,\n        // send metadata when using a text editor\n        reportTextEditor,\n        // create a text mention when using a text editor\n        createTextMention,\n        // delete a text mention when using a text editor\n        deleteTextMention,\n        // list versions of the document\n        listTextVersions,\n        // List versions of the document since the specified date\n        listTextVersionsSince,\n        // get a specific version\n        getTextVersion,\n        // create a version\n        createTextVersion,\n        // execute a contextual prompt\n        executeContextualPrompt,\n        // Support for the Liveblocks browser extension\n        getSelf_forDevTools: () => selfAsTreeNode.get(),\n        getOthers_forDevTools: () => others_forDevTools.get(),\n        // prettier-ignore\n        simulate: {\n          // These exist only for our E2E testing app\n          explicitClose: (event) => managedSocket._privateSendMachineEvent({ type: \"EXPLICIT_SOCKET_CLOSE\", event }),\n          rawSend: (data) => managedSocket.send(data)\n        },\n        attachmentUrlsStore: httpClient.getOrCreateAttachmentUrlsStore(roomId)\n      },\n      id: roomId,\n      subscribe: makeClassicSubscribeFn(\n        roomId,\n        events,\n        config.errorEventSource\n      ),\n      connect: () => managedSocket.connect(),\n      reconnect: () => managedSocket.reconnect(),\n      disconnect: () => managedSocket.disconnect(),\n      destroy: () => {\n        const { roomWillDestroy, ...eventsExceptDestroy } = eventHub;\n        for (const source of Object.values(eventsExceptDestroy)) {\n          source.dispose();\n        }\n        eventHub.roomWillDestroy.notify();\n        context.yjsProvider?.off(\"status\", yjsStatusDidChange);\n        syncSourceForStorage.destroy();\n        syncSourceForYjs.destroy();\n        uninstallBgTabSpy();\n        managedSocket.destroy();\n        roomWillDestroy.dispose();\n      },\n      // Presence\n      updatePresence,\n      updateYDoc,\n      broadcastEvent,\n      // Storage\n      batch: batch2,\n      history: {\n        undo,\n        redo,\n        canUndo,\n        canRedo,\n        clear,\n        pause: pauseHistory,\n        resume: resumeHistory\n      },\n      fetchYDoc,\n      getStorage,\n      getStorageSnapshot,\n      getStorageStatus,\n      isPresenceReady,\n      isStorageReady,\n      waitUntilPresenceReady: memoizeOnSuccess(waitUntilPresenceReady),\n      waitUntilStorageReady: memoizeOnSuccess(waitUntilStorageReady),\n      events,\n      // Core\n      getStatus: () => managedSocket.getStatus(),\n      getSelf: () => self.get(),\n      // Presence\n      getPresence: () => context.myPresence.get(),\n      getOthers: () => context.others.get(),\n      // Comments\n      getThreads,\n      getThreadsSince,\n      getThread,\n      createThread,\n      deleteThread,\n      editThreadMetadata,\n      markThreadAsResolved,\n      markThreadAsUnresolved,\n      subscribeToThread,\n      unsubscribeFromThread,\n      createComment,\n      editComment,\n      editCommentMetadata,\n      deleteComment,\n      addReaction,\n      removeReaction,\n      prepareAttachment,\n      uploadAttachment,\n      getAttachmentUrl,\n      // Notifications\n      getNotificationSettings: getSubscriptionSettings,\n      getSubscriptionSettings,\n      updateNotificationSettings: updateSubscriptionSettings,\n      updateSubscriptionSettings,\n      markInboxNotificationAsRead\n    },\n    // Explictly make the internal field non-enumerable, to avoid aggressive\n    // freezing when used with Immer\n    kInternal,\n    { enumerable: false }\n  );\n}\nfunction makeClassicSubscribeFn(roomId, events, errorEvents) {\n  function subscribeToLiveStructureDeeply(node, callback) {\n    return events.storageBatch.subscribe((updates) => {\n      const relatedUpdates = updates.filter(\n        (update) => isSameNodeOrChildOf(update.node, node)\n      );\n      if (relatedUpdates.length > 0) {\n        callback(relatedUpdates);\n      }\n    });\n  }\n  function subscribeToLiveStructureShallowly(node, callback) {\n    return events.storageBatch.subscribe((updates) => {\n      for (const update of updates) {\n        if (update.node._id === node._id) {\n          callback(update.node);\n        }\n      }\n    });\n  }\n  function subscribe(first, second, options) {\n    if (typeof first === \"string\" && isRoomEventName(first)) {\n      if (typeof second !== \"function\") {\n        throw new Error(\"Second argument must be a callback function\");\n      }\n      const callback = second;\n      switch (first) {\n        case \"event\":\n          return events.customEvent.subscribe(\n            callback\n          );\n        case \"my-presence\":\n          return events.myPresence.subscribe(callback);\n        case \"others\": {\n          const cb = callback;\n          return events.others.subscribe((event) => {\n            const { others, ...internalEvent } = event;\n            return cb(others, internalEvent);\n          });\n        }\n        case \"error\": {\n          return errorEvents.subscribe((err) => {\n            if (err.roomId === roomId) {\n              return callback(err);\n            }\n          });\n        }\n        case \"status\":\n          return events.status.subscribe(callback);\n        case \"lost-connection\":\n          return events.lostConnection.subscribe(\n            callback\n          );\n        case \"history\":\n          return events.history.subscribe(callback);\n        case \"storage-status\":\n          return events.storageStatus.subscribe(\n            callback\n          );\n        case \"comments\":\n          return events.comments.subscribe(\n            callback\n          );\n        // istanbul ignore next\n        default:\n          return assertNever(\n            first,\n            `\"${String(first)}\" is not a valid event name`\n          );\n      }\n    }\n    if (second === void 0 || typeof first === \"function\") {\n      if (typeof first === \"function\") {\n        const storageCallback = first;\n        return events.storageBatch.subscribe(storageCallback);\n      } else {\n        throw new Error(\"Please specify a listener callback\");\n      }\n    }\n    if (isLiveNode(first)) {\n      const node = first;\n      if (options?.isDeep) {\n        const storageCallback = second;\n        return subscribeToLiveStructureDeeply(node, storageCallback);\n      } else {\n        const nodeCallback = second;\n        return subscribeToLiveStructureShallowly(node, nodeCallback);\n      }\n    }\n    throw new Error(\n      `${String(first)} is not a value that can be subscribed to.`\n    );\n  }\n  return subscribe;\n}\nfunction isRoomEventName(value) {\n  return value === \"my-presence\" || value === \"others\" || value === \"event\" || value === \"error\" || value === \"history\" || value === \"status\" || value === \"storage-status\" || value === \"lost-connection\" || value === \"connection\" || value === \"comments\";\n}\nfunction makeAuthDelegateForRoom(roomId, authManager) {\n  return async () => {\n    return authManager.getAuthValue({ requestedScope: \"room:read\", roomId });\n  };\n}\nfunction makeCreateSocketDelegateForRoom(roomId, baseUrl, WebSocketPolyfill, engine) {\n  return (authValue) => {\n    const ws = WebSocketPolyfill ?? (typeof WebSocket === \"undefined\" ? void 0 : WebSocket);\n    if (ws === void 0) {\n      throw new StopRetrying(\n        \"To use Liveblocks client in a non-DOM environment, you need to provide a WebSocket polyfill.\"\n      );\n    }\n    const url2 = new URL(baseUrl);\n    url2.protocol = url2.protocol === \"http:\" ? \"ws\" : \"wss\";\n    url2.pathname = \"/v8\";\n    url2.searchParams.set(\"roomId\", roomId);\n    if (authValue.type === \"secret\") {\n      url2.searchParams.set(\"tok\", authValue.token.raw);\n    } else if (authValue.type === \"public\") {\n      url2.searchParams.set(\"pubkey\", authValue.publicApiKey);\n    } else {\n      return assertNever(authValue, \"Unhandled case\");\n    }\n    url2.searchParams.set(\"version\", PKG_VERSION || \"dev\");\n    if (engine !== void 0) {\n      url2.searchParams.set(\"e\", String(engine));\n    }\n    return new ws(url2.toString());\n  };\n}\n\n// src/client.ts\nvar MIN_THROTTLE = 16;\nvar MAX_THROTTLE = 1e3;\nvar DEFAULT_THROTTLE = 100;\nvar MIN_BACKGROUND_KEEP_ALIVE_TIMEOUT = 15e3;\nvar MIN_LOST_CONNECTION_TIMEOUT = 200;\nvar RECOMMENDED_MIN_LOST_CONNECTION_TIMEOUT = 1e3;\nvar MAX_LOST_CONNECTION_TIMEOUT = 3e4;\nvar DEFAULT_LOST_CONNECTION_TIMEOUT = 5e3;\nvar RESOLVE_USERS_BATCH_DELAY = 50;\nvar RESOLVE_ROOMS_INFO_BATCH_DELAY = 50;\nvar RESOLVE_GROUPS_INFO_BATCH_DELAY = 50;\nfunction getBaseUrl(baseUrl) {\n  if (typeof baseUrl === \"string\" && baseUrl.startsWith(\"http\")) {\n    return baseUrl;\n  } else {\n    return DEFAULT_BASE_URL;\n  }\n}\nfunction createClient(options) {\n  const clientOptions = options;\n  const throttleDelay = process.env.NODE_ENV !== \"production\" && clientOptions.__DANGEROUSLY_disableThrottling ? 0 : getThrottle(clientOptions.throttle ?? DEFAULT_THROTTLE);\n  const lostConnectionTimeout = getLostConnectionTimeout(\n    clientOptions.lostConnectionTimeout ?? DEFAULT_LOST_CONNECTION_TIMEOUT\n  );\n  const backgroundKeepAliveTimeout = getBackgroundKeepAliveTimeout(\n    clientOptions.backgroundKeepAliveTimeout\n  );\n  const baseUrl = getBaseUrl(clientOptions.baseUrl);\n  const currentUserId = new Signal(void 0);\n  const authManager = createAuthManager(options, (token) => {\n    currentUserId.set(() => token.uid);\n  });\n  const fetchPolyfill = clientOptions.polyfills?.fetch || /* istanbul ignore next */\n  globalThis.fetch?.bind(globalThis);\n  const httpClient = createApiClient({\n    baseUrl,\n    fetchPolyfill,\n    currentUserId,\n    authManager\n  });\n  const roomsById = /* @__PURE__ */ new Map();\n  const ai = createAi({\n    userId: currentUserId.get(),\n    lostConnectionTimeout,\n    backgroundKeepAliveTimeout: getBackgroundKeepAliveTimeout(\n      clientOptions.backgroundKeepAliveTimeout\n    ),\n    polyfills: clientOptions.polyfills,\n    delegates: {\n      createSocket: makeCreateSocketDelegateForAi(\n        baseUrl,\n        clientOptions.polyfills?.WebSocket\n      ),\n      authenticate: async () => {\n        const resp = await authManager.getAuthValue({\n          requestedScope: \"room:read\"\n        });\n        if (resp.type === \"public\") {\n          throw new StopRetrying(\n            \"Cannot use AI Copilots with a public API key\"\n          );\n        }\n        return resp;\n      },\n      canZombie: () => false\n    }\n  });\n  function teardownRoom(room) {\n    unlinkDevTools(room.id);\n    roomsById.delete(room.id);\n    room.destroy();\n  }\n  function leaseRoom(details) {\n    const leave = () => {\n      const self = leave;\n      if (!details.unsubs.delete(self)) {\n        warn(\n          \"This leave function was already called. Calling it more than once has no effect.\"\n        );\n      } else {\n        if (details.unsubs.size === 0) {\n          teardownRoom(details.room);\n        }\n      }\n    };\n    details.unsubs.add(leave);\n    return {\n      room: details.room,\n      leave\n    };\n  }\n  function enterRoom(roomId, ...args) {\n    const existing = roomsById.get(roomId);\n    if (existing !== void 0) {\n      return leaseRoom(existing);\n    }\n    const options2 = args[0] ?? {};\n    const initialPresence = (typeof options2.initialPresence === \"function\" ? options2.initialPresence(roomId) : options2.initialPresence) ?? {};\n    const initialStorage = (typeof options2.initialStorage === \"function\" ? options2.initialStorage(roomId) : options2.initialStorage) ?? {};\n    const newRoom = createRoom(\n      { initialPresence, initialStorage },\n      {\n        roomId,\n        throttleDelay,\n        lostConnectionTimeout,\n        backgroundKeepAliveTimeout,\n        polyfills: clientOptions.polyfills,\n        delegates: clientOptions.mockedDelegates ?? {\n          createSocket: makeCreateSocketDelegateForRoom(\n            roomId,\n            baseUrl,\n            clientOptions.polyfills?.WebSocket,\n            options2.engine\n          ),\n          authenticate: makeAuthDelegateForRoom(roomId, authManager)\n        },\n        enableDebugLogging: clientOptions.enableDebugLogging,\n        baseUrl,\n        errorEventSource: liveblocksErrorSource,\n        unstable_streamData: !!clientOptions.unstable_streamData,\n        roomHttpClient: httpClient,\n        createSyncSource,\n        badgeLocation: clientOptions.badgeLocation ?? \"bottom-right\"\n      }\n    );\n    const newRoomDetails = {\n      room: newRoom,\n      unsubs: /* @__PURE__ */ new Set()\n    };\n    roomsById.set(roomId, newRoomDetails);\n    setupDevTools(() => Array.from(roomsById.keys()));\n    linkDevTools(roomId, newRoom);\n    const shouldConnect = options2.autoConnect ?? true;\n    if (shouldConnect) {\n      if (typeof atob === \"undefined\") {\n        if (clientOptions.polyfills?.atob === void 0) {\n          throw new Error(\n            \"You need to polyfill atob to use the client in your environment. Please follow the instructions at https://liveblocks.io/docs/errors/liveblocks-client/atob-polyfill\"\n          );\n        }\n        global.atob = clientOptions.polyfills.atob;\n      }\n      newRoom.connect();\n    }\n    return leaseRoom(newRoomDetails);\n  }\n  function getRoom(roomId) {\n    const room = roomsById.get(roomId)?.room;\n    return room ? room : null;\n  }\n  function logout() {\n    authManager.reset();\n    currentUserId.set(() => void 0);\n    for (const { room } of roomsById.values()) {\n      if (!isIdle(room.getStatus())) {\n        room.reconnect();\n      }\n    }\n  }\n  const resolveUsers = clientOptions.resolveUsers;\n  const batchedResolveUsers = new Batch(\n    async (batchedUserIds) => {\n      const userIds = batchedUserIds.flat();\n      const users = await resolveUsers?.({ userIds });\n      warnOnceIf(\n        !resolveUsers,\n        \"Set the resolveUsers option in createClient to specify user info.\"\n      );\n      return users ?? userIds.map(() => void 0);\n    },\n    { delay: RESOLVE_USERS_BATCH_DELAY }\n  );\n  const usersStore = createBatchStore(batchedResolveUsers);\n  function invalidateResolvedUsers(userIds) {\n    usersStore.invalidate(userIds);\n  }\n  const resolveRoomsInfo = clientOptions.resolveRoomsInfo;\n  const batchedResolveRoomsInfo = new Batch(\n    async (batchedRoomIds) => {\n      const roomIds = batchedRoomIds.flat();\n      const roomsInfo = await resolveRoomsInfo?.({ roomIds });\n      warnOnceIf(\n        !resolveRoomsInfo,\n        \"Set the resolveRoomsInfo option in createClient to specify room info.\"\n      );\n      return roomsInfo ?? roomIds.map(() => void 0);\n    },\n    { delay: RESOLVE_ROOMS_INFO_BATCH_DELAY }\n  );\n  const roomsInfoStore = createBatchStore(batchedResolveRoomsInfo);\n  function invalidateResolvedRoomsInfo(roomIds) {\n    roomsInfoStore.invalidate(roomIds);\n  }\n  const resolveGroupsInfo = clientOptions.resolveGroupsInfo;\n  const batchedResolveGroupsInfo = new Batch(\n    async (batchedGroupIds) => {\n      const groupIds = batchedGroupIds.flat();\n      const groupsInfo = await resolveGroupsInfo?.({ groupIds });\n      warnOnceIf(\n        !resolveGroupsInfo,\n        \"Set the resolveGroupsInfo option in createClient to specify group info.\"\n      );\n      return groupsInfo ?? groupIds.map(() => void 0);\n    },\n    { delay: RESOLVE_GROUPS_INFO_BATCH_DELAY }\n  );\n  const groupsInfoStore = createBatchStore(batchedResolveGroupsInfo);\n  function invalidateResolvedGroupsInfo(groupIds) {\n    groupsInfoStore.invalidate(groupIds);\n  }\n  const mentionSuggestionsCache = /* @__PURE__ */ new Map();\n  function invalidateResolvedMentionSuggestions() {\n    mentionSuggestionsCache.clear();\n  }\n  const syncStatusSources = [];\n  const syncStatusSignal = new Signal(\"synchronized\");\n  const liveblocksErrorSource = makeEventSource();\n  function getSyncStatus() {\n    const status = syncStatusSignal.get();\n    return status === \"synchronizing\" ? status : \"synchronized\";\n  }\n  function recompute() {\n    syncStatusSignal.set(\n      syncStatusSources.some((src) => src.get() === \"synchronizing\") ? \"synchronizing\" : syncStatusSources.some((src) => src.get() === \"has-local-changes\") ? \"has-local-changes\" : \"synchronized\"\n    );\n  }\n  function createSyncSource() {\n    const source = new Signal(\"synchronized\");\n    syncStatusSources.push(source);\n    const unsub = source.subscribe(() => recompute());\n    function setSyncStatus(status) {\n      source.set(status);\n    }\n    function destroy() {\n      unsub();\n      const index = syncStatusSources.findIndex((item) => item === source);\n      if (index > -1) {\n        const [ref] = syncStatusSources.splice(index, 1);\n        const wasStillPending = ref.get() !== \"synchronized\";\n        if (wasStillPending) {\n          recompute();\n        }\n      }\n    }\n    return { setSyncStatus, destroy };\n  }\n  {\n    const maybePreventClose = (e) => {\n      if (clientOptions.preventUnsavedChanges && syncStatusSignal.get() !== \"synchronized\") {\n        e.preventDefault();\n      }\n    };\n    const win = typeof window !== \"undefined\" ? window : void 0;\n    win?.addEventListener(\"beforeunload\", maybePreventClose);\n  }\n  async function getNotificationSettings(options2) {\n    const plainSettings = await httpClient.getNotificationSettings(options2);\n    const settings = createNotificationSettings(plainSettings);\n    return settings;\n  }\n  async function updateNotificationSettings(settings) {\n    const plainSettings = await httpClient.updateNotificationSettings(settings);\n    const settingsObject = createNotificationSettings(plainSettings);\n    return settingsObject;\n  }\n  const client = Object.defineProperty(\n    {\n      enterRoom,\n      getRoom,\n      logout,\n      // Public inbox notifications API\n      getInboxNotifications: httpClient.getInboxNotifications,\n      getInboxNotificationsSince: httpClient.getInboxNotificationsSince,\n      getUnreadInboxNotificationsCount: httpClient.getUnreadInboxNotificationsCount,\n      markAllInboxNotificationsAsRead: httpClient.markAllInboxNotificationsAsRead,\n      markInboxNotificationAsRead: httpClient.markInboxNotificationAsRead,\n      deleteAllInboxNotifications: httpClient.deleteAllInboxNotifications,\n      deleteInboxNotification: httpClient.deleteInboxNotification,\n      // Public notification settings API\n      getNotificationSettings,\n      updateNotificationSettings,\n      // Advanced resolvers APIs\n      resolvers: {\n        invalidateUsers: invalidateResolvedUsers,\n        invalidateRoomsInfo: invalidateResolvedRoomsInfo,\n        invalidateGroupsInfo: invalidateResolvedGroupsInfo,\n        invalidateMentionSuggestions: invalidateResolvedMentionSuggestions\n      },\n      getSyncStatus,\n      events: {\n        error: liveblocksErrorSource,\n        syncStatus: syncStatusSignal\n      },\n      // Internal\n      [kInternal]: {\n        currentUserId,\n        mentionSuggestionsCache,\n        ai,\n        resolveMentionSuggestions: clientOptions.resolveMentionSuggestions,\n        usersStore,\n        roomsInfoStore,\n        groupsInfoStore,\n        getRoomIds() {\n          return Array.from(roomsById.keys());\n        },\n        httpClient,\n        // Type-level helper only, it's effectively only an identity-function at runtime\n        as: () => client,\n        createSyncSource,\n        emitError: (context, cause) => {\n          const error3 = LiveblocksError.from(context, cause);\n          const didNotify = liveblocksErrorSource.notify(error3);\n          if (!didNotify) {\n            error2(error3.message);\n          }\n        }\n      }\n    },\n    kInternal,\n    {\n      enumerable: false\n    }\n  );\n  return client;\n}\nfunction checkBounds(option, value, min, max, recommendedMin) {\n  if (typeof value !== \"number\" || value < min || max !== void 0 && value > max) {\n    throw new Error(\n      max !== void 0 ? `${option} should be between ${recommendedMin ?? min} and ${max}.` : `${option} should be at least ${recommendedMin ?? min}.`\n    );\n  }\n  return value;\n}\nfunction getBackgroundKeepAliveTimeout(value) {\n  if (value === void 0) return void 0;\n  return checkBounds(\n    \"backgroundKeepAliveTimeout\",\n    value,\n    MIN_BACKGROUND_KEEP_ALIVE_TIMEOUT\n  );\n}\nfunction getThrottle(value) {\n  return checkBounds(\"throttle\", value, MIN_THROTTLE, MAX_THROTTLE);\n}\nfunction getLostConnectionTimeout(value) {\n  return checkBounds(\n    \"lostConnectionTimeout\",\n    value,\n    MIN_LOST_CONNECTION_TIMEOUT,\n    MAX_LOST_CONNECTION_TIMEOUT,\n    RECOMMENDED_MIN_LOST_CONNECTION_TIMEOUT\n  );\n}\n\n// src/comments/comment-body.ts\nfunction isCommentBodyParagraph(element) {\n  return \"type\" in element && element.type === \"paragraph\";\n}\nfunction isCommentBodyText(element) {\n  return !(\"type\" in element) && \"text\" in element && typeof element.text === \"string\";\n}\nfunction isCommentBodyMention(element) {\n  return \"type\" in element && element.type === \"mention\";\n}\nfunction isCommentBodyLink(element) {\n  return \"type\" in element && element.type === \"link\";\n}\nvar commentBodyElementsGuards = {\n  paragraph: isCommentBodyParagraph,\n  text: isCommentBodyText,\n  link: isCommentBodyLink,\n  mention: isCommentBodyMention\n};\nvar commentBodyElementsTypes = {\n  paragraph: \"block\",\n  text: \"inline\",\n  link: \"inline\",\n  mention: \"inline\"\n};\nfunction traverseCommentBody(body, elementOrVisitor, possiblyVisitor) {\n  if (!body || !body?.content) {\n    return;\n  }\n  const element = typeof elementOrVisitor === \"string\" ? elementOrVisitor : void 0;\n  const type = element ? commentBodyElementsTypes[element] : \"all\";\n  const guard = element ? commentBodyElementsGuards[element] : () => true;\n  const visitor = typeof elementOrVisitor === \"function\" ? elementOrVisitor : possiblyVisitor;\n  for (const block of body.content) {\n    if (type === \"all\" || type === \"block\") {\n      if (guard(block)) {\n        visitor?.(block);\n      }\n    }\n    if (type === \"all\" || type === \"inline\") {\n      for (const inline of block.children) {\n        if (guard(inline)) {\n          visitor?.(inline);\n        }\n      }\n    }\n  }\n}\nfunction getMentionsFromCommentBody(body, predicate) {\n  const mentionIds = /* @__PURE__ */ new Set();\n  const mentions = [];\n  traverseCommentBody(body, \"mention\", (mention) => {\n    if (\n      // If this mention isn't already in the list\n      !mentionIds.has(mention.id) && // And the provided predicate is true\n      (predicate ? predicate(mention) : true)\n    ) {\n      mentionIds.add(mention.id);\n      mentions.push(mention);\n    }\n  });\n  return mentions;\n}\nasync function resolveMentionsInCommentBody(body, resolveUsers, resolveGroupsInfo) {\n  const resolvedUsers = /* @__PURE__ */ new Map();\n  const resolvedGroupsInfo = /* @__PURE__ */ new Map();\n  if (!resolveUsers && !resolveGroupsInfo) {\n    return {\n      users: resolvedUsers,\n      groups: resolvedGroupsInfo\n    };\n  }\n  const mentions = getMentionsFromCommentBody(body);\n  const userIds = mentions.filter((mention) => mention.kind === \"user\").map((mention) => mention.id);\n  const groupIds = mentions.filter((mention) => mention.kind === \"group\").map((mention) => mention.id);\n  const [users, groups] = await Promise.all([\n    resolveUsers && userIds.length > 0 ? resolveUsers({ userIds }) : void 0,\n    resolveGroupsInfo && groupIds.length > 0 ? resolveGroupsInfo({ groupIds }) : void 0\n  ]);\n  if (users) {\n    for (const [index, userId] of userIds.entries()) {\n      const user = users[index];\n      if (user) {\n        resolvedUsers.set(userId, user);\n      }\n    }\n  }\n  if (groups) {\n    for (const [index, groupId] of groupIds.entries()) {\n      const group = groups[index];\n      if (group) {\n        resolvedGroupsInfo.set(groupId, group);\n      }\n    }\n  }\n  return {\n    users: resolvedUsers,\n    groups: resolvedGroupsInfo\n  };\n}\nvar htmlEscapables = {\n  \"&\": \"&amp;\",\n  \"<\": \"&lt;\",\n  \">\": \"&gt;\",\n  '\"': \"&quot;\",\n  \"'\": \"&#39;\"\n};\nvar htmlEscapablesRegex = new RegExp(\n  Object.keys(htmlEscapables).map((entity) => `\\\\${entity}`).join(\"|\"),\n  \"g\"\n);\nfunction htmlSafe(value) {\n  return new HtmlSafeString([String(value)], []);\n}\nfunction joinHtml(strings) {\n  if (strings.length <= 0) {\n    return new HtmlSafeString([\"\"], []);\n  }\n  return new HtmlSafeString(\n    [\"\", ...Array(strings.length - 1).fill(\"\"), \"\"],\n    strings\n  );\n}\nfunction escapeHtml(value) {\n  if (value instanceof HtmlSafeString) {\n    return value.toString();\n  }\n  if (Array.isArray(value)) {\n    return joinHtml(value).toString();\n  }\n  return String(value).replace(\n    htmlEscapablesRegex,\n    (character) => htmlEscapables[character]\n  );\n}\nvar HtmlSafeString = class {\n  #strings;\n  #values;\n  constructor(strings, values2) {\n    this.#strings = strings;\n    this.#values = values2;\n  }\n  toString() {\n    return this.#strings.reduce((result, str, i) => {\n      return result + escapeHtml(nn(this.#values[i - 1])) + str;\n    });\n  }\n};\nfunction html(strings, ...values2) {\n  return new HtmlSafeString(strings, values2);\n}\nvar markdownEscapables = {\n  _: \"\\\\_\",\n  \"*\": \"\\\\*\",\n  \"#\": \"\\\\#\",\n  \"`\": \"\\\\`\",\n  \"~\": \"\\\\~\",\n  \"!\": \"\\\\!\",\n  \"|\": \"\\\\|\",\n  \"(\": \"\\\\(\",\n  \")\": \"\\\\)\",\n  \"{\": \"\\\\{\",\n  \"}\": \"\\\\}\",\n  \"[\": \"\\\\[\",\n  \"]\": \"\\\\]\"\n};\nvar markdownEscapablesRegex = new RegExp(\n  Object.keys(markdownEscapables).map((entity) => `\\\\${entity}`).join(\"|\"),\n  \"g\"\n);\nfunction joinMarkdown(strings) {\n  if (strings.length <= 0) {\n    return new MarkdownSafeString([\"\"], []);\n  }\n  return new MarkdownSafeString(\n    [\"\", ...Array(strings.length - 1).fill(\"\"), \"\"],\n    strings\n  );\n}\nfunction escapeMarkdown(value) {\n  if (value instanceof MarkdownSafeString) {\n    return value.toString();\n  }\n  if (Array.isArray(value)) {\n    return joinMarkdown(value).toString();\n  }\n  return String(value).replace(\n    markdownEscapablesRegex,\n    (character) => markdownEscapables[character]\n  );\n}\nvar MarkdownSafeString = class {\n  #strings;\n  #values;\n  constructor(strings, values2) {\n    this.#strings = strings;\n    this.#values = values2;\n  }\n  toString() {\n    return this.#strings.reduce((result, str, i) => {\n      return result + escapeMarkdown(nn(this.#values[i - 1])) + str;\n    });\n  }\n};\nfunction markdown(strings, ...values2) {\n  return new MarkdownSafeString(strings, values2);\n}\nvar stringifyCommentBodyPlainElements = {\n  paragraph: ({ children }) => children,\n  text: ({ element }) => element.text,\n  link: ({ element }) => element.text ?? element.url,\n  mention: ({ element, user, group }) => {\n    return `@${user?.name ?? group?.name ?? element.id}`;\n  }\n};\nvar stringifyCommentBodyHtmlElements = {\n  paragraph: ({ children }) => {\n    return children ? html`<p>${htmlSafe(children)}</p>` : children;\n  },\n  text: ({ element }) => {\n    let children = element.text;\n    if (!children) {\n      return html`${children}`;\n    }\n    if (element.bold) {\n      children = html`<strong>${children}</strong>`;\n    }\n    if (element.italic) {\n      children = html`<em>${children}</em>`;\n    }\n    if (element.strikethrough) {\n      children = html`<s>${children}</s>`;\n    }\n    if (element.code) {\n      children = html`<code>${children}</code>`;\n    }\n    return html`${children}`;\n  },\n  link: ({ element, href }) => {\n    return html`<a href=\"${href}\" target=\"_blank\" rel=\"noopener noreferrer\">${element.text ? html`${element.text}` : element.url}</a>`;\n  },\n  mention: ({ element, user, group }) => {\n    return html`<span data-mention>@${user?.name ? html`${user?.name}` : group?.name ? html`${group?.name}` : element.id}</span>`;\n  }\n};\nvar stringifyCommentBodyMarkdownElements = {\n  paragraph: ({ children }) => {\n    return children;\n  },\n  text: ({ element }) => {\n    let children = element.text;\n    if (!children) {\n      return children;\n    }\n    if (element.bold) {\n      children = markdown`**${children}**`;\n    }\n    if (element.italic) {\n      children = markdown`_${children}_`;\n    }\n    if (element.strikethrough) {\n      children = markdown`~~${children}~~`;\n    }\n    if (element.code) {\n      children = markdown`\\`${children}\\``;\n    }\n    return children;\n  },\n  link: ({ element, href }) => {\n    return markdown`[${element.text ?? element.url}](${href})`;\n  },\n  mention: ({ element, user, group }) => {\n    return markdown`@${user?.name ?? group?.name ?? element.id}`;\n  }\n};\nasync function stringifyCommentBody(body, options) {\n  const format = options?.format ?? \"plain\";\n  const separator = options?.separator ?? (format === \"markdown\" ? \"\\n\\n\" : \"\\n\");\n  const elements = {\n    ...format === \"html\" ? stringifyCommentBodyHtmlElements : format === \"markdown\" ? stringifyCommentBodyMarkdownElements : stringifyCommentBodyPlainElements,\n    ...options?.elements\n  };\n  const { users: resolvedUsers, groups: resolvedGroupsInfo } = await resolveMentionsInCommentBody(\n    body,\n    options?.resolveUsers,\n    options?.resolveGroupsInfo\n  );\n  const blocks = body.content.flatMap((block, blockIndex) => {\n    switch (block.type) {\n      case \"paragraph\": {\n        const inlines = block.children.flatMap((inline, inlineIndex) => {\n          if (isCommentBodyMention(inline)) {\n            return inline.id ? [\n              elements.mention(\n                {\n                  element: inline,\n                  user: inline.kind === \"user\" ? resolvedUsers.get(inline.id) : void 0,\n                  group: inline.kind === \"group\" ? resolvedGroupsInfo.get(inline.id) : void 0\n                },\n                inlineIndex\n              )\n            ] : [];\n          }\n          if (isCommentBodyLink(inline)) {\n            const href = sanitizeUrl(inline.url);\n            if (href === null) {\n              return [\n                elements.text(\n                  {\n                    element: { text: inline.text ?? inline.url }\n                  },\n                  inlineIndex\n                )\n              ];\n            }\n            return [\n              elements.link(\n                {\n                  element: inline,\n                  href\n                },\n                inlineIndex\n              )\n            ];\n          }\n          if (isCommentBodyText(inline)) {\n            return [elements.text({ element: inline }, inlineIndex)];\n          }\n          return [];\n        });\n        return [\n          elements.paragraph(\n            { element: block, children: inlines.join(\"\") },\n            blockIndex\n          )\n        ];\n      }\n      default:\n        return [];\n    }\n  });\n  return blocks.join(separator);\n}\n\n// src/crdts/utils.ts\nfunction toPlainLson(lson) {\n  if (lson instanceof LiveObject) {\n    return {\n      liveblocksType: \"LiveObject\",\n      data: Object.fromEntries(\n        Object.entries(lson.toObject()).flatMap(\n          ([key, value]) => value !== void 0 ? [[key, toPlainLson(value)]] : []\n        )\n      )\n    };\n  } else if (lson instanceof LiveMap) {\n    return {\n      liveblocksType: \"LiveMap\",\n      data: Object.fromEntries(\n        [...lson].map(([key, value]) => [key, toPlainLson(value)])\n      )\n    };\n  } else if (lson instanceof LiveList) {\n    return {\n      liveblocksType: \"LiveList\",\n      data: [...lson].map((item) => toPlainLson(item))\n    };\n  } else {\n    return lson;\n  }\n}\n\n// src/immutable.ts\nfunction lsonObjectToJson(obj) {\n  const result = {};\n  for (const key in obj) {\n    const val = obj[key];\n    if (val !== void 0) {\n      result[key] = lsonToJson(val);\n    }\n  }\n  return result;\n}\nfunction liveObjectToJson(liveObject) {\n  return lsonObjectToJson(liveObject.toObject());\n}\nfunction liveMapToJson(map) {\n  const result = {};\n  for (const [key, value] of map.entries()) {\n    result[key] = lsonToJson(value);\n  }\n  return result;\n}\nfunction lsonListToJson(value) {\n  return value.map(lsonToJson);\n}\nfunction liveListToJson(value) {\n  return lsonListToJson(value.toArray());\n}\nfunction lsonToJson(value) {\n  if (value instanceof LiveObject) {\n    return liveObjectToJson(value);\n  } else if (value instanceof LiveList) {\n    return liveListToJson(value);\n  } else if (value instanceof LiveMap) {\n    return liveMapToJson(value);\n  } else if (value instanceof LiveRegister) {\n    return value.data;\n  }\n  if (Array.isArray(value)) {\n    return lsonListToJson(value);\n  } else if (isPlainObject(value)) {\n    return lsonObjectToJson(value);\n  }\n  return value;\n}\nfunction deepLiveify(value) {\n  if (Array.isArray(value)) {\n    return new LiveList(value.map(deepLiveify));\n  } else if (isPlainObject(value)) {\n    const init = {};\n    for (const key in value) {\n      const val = value[key];\n      if (val === void 0) {\n        continue;\n      }\n      init[key] = deepLiveify(val);\n    }\n    return new LiveObject(init);\n  } else {\n    return value;\n  }\n}\nfunction patchLiveList(liveList, prev, next) {\n  let i = 0;\n  let prevEnd = prev.length - 1;\n  let nextEnd = next.length - 1;\n  let prevNode = prev[0];\n  let nextNode = next[0];\n  outer: {\n    while (prevNode === nextNode) {\n      ++i;\n      if (i > prevEnd || i > nextEnd) {\n        break outer;\n      }\n      prevNode = prev[i];\n      nextNode = next[i];\n    }\n    prevNode = prev[prevEnd];\n    nextNode = next[nextEnd];\n    while (prevNode === nextNode) {\n      prevEnd--;\n      nextEnd--;\n      if (i > prevEnd || i > nextEnd) {\n        break outer;\n      }\n      prevNode = prev[prevEnd];\n      nextNode = next[nextEnd];\n    }\n  }\n  if (i > prevEnd) {\n    if (i <= nextEnd) {\n      while (i <= nextEnd) {\n        liveList.insert(deepLiveify(next[i]), i);\n        i++;\n      }\n    }\n  } else if (i > nextEnd) {\n    let localI = i;\n    while (localI <= prevEnd) {\n      liveList.delete(i);\n      localI++;\n    }\n  } else {\n    while (i <= prevEnd && i <= nextEnd) {\n      prevNode = prev[i];\n      nextNode = next[i];\n      const liveListNode = liveList.get(i);\n      if (isLiveObject(liveListNode) && isPlainObject(prevNode) && isPlainObject(nextNode)) {\n        patchLiveObject(liveListNode, prevNode, nextNode);\n      } else {\n        liveList.set(i, deepLiveify(nextNode));\n      }\n      i++;\n    }\n    while (i <= nextEnd) {\n      liveList.insert(deepLiveify(next[i]), i);\n      i++;\n    }\n    let localI = i;\n    while (localI <= prevEnd) {\n      liveList.delete(i);\n      localI++;\n    }\n  }\n}\nfunction patchLiveObjectKey(liveObject, key, prev, next) {\n  if (process.env.NODE_ENV !== \"production\") {\n    const nonSerializableValue = findNonSerializableValue(next);\n    if (nonSerializableValue) {\n      error2(\n        `New state path: '${nonSerializableValue.path}' value: '${String(\n          nonSerializableValue.value\n        )}' is not serializable.\nOnly serializable value can be synced with Liveblocks.`\n      );\n      return;\n    }\n  }\n  const value = liveObject.get(key);\n  if (next === void 0) {\n    liveObject.delete(key);\n  } else if (value === void 0) {\n    liveObject.set(key, deepLiveify(next));\n  } else if (prev === next) {\n    return;\n  } else if (isLiveList(value) && Array.isArray(prev) && Array.isArray(next)) {\n    patchLiveList(value, prev, next);\n  } else if (isLiveObject(value) && isPlainObject(prev) && isPlainObject(next)) {\n    patchLiveObject(value, prev, next);\n  } else {\n    liveObject.set(key, deepLiveify(next));\n  }\n}\nfunction patchLiveObject(root, prev, next) {\n  const updates = {};\n  for (const key in next) {\n    patchLiveObjectKey(root, key, prev[key], next[key]);\n  }\n  for (const key in prev) {\n    if (next[key] === void 0) {\n      root.delete(key);\n    }\n  }\n  if (Object.keys(updates).length > 0) {\n    root.update(updates);\n  }\n}\nfunction getParentsPath(node) {\n  const path = [];\n  while (node.parent.type === \"HasParent\") {\n    if (isLiveList(node.parent.node)) {\n      path.push(node.parent.node._indexOfPosition(node.parent.key));\n    } else {\n      path.push(node.parent.key);\n    }\n    node = node.parent.node;\n  }\n  return path;\n}\nfunction legacy_patchImmutableObject(state, updates) {\n  return updates.reduce(\n    (state2, update) => legacy_patchImmutableObjectWithUpdate(state2, update),\n    state\n  );\n}\nfunction legacy_patchImmutableObjectWithUpdate(state, update) {\n  const path = getParentsPath(update.node);\n  return legacy_patchImmutableNode(state, path, update);\n}\nfunction legacy_patchImmutableNode(state, path, update) {\n  const pathItem = path.pop();\n  if (pathItem === void 0) {\n    switch (update.type) {\n      case \"LiveObject\": {\n        if (!isJsonObject(state)) {\n          throw new Error(\n            \"Internal: received update on LiveObject but state was not an object\"\n          );\n        }\n        const newState = Object.assign({}, state);\n        for (const key in update.updates) {\n          if (update.updates[key]?.type === \"update\") {\n            const val = update.node.get(key);\n            if (val !== void 0) {\n              newState[key] = lsonToJson(val);\n            }\n          } else if (update.updates[key]?.type === \"delete\") {\n            delete newState[key];\n          }\n        }\n        return newState;\n      }\n      case \"LiveList\": {\n        if (!Array.isArray(state)) {\n          throw new Error(\n            \"Internal: received update on LiveList but state was not an array\"\n          );\n        }\n        let newState = state.map((x) => x);\n        for (const listUpdate of update.updates) {\n          if (listUpdate.type === \"set\") {\n            newState = newState.map(\n              (item, index) => index === listUpdate.index ? lsonToJson(listUpdate.item) : item\n            );\n          } else if (listUpdate.type === \"insert\") {\n            if (listUpdate.index === newState.length) {\n              newState.push(lsonToJson(listUpdate.item));\n            } else {\n              newState = [\n                ...newState.slice(0, listUpdate.index),\n                lsonToJson(listUpdate.item),\n                ...newState.slice(listUpdate.index)\n              ];\n            }\n          } else if (listUpdate.type === \"delete\") {\n            newState.splice(listUpdate.index, 1);\n          } else if (listUpdate.type === \"move\") {\n            if (listUpdate.previousIndex > listUpdate.index) {\n              newState = [\n                ...newState.slice(0, listUpdate.index),\n                lsonToJson(listUpdate.item),\n                ...newState.slice(listUpdate.index, listUpdate.previousIndex),\n                ...newState.slice(listUpdate.previousIndex + 1)\n              ];\n            } else {\n              newState = [\n                ...newState.slice(0, listUpdate.previousIndex),\n                ...newState.slice(\n                  listUpdate.previousIndex + 1,\n                  listUpdate.index + 1\n                ),\n                lsonToJson(listUpdate.item),\n                ...newState.slice(listUpdate.index + 1)\n              ];\n            }\n          }\n        }\n        return newState;\n      }\n      case \"LiveMap\": {\n        if (!isJsonObject(state)) {\n          throw new Error(\n            \"Internal: received update on LiveMap but state was not an object\"\n          );\n        }\n        const newState = Object.assign({}, state);\n        for (const key in update.updates) {\n          if (update.updates[key]?.type === \"update\") {\n            const value = update.node.get(key);\n            if (value !== void 0) {\n              newState[key] = lsonToJson(value);\n            }\n          } else if (update.updates[key]?.type === \"delete\") {\n            delete newState[key];\n          }\n        }\n        return newState;\n      }\n    }\n  }\n  if (Array.isArray(state)) {\n    const newArray = [...state];\n    newArray[pathItem] = legacy_patchImmutableNode(\n      state[pathItem],\n      path,\n      update\n    );\n    return newArray;\n  } else if (isJsonObject(state)) {\n    const node = state[pathItem];\n    if (node === void 0) {\n      return state;\n    } else {\n      const stateAsObj = state;\n      return {\n        ...stateAsObj,\n        [pathItem]: legacy_patchImmutableNode(node, path, update)\n      };\n    }\n  } else {\n    return state;\n  }\n}\n\n// src/lib/abortController.ts\nfunction makeAbortController(externalSignal) {\n  const ctl = new AbortController();\n  return {\n    signal: externalSignal ? AbortSignal.any([ctl.signal, externalSignal]) : ctl.signal,\n    abort: ctl.abort.bind(ctl)\n  };\n}\n\n// src/lib/deprecation.ts\nvar _emittedDeprecationWarnings = /* @__PURE__ */ new Set();\nfunction deprecate(message, key = message) {\n  if (process.env.NODE_ENV !== \"production\") {\n    if (!_emittedDeprecationWarnings.has(key)) {\n      _emittedDeprecationWarnings.add(key);\n      errorWithTitle(\"Deprecation warning\", message);\n    }\n  }\n}\nfunction deprecateIf(condition, message, key = message) {\n  if (process.env.NODE_ENV !== \"production\") {\n    if (condition) {\n      deprecate(message, key);\n    }\n  }\n}\nfunction throwUsageError(message) {\n  if (process.env.NODE_ENV !== \"production\") {\n    const usageError = new Error(message);\n    usageError.name = \"Usage error\";\n    errorWithTitle(\"Usage error\", message);\n    throw usageError;\n  }\n}\nfunction errorIf(condition, message) {\n  if (process.env.NODE_ENV !== \"production\") {\n    if (condition) {\n      throwUsageError(message);\n    }\n  }\n}\n\n// src/lib/Poller.ts\nvar BACKOFF_DELAYS2 = [1e3, 2e3, 4e3, 8e3, 1e4];\nfunction makePoller(callback, intervalMs, options) {\n  const startTime = performance.now();\n  const doc = typeof document !== \"undefined\" ? document : void 0;\n  const win = typeof window !== \"undefined\" ? window : void 0;\n  const maxStaleTimeMs = options?.maxStaleTimeMs ?? Number.POSITIVE_INFINITY;\n  const context = {\n    inForeground: doc?.visibilityState !== \"hidden\",\n    lastSuccessfulPollAt: startTime,\n    count: 0,\n    backoff: 0\n  };\n  function mayPoll() {\n    return context.count > 0 && context.inForeground;\n  }\n  const fsm = new FSM({}).addState(\"@idle\").addState(\"@enabled\").addState(\"@polling\");\n  fsm.addTransitions(\"@idle\", { START: \"@enabled\" });\n  fsm.addTransitions(\"@enabled\", { STOP: \"@idle\", POLL: \"@polling\" });\n  fsm.addTimedTransition(\n    \"@enabled\",\n    () => {\n      const lastPoll = context.lastSuccessfulPollAt;\n      const nextPoll = lastPoll + intervalMs;\n      return Math.max(0, nextPoll - performance.now()) + context.backoff;\n    },\n    \"@polling\"\n  );\n  fsm.onEnterAsync(\n    \"@polling\",\n    async (_ctx, signal) => {\n      await callback(signal);\n      if (!signal.aborted) {\n        context.lastSuccessfulPollAt = performance.now();\n      }\n    },\n    // When OK\n    () => {\n      return {\n        target: mayPoll() ? \"@enabled\" : \"@idle\",\n        effect: () => {\n          context.backoff = 0;\n        }\n      };\n    },\n    // When error\n    () => {\n      return {\n        target: mayPoll() ? \"@enabled\" : \"@idle\",\n        effect: () => {\n          context.backoff = BACKOFF_DELAYS2.find((delay) => delay > context.backoff) ?? BACKOFF_DELAYS2[BACKOFF_DELAYS2.length - 1];\n        }\n      };\n    },\n    3e4\n    // Abort the poll if the callback takes more than 30 seconds to complete\n  );\n  function startOrStop() {\n    if (mayPoll()) {\n      fsm.send({ type: \"START\" });\n    } else {\n      fsm.send({ type: \"STOP\" });\n    }\n  }\n  function inc() {\n    context.count++;\n    startOrStop();\n  }\n  function dec() {\n    context.count--;\n    if (context.count < 0) {\n      context.count = 0;\n    }\n    startOrStop();\n  }\n  function pollNowIfStale() {\n    if (performance.now() - context.lastSuccessfulPollAt > maxStaleTimeMs) {\n      fsm.send({ type: \"POLL\" });\n    }\n  }\n  function markAsStale() {\n    context.lastSuccessfulPollAt = performance.now() - maxStaleTimeMs - 1;\n  }\n  function setInForeground(inForeground) {\n    context.inForeground = inForeground;\n    startOrStop();\n    pollNowIfStale();\n  }\n  function onVisibilityChange() {\n    setInForeground(doc?.visibilityState !== \"hidden\");\n  }\n  doc?.addEventListener(\"visibilitychange\", onVisibilityChange);\n  win?.addEventListener(\"online\", onVisibilityChange);\n  win?.addEventListener(\"focus\", pollNowIfStale);\n  fsm.start();\n  return {\n    inc,\n    dec,\n    pollNowIfStale,\n    markAsStale,\n    // Internal API, used by unit tests only to simulate visibility events\n    setInForeground\n  };\n}\n\n// src/protocol/Subscriptions.ts\nfunction getSubscriptionKey(subscription, subjectId) {\n  if (typeof subscription === \"string\") {\n    return `${subscription}:${subjectId}`;\n  }\n  return `${subscription.kind}:${subscription.subjectId}`;\n}\n\n// src/types/Others.ts\nvar TextEditorType = /* @__PURE__ */ ((TextEditorType2) => {\n  TextEditorType2[\"Lexical\"] = \"lexical\";\n  TextEditorType2[\"TipTap\"] = \"tiptap\";\n  TextEditorType2[\"BlockNote\"] = \"blocknote\";\n  return TextEditorType2;\n})(TextEditorType || {});\n\n// src/index.ts\ndetectDupes(PKG_NAME, PKG_VERSION, PKG_FORMAT);\nexport {\n  ClientMsgCode,\n  CrdtType,\n  DefaultMap,\n  Deque,\n  DerivedSignal,\n  HttpError,\n  LiveList,\n  LiveMap,\n  LiveObject,\n  LiveblocksError,\n  MENTION_CHARACTER,\n  MutableSignal,\n  OpCode,\n  Permission,\n  Promise_withResolvers,\n  ServerMsgCode,\n  Signal,\n  SortedList,\n  TextEditorType,\n  WebsocketCloseCodes,\n  asPos,\n  assert,\n  assertNever,\n  autoRetry,\n  b64decode,\n  batch,\n  checkBounds,\n  chunk,\n  cloneLson,\n  compactNodesToNodeStream,\n  compactObject,\n  fancy_console_exports as console,\n  convertToCommentData,\n  convertToCommentUserReaction,\n  convertToGroupData,\n  convertToInboxNotificationData,\n  convertToSubscriptionData,\n  convertToThreadData,\n  convertToUserSubscriptionData,\n  createClient,\n  createCommentAttachmentId,\n  createCommentId,\n  createInboxNotificationId,\n  createManagedPool,\n  createNotificationSettings,\n  createThreadId,\n  defineAiTool,\n  deprecate,\n  deprecateIf,\n  detectDupes,\n  entries,\n  errorIf,\n  findLastIndex,\n  freeze,\n  generateUrl,\n  getMentionsFromCommentBody,\n  getSubscriptionKey,\n  html,\n  htmlSafe,\n  isCommentBodyLink,\n  isCommentBodyMention,\n  isCommentBodyText,\n  isJsonArray,\n  isJsonObject,\n  isJsonScalar,\n  isListStorageNode,\n  isLiveNode,\n  isMapStorageNode,\n  isNotificationChannelEnabled,\n  isNumberOperator,\n  isObjectStorageNode,\n  isPlainObject,\n  isRegisterStorageNode,\n  isRootStorageNode,\n  isStartsWithOperator,\n  isUrl,\n  kInternal,\n  keys,\n  legacy_patchImmutableObject,\n  lsonToJson,\n  makeAbortController,\n  makeEventSource,\n  makePoller,\n  makePosition,\n  mapValues,\n  memoizeOnSuccess,\n  nanoid,\n  nn,\n  nodeStreamToCompactNodes,\n  objectToQuery,\n  patchLiveObjectKey,\n  patchNotificationSettings,\n  raise,\n  resolveMentionsInCommentBody,\n  sanitizeUrl,\n  shallow,\n  shallow2,\n  stableStringify,\n  stringifyCommentBody,\n  throwUsageError,\n  toPlainLson,\n  tryParseJson,\n  url,\n  urljoin,\n  wait,\n  warnOnce,\n  warnOnceIf,\n  withTimeout\n};\n//# sourceMappingURL=index.js.map","import { AppRouteRouteModule } from \"next/dist/esm/server/route-modules/app-route/module.compiled\";\nimport { RouteKind } from \"next/dist/esm/server/route-kind\";\nimport { patchFetch as _patchFetch } from \"next/dist/esm/server/lib/patch-fetch\";\nimport { addRequestMeta, getRequestMeta } from \"next/dist/esm/server/request-meta\";\nimport { getTracer, SpanKind } from \"next/dist/esm/server/lib/trace/tracer\";\nimport { setManifestsSingleton } from \"next/dist/esm/server/app-render/manifests-singleton\";\nimport { normalizeAppPath } from \"next/dist/esm/shared/lib/router/utils/app-paths\";\nimport { NodeNextRequest, NodeNextResponse } from \"next/dist/esm/server/base-http/node\";\nimport { NextRequestAdapter, signalFromNodeResponse } from \"next/dist/esm/server/web/spec-extension/adapters/next-request\";\nimport { BaseServerSpan } from \"next/dist/esm/server/lib/trace/constants\";\nimport { getRevalidateReason } from \"next/dist/esm/server/instrumentation/utils\";\nimport { sendResponse } from \"next/dist/esm/server/send-response\";\nimport { fromNodeOutgoingHttpHeaders, toNodeOutgoingHttpHeaders } from \"next/dist/esm/server/web/utils\";\nimport { getCacheControlHeader } from \"next/dist/esm/server/lib/cache-control\";\nimport { INFINITE_CACHE, NEXT_CACHE_TAGS_HEADER } from \"next/dist/esm/lib/constants\";\nimport { NoFallbackError } from \"next/dist/esm/shared/lib/no-fallback-error.external\";\nimport { CachedRouteKind } from \"next/dist/esm/server/response-cache\";\nimport * as userland from \"INNER_APP_ROUTE\";\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"\"\nconst routeModule = new AppRouteRouteModule({\n    definition: {\n        kind: RouteKind.APP_ROUTE,\n        page: \"/api/liveblocks-auth/route\",\n        pathname: \"/api/liveblocks-auth\",\n        filename: \"route\",\n        bundlePath: \"\"\n    },\n    distDir: process.env.__NEXT_RELATIVE_DIST_DIR || '',\n    relativeProjectDir: process.env.__NEXT_RELATIVE_PROJECT_DIR || '',\n    resolvedPagePath: \"[project]/app/api/liveblocks-auth/route.ts\",\n    nextConfigOutput,\n    userland\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { workAsyncStorage, workUnitAsyncStorage, serverHooks } = routeModule;\nfunction patchFetch() {\n    return _patchFetch({\n        workAsyncStorage,\n        workUnitAsyncStorage\n    });\n}\nexport { routeModule, workAsyncStorage, workUnitAsyncStorage, serverHooks, patchFetch,  };\nexport async function handler(req, res, ctx) {\n    if (routeModule.isDev) {\n        addRequestMeta(req, 'devRequestTimingInternalsEnd', process.hrtime.bigint());\n    }\n    let srcPage = \"/api/liveblocks-auth/route\";\n    // turbopack doesn't normalize `/index` in the page name\n    // so we need to to process dynamic routes properly\n    // TODO: fix turbopack providing differing value from webpack\n    if (process.env.TURBOPACK) {\n        srcPage = srcPage.replace(/\\/index$/, '') || '/';\n    } else if (srcPage === '/index') {\n        // we always normalize /index specifically\n        srcPage = '/';\n    }\n    const multiZoneDraftMode = process.env.__NEXT_MULTI_ZONE_DRAFT_MODE;\n    const prepareResult = await routeModule.prepare(req, res, {\n        srcPage,\n        multiZoneDraftMode\n    });\n    if (!prepareResult) {\n        res.statusCode = 400;\n        res.end('Bad Request');\n        ctx.waitUntil == null ? void 0 : ctx.waitUntil.call(ctx, Promise.resolve());\n        return null;\n    }\n    const { buildId, params, nextConfig, parsedUrl, isDraftMode, prerenderManifest, routerServerContext, isOnDemandRevalidate, revalidateOnlyGenerated, resolvedPathname, clientReferenceManifest, serverActionsManifest } = prepareResult;\n    const normalizedSrcPage = normalizeAppPath(srcPage);\n    let isIsr = Boolean(prerenderManifest.dynamicRoutes[normalizedSrcPage] || prerenderManifest.routes[resolvedPathname]);\n    const render404 = async ()=>{\n        // TODO: should route-module itself handle rendering the 404\n        if (routerServerContext == null ? void 0 : routerServerContext.render404) {\n            await routerServerContext.render404(req, res, parsedUrl, false);\n        } else {\n            res.end('This page could not be found');\n        }\n        return null;\n    };\n    if (isIsr && !isDraftMode) {\n        const isPrerendered = Boolean(prerenderManifest.routes[resolvedPathname]);\n        const prerenderInfo = prerenderManifest.dynamicRoutes[normalizedSrcPage];\n        if (prerenderInfo) {\n            if (prerenderInfo.fallback === false && !isPrerendered) {\n                if (nextConfig.experimental.adapterPath) {\n                    return await render404();\n                }\n                throw new NoFallbackError();\n            }\n        }\n    }\n    let cacheKey = null;\n    if (isIsr && !routeModule.isDev && !isDraftMode) {\n        cacheKey = resolvedPathname;\n        // ensure /index and / is normalized to one key\n        cacheKey = cacheKey === '/index' ? '/' : cacheKey;\n    }\n    const supportsDynamicResponse = // If we're in development, we always support dynamic HTML\n    routeModule.isDev === true || // If this is not SSG or does not have static paths, then it supports\n    // dynamic HTML.\n    !isIsr;\n    // This is a revalidation request if the request is for a static\n    // page and it is not being resumed from a postponed render and\n    // it is not a dynamic RSC request then it is a revalidation\n    // request.\n    const isStaticGeneration = isIsr && !supportsDynamicResponse;\n    // Before rendering (which initializes component tree modules), we have to\n    // set the reference manifests to our global store so Server Action's\n    // encryption util can access to them at the top level of the page module.\n    if (serverActionsManifest && clientReferenceManifest) {\n        setManifestsSingleton({\n            page: srcPage,\n            clientReferenceManifest,\n            serverActionsManifest\n        });\n    }\n    const method = req.method || 'GET';\n    const tracer = getTracer();\n    const activeSpan = tracer.getActiveScopeSpan();\n    const context = {\n        params,\n        prerenderManifest,\n        renderOpts: {\n            experimental: {\n                authInterrupts: Boolean(nextConfig.experimental.authInterrupts)\n            },\n            cacheComponents: Boolean(nextConfig.cacheComponents),\n            supportsDynamicResponse,\n            incrementalCache: getRequestMeta(req, 'incrementalCache'),\n            cacheLifeProfiles: nextConfig.cacheLife,\n            waitUntil: ctx.waitUntil,\n            onClose: (cb)=>{\n                res.on('close', cb);\n            },\n            onAfterTaskError: undefined,\n            onInstrumentationRequestError: (error, _request, errorContext, silenceLog)=>routeModule.onRequestError(req, error, errorContext, silenceLog, routerServerContext)\n        },\n        sharedContext: {\n            buildId\n        }\n    };\n    const nodeNextReq = new NodeNextRequest(req);\n    const nodeNextRes = new NodeNextResponse(res);\n    const nextReq = NextRequestAdapter.fromNodeNextRequest(nodeNextReq, signalFromNodeResponse(res));\n    try {\n        const invokeRouteModule = async (span)=>{\n            return routeModule.handle(nextReq, context).finally(()=>{\n                if (!span) return;\n                span.setAttributes({\n                    'http.status_code': res.statusCode,\n                    'next.rsc': false\n                });\n                const rootSpanAttributes = tracer.getRootSpanAttributes();\n                // We were unable to get attributes, probably OTEL is not enabled\n                if (!rootSpanAttributes) {\n                    return;\n                }\n                if (rootSpanAttributes.get('next.span_type') !== BaseServerSpan.handleRequest) {\n                    console.warn(`Unexpected root span type '${rootSpanAttributes.get('next.span_type')}'. Please report this Next.js issue https://github.com/vercel/next.js`);\n                    return;\n                }\n                const route = rootSpanAttributes.get('next.route');\n                if (route) {\n                    const name = `${method} ${route}`;\n                    span.setAttributes({\n                        'next.route': route,\n                        'http.route': route,\n                        'next.span_name': name\n                    });\n                    span.updateName(name);\n                } else {\n                    span.updateName(`${method} ${srcPage}`);\n                }\n            });\n        };\n        const isMinimalMode = Boolean(process.env.MINIMAL_MODE || getRequestMeta(req, 'minimalMode'));\n        const handleResponse = async (currentSpan)=>{\n            var _cacheEntry_value;\n            const responseGenerator = async ({ previousCacheEntry })=>{\n                try {\n                    if (!isMinimalMode && isOnDemandRevalidate && revalidateOnlyGenerated && !previousCacheEntry) {\n                        res.statusCode = 404;\n                        // on-demand revalidate always sets this header\n                        res.setHeader('x-nextjs-cache', 'REVALIDATED');\n                        res.end('This page could not be found');\n                        return null;\n                    }\n                    const response = await invokeRouteModule(currentSpan);\n                    req.fetchMetrics = context.renderOpts.fetchMetrics;\n                    let pendingWaitUntil = context.renderOpts.pendingWaitUntil;\n                    // Attempt using provided waitUntil if available\n                    // if it's not we fallback to sendResponse's handling\n                    if (pendingWaitUntil) {\n                        if (ctx.waitUntil) {\n                            ctx.waitUntil(pendingWaitUntil);\n                            pendingWaitUntil = undefined;\n                        }\n                    }\n                    const cacheTags = context.renderOpts.collectedTags;\n                    // If the request is for a static response, we can cache it so long\n                    // as it's not edge.\n                    if (isIsr) {\n                        const blob = await response.blob();\n                        // Copy the headers from the response.\n                        const headers = toNodeOutgoingHttpHeaders(response.headers);\n                        if (cacheTags) {\n                            headers[NEXT_CACHE_TAGS_HEADER] = cacheTags;\n                        }\n                        if (!headers['content-type'] && blob.type) {\n                            headers['content-type'] = blob.type;\n                        }\n                        const revalidate = typeof context.renderOpts.collectedRevalidate === 'undefined' || context.renderOpts.collectedRevalidate >= INFINITE_CACHE ? false : context.renderOpts.collectedRevalidate;\n                        const expire = typeof context.renderOpts.collectedExpire === 'undefined' || context.renderOpts.collectedExpire >= INFINITE_CACHE ? undefined : context.renderOpts.collectedExpire;\n                        // Create the cache entry for the response.\n                        const cacheEntry = {\n                            value: {\n                                kind: CachedRouteKind.APP_ROUTE,\n                                status: response.status,\n                                body: Buffer.from(await blob.arrayBuffer()),\n                                headers\n                            },\n                            cacheControl: {\n                                revalidate,\n                                expire\n                            }\n                        };\n                        return cacheEntry;\n                    } else {\n                        // send response without caching if not ISR\n                        await sendResponse(nodeNextReq, nodeNextRes, response, context.renderOpts.pendingWaitUntil);\n                        return null;\n                    }\n                } catch (err) {\n                    // if this is a background revalidate we need to report\n                    // the request error here as it won't be bubbled\n                    if (previousCacheEntry == null ? void 0 : previousCacheEntry.isStale) {\n                        const silenceLog = false;\n                        await routeModule.onRequestError(req, err, {\n                            routerKind: 'App Router',\n                            routePath: srcPage,\n                            routeType: 'route',\n                            revalidateReason: getRevalidateReason({\n                                isStaticGeneration,\n                                isOnDemandRevalidate\n                            })\n                        }, silenceLog, routerServerContext);\n                    }\n                    throw err;\n                }\n            };\n            const cacheEntry = await routeModule.handleResponse({\n                req,\n                nextConfig,\n                cacheKey,\n                routeKind: RouteKind.APP_ROUTE,\n                isFallback: false,\n                prerenderManifest,\n                isRoutePPREnabled: false,\n                isOnDemandRevalidate,\n                revalidateOnlyGenerated,\n                responseGenerator,\n                waitUntil: ctx.waitUntil,\n                isMinimalMode\n            });\n            // we don't create a cacheEntry for ISR\n            if (!isIsr) {\n                return null;\n            }\n            if ((cacheEntry == null ? void 0 : (_cacheEntry_value = cacheEntry.value) == null ? void 0 : _cacheEntry_value.kind) !== CachedRouteKind.APP_ROUTE) {\n                var _cacheEntry_value1;\n                throw Object.defineProperty(new Error(`Invariant: app-route received invalid cache entry ${cacheEntry == null ? void 0 : (_cacheEntry_value1 = cacheEntry.value) == null ? void 0 : _cacheEntry_value1.kind}`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E701\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            if (!isMinimalMode) {\n                res.setHeader('x-nextjs-cache', isOnDemandRevalidate ? 'REVALIDATED' : cacheEntry.isMiss ? 'MISS' : cacheEntry.isStale ? 'STALE' : 'HIT');\n            }\n            // Draft mode should never be cached\n            if (isDraftMode) {\n                res.setHeader('Cache-Control', 'private, no-cache, no-store, max-age=0, must-revalidate');\n            }\n            const headers = fromNodeOutgoingHttpHeaders(cacheEntry.value.headers);\n            if (!(isMinimalMode && isIsr)) {\n                headers.delete(NEXT_CACHE_TAGS_HEADER);\n            }\n            // If cache control is already set on the response we don't\n            // override it to allow users to customize it via next.config\n            if (cacheEntry.cacheControl && !res.getHeader('Cache-Control') && !headers.get('Cache-Control')) {\n                headers.set('Cache-Control', getCacheControlHeader(cacheEntry.cacheControl));\n            }\n            await sendResponse(nodeNextReq, nodeNextRes, // @ts-expect-error - Argument of type 'Buffer<ArrayBufferLike>' is not assignable to parameter of type 'BodyInit | null | undefined'.\n            new Response(cacheEntry.value.body, {\n                headers,\n                status: cacheEntry.value.status || 200\n            }));\n            return null;\n        };\n        // TODO: activeSpan code path is for when wrapped by\n        // next-server can be removed when this is no longer used\n        if (activeSpan) {\n            await handleResponse(activeSpan);\n        } else {\n            await tracer.withPropagatedContext(req.headers, ()=>tracer.trace(BaseServerSpan.handleRequest, {\n                    spanName: `${method} ${srcPage}`,\n                    kind: SpanKind.SERVER,\n                    attributes: {\n                        'http.method': method,\n                        'http.target': req.url\n                    }\n                }, handleResponse));\n        }\n    } catch (err) {\n        if (!(err instanceof NoFallbackError)) {\n            const silenceLog = false;\n            await routeModule.onRequestError(req, err, {\n                routerKind: 'App Router',\n                routePath: normalizedSrcPage,\n                routeType: 'route',\n                revalidateReason: getRevalidateReason({\n                    isStaticGeneration,\n                    isOnDemandRevalidate\n                })\n            }, silenceLog, routerServerContext);\n        }\n        // rethrow so that we can handle serving error page\n        // If this is during static generation, throw the error again.\n        if (isIsr) throw err;\n        // Otherwise, send a 500 response.\n        await sendResponse(nodeNextReq, nodeNextRes, new Response(null, {\n            status: 500\n        }));\n        return null;\n    }\n}\n\n//# sourceMappingURL=app-route.js.map\n","import { Liveblocks } from \"@liveblocks/node\";\r\nimport { NextRequest, NextResponse } from \"next/server\";\r\n\r\n// We read the secret key from the environment variables\r\nconst liveblocks = new Liveblocks({\r\n    secret: process.env.LIVEBLOCKS_SECRET_KEY as string,\r\n});\r\n\r\nexport async function POST(request: NextRequest) {\r\n    try {\r\n        // In a real application, you would authenticate the user here\r\n        // using Firebase Admin SDK or by passing a token from the client.\r\n        // For simplicity, we'll read the user info from the request body if provided,\r\n        // or generate a random anonymous user.\r\n        const body = await request.json().catch(() => ({}));\r\n        const user = body.user || {\r\n            uid: `anon-${Math.floor(Math.random() * 10000)}`,\r\n            displayName: `Player`,\r\n        };\r\n\r\n        // Prepare session for Liveblocks\r\n        const session = liveblocks.prepareSession(user.uid, {\r\n            userInfo: {\r\n                name: user.displayName || \"Unknown User\",\r\n            },\r\n        });\r\n\r\n        // Authorize the user for the requested room\r\n        // The room name is typically passed in the request body by @liveblocks/client\r\n        const { room } = body;\r\n        if (room) {\r\n            session.allow(room, session.FULL_ACCESS);\r\n        }\r\n\r\n        // Authorize the session and get the token\r\n        const { status, body: sessionBody } = await session.authorize();\r\n\r\n        return new NextResponse(sessionBody, { status });\r\n    } catch (error) {\r\n        console.error(\"Error in liveblocks auth:\", error);\r\n        return new NextResponse(\"Authentication error\", { status: 500 });\r\n    }\r\n}\r\n","// src/index.ts\nimport { detectDupes } from \"@liveblocks/core\";\n\n// src/version.ts\nvar PKG_NAME = \"@liveblocks/node\";\nvar PKG_VERSION = \"3.14.0\";\nvar PKG_FORMAT = \"esm\";\n\n// src/client.ts\nimport {\n  checkBounds,\n  ClientMsgCode,\n  convertToCommentData,\n  convertToCommentUserReaction,\n  convertToGroupData,\n  convertToInboxNotificationData,\n  convertToSubscriptionData,\n  convertToThreadData,\n  convertToUserSubscriptionData,\n  createManagedPool,\n  createNotificationSettings,\n  isPlainObject,\n  LiveObject,\n  makeAbortController,\n  objectToQuery,\n  tryParseJson,\n  url as url2,\n  urljoin\n} from \"@liveblocks/core\";\n\n// src/lib/itertools.ts\nasync function asyncConsume(iterable) {\n  const result = [];\n  for await (const item of iterable) {\n    result.push(item);\n  }\n  return result;\n}\nasync function runConcurrently(iterable, fn, concurrency) {\n  const queue = /* @__PURE__ */ new Set();\n  for await (const item of iterable) {\n    if (queue.size >= concurrency) {\n      await Promise.race(queue);\n    }\n    const promise = (async () => {\n      try {\n        await fn(item);\n      } finally {\n        queue.delete(promise);\n      }\n    })();\n    queue.add(promise);\n  }\n  if (queue.size > 0) {\n    await Promise.all(queue);\n  }\n}\n\n// src/lib/ndjson.ts\nvar LineStream = class extends TransformStream {\n  constructor() {\n    let buffer = \"\";\n    super({\n      transform(chunk, controller) {\n        buffer += chunk;\n        if (buffer.includes(\"\\n\")) {\n          const lines = buffer.split(\"\\n\");\n          for (let i = 0; i < lines.length - 1; i++) {\n            if (lines[i].length > 0) {\n              controller.enqueue(lines[i]);\n            }\n          }\n          buffer = lines[lines.length - 1];\n        }\n      },\n      flush(controller) {\n        if (buffer.length > 0) {\n          controller.enqueue(buffer);\n        }\n      }\n    });\n  }\n};\nvar NdJsonStream = class extends TransformStream {\n  constructor() {\n    super({\n      transform(line, controller) {\n        const json = JSON.parse(line);\n        controller.enqueue(json);\n      }\n    });\n  }\n};\n\n// src/lib/xwarn.ts\nfunction xwarn(resp, method, path) {\n  const message = resp.headers.get(\"X-LB-Warn\");\n  if (message) {\n    const msg = `  \\u26A0 [Liveblocks] ${message} (${method} ${path})`;\n    if (resp.ok) {\n      console.warn(msg);\n    } else {\n      console.error(msg);\n    }\n  }\n}\n\n// src/Session.ts\nimport { url } from \"@liveblocks/core\";\n\n// src/utils.ts\nvar DEFAULT_BASE_URL = \"https://api.liveblocks.io\";\nvar VALID_KEY_CHARS_REGEX = /^[\\w-]+$/;\nfunction getBaseUrl(baseUrl) {\n  if (typeof baseUrl === \"string\" && baseUrl.startsWith(\"http\")) {\n    return baseUrl;\n  } else {\n    return DEFAULT_BASE_URL;\n  }\n}\nasync function fetchPolyfill() {\n  return typeof globalThis.fetch !== \"undefined\" ? globalThis.fetch : (await import(\"node-fetch\")).default;\n}\nfunction isString(value) {\n  return typeof value === \"string\";\n}\nfunction startsWith(value, prefix) {\n  return isString(value) && value.startsWith(prefix);\n}\nfunction isNonEmpty(value) {\n  return isString(value) && value.length > 0;\n}\nfunction assertNonEmpty(value, field) {\n  if (!isNonEmpty(value)) {\n    throw new Error(\n      `Invalid value for field '${field}'. Please provide a non-empty string. For more information: https://liveblocks.io/docs/api-reference/liveblocks-node#authorize`\n    );\n  }\n}\nfunction assertSecretKey(value, field) {\n  if (!startsWith(value, \"sk_\")) {\n    throw new Error(\n      `Invalid value for field '${field}'. Secret keys must start with 'sk_'. Please provide the secret key from your Liveblocks dashboard at https://liveblocks.io/dashboard/apikeys.`\n    );\n  }\n  if (!VALID_KEY_CHARS_REGEX.test(value)) {\n    throw new Error(\n      `Invalid chars found in field '${field}'. Please check that you correctly copied the secret key from your Liveblocks dashboard at https://liveblocks.io/dashboard/apikeys.`\n    );\n  }\n}\nfunction normalizeStatusCode(statusCode) {\n  if (statusCode >= 200 && statusCode < 300) {\n    return 200;\n  } else if (statusCode >= 500) {\n    return 503;\n  } else {\n    return statusCode;\n  }\n}\n\n// src/Session.ts\nvar ALL_PERMISSIONS = Object.freeze([\n  \"room:write\",\n  \"room:read\",\n  \"room:presence:write\",\n  \"comments:write\",\n  \"comments:read\"\n]);\nfunction isPermission(value) {\n  return ALL_PERMISSIONS.includes(value);\n}\nvar MAX_PERMS_PER_SET = 10;\nvar READ_ACCESS = Object.freeze([\n  \"room:read\",\n  \"room:presence:write\",\n  \"comments:read\"\n]);\nvar FULL_ACCESS = Object.freeze([\"room:write\", \"comments:write\"]);\nvar roomPatternRegex = /^([*]|[^*]{1,128}[*]?)$/;\nvar Session = class {\n  FULL_ACCESS = FULL_ACCESS;\n  READ_ACCESS = READ_ACCESS;\n  #postFn;\n  #userId;\n  #userInfo;\n  #organizationId;\n  /** Only used as a hint to produce better error messages. */\n  #localDev;\n  #sealed = false;\n  #permissions = /* @__PURE__ */ new Map();\n  /** @internal */\n  constructor(postFn, userId, userInfo, organizationId, localDev) {\n    assertNonEmpty(userId, \"userId\");\n    this.#postFn = postFn;\n    this.#userId = userId;\n    this.#userInfo = userInfo;\n    this.#organizationId = organizationId;\n    this.#localDev = localDev ?? false;\n  }\n  #getOrCreate(roomId) {\n    if (this.#sealed) {\n      throw new Error(\"You can no longer change these permissions.\");\n    }\n    let perms = this.#permissions.get(roomId);\n    if (perms) {\n      return perms;\n    } else {\n      if (this.#permissions.size >= MAX_PERMS_PER_SET) {\n        throw new Error(\n          \"You cannot add permissions for more than 10 rooms in a single token\"\n        );\n      }\n      perms = /* @__PURE__ */ new Set();\n      this.#permissions.set(roomId, perms);\n      return perms;\n    }\n  }\n  allow(roomIdOrPattern, newPerms) {\n    if (typeof roomIdOrPattern !== \"string\") {\n      throw new Error(\"Room name or pattern must be a string\");\n    }\n    if (!roomPatternRegex.test(roomIdOrPattern)) {\n      throw new Error(\"Invalid room name or pattern\");\n    }\n    if (newPerms.length === 0) {\n      throw new Error(\"Permission list cannot be empty\");\n    }\n    const existingPerms = this.#getOrCreate(roomIdOrPattern);\n    for (const perm of newPerms) {\n      if (!isPermission(perm)) {\n        throw new Error(`Not a valid permission: ${perm}`);\n      }\n      existingPerms.add(perm);\n    }\n    return this;\n  }\n  /** @internal - For unit tests only */\n  hasPermissions() {\n    return this.#permissions.size > 0;\n  }\n  /** @internal - For unit tests only */\n  seal() {\n    if (this.#sealed) {\n      throw new Error(\n        \"You cannot reuse Session instances. Please create a new session every time.\"\n      );\n    }\n    this.#sealed = true;\n  }\n  /** @internal - For unit tests only */\n  serializePermissions() {\n    return Object.fromEntries(\n      Array.from(this.#permissions.entries()).map(([pat, perms]) => [\n        pat,\n        Array.from(perms)\n      ])\n    );\n  }\n  /**\n   * Call this to authorize the session to access Liveblocks. Note that this\n   * will return a Liveblocks \"access token\". Anyone that obtains such access\n   * token will have access to the allowed resources.\n   */\n  async authorize() {\n    this.seal();\n    if (!this.hasPermissions()) {\n      console.warn(\n        \"Access tokens without any permission will not be supported soon, you should use wildcards when the client requests a token for resources outside a room. See https://liveblocks.io/docs/errors/liveblocks-client/access-tokens-not-enough-permissions\"\n      );\n    }\n    try {\n      const body = {\n        // Required\n        userId: this.#userId,\n        permissions: this.serializePermissions(),\n        // Optional metadata\n        userInfo: this.#userInfo\n      };\n      if (this.#organizationId !== void 0) {\n        body.organizationId = this.#organizationId;\n      }\n      const resp = await this.#postFn(url`/v2/authorize-user`, body);\n      return {\n        status: normalizeStatusCode(resp.status),\n        body: await resp.text()\n      };\n    } catch (er) {\n      return {\n        status: 503,\n        body: this.#localDev ? \"Could not connect to your Liveblocks dev server. Is it running?\" : 'Call to /v2/authorize-user failed. See \"error\" for more information.',\n        error: er\n      };\n    }\n  }\n};\n\n// src/client.ts\nfunction inflateRoomData(room) {\n  const createdAt = new Date(room.createdAt);\n  const lastConnectionAt = room.lastConnectionAt ? new Date(room.lastConnectionAt) : void 0;\n  return {\n    ...room,\n    createdAt,\n    lastConnectionAt\n  };\n}\nfunction inflateAiCopilot(copilot) {\n  return {\n    ...copilot,\n    createdAt: new Date(copilot.createdAt),\n    updatedAt: new Date(copilot.updatedAt),\n    lastUsedAt: copilot.lastUsedAt ? new Date(copilot.lastUsedAt) : void 0\n  };\n}\nfunction inflateKnowledgeSource(source) {\n  return {\n    ...source,\n    createdAt: new Date(source.createdAt),\n    updatedAt: new Date(source.updatedAt),\n    lastIndexedAt: new Date(source.lastIndexedAt)\n  };\n}\nfunction inflateWebKnowledgeSourceLink(link) {\n  return {\n    ...link,\n    createdAt: new Date(link.createdAt),\n    lastIndexedAt: new Date(link.lastIndexedAt)\n  };\n}\nvar Liveblocks = class {\n  #secret;\n  #baseUrl;\n  /** Only used as a hint to produce better error messages. */\n  #localDev;\n  /**\n   * Interact with the Liveblocks API from your Node.js backend.\n   */\n  constructor(options) {\n    const options_ = options;\n    const secret = options_.secret;\n    assertSecretKey(secret, \"secret\");\n    this.#secret = secret;\n    this.#baseUrl = new URL(getBaseUrl(options.baseUrl));\n    this.#localDev = !!options.baseUrl && /^https?:\\/\\/localhost[:/]/.test(options.baseUrl);\n  }\n  async #post(path, json, options) {\n    const url3 = urljoin(this.#baseUrl, path);\n    const headers = {\n      Authorization: `Bearer ${this.#secret}`,\n      \"Content-Type\": \"application/json\"\n    };\n    const fetch = await fetchPolyfill();\n    const res = await fetch(url3, {\n      method: \"POST\",\n      headers,\n      body: JSON.stringify(json),\n      signal: options?.signal\n    });\n    xwarn(res, \"POST\", path);\n    return res;\n  }\n  async #putBinary(path, body, params, options) {\n    const url3 = urljoin(this.#baseUrl, path, params);\n    const headers = {\n      Authorization: `Bearer ${this.#secret}`,\n      \"Content-Type\": \"application/octet-stream\"\n    };\n    const fetch = await fetchPolyfill();\n    const res = await fetch(url3, {\n      method: \"PUT\",\n      headers,\n      body,\n      signal: options?.signal\n    });\n    xwarn(res, \"PUT\", path);\n    return res;\n  }\n  async #delete(path, params, options) {\n    const url3 = urljoin(this.#baseUrl, path, params);\n    const headers = {\n      Authorization: `Bearer ${this.#secret}`\n    };\n    const fetch = await fetchPolyfill();\n    const res = await fetch(url3, {\n      method: \"DELETE\",\n      headers,\n      signal: options?.signal\n    });\n    xwarn(res, \"DELETE\", path);\n    return res;\n  }\n  async #get(path, params, options) {\n    const url3 = urljoin(this.#baseUrl, path, params);\n    const headers = {\n      Authorization: `Bearer ${this.#secret}`\n    };\n    const fetch = await fetchPolyfill();\n    const res = await fetch(url3, {\n      method: \"GET\",\n      headers,\n      signal: options?.signal\n    });\n    xwarn(res, \"GET\", path);\n    return res;\n  }\n  /* -------------------------------------------------------------------------------------------------\n   * Authentication\n   * -----------------------------------------------------------------------------------------------*/\n  /**\n   * Prepares a new session to authorize a user to access Liveblocks.\n   *\n   * IMPORTANT:\n   * Always make sure that you trust the user making the request to your\n   * backend before calling .prepareSession()!\n   *\n   * @param userId Tell Liveblocks the user ID of the user to authorize. Must\n   * uniquely identify the user account in your system. The uniqueness of this\n   * value will determine how many MAUs will be counted/billed.\n   *\n   * @param options.organizationId (optional) The organization ID to authorize the user for.\n   *\n   * @param options.userInfo Custom metadata to attach to this user. Data you\n   * add here will be visible to all other clients in the room, through the\n   * `other.info` property.\n   *\n   */\n  prepareSession(userId, ...rest) {\n    const options = rest[0];\n    return new Session(\n      this.#post.bind(this),\n      userId,\n      options?.userInfo,\n      options?.organizationId ?? options?.tenantId,\n      this.#localDev\n    );\n  }\n  /**\n   * Call this to authenticate the user as an actor you want to allow to use\n   * Liveblocks.\n   *\n   * You should use this method only if you want to manage your permissions\n   * through the Liveblocks Permissions API. This method is more complicated to\n   * set up, but allows for finer-grained specification of permissions.\n   *\n   * Calling `.identifyUser()` only lets you securely identify a user (and what\n   * groups they belong to). What permissions this user will end up having is\n   * determined by whatever permissions you assign the user/group in your\n   * Liveblocks account, through the Permissions API:\n   * https://liveblocks.io/docs/rooms/permissions\n   *\n   * IMPORTANT:\n   * Always verify that you trust the user making the request before calling\n   * .identifyUser()!\n   *\n   * @param identity Tell Liveblocks the user ID of the user to authenticate.\n   * Must uniquely identify the user account in your system. The uniqueness of\n   * this value will determine how many MAUs will be counted/billed.\n   *\n   * If you also want to assign which groups this user belongs to, use the\n   * object form and specify the `groupIds` property. Those `groupIds` should\n   * match the groupIds you assigned permissions to via the Liveblocks\n   * Permissions API, see\n   * https://liveblocks.io/docs/rooms/permissions#permissions-levels-groups-accesses-example\n   *\n   * @param options.userInfo Custom metadata to attach to this user. Data you\n   * add here will be visible to all other clients in the room, through the\n   * `other.info` property.\n   */\n  // These fields define the security identity of the user. Whatever you pass in here will define which\n  async identifyUser(identity, ...rest) {\n    const options = rest[0];\n    const path = url2`/v2/identify-user`;\n    const { userId, groupIds, tenantId, organizationId } = typeof identity === \"string\" ? {\n      userId: identity,\n      groupIds: void 0,\n      tenantId: void 0,\n      organizationId: void 0\n    } : identity;\n    assertNonEmpty(userId, \"userId\");\n    const body = {\n      userId,\n      groupIds,\n      userInfo: options?.userInfo\n    };\n    if (organizationId !== void 0) {\n      body.organizationId = organizationId;\n    } else if (tenantId !== void 0) {\n      body.organizationId = tenantId;\n    }\n    try {\n      const resp = await this.#post(path, body);\n      return {\n        status: normalizeStatusCode(resp.status),\n        body: await resp.text()\n      };\n    } catch (er) {\n      return {\n        status: 503,\n        body: this.#localDev ? \"Could not connect to your Liveblocks dev server. Is it running?\" : `Call to ${urljoin(\n          this.#baseUrl,\n          path\n        )} failed. See \"error\" for more information.`,\n        error: er\n      };\n    }\n  }\n  /* -------------------------------------------------------------------------------------------------\n   * Room\n   * -----------------------------------------------------------------------------------------------*/\n  /**\n   * Returns a list of your rooms. The rooms are returned sorted by creation date, from newest to oldest. You can filter rooms by metadata, users accesses and groups accesses.\n   * @param params.limit (optional) A limit on the number of rooms to be returned. The limit can range between 1 and 100, and defaults to 20.\n   * @param params.startingAfter (optional) A cursor used for pagination. You get the value from the response of the previous page.\n   * @param params.userId (optional) A filter on users accesses.\n   * @param params.metadata (optional) A filter on metadata. Multiple metadata keys can be used to filter rooms.\n   * @param params.groupIds (optional) A filter on groups accesses. Multiple groups can be used.\n   * @param params.organizationId (optional) A filter on organization ID.\n   * @param params.query (optional) A query to filter rooms by. It is based on our query language. You can filter by metadata and room ID.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   * @returns A list of rooms.\n   */\n  async getRooms(params = {}, options) {\n    const path = url2`/v2/rooms`;\n    let query;\n    if (typeof params.query === \"string\") {\n      query = params.query;\n    } else if (typeof params.query === \"object\") {\n      query = objectToQuery(params.query);\n    }\n    const queryParams = {\n      limit: params.limit,\n      startingAfter: params.startingAfter,\n      userId: params.userId,\n      groupIds: params.groupIds ? params.groupIds.join(\",\") : void 0,\n      query\n    };\n    if (params.organizationId !== void 0) {\n      queryParams.organizationId = params.organizationId;\n    } else if (params.tenantId !== void 0) {\n      queryParams.organizationId = params.tenantId;\n    }\n    const res = await this.#get(path, queryParams, options);\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    const page = await res.json();\n    const rooms = page.data.map(inflateRoomData);\n    return {\n      ...page,\n      data: rooms\n    };\n  }\n  /**\n   * Iterates over all rooms that match the given criteria.\n   *\n   * The difference with .getRooms() is that pagination will happen\n   * automatically under the hood, using the given `pageSize`.\n   *\n   * @param criteria.userId (optional) A filter on users accesses.\n   * @param criteria.groupIds (optional) A filter on groups accesses. Multiple groups can be used.\n   * @param criteria.query.roomId (optional) A filter by room ID.\n   * @param criteria.query.metadata (optional) A filter by metadata.\n   *\n   * @param options.pageSize (optional) The page size to use for each request.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   */\n  async *iterRooms(criteria, options) {\n    const { signal } = options ?? {};\n    const pageSize = checkBounds(\"pageSize\", options?.pageSize ?? 40, 20);\n    let cursor = void 0;\n    while (true) {\n      const { nextCursor, data } = await this.getRooms(\n        { ...criteria, startingAfter: cursor, limit: pageSize },\n        { signal }\n      );\n      for (const item of data) {\n        yield item;\n      }\n      if (!nextCursor) {\n        break;\n      }\n      cursor = nextCursor;\n    }\n  }\n  /**\n   * Creates a new room with the given id.\n   * @param roomId The id of the room to create.\n   * @param params.defaultAccesses The default accesses for the room.\n   * @param params.groupsAccesses (optional) The group accesses for the room. Can contain a maximum of 100 entries. Key length has a limit of 40 characters.\n   * @param params.usersAccesses (optional) The user accesses for the room. Can contain a maximum of 100 entries. Key length has a limit of 40 characters.\n   * @param params.metadata (optional) The metadata for the room. Supports upto a maximum of 50 entries. Key length has a limit of 40 characters. Value length has a limit of 256 characters.\n   * @param params.organizationId (optional) The organization ID to create the room for.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   * @returns The created room.\n   */\n  async createRoom(roomId, params, options) {\n    const {\n      defaultAccesses,\n      groupsAccesses,\n      usersAccesses,\n      metadata,\n      tenantId,\n      organizationId,\n      engine\n    } = params;\n    const body = {\n      id: roomId,\n      defaultAccesses,\n      groupsAccesses,\n      usersAccesses,\n      metadata,\n      engine\n    };\n    if (organizationId !== void 0) {\n      body.organizationId = organizationId;\n    } else if (tenantId !== void 0) {\n      body.organizationId = tenantId;\n    }\n    const res = await this.#post(\n      options?.idempotent ? url2`/v2/rooms?idempotent` : url2`/v2/rooms`,\n      body,\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    const data = await res.json();\n    return inflateRoomData(data);\n  }\n  /**\n   * Returns a room with the given id, or creates one with the given creation\n   * options if it doesn't exist yet.\n   *\n   * @param roomId The id of the room.\n   * @param params.defaultAccesses The default accesses for the room if the room will be created.\n   * @param params.groupsAccesses (optional) The group accesses for the room if the room will be created. Can contain a maximum of 100 entries. Key length has a limit of 40 characters.\n   * @param params.usersAccesses (optional) The user accesses for the room if the room will be created. Can contain a maximum of 100 entries. Key length has a limit of 40 characters.\n   * @param params.metadata (optional) The metadata for the room if the room will be created. Supports upto a maximum of 50 entries. Key length has a limit of 40 characters. Value length has a limit of 256 characters.\n   * @param params.organizationId (optional) The organization ID to create the room for.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   * @returns The room.\n   */\n  async getOrCreateRoom(roomId, params, options) {\n    return await this.createRoom(roomId, params, {\n      ...options,\n      idempotent: true\n    });\n  }\n  /**\n   * Updates or creates a new room with the given properties.\n   *\n   * @param roomId The id of the room to update or create.\n   * @param update The fields to update. These values will be updated when the room exists, or set when the room does not exist and gets created. Must specify at least one key.\n   * @param create (optional) The fields to only use when the room does not exist and will be created. When the room already exists, these values are ignored.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   * @returns The room.\n   */\n  async upsertRoom(roomId, params, options) {\n    const res = await this.#post(\n      url2`/v2/rooms/${roomId}/upsert`,\n      params,\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    const data = await res.json();\n    return inflateRoomData(data);\n  }\n  /**\n   * Returns a room with the given id.\n   * @param roomId The id of the room to return.\n   * @returns The room with the given id.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   */\n  async getRoom(roomId, options) {\n    const res = await this.#get(url2`/v2/rooms/${roomId}`, void 0, options);\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    const data = await res.json();\n    return inflateRoomData(data);\n  }\n  /**\n   * Updates specific properties of a room. Its not necessary to provide the entire rooms information.\n   * Setting a property to `null` means to delete this property.\n   * @param roomId The id of the room to update.\n   * @param params.defaultAccesses (optional) The default accesses for the room.\n   * @param params.groupsAccesses (optional) The group accesses for the room. Can contain a maximum of 100 entries. Key length has a limit of 40 characters.\n   * @param params.usersAccesses (optional) The user accesses for the room. Can contain a maximum of 100 entries. Key length has a limit of 40 characters.\n   * @param params.metadata (optional) The metadata for the room. Supports upto a maximum of 50 entries. Key length has a limit of 40 characters. Value length has a limit of 256 characters.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   * @returns The updated room.\n   */\n  async updateRoom(roomId, params, options) {\n    const { defaultAccesses, groupsAccesses, usersAccesses, metadata } = params;\n    const res = await this.#post(\n      url2`/v2/rooms/${roomId}`,\n      {\n        defaultAccesses,\n        groupsAccesses,\n        usersAccesses,\n        metadata\n      },\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    const data = await res.json();\n    return inflateRoomData(data);\n  }\n  /**\n   * Deletes a room with the given id. A deleted room is no longer accessible from the API or the dashboard and it cannot be restored.\n   * @param roomId The id of the room to delete.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   */\n  async deleteRoom(roomId, options) {\n    const res = await this.#delete(\n      url2`/v2/rooms/${roomId}`,\n      void 0,\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n  }\n  /**\n   * Prepares a room for connectivity, making the eventual connection faster. Use this when you know you'll be loading a room but are not yet connected to it.\n   * @param roomId The id of the room to prewarm.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   */\n  async prewarmRoom(roomId, options) {\n    const res = await this.#get(\n      url2`/v2/rooms/${roomId}/prewarm`,\n      void 0,\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n  }\n  /**\n   * Returns a list of users currently present in the requested room. For better performance, we recommand to call this endpoint every 10 seconds maximum. Duplicates can happen if a user is in the requested room with multiple browser tabs opened.\n   * @param roomId The id of the room to get the users from.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   * @returns A list of users currently present in the requested room.\n   */\n  async getActiveUsers(roomId, options) {\n    const res = await this.#get(\n      url2`/v2/rooms/${roomId}/active_users`,\n      void 0,\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    return await res.json();\n  }\n  /**\n   * Boadcasts an event to a room without having to connect to it via the client from @liveblocks/client. The connectionId passed to event listeners is -1 when using this API.\n   * @param roomId The id of the room to broadcast the event to.\n   * @param message The message to broadcast. It can be any JSON serializable value.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   */\n  async broadcastEvent(roomId, message, options) {\n    const res = await this.#post(\n      url2`/v2/rooms/${roomId}/broadcast_event`,\n      message,\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n  }\n  /**\n   * Sets ephemeral presence for a user in a room without requiring a WebSocket connection.\n   * The presence data will automatically expire after the specified TTL.\n   * This is useful for scenarios like showing an AI agent's presence in a room.\n   *\n   * @param roomId The id of the room to set presence in.\n   * @param params.userId The ID of the user to set presence for.\n   * @param params.data The presence data as a JSON object.\n   * @param params.userInfo (optional) Metadata about the user or agent\n   * @param params.ttl (optional) Time-to-live in seconds. If not specified, the default TTL is 60 seconds. (minimum: 2, maximum: 3599).\n   * @param options.signal (optional) An abort signal to cancel the request.\n   */\n  async setPresence(roomId, params, options) {\n    const res = await this.#post(\n      url2`/v2/rooms/${roomId}/presence`,\n      {\n        userId: params.userId,\n        data: params.data,\n        userInfo: params.userInfo,\n        ttl: params.ttl\n      },\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n  }\n  async getStorageDocument(roomId, format = \"plain-lson\", options) {\n    const res = await this.#get(\n      url2`/v2/rooms/${roomId}/storage`,\n      { format },\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    return await res.json();\n  }\n  async #requestStorageMutation(roomId, options) {\n    const resp = await this.#post(\n      url2`/v2/rooms/${roomId}/request-storage-mutation`,\n      {},\n      options\n    );\n    if (!resp.ok) {\n      throw await LiveblocksError.from(resp);\n    }\n    if (resp.headers.get(\"content-type\") !== \"application/x-ndjson\") {\n      throw new Error(\"Unexpected response content type\");\n    }\n    if (resp.body === null) {\n      throw new Error(\"Unexpected null body in response\");\n    }\n    const stream = resp.body.pipeThrough(new TextDecoderStream()).pipeThrough(new LineStream()).pipeThrough(new NdJsonStream());\n    const iter = stream[Symbol.asyncIterator]();\n    const first = (await iter.next()).value;\n    if (!isPlainObject(first) || typeof first.actor !== \"number\") {\n      throw new Error(\"Failed to obtain a unique session\");\n    }\n    const nodes = await asyncConsume(iter);\n    return { actor: first.actor, nodes };\n  }\n  /**\n   * Initializes a rooms Storage. The room must already exist and have an empty Storage.\n   * Calling this endpoint will disconnect all users from the room if there are any.\n   *\n   * @param roomId The id of the room to initialize the storage from.\n   * @param document The document to initialize the storage with.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   * @returns The initialized storage document. It is of the same format as the one passed in.\n   */\n  async initializeStorageDocument(roomId, document, options) {\n    const res = await this.#post(\n      url2`/v2/rooms/${roomId}/storage`,\n      document,\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    return await res.json();\n  }\n  /**\n   * Deletes all of the rooms Storage data and disconnect all users from the room if there are any. Note that this does not delete the Yjs document in the room if one exists.\n   * @param roomId The id of the room to delete the storage from.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   */\n  async deleteStorageDocument(roomId, options) {\n    const res = await this.#delete(\n      url2`/v2/rooms/${roomId}/storage`,\n      void 0,\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n  }\n  /* -------------------------------------------------------------------------------------------------\n   * Yjs\n   * -----------------------------------------------------------------------------------------------*/\n  /**\n   * Returns a JSON representation of the rooms Yjs document.\n   * @param roomId The id of the room to get the Yjs document from.\n   * @param params.format (optional) If true, YText will return formatting.\n   * @param params.key (optional) If provided, returns only a single keys value, e.g. doc.get(key).toJSON().\n   * @param params.type (optional) Used with key to override the inferred type, i.e. \"ymap\" will return doc.get(key, Y.Map).\n   * @param options.signal (optional) An abort signal to cancel the request.\n   * @returns A JSON representation of the rooms Yjs document.\n   */\n  async getYjsDocument(roomId, params = {}, options) {\n    const { format, key, type } = params;\n    const path = url2`v2/rooms/${roomId}/ydoc`;\n    const res = await this.#get(\n      path,\n      { formatting: format ? \"true\" : void 0, key, type },\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    return await res.json();\n  }\n  /**\n   * Send a Yjs binary update to the rooms Yjs document. You can use this endpoint to initialize Yjs data for the room or to update the rooms Yjs document.\n   * @param roomId The id of the room to send the Yjs binary update to.\n   * @param update The Yjs update to send. Typically the result of calling `Yjs.encodeStateAsUpdate(doc)`. Read the [Yjs documentation](https://docs.yjs.dev/api/document-updates) to learn how to create a binary update.\n   * @param params.guid (optional) If provided, the binary update will be applied to the Yjs subdocument with the given guid. If not provided, the binary update will be applied to the root Yjs document.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   */\n  async sendYjsBinaryUpdate(roomId, update, params = {}, options) {\n    const res = await this.#putBinary(\n      url2`/v2/rooms/${roomId}/ydoc`,\n      update,\n      { guid: params.guid },\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n  }\n  /**\n   * Returns the rooms Yjs document encoded as a single binary update. This can be used by Y.applyUpdate(responseBody) to get a copy of the document in your backend.\n   * See [Yjs documentation](https://docs.yjs.dev/api/document-updates) for more information on working with updates.\n   * @param roomId The id of the room to get the Yjs document from.\n   * @param params.guid (optional) If provided, returns the binary update of the Yjs subdocument with the given guid. If not provided, returns the binary update of the root Yjs document.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   * @returns The rooms Yjs document encoded as a single binary update.\n   */\n  async getYjsDocumentAsBinaryUpdate(roomId, params = {}, options) {\n    const res = await this.#get(\n      url2`/v2/rooms/${roomId}/ydoc-binary`,\n      { guid: params.guid },\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    return res.arrayBuffer();\n  }\n  /* -------------------------------------------------------------------------------------------------\n   * Comments\n   * -----------------------------------------------------------------------------------------------*/\n  /**\n   * Gets all the threads in a room.\n   *\n   * @param params.roomId The room ID to get the threads from.\n   * @param params.query The query to filter threads by. It is based on our query language and can filter by metadata.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   * @returns A list of threads.\n   */\n  async getThreads(params, options) {\n    const { roomId } = params;\n    let query;\n    if (typeof params.query === \"string\") {\n      query = params.query;\n    } else if (typeof params.query === \"object\") {\n      query = objectToQuery(params.query);\n    }\n    const res = await this.#get(\n      url2`/v2/rooms/${roomId}/threads`,\n      { query },\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    const { data } = await res.json();\n    return {\n      data: data.map((thread) => convertToThreadData(thread))\n    };\n  }\n  /**\n   * Gets a thread.\n   *\n   * @param params.roomId The room ID to get the thread from.\n   * @param params.threadId The thread ID.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   * @returns A thread.\n   */\n  async getThread(params, options) {\n    const { roomId, threadId } = params;\n    const res = await this.#get(\n      url2`/v2/rooms/${roomId}/threads/${threadId}`,\n      void 0,\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    return convertToThreadData(await res.json());\n  }\n  /**\n   * @deprecated Prefer using `getMentionsFromCommentBody` to extract mentions\n   * from comments and threads, or `Liveblocks.getThreadSubscriptions` to get\n   * the list of users who are subscribed to a thread.\n   *\n   * Gets a thread's participants.\n   *\n   * Participants are users who have commented on the thread\n   * or users that have been mentioned in a comment.\n   *\n   * @param params.roomId The room ID to get the thread participants from.\n   * @param params.threadId The thread ID to get the participants from.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   * @returns An object containing an array of participant IDs.\n   */\n  async getThreadParticipants(params, options) {\n    const { roomId, threadId } = params;\n    const res = await this.#get(\n      url2`/v2/rooms/${roomId}/threads/${threadId}/participants`,\n      void 0,\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    return await res.json();\n  }\n  /**\n   * Gets a thread's subscriptions.\n   *\n   * @param params.roomId The room ID to get the thread subscriptions from.\n   * @param params.threadId The thread ID to get the subscriptions from.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   * @returns An array of subscriptions.\n   */\n  async getThreadSubscriptions(params, options) {\n    const { roomId, threadId } = params;\n    const res = await this.#get(\n      url2`/v2/rooms/${roomId}/threads/${threadId}/subscriptions`,\n      void 0,\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    const { data } = await res.json();\n    return {\n      data: data.map(convertToUserSubscriptionData)\n    };\n  }\n  /**\n   * Gets a thread's comment.\n   *\n   * @param params.roomId The room ID to get the comment from.\n   * @param params.threadId The thread ID to get the comment from.\n   * @param params.commentId The comment ID.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   * @returns A comment.\n   */\n  async getComment(params, options) {\n    const { roomId, threadId, commentId } = params;\n    const res = await this.#get(\n      url2`/v2/rooms/${roomId}/threads/${threadId}/comments/${commentId}`,\n      void 0,\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    return convertToCommentData(await res.json());\n  }\n  /**\n   * Creates a comment.\n   *\n   * @param params.roomId The room ID to create the comment in.\n   * @param params.threadId The thread ID to create the comment in.\n   * @param params.data.userId The user ID of the user who is set to create the comment.\n   * @param params.data.createdAt (optional) The date the comment is set to be created.\n   * @param params.data.body The body of the comment.\n   * @param params.data.metadata (optional) The metadata for the comment.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   * @returns The created comment.\n   */\n  async createComment(params, options) {\n    const { roomId, threadId, data } = params;\n    const res = await this.#post(\n      url2`/v2/rooms/${roomId}/threads/${threadId}/comments`,\n      {\n        ...data,\n        createdAt: data.createdAt?.toISOString()\n      },\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    return convertToCommentData(await res.json());\n  }\n  /**\n   * Edits a comment.\n   * @param params.roomId The room ID to edit the comment in.\n   * @param params.threadId The thread ID to edit the comment in.\n   * @param params.commentId The comment ID to edit.\n   * @param params.data.body The body of the comment.\n   * @param params.data.metadata (optional) The metadata for the comment. Value must be a string, boolean or number. Use null to delete a key.\n   * @param params.data.editedAt (optional) The date the comment was edited.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   * @returns The edited comment.\n   */\n  async editComment(params, options) {\n    const { roomId, threadId, commentId, data } = params;\n    const res = await this.#post(\n      url2`/v2/rooms/${roomId}/threads/${threadId}/comments/${commentId}`,\n      {\n        body: data.body,\n        editedAt: data.editedAt?.toISOString(),\n        metadata: data.metadata\n      },\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    return convertToCommentData(await res.json());\n  }\n  /**\n   * Deletes a comment. Deletes a comment. If there are no remaining comments in the thread, the thread is also deleted.\n   * @param params.roomId The room ID to delete the comment in.\n   * @param params.threadId The thread ID to delete the comment in.\n   * @param params.commentId The comment ID to delete.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   */\n  async deleteComment(params, options) {\n    const { roomId, threadId, commentId } = params;\n    const res = await this.#delete(\n      url2`/v2/rooms/${roomId}/threads/${threadId}/comments/${commentId}`,\n      void 0,\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n  }\n  /**\n   * Creates a new thread. The thread will be created with the specified comment as its first comment.\n   * If the thread already exists, a `LiveblocksError` will be thrown with status code 409.\n   * @param params.roomId The room ID to create the thread in.\n   * @param params.thread.metadata (optional) The metadata for the thread. Supports upto a maximum of 10 entries. Value must be a string, boolean or number\n   * @param params.thread.comment.userId The user ID of the user who created the comment.\n   * @param params.thread.comment.createdAt (optional) The date the comment was created.\n   * @param params.thread.comment.body The body of the comment.\n   * @param params.thread.comment.metadata (optional) The metadata for the comment.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   * @returns The created thread. The thread will be created with the specified comment as its first comment.\n   */\n  async createThread(params, options) {\n    const { roomId, data } = params;\n    const res = await this.#post(\n      url2`/v2/rooms/${roomId}/threads`,\n      {\n        ...data,\n        comment: {\n          ...data.comment,\n          createdAt: data.comment.createdAt?.toISOString()\n        }\n      },\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    return convertToThreadData(await res.json());\n  }\n  /**\n   * Deletes a thread and all of its comments.\n   * @param params.roomId The room ID to delete the thread in.\n   * @param params.threadId The thread ID to delete.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   */\n  async deleteThread(params, options) {\n    const { roomId, threadId } = params;\n    const res = await this.#delete(\n      url2`/v2/rooms/${roomId}/threads/${threadId}`,\n      void 0,\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n  }\n  /**\n   * Mark a thread as resolved.\n   * @param params.roomId The room ID of the thread.\n   * @param params.threadId The thread ID to mark as resolved.\n   * @param params.data.userId The user ID of the user who marked the thread as resolved.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   * @returns The thread marked as resolved.\n   */\n  async markThreadAsResolved(params, options) {\n    const { roomId, threadId } = params;\n    const res = await this.#post(\n      url2`/v2/rooms/${roomId}/threads/${threadId}/mark-as-resolved`,\n      { userId: params.data.userId },\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    return convertToThreadData(await res.json());\n  }\n  /**\n   * Mark a thread as unresolved.\n   * @param params.roomId The room ID of the thread.\n   * @param params.threadId The thread ID to mark as unresolved.\n   * @param params.data.userId The user ID of the user who marked the thread as unresolved.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   * @returns The thread marked as unresolved.\n   */\n  async markThreadAsUnresolved(params, options) {\n    const { roomId, threadId } = params;\n    const res = await this.#post(\n      url2`/v2/rooms/${roomId}/threads/${threadId}/mark-as-unresolved`,\n      { userId: params.data.userId },\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    return convertToThreadData(await res.json());\n  }\n  /**\n   * Subscribes a user to a thread.\n   * @param params.roomId The room ID of the thread.\n   * @param params.threadId The thread ID to subscribe to.\n   * @param params.data.userId The user ID of the user to subscribe to the thread.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   * @returns The thread subscription.\n   */\n  async subscribeToThread(params, options) {\n    const { roomId, threadId } = params;\n    const res = await this.#post(\n      url2`/v2/rooms/${roomId}/threads/${threadId}/subscribe`,\n      { userId: params.data.userId },\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    return convertToSubscriptionData(\n      await res.json()\n    );\n  }\n  /**\n   * Unsubscribes a user from a thread.\n   * @param params.roomId The room ID of the thread.\n   * @param params.threadId The thread ID to unsubscribe from.\n   * @param params.data.userId The user ID of the user to unsubscribe from the thread.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   */\n  async unsubscribeFromThread(params, options) {\n    const { roomId, threadId } = params;\n    const res = await this.#post(\n      url2`/v2/rooms/${roomId}/threads/${threadId}/unsubscribe`,\n      { userId: params.data.userId },\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n  }\n  /**\n   * Updates the metadata of the specified thread in a room.\n   * @param params.roomId The room ID to update the thread in.\n   * @param params.threadId The thread ID to update.\n   * @param params.data.metadata The metadata for the thread. Value must be a string, boolean or number\n   * @param params.data.userId The user ID of the user who updated the thread.\n   * @param params.data.updatedAt (optional) The date the thread is set to be updated.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   * @returns The updated thread metadata.\n   */\n  async editThreadMetadata(params, options) {\n    const { roomId, threadId, data } = params;\n    const res = await this.#post(\n      url2`/v2/rooms/${roomId}/threads/${threadId}/metadata`,\n      {\n        ...data,\n        updatedAt: data.updatedAt?.toISOString()\n      },\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    return await res.json();\n  }\n  /**\n   * Updates the metadata of the specified comment in a room.\n   * @param params.roomId The room ID to update the comment in.\n   * @param params.threadId The thread ID to update the comment in.\n   * @param params.commentId The comment ID to update.\n   * @param params.data.metadata The metadata for the comment. Value must be a string, boolean or number. Use null to delete a key.\n   * @param params.data.userId The user ID of the user who updated the comment.\n   * @param params.data.updatedAt (optional) The date the comment metadata is set to be updated.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   * @returns The updated comment metadata.\n   */\n  async editCommentMetadata(params, options) {\n    const { roomId, threadId, commentId, data } = params;\n    const res = await this.#post(\n      url2`/v2/rooms/${roomId}/threads/${threadId}/comments/${commentId}/metadata`,\n      {\n        ...data,\n        updatedAt: data.updatedAt?.toISOString()\n      },\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    return await res.json();\n  }\n  /**\n   * Adds a new comment reaction to a comment.\n   * @param params.roomId The room ID to add the comment reaction in.\n   * @param params.threadId The thread ID to add the comment reaction in.\n   * @param params.commentId The comment ID to add the reaction in.\n   * @param params.data.emoji The (emoji) reaction to add.\n   * @param params.data.userId The user ID of the user associated with the reaction.\n   * @param params.data.createdAt (optional) The date the reaction is set to be created.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   * @returns The created comment reaction.\n   */\n  async addCommentReaction(params, options) {\n    const { roomId, threadId, commentId, data } = params;\n    const res = await this.#post(\n      url2`/v2/rooms/${roomId}/threads/${threadId}/comments/${commentId}/add-reaction`,\n      {\n        ...data,\n        createdAt: data.createdAt?.toISOString()\n      },\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    const reaction = await res.json();\n    return convertToCommentUserReaction(reaction);\n  }\n  /**\n   * Removes a reaction from a comment.\n   * @param params.roomId The room ID to remove the comment reaction from.\n   * @param params.threadId The thread ID to remove the comment reaction from.\n   * @param params.commentId The comment ID to remove the reaction from.\n   * @param params.data.emoji The (emoji) reaction to remove.\n   * @param params.data.userId The user ID of the user associated with the reaction.\n   * @param params.data.removedAt (optional) The date the reaction is set to be removed.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   */\n  async removeCommentReaction(params, options) {\n    const { roomId, threadId, data } = params;\n    const res = await this.#post(\n      url2`/v2/rooms/${roomId}/threads/${threadId}/comments/${params.commentId}/remove-reaction`,\n      {\n        ...data,\n        removedAt: data.removedAt?.toISOString()\n      },\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n  }\n  /**\n   * Returns the inbox notifications for a user.\n   * @param params.userId The user ID to get the inbox notifications from.\n   * @param params.inboxNotificationId The ID of the inbox notification to get.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   */\n  async getInboxNotification(params, options) {\n    const { userId, inboxNotificationId } = params;\n    const res = await this.#get(\n      url2`/v2/users/${userId}/inbox-notifications/${inboxNotificationId}`,\n      void 0,\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    return convertToInboxNotificationData(\n      await res.json()\n    );\n  }\n  /**\n   * Returns the inbox notifications for a user.\n   * @param params.userId The user ID to get the inbox notifications from.\n   * @param params.query The query to filter inbox notifications by. It is based on our query language and can filter by unread.\n   * @param params.organizationId (optional) The organization ID to get the inbox notifications for.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   */\n  async getInboxNotifications(params, options) {\n    const { userId, tenantId, organizationId, limit, startingAfter } = params;\n    let query;\n    if (typeof params.query === \"string\") {\n      query = params.query;\n    } else if (typeof params.query === \"object\") {\n      query = objectToQuery(params.query);\n    }\n    const queryParams = {\n      query,\n      limit,\n      startingAfter\n    };\n    if (organizationId !== void 0) {\n      queryParams.organizationId = organizationId;\n    } else if (tenantId !== void 0) {\n      queryParams.organizationId = tenantId;\n    }\n    const res = await this.#get(\n      url2`/v2/users/${userId}/inbox-notifications`,\n      queryParams,\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    const page = await res.json();\n    return {\n      ...page,\n      data: page.data.map(convertToInboxNotificationData)\n    };\n  }\n  /**\n   * Iterates over all inbox notifications for a user.\n   *\n   * The difference with .getInboxNotifications() is that pagination will\n   * happen automatically under the hood, using the given `pageSize`.\n   *\n   * @param criteria.userId The user ID to get the inbox notifications from.\n   * @param criteria.query The query to filter inbox notifications by. It is based on our query language and can filter by unread.\n   * @param criteria.organizationId (optional) The organization ID to get the inbox notifications for.\n   * @param options.pageSize (optional) The page size to use for each request.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   */\n  async *iterInboxNotifications(criteria, options) {\n    const { signal } = options ?? {};\n    const pageSize = checkBounds(\"pageSize\", options?.pageSize ?? 50, 10);\n    let cursor = void 0;\n    while (true) {\n      const { nextCursor, data } = await this.getInboxNotifications(\n        { ...criteria, startingAfter: cursor, limit: pageSize },\n        { signal }\n      );\n      for (const item of data) {\n        yield item;\n      }\n      if (!nextCursor) {\n        break;\n      }\n      cursor = nextCursor;\n    }\n  }\n  /**\n   * Returns all room subscription settings for a user.\n   * @param params.userId The user ID to get the room subscription settings from.\n   * @param params.organizationId (optional) The organization ID to get the room subscription settings for.\n   * @param params.startingAfter (optional) The cursor to start the pagination from.\n   * @param params.limit (optional) The number of items to return.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   */\n  async getUserRoomSubscriptionSettings(params, options) {\n    const { userId, tenantId, organizationId, startingAfter, limit } = params;\n    const queryParams = {\n      startingAfter,\n      limit\n    };\n    if (organizationId !== void 0) {\n      queryParams.organizationId = organizationId;\n    } else if (tenantId !== void 0) {\n      queryParams.organizationId = tenantId;\n    }\n    const res = await this.#get(\n      url2`/v2/users/${userId}/room-subscription-settings`,\n      queryParams,\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    return await res.json();\n  }\n  /**\n   * Gets the user's room subscription settings.\n   * @param params.userId The user ID to get the room subscription settings from.\n   * @param params.roomId The room ID to get the room subscription settings from.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   */\n  async getRoomSubscriptionSettings(params, options) {\n    const { userId, roomId } = params;\n    const res = await this.#get(\n      url2`/v2/rooms/${roomId}/users/${userId}/subscription-settings`,\n      void 0,\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    return await res.json();\n  }\n  /**\n   * Updates the user's room subscription settings.\n   * @param params.userId The user ID to update the room subscription settings for.\n   * @param params.roomId The room ID to update the room subscription settings for.\n   * @param params.data The new room subscription settings for the user.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   */\n  async updateRoomSubscriptionSettings(params, options) {\n    const { userId, roomId, data } = params;\n    const res = await this.#post(\n      url2`/v2/rooms/${roomId}/users/${userId}/subscription-settings`,\n      data,\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    return await res.json();\n  }\n  /**\n   * Delete the user's room subscription settings.\n   * @param params.userId The user ID to delete the room subscription settings from.\n   * @param params.roomId The room ID to delete the room subscription settings from.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   */\n  async deleteRoomSubscriptionSettings(params, options) {\n    const { userId, roomId } = params;\n    const res = await this.#delete(\n      url2`/v2/rooms/${roomId}/users/${userId}/subscription-settings`,\n      void 0,\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n  }\n  /**\n   * Update a room ID.\n   * @param params.roomId The current ID of the room.\n   * @param params.newRoomId The new room ID.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   */\n  async updateRoomId(params, options) {\n    const { currentRoomId, newRoomId } = params;\n    const res = await this.#post(\n      url2`/v2/rooms/${currentRoomId}/update-room-id`,\n      { newRoomId },\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    const data = await res.json();\n    return inflateRoomData(data);\n  }\n  /**\n   * Triggers an inbox notification for a user.\n   * @param params.userId The user ID to trigger the inbox notification for.\n   * @param params.kind The kind of inbox notification to trigger.\n   * @param params.subjectId The subject ID of the triggered inbox notification.\n   * @param params.activityData The activity data of the triggered inbox notification.\n   * @param params.roomId (optional) The room ID to trigger the inbox notification for.\n   * @param params.organizationId (optional) The organization ID to trigger the inbox notification for.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   */\n  async triggerInboxNotification(params, options) {\n    const { tenantId, organizationId, ...restParams } = params;\n    const body = {\n      ...restParams\n    };\n    if (organizationId !== void 0) {\n      body.organizationId = organizationId;\n    } else if (tenantId !== void 0) {\n      body.organizationId = tenantId;\n    }\n    const res = await this.#post(\n      url2`/v2/inbox-notifications/trigger`,\n      body,\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n  }\n  /**\n   * Deletes an inbox notification for a user.\n   * @param params.userId The user ID for which to delete the inbox notification.\n   * @param params.inboxNotificationId The ID of the inbox notification to delete.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   */\n  async deleteInboxNotification(params, options) {\n    const { userId, inboxNotificationId } = params;\n    const res = await this.#delete(\n      url2`/v2/users/${userId}/inbox-notifications/${inboxNotificationId}`,\n      void 0,\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n  }\n  /**\n   * Deletes all inbox notifications for a user.\n   * @param params.userId The user ID for which to delete all the inbox notifications.\n   * @param params.organizationId (optional) The organization ID to delete the inbox notifications for.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   */\n  async deleteAllInboxNotifications(params, options) {\n    const { userId, tenantId, organizationId } = params;\n    const queryParams = {};\n    if (organizationId !== void 0) {\n      queryParams.organizationId = organizationId;\n    } else if (tenantId !== void 0) {\n      queryParams.organizationId = tenantId;\n    }\n    const res = await this.#delete(\n      url2`/v2/users/${userId}/inbox-notifications`,\n      queryParams,\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n  }\n  /**\n   * Get notification settings for a user for a project.\n   * @param params.userId The user ID to get the notifications settings for.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   */\n  async getNotificationSettings(params, options) {\n    const { userId } = params;\n    const res = await this.#get(\n      url2`/v2/users/${userId}/notification-settings`,\n      void 0,\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    const plainSettings = await res.json();\n    const settings = createNotificationSettings(plainSettings);\n    return settings;\n  }\n  /**\n   * Update the user's notification settings.\n   * @param params.userId The user ID to update the notification settings for.\n   * @param params.data The new notification settings for the user.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   */\n  async updateNotificationSettings(params, options) {\n    const { userId, data } = params;\n    const res = await this.#post(\n      url2`/v2/users/${userId}/notification-settings`,\n      data,\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    const plainSettings = await res.json();\n    const settings = createNotificationSettings(plainSettings);\n    return settings;\n  }\n  /**\n   * Delete the user's notification settings\n   * @param params.userId The user ID to update the notification settings for.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   */\n  async deleteNotificationSettings(params, options) {\n    const { userId } = params;\n    const res = await this.#delete(\n      url2`/v2/users/${userId}/notification-settings`,\n      void 0,\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n  }\n  /**\n   * Create a group\n   * @param params.groupId The ID of the group to create.\n   * @param params.memberIds The IDs of the members to add to the group.\n   * @param params.organizationId (optional) The organization ID to create the group for.\n   * @param params.scopes (optional) The scopes to grant to the group. The default is `{ mention: true }`.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   */\n  async createGroup(params, options) {\n    const { tenantId, organizationId, ...restParams } = params;\n    const body = {\n      ...restParams,\n      // The REST API uses `id` since a group is a resource,\n      // but we use `groupId` here for consistency with the other methods.\n      id: params.groupId\n    };\n    if (organizationId !== void 0) {\n      body.organizationId = organizationId;\n    } else if (tenantId !== void 0) {\n      body.organizationId = tenantId;\n    }\n    const res = await this.#post(url2`/v2/groups`, body, options);\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    const group = await res.json();\n    return convertToGroupData(group);\n  }\n  /**\n   * Get a group\n   * @param params.groupId The ID of the group to get.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   */\n  async getGroup(params, options) {\n    const res = await this.#get(\n      url2`/v2/groups/${params.groupId}`,\n      void 0,\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    const group = await res.json();\n    return convertToGroupData(group);\n  }\n  /**\n   * Add members to a group\n   * @param params.groupId The ID of the group to add members to.\n   * @param params.memberIds The IDs of the members to add to the group.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   */\n  async addGroupMembers(params, options) {\n    const res = await this.#post(\n      url2`/v2/groups/${params.groupId}/add-members`,\n      { memberIds: params.memberIds },\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    const group = await res.json();\n    return convertToGroupData(group);\n  }\n  /**\n   * Remove members from a group\n   * @param params.groupId The ID of the group to remove members from.\n   * @param params.memberIds The IDs of the members to remove from the group.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   */\n  async removeGroupMembers(params, options) {\n    const res = await this.#post(\n      url2`/v2/groups/${params.groupId}/remove-members`,\n      { memberIds: params.memberIds },\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    const group = await res.json();\n    return convertToGroupData(group);\n  }\n  /**\n   * Delete a group\n   * @param params.groupId The ID of the group to delete.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   */\n  async deleteGroup(params, options) {\n    const res = await this.#delete(\n      url2`/v2/groups/${params.groupId}`,\n      void 0,\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n  }\n  /**\n   * Get all groups\n   * @param params.limit (optional) The number of groups to return.\n   * @param params.startingAfter (optional) The cursor to start the pagination from.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   */\n  async getGroups(params, options) {\n    const res = await this.#get(\n      url2`/v2/groups`,\n      { startingAfter: params?.startingAfter, limit: params?.limit },\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    const page = await res.json();\n    return {\n      ...page,\n      data: page.data.map(convertToGroupData)\n    };\n  }\n  /**\n   * Returns all groups a user is a member of.\n   * @param params.userId The user ID to get the groups for.\n   * @param params.startingAfter (optional) The cursor to start the pagination from.\n   * @param params.limit (optional) The number of items to return.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   */\n  async getUserGroups(params, options) {\n    const { userId, startingAfter, limit } = params;\n    const res = await this.#get(\n      url2`/v2/users/${userId}/groups`,\n      { startingAfter, limit },\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    const page = await res.json();\n    return {\n      ...page,\n      data: page.data.map(convertToGroupData)\n    };\n  }\n  /**\n   * Retrieves the current Storage contents for the given room ID and calls the\n   * provided callback function, in which you can mutate the Storage contents\n   * at will.\n   *\n   * If you need to run the same mutation across multiple rooms, prefer using\n   * `.massMutateStorage()` instead of looping over room IDs yourself.\n   */\n  async mutateStorage(roomId, callback, options) {\n    return this.#_mutateOneRoom(roomId, void 0, callback, options);\n  }\n  /**\n   * Retrieves the Storage contents for each room that matches the given\n   * criteria and calls the provided callback function, in which you can mutate\n   * the Storage contents at will.\n   *\n   * You can use the `criteria` parameter to select which rooms to process by\n   * their metadata. If you pass `{}` (empty object), all rooms will be\n   * selected and processed.\n   *\n   * This method will execute mutations in parallel, using the specified\n   * `concurrency` value. If you which to run the mutations serially, set\n   * `concurrency` to 1.\n   */\n  async massMutateStorage(criteria, callback, massOptions) {\n    const concurrency = checkBounds(\n      \"concurrency\",\n      massOptions?.concurrency ?? 8,\n      1,\n      20\n    );\n    const pageSize = Math.max(20, concurrency * 4);\n    const { signal } = massOptions ?? {};\n    const rooms = this.iterRooms(criteria, { pageSize, signal });\n    const options = { signal };\n    await runConcurrently(\n      rooms,\n      (roomData) => this.#_mutateOneRoom(roomData.id, roomData, callback, options),\n      concurrency\n    );\n  }\n  async #_mutateOneRoom(roomId, room, callback, options) {\n    const debounceInterval = 200;\n    const { signal, abort } = makeAbortController(options?.signal);\n    let opsBuffer = [];\n    let outstandingFlush$ = void 0;\n    let lastFlush = performance.now();\n    const flushIfNeeded = (force) => {\n      if (opsBuffer.length === 0)\n        return;\n      if (outstandingFlush$) {\n        return;\n      }\n      const now = performance.now();\n      if (!(force || now - lastFlush > debounceInterval)) {\n        return;\n      }\n      lastFlush = now;\n      const ops = opsBuffer;\n      opsBuffer = [];\n      outstandingFlush$ = this.#sendMessage(\n        roomId,\n        [{ type: ClientMsgCode.UPDATE_STORAGE, ops }],\n        { signal }\n      ).catch((err) => {\n        abort(err);\n      }).finally(() => {\n        outstandingFlush$ = void 0;\n      });\n    };\n    try {\n      const resp = await this.#requestStorageMutation(roomId, { signal });\n      const { actor, nodes } = resp;\n      const pool = createManagedPool(roomId, {\n        getCurrentConnectionId: () => actor,\n        onDispatch: (ops, _reverse, _storageUpdates) => {\n          if (ops.length === 0) return;\n          for (const op of ops) {\n            opsBuffer.push(op);\n          }\n          flushIfNeeded(\n            /* force */\n            false\n          );\n        }\n      });\n      const root = LiveObject._fromItems(nodes, pool);\n      const callback$ = callback({ room, root });\n      flushIfNeeded(\n        /* force */\n        true\n      );\n      await callback$;\n    } catch (e) {\n      abort();\n      throw e;\n    } finally {\n      await outstandingFlush$;\n      flushIfNeeded(\n        /* force */\n        true\n      );\n      await outstandingFlush$;\n    }\n  }\n  async #sendMessage(roomId, messages, options) {\n    const res = await this.#post(\n      url2`/v2/rooms/${roomId}/send-message`,\n      { messages },\n      { signal: options?.signal }\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n  }\n  /**\n   * Returns a paginated list of AI copilots. The copilots are returned sorted by creation date, from newest to oldest.\n   * @param params.limit (optional) A limit on the number of copilots to return. The limit can range between 1 and 100, and defaults to 20.\n   * @param params.startingAfter (optional) A cursor used for pagination. You get the value from the response of the previous page.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   * @returns A paginated list of AI copilots.\n   */\n  async getAiCopilots(params = {}, options) {\n    const res = await this.#get(\n      url2`/v2/ai/copilots`,\n      {\n        limit: params.limit,\n        startingAfter: params.startingAfter\n      },\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    const page = await res.json();\n    return {\n      ...page,\n      data: page.data.map(inflateAiCopilot)\n    };\n  }\n  /**\n   * Creates an AI copilot.\n   * @param params The parameters to create the copilot with.\n   * @returns The created copilot.\n   */\n  async createAiCopilot(params, options) {\n    const res = await this.#post(url2`/v2/ai/copilots`, params, options);\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    const data = await res.json();\n    return inflateAiCopilot(data);\n  }\n  /**\n   * Returns an AI copilot with the given id.\n   * @param copilotId The id of the copilot to return.\n   * @returns The copilot with the given id.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   */\n  async getAiCopilot(copilotId, options) {\n    const res = await this.#get(\n      url2`/v2/ai/copilots/${copilotId}`,\n      void 0,\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    const data = await res.json();\n    return inflateAiCopilot(data);\n  }\n  /**\n   * Updates an AI copilot with the given id.\n   * @param copilotId The id of the copilot to update.\n   * @param params The parameters to update the copilot with.\n   * @returns The updated copilot.\n   */\n  async updateAiCopilot(copilotId, params, options) {\n    const res = await this.#post(\n      url2`/v2/ai/copilots/${copilotId}`,\n      params,\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    const data = await res.json();\n    return inflateAiCopilot(data);\n  }\n  /**\n   * Deletes an AI copilot with the given id. A deleted copilot is no longer accessible from the API or the dashboard and it cannot be restored.\n   * @param copilotId The id of the copilot to delete.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   */\n  async deleteAiCopilot(copilotId, options) {\n    const res = await this.#delete(\n      url2`/v2/ai/copilots/${copilotId}`,\n      void 0,\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n  }\n  /**\n   * Creates a web knowledge source.\n   * @param params.url The URL of the web knowledge source.\n   * @param params.type The type of the web knowledge source: \"individual_link\", \"crawl\" or \"sitemap\".\n   * @param options.signal (optional) An abort signal to cancel the request.\n   * @returns The id of the created web knowledge source.\n   */\n  async createWebKnowledgeSource(params, options) {\n    const res = await this.#post(\n      url2`/v2/ai/copilots/${params.copilotId}/knowledge/web`,\n      params,\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    const data = await res.json();\n    return data;\n  }\n  /**\n   * Creates a file knowledge source.\n   * @param params.copilotId The id of the copilot.\n   * @param params.name The name of the file knowledge source.\n   * @param params.file The file to create the knowledge source from.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   * @returns The id of the created file knowledge source.\n   */\n  async createFileKnowledgeSource(params, options) {\n    const fetch = await fetchPolyfill();\n    const res = await fetch(\n      urljoin(\n        this.#baseUrl,\n        url2`/v2/ai/copilots/${params.copilotId}/knowledge/file/${params.file.name}`\n      ),\n      {\n        method: \"PUT\",\n        body: params.file,\n        headers: {\n          Authorization: `Bearer ${this.#secret}`,\n          \"Content-Type\": params.file.type,\n          \"Content-Length\": String(params.file.size)\n        },\n        signal: options?.signal\n      }\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    const data = await res.json();\n    return data;\n  }\n  /**\n   * Deletes a file knowledge source.\n   * @param params.copilotId The id of the copilot.\n   * @param params.knowledgeSourceId The id of the knowledge source to delete.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   */\n  async deleteFileKnowledgeSource(params, options) {\n    const res = await this.#delete(\n      url2`/v2/ai/copilots/${params.copilotId}/knowledge/file/${params.knowledgeSourceId}`,\n      void 0,\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n  }\n  /**\n   * Deletes a web knowledge source.\n   * @param params.copilotId The id of the copilot.\n   * @param params.knowledgeSourceId The id of the knowledge source to delete.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   */\n  async deleteWebKnowledgeSource(params, options) {\n    const res = await this.#delete(\n      url2`/v2/ai/copilots/${params.copilotId}/knowledge/web/${params.knowledgeSourceId}`,\n      void 0,\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n  }\n  /**\n   * Returns a paginated list of knowledge sources.\n   * @param params.copilotId The id of the copilot.\n   * @param params.limit (optional) A limit on the number of knowledge sources to return. The limit can range between 1 and 100, and defaults to 20.\n   * @param params.startingAfter (optional) A cursor used for pagination. You get the value from the response of the previous page.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   * @returns A paginated list of knowledge sources.\n   */\n  async getKnowledgeSources(params, options) {\n    const res = await this.#get(\n      url2`/v2/ai/copilots/${params.copilotId}/knowledge`,\n      {\n        limit: params.limit,\n        startingAfter: params.startingAfter\n      },\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    const page = await res.json();\n    return {\n      ...page,\n      data: page.data.map(inflateKnowledgeSource)\n    };\n  }\n  /**\n   * Returns a knowledge source with the given id.\n   * @param params.copilotId The id of the copilot.\n   * @param params.knowledgeSourceId The id of the knowledge source to return.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   * @returns The knowledge source.\n   */\n  async getKnowledgeSource(params, options) {\n    const res = await this.#get(\n      url2`/v2/ai/copilots/${params.copilotId}/knowledge/${params.knowledgeSourceId}`,\n      void 0,\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    const data = await res.json();\n    return inflateKnowledgeSource(data);\n  }\n  /**\n   * Returns the content of a file knowledge source.\n   * @param params.copilotId The id of the copilot.\n   * @param params.knowledgeSourceId The id of the knowledge source.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   * @returns The content of the file knowledge source.\n   */\n  async getFileKnowledgeSourceMarkdown(params, options) {\n    const res = await this.#get(\n      url2`/v2/ai/copilots/${params.copilotId}/knowledge/file/${params.knowledgeSourceId}`,\n      void 0,\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    const data = await res.json();\n    return data.content;\n  }\n  /**\n   * Returns a paginated list of web knowledge source links.\n   * @param params.copilotId The id of the copilot.\n   * @param params.knowledgeSourceId The id of the knowledge source.\n   * @param params.limit (optional) A limit on the number of links to return. The limit can range between 1 and 100, and defaults to 20.\n   * @param params.startingAfter (optional) A cursor used for pagination. You get the value from the response of the previous page.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   * @returns A paginated list of web knowledge source links.\n   */\n  async getWebKnowledgeSourceLinks(params, options) {\n    const res = await this.#get(\n      url2`/v2/ai/copilots/${params.copilotId}/knowledge/web/${params.knowledgeSourceId}/links`,\n      {\n        limit: params.limit,\n        startingAfter: params.startingAfter\n      },\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    const page = await res.json();\n    return {\n      ...page,\n      data: page.data.map(inflateWebKnowledgeSourceLink)\n    };\n  }\n};\nvar LiveblocksError = class _LiveblocksError extends Error {\n  status;\n  details;\n  constructor(message, status, details) {\n    super(message);\n    this.name = \"LiveblocksError\";\n    this.status = status;\n    this.details = details;\n  }\n  toString() {\n    let msg = `${this.name}: ${this.message} (status ${this.status})`;\n    if (this.details) {\n      msg += `\n${this.details}`;\n    }\n    return msg;\n  }\n  static async from(res) {\n    const origErrLocation = new Error();\n    Error.captureStackTrace(origErrLocation, _LiveblocksError.from);\n    const FALLBACK = \"An error happened without an error message\";\n    let text;\n    try {\n      text = await res.text();\n    } catch {\n      text = FALLBACK;\n    }\n    const obj = tryParseJson(text) ?? { message: text };\n    const message = obj.message || FALLBACK;\n    const details = [\n      obj.suggestion ? `Suggestion: ${String(obj.suggestion)}` : void 0,\n      obj.docs ? `See also: ${String(obj.docs)}` : void 0\n    ].filter(Boolean).join(\"\\n\") || void 0;\n    const err = new _LiveblocksError(message, res.status, details);\n    err.stack = origErrLocation.stack;\n    return err;\n  }\n};\n\n// src/webhooks.ts\nimport * as base64 from \"@stablelib/base64\";\nimport * as sha256 from \"fast-sha256\";\nvar WebhookHandler = class _WebhookHandler {\n  #secretBuffer;\n  static #secretPrefix = \"whsec_\";\n  constructor(secret) {\n    if (!secret) throw new Error(\"Secret is required\");\n    if (typeof secret !== \"string\") throw new Error(\"Secret must be a string\");\n    if (secret.startsWith(_WebhookHandler.#secretPrefix) === false)\n      throw new Error(\"Invalid secret, must start with whsec_\");\n    const secretKey = secret.slice(_WebhookHandler.#secretPrefix.length);\n    this.#secretBuffer = Buffer.from(secretKey, \"base64\");\n  }\n  /**\n   * Verifies a webhook request and returns the event\n   */\n  verifyRequest(request) {\n    const { headers, rawBody } = request;\n    const { webhookId, timestamp, rawSignatures } = this.#verifyHeaders(headers);\n    if (typeof rawBody !== \"string\") {\n      throw new Error(\n        `Invalid rawBody field, must be a string, got \"${typeof rawBody}\" instead. It is likely that you need to JSON.stringify the body before passing it.`\n      );\n    }\n    this.#verifyTimestamp(timestamp);\n    const signature = this.#sign(`${webhookId}.${timestamp}.${rawBody}`);\n    const expectedSignatures = rawSignatures.split(\" \").map((rawSignature) => {\n      const [, parsedSignature] = rawSignature.split(\",\");\n      return parsedSignature;\n    }).filter(isNotUndefined);\n    if (expectedSignatures.includes(signature) === false)\n      throw new Error(\n        `Invalid signature, expected one of ${expectedSignatures.join(\n          \", \"\n        )}, got ${signature}`\n      );\n    const event = JSON.parse(rawBody);\n    this.#verifyWebhookEventType(event);\n    return event;\n  }\n  /**\n   * Verifies the headers and returns the webhookId, timestamp and rawSignatures\n   */\n  #verifyHeaders(headers) {\n    const usingNativeHeaders = typeof Headers !== \"undefined\" && headers instanceof Headers;\n    const normalizedHeaders = usingNativeHeaders ? Object.fromEntries(headers) : headers;\n    const sanitizedHeaders = {};\n    Object.keys(normalizedHeaders).forEach((key) => {\n      sanitizedHeaders[key.toLowerCase()] = normalizedHeaders[key];\n    });\n    const webhookId = sanitizedHeaders[\"webhook-id\"];\n    if (typeof webhookId !== \"string\")\n      throw new Error(\"Invalid webhook-id header\");\n    const timestamp = sanitizedHeaders[\"webhook-timestamp\"];\n    if (typeof timestamp !== \"string\")\n      throw new Error(\"Invalid webhook-timestamp header\");\n    const rawSignatures = sanitizedHeaders[\"webhook-signature\"];\n    if (typeof rawSignatures !== \"string\")\n      throw new Error(\"Invalid webhook-signature header\");\n    return { webhookId, timestamp, rawSignatures };\n  }\n  /**\n   * Signs the content with the secret\n   * @param content\n   * @returns `string`\n   */\n  #sign(content) {\n    const encoder = new TextEncoder();\n    const toSign = encoder.encode(content);\n    return base64.encode(sha256.hmac(this.#secretBuffer, toSign));\n  }\n  /**\n   * Verifies that the timestamp is not too old or in the future\n   */\n  #verifyTimestamp(timestampHeader) {\n    const now = Math.floor(Date.now() / 1e3);\n    const timestamp = parseInt(timestampHeader, 10);\n    if (isNaN(timestamp)) {\n      throw new Error(\"Invalid timestamp\");\n    }\n    if (timestamp < now - WEBHOOK_TOLERANCE_IN_SECONDS) {\n      throw new Error(\"Timestamp too old\");\n    }\n    if (timestamp > now + WEBHOOK_TOLERANCE_IN_SECONDS) {\n      throw new Error(\"Timestamp in the future\");\n    }\n  }\n  /**\n   * Ensures that the event is a known event type\n   * or throws and prompts the user to upgrade to a higher version of @liveblocks/node\n   */\n  #verifyWebhookEventType(event) {\n    if (event && event.type && [\n      \"storageUpdated\",\n      \"userEntered\",\n      \"userLeft\",\n      \"roomCreated\",\n      \"roomDeleted\",\n      \"commentCreated\",\n      \"commentEdited\",\n      \"commentDeleted\",\n      \"commentReactionAdded\",\n      \"commentReactionRemoved\",\n      \"commentMetadataUpdated\",\n      \"threadMetadataUpdated\",\n      \"threadCreated\",\n      \"threadDeleted\",\n      \"ydocUpdated\",\n      \"notification\",\n      \"threadMarkedAsResolved\",\n      \"threadMarkedAsUnresolved\"\n    ].includes(event.type)) {\n      if (event.type === \"notification\") {\n        const notification = event;\n        if (notification.data.kind === \"thread\" || notification.data.kind === \"textMention\" || isCustomKind(notification.data.kind)) {\n          return;\n        } else {\n          throw new Error(\n            `Unknown notification kind: ${JSON.stringify(notification.data.kind)}`\n          );\n        }\n      }\n      return;\n    }\n    throw new Error(\n      \"Unknown event type, please upgrade to a higher version of @liveblocks/node\"\n    );\n  }\n};\nvar WEBHOOK_TOLERANCE_IN_SECONDS = 5 * 60;\nvar isNotUndefined = (value) => value !== void 0;\nvar isCustomKind = (value) => {\n  return isString(value) && value.startsWith(\"$\");\n};\nfunction isThreadNotificationEvent(event) {\n  return event.type === \"notification\" && event.data.kind === \"thread\";\n}\nfunction isTextMentionNotificationEvent(event) {\n  return event.type === \"notification\" && event.data.kind === \"textMention\";\n}\nfunction isCustomNotificationEvent(event) {\n  return event.type === \"notification\" && isCustomKind(event.data.kind);\n}\n\n// src/index.ts\nimport {\n  getMentionsFromCommentBody,\n  isNotificationChannelEnabled,\n  LiveList,\n  LiveMap,\n  LiveObject as LiveObject2,\n  stringifyCommentBody\n} from \"@liveblocks/core\";\ndetectDupes(PKG_NAME, PKG_VERSION, PKG_FORMAT);\nexport {\n  LiveList,\n  LiveMap,\n  LiveObject2 as LiveObject,\n  Liveblocks,\n  LiveblocksError,\n  WebhookHandler,\n  getMentionsFromCommentBody,\n  isCustomNotificationEvent,\n  isNotificationChannelEnabled,\n  isTextMentionNotificationEvent,\n  isThreadNotificationEvent,\n  stringifyCommentBody\n};\n//# sourceMappingURL=index.js.map"],"names":[],"mappings":"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","ignoreList":[1,2,3,5]}