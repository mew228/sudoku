(globalThis.TURBOPACK || (globalThis.TURBOPACK = [])).push([typeof document === "object" ? document.currentScript : undefined,
"[project]/node_modules/@liveblocks/react/dist/chunk-SVZO3VVV.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ClientContext",
    ()=>ClientContext,
    "LiveblocksProvider",
    ()=>LiveblocksProvider,
    "RegisterAiKnowledge",
    ()=>RegisterAiKnowledge,
    "RegisterAiTool",
    ()=>RegisterAiTool,
    "RoomContext",
    ()=>RoomContext,
    "_RoomProvider",
    ()=>_RoomProvider,
    "_useAddReaction",
    ()=>_useAddReaction,
    "_useAiChat",
    ()=>_useAiChat,
    "_useAiChatMessages",
    ()=>_useAiChatMessages,
    "_useAiChatMessagesSuspense",
    ()=>_useAiChatMessagesSuspense,
    "_useAiChatSuspense",
    ()=>_useAiChatSuspense,
    "_useAiChats",
    ()=>_useAiChats,
    "_useAiChatsSuspense",
    ()=>_useAiChatsSuspense,
    "_useBroadcastEvent",
    ()=>_useBroadcastEvent,
    "_useCreateComment",
    ()=>_useCreateComment,
    "_useCreateThread",
    ()=>_useCreateThread,
    "_useDeleteThread",
    ()=>_useDeleteThread,
    "_useEditComment",
    ()=>_useEditComment,
    "_useEditCommentMetadata",
    ()=>_useEditCommentMetadata,
    "_useEditThreadMetadata",
    ()=>_useEditThreadMetadata,
    "_useEventListener",
    ()=>_useEventListener,
    "_useHistoryVersions",
    ()=>_useHistoryVersions,
    "_useHistoryVersionsSuspense",
    ()=>_useHistoryVersionsSuspense,
    "_useInboxNotificationThread",
    ()=>_useInboxNotificationThread,
    "_useIsInsideRoom",
    ()=>_useIsInsideRoom,
    "_useMutation",
    ()=>_useMutation,
    "_useMyPresence",
    ()=>_useMyPresence,
    "_useOther",
    ()=>_useOther,
    "_useOtherSuspense",
    ()=>_useOtherSuspense,
    "_useOthers",
    ()=>_useOthers,
    "_useOthersListener",
    ()=>_useOthersListener,
    "_useOthersMapped",
    ()=>_useOthersMapped,
    "_useOthersMappedSuspense",
    ()=>_useOthersMappedSuspense,
    "_useOthersSuspense",
    ()=>_useOthersSuspense,
    "_useRoom",
    ()=>_useRoom,
    "_useRoomSubscriptionSettings",
    ()=>_useRoomSubscriptionSettings,
    "_useRoomSubscriptionSettingsSuspense",
    ()=>_useRoomSubscriptionSettingsSuspense,
    "_useSearchComments",
    ()=>_useSearchComments,
    "_useSelf",
    ()=>_useSelf,
    "_useSelfSuspense",
    ()=>_useSelfSuspense,
    "_useStorage",
    ()=>_useStorage,
    "_useStorageRoot",
    ()=>_useStorageRoot,
    "_useStorageSuspense",
    ()=>_useStorageSuspense,
    "_useThreads",
    ()=>_useThreads,
    "_useThreadsSuspense",
    ()=>_useThreadsSuspense,
    "_useUpdateMyPresence",
    ()=>_useUpdateMyPresence,
    "_useUrlMetadata",
    ()=>_useUrlMetadata,
    "_useUrlMetadataSuspense",
    ()=>_useUrlMetadataSuspense,
    "_useUser",
    ()=>_useUser,
    "_useUserSuspense",
    ()=>_useUserSuspense,
    "_useUserThreadsSuspense_experimental",
    ()=>_useUserThreadsSuspense_experimental,
    "_useUserThreads_experimental",
    ()=>_useUserThreads_experimental,
    "createLiveblocksContext",
    ()=>createLiveblocksContext,
    "createRoomContext",
    ()=>createRoomContext,
    "getUmbrellaStoreForClient",
    ()=>getUmbrellaStoreForClient,
    "useAddRoomCommentReaction",
    ()=>useAddRoomCommentReaction,
    "useAiChatStatus",
    ()=>useAiChatStatus,
    "useAttachmentUrl",
    ()=>useAttachmentUrl,
    "useAttachmentUrlSuspense",
    ()=>useAttachmentUrlSuspense,
    "useCanRedo",
    ()=>useCanRedo,
    "useCanUndo",
    ()=>useCanUndo,
    "useClient",
    ()=>useClient,
    "useClientOrNull",
    ()=>useClientOrNull,
    "useCreateAiChat",
    ()=>useCreateAiChat,
    "useCreateRoomComment",
    ()=>useCreateRoomComment,
    "useCreateRoomThread",
    ()=>useCreateRoomThread,
    "useCreateTextMention",
    ()=>useCreateTextMention,
    "useDeleteAiChat",
    ()=>useDeleteAiChat,
    "useDeleteAllInboxNotifications",
    ()=>useDeleteAllInboxNotifications,
    "useDeleteComment",
    ()=>useDeleteComment,
    "useDeleteInboxNotification",
    ()=>useDeleteInboxNotification,
    "useDeleteRoomComment",
    ()=>useDeleteRoomComment,
    "useDeleteRoomThread",
    ()=>useDeleteRoomThread,
    "useDeleteTextMention",
    ()=>useDeleteTextMention,
    "useEditRoomComment",
    ()=>useEditRoomComment,
    "useEditRoomThreadMetadata",
    ()=>useEditRoomThreadMetadata,
    "useErrorListener",
    ()=>useErrorListener,
    "useGroupInfo",
    ()=>useGroupInfo,
    "useGroupInfoSuspense",
    ()=>useGroupInfoSuspense,
    "useHistory",
    ()=>useHistory,
    "useHistoryVersionData",
    ()=>useHistoryVersionData,
    "useInboxNotifications",
    ()=>useInboxNotifications,
    "useInboxNotificationsSuspense",
    ()=>useInboxNotificationsSuspense,
    "useLatest",
    ()=>useLatest,
    "useLostConnectionListener",
    ()=>useLostConnectionListener,
    "useMarkAllInboxNotificationsAsRead",
    ()=>useMarkAllInboxNotificationsAsRead,
    "useMarkInboxNotificationAsRead",
    ()=>useMarkInboxNotificationAsRead,
    "useMarkRoomThreadAsRead",
    ()=>useMarkRoomThreadAsRead,
    "useMarkRoomThreadAsResolved",
    ()=>useMarkRoomThreadAsResolved,
    "useMarkRoomThreadAsUnresolved",
    ()=>useMarkRoomThreadAsUnresolved,
    "useMarkThreadAsRead",
    ()=>useMarkThreadAsRead,
    "useMarkThreadAsResolved",
    ()=>useMarkThreadAsResolved,
    "useMarkThreadAsUnresolved",
    ()=>useMarkThreadAsUnresolved,
    "useMentionSuggestionsCache",
    ()=>useMentionSuggestionsCache,
    "useNotificationSettings",
    ()=>useNotificationSettings,
    "useNotificationSettingsSuspense",
    ()=>useNotificationSettingsSuspense,
    "useOthersConnectionIds",
    ()=>useOthersConnectionIds,
    "useOthersConnectionIdsSuspense",
    ()=>useOthersConnectionIdsSuspense,
    "useRedo",
    ()=>useRedo,
    "useRemoveReaction",
    ()=>useRemoveReaction,
    "useRemoveRoomCommentReaction",
    ()=>useRemoveRoomCommentReaction,
    "useReportTextEditor",
    ()=>useReportTextEditor,
    "useResolveMentionSuggestions",
    ()=>useResolveMentionSuggestions,
    "useRoomAttachmentUrl",
    ()=>useRoomAttachmentUrl,
    "useRoomInfo",
    ()=>useRoomInfo,
    "useRoomInfoSuspense",
    ()=>useRoomInfoSuspense,
    "useRoomPermissions",
    ()=>useRoomPermissions,
    "useRoomThreadSubscription",
    ()=>useRoomThreadSubscription,
    "useSendAiMessage",
    ()=>useSendAiMessage,
    "useSignal",
    ()=>useSignal,
    "useStatus",
    ()=>useStatus,
    "useSubscribeToThread",
    ()=>useSubscribeToThread,
    "useSyncExternalStoreWithSelector",
    ()=>useSyncExternalStoreWithSelector,
    "useSyncStatus",
    ()=>useSyncStatus,
    "useThreadSubscription",
    ()=>useThreadSubscription,
    "useUndo",
    ()=>useUndo,
    "useUnreadInboxNotificationsCount",
    ()=>useUnreadInboxNotificationsCount,
    "useUnreadInboxNotificationsCountSuspense",
    ()=>useUnreadInboxNotificationsCountSuspense,
    "useUnsubscribeFromThread",
    ()=>useUnsubscribeFromThread,
    "useUpdateNotificationSettings",
    ()=>useUpdateNotificationSettings,
    "useUpdateRoomSubscriptionSettings",
    ()=>useUpdateRoomSubscriptionSettings,
    "useYjsProvider",
    ()=>useYjsProvider
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
// src/contexts.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@liveblocks/core/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
// src/liveblocks.tsx
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)");
;
;
var ClientContext = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createContext"])(null);
function useClientOrNull() {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useContext"])(ClientContext);
}
function useClient() {
    return useClientOrNull() ?? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])("LiveblocksProvider is missing from the React tree.");
}
var RoomContext = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createContext"])(null);
function useRoomOrNull() {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useContext"])(RoomContext);
}
function useIsInsideRoom() {
    const room = useRoomOrNull();
    return room !== null;
}
;
function useLatest(value) {
    const ref = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(value);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useLatest.useEffect": ()=>{
            ref.current = value;
        }
    }["useLatest.useEffect"], [
        value
    ]);
    return ref;
}
;
;
function useAi() {
    return useClient()[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].ai;
}
function useRandom() {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["nanoid"])[0];
}
var RegisterAiKnowledge = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["memo"])(function RegisterAiKnowledge2(props) {
    const layerId = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useId"])();
    const ai = useAi();
    const { description, value, chatId } = props;
    const [layerKey, setLayerKey] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])();
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "RegisterAiKnowledge.RegisterAiKnowledge2.useEffect2": ()=>{
            const { layerKey: layerKey2, deregister } = ai.registerKnowledgeLayer(layerId, chatId);
            setLayerKey(layerKey2);
            return ({
                "RegisterAiKnowledge.RegisterAiKnowledge2.useEffect2": ()=>{
                    deregister();
                    setLayerKey(void 0);
                }
            })["RegisterAiKnowledge.RegisterAiKnowledge2.useEffect2"];
        }
    }["RegisterAiKnowledge.RegisterAiKnowledge2.useEffect2"], [
        ai,
        layerId,
        chatId
    ]);
    const randomKey = useRandom();
    const knowledgeKey = props.id ?? randomKey;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "RegisterAiKnowledge.RegisterAiKnowledge2.useEffect2": ()=>{
            if (layerKey !== void 0) {
                ai.updateKnowledge(layerKey, {
                    description,
                    value
                }, knowledgeKey, chatId);
            }
        }
    }["RegisterAiKnowledge.RegisterAiKnowledge2.useEffect2"], [
        ai,
        layerKey,
        knowledgeKey,
        description,
        value,
        chatId
    ]);
    return null;
});
var RegisterAiTool = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["memo"])(function RegisterAiTool2({ chatId, name, tool, enabled }) {
    const client = useClient();
    const ai = client[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].ai;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "RegisterAiTool.RegisterAiTool2.useEffect2": ()=>{
            const toolWithEnabled = enabled !== void 0 ? {
                ...tool,
                enabled
            } : tool;
            return ai.registerTool(name, toolWithEnabled, chatId);
        }
    }["RegisterAiTool.RegisterAiTool2.useEffect2"], [
        ai,
        chatId,
        name,
        tool,
        enabled
    ]);
    return null;
});
;
function is(x, y) {
    return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
}
function useSyncExternalStoreWithSelector(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {
    const instRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(null);
    let inst;
    if (instRef.current === null) {
        inst = {
            hasValue: false,
            value: null
        };
        instRef.current = inst;
    } else {
        inst = instRef.current;
    }
    const [getSelection, getServerSelection] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "useSyncExternalStoreWithSelector.useMemo": ()=>{
            let hasMemo = false;
            let memoizedSnapshot;
            let memoizedSelection;
            const memoizedSelector = {
                "useSyncExternalStoreWithSelector.useMemo.memoizedSelector": (nextSnapshot)=>{
                    if (!hasMemo) {
                        hasMemo = true;
                        memoizedSnapshot = nextSnapshot;
                        const nextSelection2 = selector(nextSnapshot);
                        if (isEqual !== void 0) {
                            if (inst.hasValue) {
                                const currentSelection = inst.value;
                                if (isEqual(currentSelection, nextSelection2)) {
                                    memoizedSelection = currentSelection;
                                    return currentSelection;
                                }
                            }
                        }
                        memoizedSelection = nextSelection2;
                        return nextSelection2;
                    }
                    const prevSnapshot = memoizedSnapshot;
                    const prevSelection = memoizedSelection;
                    if (is(prevSnapshot, nextSnapshot)) {
                        return prevSelection;
                    }
                    const nextSelection = selector(nextSnapshot);
                    if (isEqual !== void 0 && isEqual(prevSelection, nextSelection)) {
                        memoizedSnapshot = nextSnapshot;
                        return prevSelection;
                    }
                    memoizedSnapshot = nextSnapshot;
                    memoizedSelection = nextSelection;
                    return nextSelection;
                }
            }["useSyncExternalStoreWithSelector.useMemo.memoizedSelector"];
            const maybeGetServerSnapshot = getServerSnapshot === void 0 ? null : getServerSnapshot;
            const getSnapshotWithSelector = {
                "useSyncExternalStoreWithSelector.useMemo.getSnapshotWithSelector": ()=>memoizedSelector(getSnapshot())
            }["useSyncExternalStoreWithSelector.useMemo.getSnapshotWithSelector"];
            const getServerSnapshotWithSelector = maybeGetServerSnapshot === null ? void 0 : ({
                "useSyncExternalStoreWithSelector.useMemo": ()=>memoizedSelector(maybeGetServerSnapshot())
            })["useSyncExternalStoreWithSelector.useMemo"];
            return [
                getSnapshotWithSelector,
                getServerSnapshotWithSelector
            ];
        }
    }["useSyncExternalStoreWithSelector.useMemo"], [
        getSnapshot,
        getServerSnapshot,
        selector,
        isEqual
    ]);
    const value = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useSyncExternalStore"])(subscribe, getSelection, getServerSelection);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useSyncExternalStoreWithSelector.useEffect3": ()=>{
            inst.hasValue = true;
            inst.value = value;
        }
    }["useSyncExternalStoreWithSelector.useEffect3"], [
        value
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useDebugValue"])(value);
    return value;
}
;
var identity = (value)=>value;
function useSignal(signal, selector, isEqual) {
    if (signal instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MutableSignal"]) {
        throw new Error("Using a mutable Signal with useSignal will likely not work as expected.");
    }
    return useSyncExternalStoreWithSelector(signal.subscribe, signal.get, signal.get, selector ?? identity, isEqual);
}
;
;
// src/config.ts
var SECONDS = 1e3;
var MINUTES = 60 * SECONDS;
var config = {
    SMOOTH_DELAY: 1 * SECONDS,
    NOTIFICATIONS_POLL_INTERVAL: 1 * MINUTES,
    NOTIFICATIONS_MAX_STALE_TIME: 5 * SECONDS,
    ROOM_THREADS_POLL_INTERVAL: 5 * MINUTES,
    ROOM_THREADS_MAX_STALE_TIME: 5 * SECONDS,
    USER_THREADS_POLL_INTERVAL: 1 * MINUTES,
    USER_THREADS_MAX_STALE_TIME: 30 * SECONDS,
    HISTORY_VERSIONS_POLL_INTERVAL: 1 * MINUTES,
    HISTORY_VERSIONS_MAX_STALE_TIME: 5 * SECONDS,
    ROOM_SUBSCRIPTION_SETTINGS_POLL_INTERVAL: 1 * MINUTES,
    ROOM_SUBSCRIPTION_SETTINGS_MAX_STALE_TIME: 5 * SECONDS,
    USER_NOTIFICATION_SETTINGS_INTERVAL: 5 * MINUTES,
    USER_NOTIFICATION_SETTINGS_MAX_STALE_TIME: 1 * MINUTES
};
// src/lib/AsyncResult.ts
var ASYNC_LOADING = Object.freeze({
    isLoading: true
});
var ASYNC_ERR = (error)=>Object.freeze({
        isLoading: false,
        error
    });
function ASYNC_OK(fieldOrData, data) {
    if (arguments.length === 1) {
        return Object.freeze({
            isLoading: false,
            data: fieldOrData
        });
    } else {
        return Object.freeze({
            isLoading: false,
            [fieldOrData]: data
        });
    }
}
// src/lib/ssr.ts
function ensureNotServerSide() {
    if (typeof window === "undefined") {
        throw new Error("You cannot use the Suspense version of Liveblocks hooks server side. Make sure to only call them client side by using a ClientSideSuspense wrapper.\nFor tips, see https://liveblocks.io/docs/api-reference/liveblocks-react#ClientSideSuspense");
    }
}
;
function useInitial(value, roomId) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "useInitial.useMemo2": ()=>value
    }["useInitial.useMemo2"], [
        roomId
    ]);
}
function useInitialUnlessFunction(latestValue, roomId) {
    const frozenValue = useInitial(latestValue, roomId);
    const ref = useLatest(latestValue);
    const wrapper = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useInitialUnlessFunction.useCallback[wrapper]": (...args)=>ref.current(...args)
    }["useInitialUnlessFunction.useCallback[wrapper]"], [
        ref
    ]);
    if (typeof frozenValue === "function") {
        return wrapper;
    } else {
        return frozenValue;
    }
}
;
var reactUse = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[" use ".trim().toString()];
var use = reactUse ?? ((promise)=>{
    if (promise.status === "pending") {
        throw promise;
    } else if (promise.status === "fulfilled") {
        return promise.value;
    } else if (promise.status === "rejected") {
        throw promise.reason;
    } else {
        promise.status = "pending";
        promise.then((v)=>{
            promise.status = "fulfilled";
            promise.value = v;
        }, (e)=>{
            promise.status = "rejected";
            promise.reason = e;
        });
        throw promise;
    }
});
;
// src/lib/autobind.ts
function autobind(self) {
    const seen = /* @__PURE__ */ new Set();
    seen.add("constructor");
    let obj = self.constructor.prototype;
    do {
        for (const key of Reflect.ownKeys(obj)){
            if (seen.has(key)) continue;
            const descriptor = Reflect.getOwnPropertyDescriptor(obj, key);
            if (typeof descriptor?.value === "function") {
                seen.add(key);
                self[key] = self[key].bind(self);
            }
        }
    }while ((obj = Reflect.getPrototypeOf(obj)) && obj !== Object.prototype)
}
// src/lib/itertools.ts
function find(it, predicate) {
    for (const item of it){
        if (predicate(item)) return item;
    }
    return void 0;
}
;
function makeThreadsFilter(query, subscriptions) {
    return (thread)=>matchesThreadsQuery(thread, query, subscriptions) && matchesThreadMetadata(thread, query);
}
function matchesThreadsQuery(thread, q, subscriptions) {
    let subscription = void 0;
    if (subscriptions) {
        subscription = subscriptions?.[(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getSubscriptionKey"])("thread", thread.id)];
    }
    return (q.resolved === void 0 || thread.resolved === q.resolved) && (q.subscribed === void 0 || q.subscribed === true && subscription !== void 0 || q.subscribed === false && subscription === void 0);
}
function matchesThreadMetadata(thread, q) {
    const metadata = thread.metadata;
    return q.metadata === void 0 || Object.entries(q.metadata).every(([key, op])=>// Ignore explicit-undefined filters
        // Boolean logic: op? => value matches the operator
        op === void 0 || matchesOperator(metadata[key], op));
}
function matchesOperator(value, op) {
    if (op === null) {
        return value === void 0;
    } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isStartsWithOperator"])(op)) {
        return typeof value === "string" && value.startsWith(op.startsWith);
    } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNumberOperator"])(op)) {
        return typeof value === "number" && matchesNumberOperator(value, op);
    } else {
        return value === op;
    }
}
function matchesNumberOperator(value, op) {
    return (op.lt === void 0 || value < op.lt) && (op.gt === void 0 || value > op.gt) && (op.lte === void 0 || value <= op.lte) && (op.gte === void 0 || value >= op.gte);
}
function makeInboxNotificationsFilter(query) {
    return (inboxNotification)=>matchesInboxNotificationsQuery(inboxNotification, query);
}
function matchesInboxNotificationsQuery(inboxNotification, q) {
    return (q.roomId === void 0 || q.roomId === inboxNotification.roomId) && (q.kind === void 0 || q.kind === inboxNotification.kind);
}
;
function sanitizeThread(thread) {
    if (thread.deletedAt) {
        if (thread.comments.length > 0) {
            return {
                ...thread,
                comments: []
            };
        }
    }
    const hasComment = thread.comments.some((c)=>!c.deletedAt);
    if (!hasComment) {
        return {
            ...thread,
            deletedAt: /* @__PURE__ */ new Date(),
            comments: []
        };
    }
    return thread;
}
var ThreadDB = class _ThreadDB {
    #byId;
    #asc;
    #desc;
    // This signal will be notified on every mutation
    signal;
    constructor(){
        this.#asc = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SortedList"].from([], (t1, t2)=>{
            const d1 = t1.createdAt;
            const d2 = t2.createdAt;
            return d1 < d2 ? true : d1 === d2 ? t1.id < t2.id : false;
        });
        this.#desc = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SortedList"].from([], (t1, t2)=>{
            const d2 = t2.updatedAt;
            const d1 = t1.updatedAt;
            return d2 < d1 ? true : d2 === d1 ? t2.id < t1.id : false;
        });
        this.#byId = /* @__PURE__ */ new Map();
        this.signal = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MutableSignal"](this);
    }
    //
    // Public APIs
    //
    clone() {
        const newPool = new _ThreadDB();
        newPool.#byId = new Map(this.#byId);
        newPool.#asc = this.#asc.clone();
        newPool.#desc = this.#desc.clone();
        return newPool;
    }
    /** Returns an existing thread by ID. Will never return a deleted thread. */ get(threadId) {
        const thread = this.getEvenIfDeleted(threadId);
        return thread?.deletedAt ? void 0 : thread;
    }
    /** Returns the (possibly deleted) thread by ID. */ getEvenIfDeleted(threadId) {
        return this.#byId.get(threadId);
    }
    /** Adds or updates a thread in the DB. If the newly given thread is a deleted one, it will get deleted. */ upsert(thread) {
        this.signal.mutate(()=>{
            thread = sanitizeThread(thread);
            const id = thread.id;
            const toRemove = this.#byId.get(id);
            if (toRemove) {
                if (toRemove.deletedAt) return false;
                this.#asc.remove(toRemove);
                this.#desc.remove(toRemove);
            }
            if (!thread.deletedAt) {
                this.#asc.add(thread);
                this.#desc.add(thread);
            }
            this.#byId.set(id, thread);
            return true;
        });
    }
    /** Like .upsert(), except it won't update if a thread by this ID already exists. */ // TODO Consider renaming this to just .upsert(). I'm not sure if we really
    // TODO need the raw .upsert(). Would be nice if this behavior was the default.
    upsertIfNewer(thread) {
        const existing = this.get(thread.id);
        if (!existing || thread.updatedAt >= existing.updatedAt) {
            this.upsert(thread);
        }
    }
    applyDelta(newThreads, deletedThreads) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["batch"])(()=>{
            for (const thread of newThreads){
                this.upsertIfNewer(thread);
            }
            for (const { id, deletedAt } of deletedThreads){
                const existing = this.getEvenIfDeleted(id);
                if (!existing) continue;
                this.delete(id, deletedAt);
            }
        });
    }
    /**
   * Marks a thread as deleted. It will no longer pop up in .findMany()
   * queries, but it can still be accessed via `.getEvenIfDeleted()`.
   */ delete(threadId, deletedAt) {
        const existing = this.#byId.get(threadId);
        if (existing && !existing.deletedAt) {
            this.upsert({
                ...existing,
                deletedAt,
                updatedAt: deletedAt
            });
        }
    }
    /**
   * Returns all threads matching a given roomId and query. If roomId is not
   * specified, it will return all threads matching the query, across all
   * rooms.
   *
   * Returns the results in the requested order. Please note:
   *   'asc'  means by createdAt ASC
   *   'desc' means by updatedAt DESC
   *
   * Will never return deleted threads in the result.
   *
   * Subscriptions are needed to filter threads based on the user's subscriptions.
   */ findMany(roomId, query, direction, subscriptions) {
        const index = direction === "desc" ? this.#desc : this.#asc;
        const crit = [];
        if (roomId !== void 0) {
            crit.push((t)=>t.roomId === roomId);
        }
        if (query !== void 0) {
            crit.push(makeThreadsFilter(query, subscriptions));
        }
        return Array.from(index.filter((t)=>crit.every((pred)=>pred(t))));
    }
};
// src/umbrella-store.ts
function makeRoomThreadsQueryKey(roomId, query) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["stableStringify"])([
        roomId,
        query ?? {}
    ]);
}
function makeUserThreadsQueryKey(query) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["stableStringify"])(query ?? {});
}
function makeAiChatsQueryKey(query) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["stableStringify"])(query ?? {});
}
function makeInboxNotificationsQueryKey(query) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["stableStringify"])(query ?? {});
}
function usify(promise) {
    if ("status" in promise) {
        return promise;
    }
    const usable = promise;
    usable.status = "pending";
    usable.then((value)=>{
        usable.status = "fulfilled";
        usable.value = value;
    }, (err)=>{
        usable.status = "rejected";
        usable.reason = err;
    });
    return usable;
}
var noop = Promise.resolve();
var PaginatedResource = class {
    #signal;
    signal;
    #fetchPage;
    #pendingFetchMore;
    constructor(fetchPage){
        this.#signal = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Signal"](ASYNC_LOADING);
        this.#fetchPage = fetchPage;
        this.#pendingFetchMore = null;
        this.signal = this.#signal.asReadonly();
        autobind(this);
    }
    get() {
        return this.#signal.get();
    }
    #patch(patch) {
        const state = this.#signal.get();
        if (state.data === void 0) return;
        this.#signal.set(ASYNC_OK({
            ...state.data,
            ...patch
        }));
    }
    async #fetchMore() {
        const state = this.#signal.get();
        if (!state.data?.cursor || state.data.isFetchingMore) {
            return;
        }
        this.#patch({
            isFetchingMore: true
        });
        try {
            const nextCursor = await this.#fetchPage(state.data.cursor);
            this.#patch({
                cursor: nextCursor,
                hasFetchedAll: nextCursor === null,
                fetchMoreError: void 0,
                isFetchingMore: false
            });
        } catch (err) {
            this.#patch({
                isFetchingMore: false,
                fetchMoreError: err
            });
        }
    }
    fetchMore() {
        const state = this.#signal.get();
        if (!state.data?.cursor) return noop;
        if (!this.#pendingFetchMore) {
            this.#pendingFetchMore = this.#fetchMore().finally(()=>{
                this.#pendingFetchMore = null;
            });
        }
        return this.#pendingFetchMore;
    }
    #cachedPromise = null;
    waitUntilLoaded() {
        if (this.#cachedPromise) {
            return this.#cachedPromise;
        }
        const initialPageFetch$ = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["autoRetry"])(()=>this.#fetchPage(/* cursor */ void 0), 5, [
            5e3,
            5e3,
            1e4,
            15e3
        ]);
        const promise = usify(initialPageFetch$);
        promise.then((cursor)=>{
            this.#signal.set(ASYNC_OK({
                cursor,
                hasFetchedAll: cursor === null,
                isFetchingMore: false,
                fetchMoreError: void 0,
                fetchMore: this.fetchMore
            }));
        }, (err)=>{
            this.#signal.set(ASYNC_ERR(err));
            setTimeout(()=>{
                this.#cachedPromise = null;
                this.#signal.set(ASYNC_LOADING);
            }, 5e3);
        });
        this.#cachedPromise = promise;
        return this.#cachedPromise;
    }
};
var SinglePageResource = class {
    #signal;
    signal;
    #fetchPage;
    #autoRetry = true;
    constructor(fetchPage, autoRetry2 = true){
        this.#signal = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Signal"](ASYNC_LOADING);
        this.signal = this.#signal.asReadonly();
        this.#fetchPage = fetchPage;
        this.#autoRetry = autoRetry2;
        autobind(this);
    }
    get() {
        return this.#signal.get();
    }
    #cachedPromise = null;
    waitUntilLoaded() {
        if (this.#cachedPromise) {
            return this.#cachedPromise;
        }
        const initialFetcher$ = this.#autoRetry ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["autoRetry"])(()=>this.#fetchPage(), 5, [
            5e3,
            5e3,
            1e4,
            15e3
        ]) : this.#fetchPage();
        const promise = usify(initialFetcher$);
        promise.then(()=>{
            this.#signal.set(ASYNC_OK(void 0));
        }, (err)=>{
            this.#signal.set(ASYNC_ERR(err));
            if (this.#autoRetry) {
                setTimeout(()=>{
                    this.#cachedPromise = null;
                    this.#signal.set(ASYNC_LOADING);
                }, 5e3);
            }
        });
        this.#cachedPromise = promise;
        return promise;
    }
};
function createStore_forNotifications() {
    const signal = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MutableSignal"](/* @__PURE__ */ new Map());
    function markRead(notificationId, readAt) {
        signal.mutate((lut)=>{
            const existing = lut.get(notificationId);
            if (!existing) {
                return false;
            }
            lut.set(notificationId, {
                ...existing,
                readAt
            });
            return true;
        });
    }
    function markAllRead(readAt) {
        signal.mutate((lut)=>{
            for (const n of lut.values()){
                n.readAt = readAt;
            }
        });
    }
    function deleteOne(inboxNotificationId) {
        signal.mutate((lut)=>lut.delete(inboxNotificationId));
    }
    function clear() {
        signal.mutate((lut)=>lut.clear());
    }
    function applyDelta(newNotifications, deletedNotifications) {
        signal.mutate((lut)=>{
            let mutated = false;
            for (const n of newNotifications){
                const existing = lut.get(n.id);
                if (existing) {
                    const result = compareInboxNotifications(existing, n);
                    if (result === 1) continue;
                }
                lut.set(n.id, n);
                mutated = true;
            }
            for (const n of deletedNotifications){
                lut.delete(n.id);
                mutated = true;
            }
            return mutated;
        });
    }
    function updateAssociatedNotification(newComment) {
        signal.mutate((lut)=>{
            const existing = find(lut.values(), (notification)=>notification.kind === "thread" && notification.threadId === newComment.threadId);
            if (!existing) return false;
            lut.set(existing.id, {
                ...existing,
                notifiedAt: newComment.createdAt,
                readAt: newComment.createdAt
            });
            return true;
        });
    }
    function upsert(notification) {
        signal.mutate((lut)=>{
            lut.set(notification.id, notification);
        });
    }
    return {
        signal: signal.asReadonly(),
        // Mutations
        markAllRead,
        markRead,
        delete: deleteOne,
        applyDelta,
        clear,
        updateAssociatedNotification,
        upsert
    };
}
function createStore_forUnreadNotificationsCount() {
    const baseSignal = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MutableSignal"](/* @__PURE__ */ new Map());
    function update(queryKey, count) {
        baseSignal.mutate((lut)=>{
            lut.set(queryKey, count);
        });
    }
    return {
        signal: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DerivedSignal"].from(baseSignal, (c)=>Object.fromEntries(c)),
        // Mutations
        update
    };
}
function createStore_forSubscriptions(updates, threads) {
    const baseSignal = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MutableSignal"](/* @__PURE__ */ new Map());
    function applyDelta(newSubscriptions, deletedSubscriptions) {
        baseSignal.mutate((lut)=>{
            let mutated = false;
            for (const s of newSubscriptions){
                lut.set((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getSubscriptionKey"])(s), s);
                mutated = true;
            }
            for (const s of deletedSubscriptions){
                lut.delete((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getSubscriptionKey"])(s));
                mutated = true;
            }
            return mutated;
        });
    }
    function create(subscription) {
        baseSignal.mutate((lut)=>{
            lut.set((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getSubscriptionKey"])(subscription), subscription);
        });
    }
    function deleteOne(subscriptionKey) {
        baseSignal.mutate((lut)=>{
            lut.delete(subscriptionKey);
        });
    }
    return {
        signal: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DerivedSignal"].from(baseSignal, updates, (base, updates2)=>applyOptimisticUpdates_forSubscriptions(base, threads, updates2)),
        // Mutations
        applyDelta,
        create,
        delete: deleteOne
    };
}
function createStore_forRoomSubscriptionSettings(updates) {
    const baseSignal = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MutableSignal"](/* @__PURE__ */ new Map());
    function update(roomId, settings) {
        baseSignal.mutate((lut)=>{
            lut.set(roomId, settings);
        });
    }
    return {
        signal: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DerivedSignal"].from(baseSignal, updates, (base, updates2)=>applyOptimisticUpdates_forRoomSubscriptionSettings(base, updates2)),
        // Mutations
        update
    };
}
function createStore_forHistoryVersions() {
    const baseSignal = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MutableSignal"](new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DefaultMap"](()=>/* @__PURE__ */ new Map()));
    function update(roomId, versions) {
        baseSignal.mutate((lut)=>{
            const versionsById = lut.getOrCreate(roomId);
            for (const version of versions){
                versionsById.set(version.id, version);
            }
        });
    }
    return {
        signal: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DerivedSignal"].from(baseSignal, (hv)=>Object.fromEntries([
                ...hv
            ].map(([roomId, versions])=>[
                    roomId,
                    Object.fromEntries(versions)
                ]))),
        // Mutations
        update
    };
}
function createStore_forUrlsMetadata() {
    const baseSignal = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MutableSignal"](/* @__PURE__ */ new Map());
    function update(url, metadata) {
        baseSignal.mutate((lut)=>{
            lut.set(url, metadata);
        });
    }
    return {
        signal: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DerivedSignal"].from(baseSignal, (m)=>Object.fromEntries(m)),
        // Mutations
        update
    };
}
function createStore_forPermissionHints() {
    const permissionsByRoomId = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DefaultMap"](()=>new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Signal"](/* @__PURE__ */ new Set()));
    function update(newHints) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["batch"])(()=>{
            for (const [roomId, permissions] of Object.entries(newHints)){
                const signal = permissionsByRoomId.getOrCreate(roomId);
                const existingPermissions = new Set(signal.get());
                for (const permission of permissions){
                    existingPermissions.add(permission);
                }
                signal.set(existingPermissions);
            }
        });
    }
    function getPermissionForRoomΣ(roomId) {
        return permissionsByRoomId.getOrCreate(roomId);
    }
    return {
        getPermissionForRoomΣ,
        // Mutations
        update
    };
}
function createStore_forNotificationSettings(updates) {
    const signal = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Signal"]((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createNotificationSettings"])({}));
    function update(settings) {
        signal.set(settings);
    }
    return {
        signal: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DerivedSignal"].from(signal, updates, (base, updates2)=>applyOptimisticUpdates_forNotificationSettings(base, updates2)),
        // Mutations
        update
    };
}
var NON_BLOCKING_OPTIMISTIC_UPDATES = /* @__PURE__ */ new Set([
    "mark-inbox-notification-as-read"
]);
function createStore_forOptimistic(client) {
    const signal = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Signal"]([]);
    const syncSource = client[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].createSyncSource();
    signal.subscribe(()=>syncSource.setSyncStatus(signal.get().some((update)=>!NON_BLOCKING_OPTIMISTIC_UPDATES.has(update.type)) ? "synchronizing" : "synchronized"));
    function add(optimisticUpdate) {
        const id = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["nanoid"])();
        const newUpdate = {
            ...optimisticUpdate,
            id
        };
        signal.set((state)=>[
                ...state,
                newUpdate
            ]);
        return id;
    }
    function remove(optimisticId) {
        signal.set((state)=>state.filter((ou)=>ou.id !== optimisticId));
    }
    return {
        signal: signal.asReadonly(),
        // Mutations
        add,
        remove
    };
}
var UmbrellaStore = class {
    #client;
    //
    // Internally, the UmbrellaStore keeps track of a few source signals that can
    // be set and mutated individually. When any of those are mutated then the
    // clean "external state" is recomputed.
    //
    //   Mutate inputs...                                             ...observe clean/consistent output!
    //
    //            .-> Base ThreadDB ---------+                 +-------> Clean threads by ID         (Part 1)
    //           /                           |                 |
    //   mutate ----> Base Notifications --+ |                 | +-----> Clean notifications         (Part 1)
    //          \                          | |                 | |       & notifications by ID
    //         | \                         | |      Apply      | |
    //         |   `-> OptimisticUpdates --+--+--> Optimistic -+-+-+-+-> Subscriptions               (Part 2)
    //          \                          |        Updates    |   | |
    //           `------- etc etc ---------+                   |   | +-> History Versions            (Part 3)
    //                       ^                                 |   |
    //                       |                                 |   +---> Room Subscription Settings  (Part 4)
    //                       |                                 |
    //                       |                                 +-------> Notification Settings       (Part 5)
    //                       |
    //                       |
    //                       |                        ^                  ^
    //                    Signal                      |                  |
    //                      or                   DerivedSignal      DerivedSignals
    //                  MutableSignal
    //
    //
    // Input signals.
    // (Can be mutated directly.)
    //
    // XXX_vincent Now that we have createStore_forX, we should probably also change
    // `threads` to this pattern, ie create a createStore_forThreads helper as
    // well. It almost works like that already anyway!
    threads;
    // Exposes its signal under `.signal` prop
    notifications;
    subscriptions;
    roomSubscriptionSettings;
    // prettier-ignore
    historyVersions;
    unreadNotificationsCount;
    urlsMetadata;
    permissionHints;
    notificationSettings;
    optimisticUpdates;
    //
    // Output signals.
    // (Readonly, clean, consistent. With optimistic updates applied.)
    //
    // Note that the output of threadifications signal is the same as the ones for
    // threads and notifications separately, but the threadifications signal will
    // be updated whenever either of them change.
    //
    outputs;
    // Notifications
    #notificationsLastRequestedAt = null;
    // Keeps track of when we successfully requested an inbox notifications update for the last time. Will be `null` as long as the first successful fetch hasn't happened yet.
    // Room Threads
    #roomThreadsLastRequestedAtByRoom = /* @__PURE__ */ new Map();
    // User Threads
    #userThreadsLastRequestedAt = null;
    // Room versions
    #roomVersionsLastRequestedAtByRoom = /* @__PURE__ */ new Map();
    // Notification Settings
    #notificationSettings;
    constructor(client){
        this.#client = client[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].as();
        this.optimisticUpdates = createStore_forOptimistic(this.#client);
        this.permissionHints = createStore_forPermissionHints();
        const notificationSettingsFetcher = async ()=>{
            const result = await this.#client.getNotificationSettings();
            this.notificationSettings.update(result);
        };
        this.notificationSettings = createStore_forNotificationSettings(this.optimisticUpdates.signal);
        this.#notificationSettings = new SinglePageResource(notificationSettingsFetcher);
        this.threads = new ThreadDB();
        this.subscriptions = createStore_forSubscriptions(this.optimisticUpdates.signal, this.threads);
        this.notifications = createStore_forNotifications();
        this.roomSubscriptionSettings = createStore_forRoomSubscriptionSettings(this.optimisticUpdates.signal);
        this.historyVersions = createStore_forHistoryVersions();
        this.unreadNotificationsCount = createStore_forUnreadNotificationsCount();
        this.urlsMetadata = createStore_forUrlsMetadata();
        const threadifications = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DerivedSignal"].from(this.threads.signal, this.notifications.signal, this.optimisticUpdates.signal, (ts, ns, updates)=>applyOptimisticUpdates_forThreadifications(ts, ns, updates));
        const threads = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DerivedSignal"].from(threadifications, (s)=>s.threadsDB);
        const notifications = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DerivedSignal"].from(threadifications, (s)=>({
                sortedNotifications: s.sortedNotifications,
                notificationsById: s.notificationsById
            }), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shallow"]);
        const threadSubscriptions = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DerivedSignal"].from(notifications, this.subscriptions.signal, (n, s)=>({
                subscriptions: s,
                notifications: n.sortedNotifications
            }));
        const loadingUserThreads = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DefaultMap"]((queryKey)=>{
            const query = JSON.parse(queryKey);
            const resource = new PaginatedResource(async (cursor)=>{
                const result = await this.#client[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].httpClient.getUserThreads_experimental({
                    cursor,
                    query
                });
                this.updateThreadifications(result.threads, result.inboxNotifications, result.subscriptions);
                this.permissionHints.update(result.permissionHints);
                if (this.#userThreadsLastRequestedAt === null) {
                    this.#userThreadsLastRequestedAt = result.requestedAt;
                }
                return result.nextCursor;
            });
            const signal = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DerivedSignal"].from(()=>{
                const result = resource.get();
                if (result.isLoading || result.error) {
                    return result;
                }
                const subscriptions = threadSubscriptions.get().subscriptions;
                const threads2 = this.outputs.threads.get().findMany(void 0, // Do _not_ filter by roomId
                query ?? {}, "desc", subscriptions);
                const page = result.data;
                return {
                    isLoading: false,
                    threads: threads2,
                    hasFetchedAll: page.hasFetchedAll,
                    isFetchingMore: page.isFetchingMore,
                    fetchMoreError: page.fetchMoreError,
                    fetchMore: page.fetchMore
                };
            }, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shallow2"]);
            return {
                signal,
                waitUntilLoaded: resource.waitUntilLoaded
            };
        });
        const loadingRoomThreads = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DefaultMap"]((queryKey)=>{
            const [roomId, query] = JSON.parse(queryKey);
            const resource = new PaginatedResource(async (cursor)=>{
                const result = await this.#client[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].httpClient.getThreads({
                    roomId,
                    cursor,
                    query
                });
                this.updateThreadifications(result.threads, result.inboxNotifications, result.subscriptions);
                this.permissionHints.update(result.permissionHints);
                const lastRequestedAt = this.#roomThreadsLastRequestedAtByRoom.get(roomId);
                if (lastRequestedAt === void 0 || lastRequestedAt > result.requestedAt) {
                    this.#roomThreadsLastRequestedAtByRoom.set(roomId, result.requestedAt);
                }
                return result.nextCursor;
            });
            const signal = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DerivedSignal"].from(()=>{
                const result = resource.get();
                if (result.isLoading || result.error) {
                    return result;
                }
                const subscriptions = threadSubscriptions.get().subscriptions;
                const threads2 = this.outputs.threads.get().findMany(roomId, query ?? {}, "asc", subscriptions);
                const page = result.data;
                return {
                    isLoading: false,
                    threads: threads2,
                    hasFetchedAll: page.hasFetchedAll,
                    isFetchingMore: page.isFetchingMore,
                    fetchMoreError: page.fetchMoreError,
                    fetchMore: page.fetchMore
                };
            }, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shallow2"]);
            return {
                signal,
                waitUntilLoaded: resource.waitUntilLoaded
            };
        });
        const loadingNotifications = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DefaultMap"]((queryKey)=>{
            const query = JSON.parse(queryKey);
            const resource = new PaginatedResource(async (cursor)=>{
                const result = await this.#client.getInboxNotifications({
                    cursor,
                    query
                });
                this.updateThreadifications(result.threads, result.inboxNotifications, result.subscriptions);
                if (this.#notificationsLastRequestedAt === null) {
                    this.#notificationsLastRequestedAt = result.requestedAt;
                }
                const nextCursor = result.nextCursor;
                return nextCursor;
            });
            const signal = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DerivedSignal"].from(()=>{
                const result = resource.get();
                if (result.isLoading || result.error) {
                    return result;
                }
                const crit = [];
                if (query !== void 0) {
                    crit.push(makeInboxNotificationsFilter(query));
                }
                const inboxNotifications = this.outputs.notifications.get().sortedNotifications.filter((inboxNotification)=>crit.every((pred)=>pred(inboxNotification)));
                const page = result.data;
                return {
                    isLoading: false,
                    inboxNotifications,
                    hasFetchedAll: page.hasFetchedAll,
                    isFetchingMore: page.isFetchingMore,
                    fetchMoreError: page.fetchMoreError,
                    fetchMore: page.fetchMore
                };
            }, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shallow2"]);
            return {
                signal,
                waitUntilLoaded: resource.waitUntilLoaded
            };
        });
        const unreadNotificationsCount = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DefaultMap"]((queryKey)=>{
            const query = JSON.parse(queryKey);
            const resource = new SinglePageResource(async ()=>{
                const result = await this.#client.getUnreadInboxNotificationsCount({
                    query
                });
                this.unreadNotificationsCount.update(queryKey, result);
            });
            const signal = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DerivedSignal"].from(()=>{
                const result = resource.get();
                if (result.isLoading || result.error) {
                    return result;
                } else {
                    return ASYNC_OK("count", (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["nn"])(this.unreadNotificationsCount.signal.get()[queryKey]));
                }
            }, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shallow"]);
            return {
                signal,
                waitUntilLoaded: resource.waitUntilLoaded
            };
        });
        const roomSubscriptionSettingsByRoomId = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DefaultMap"]((roomId)=>{
            const resource = new SinglePageResource(async ()=>{
                const room = this.#client.getRoom(roomId);
                if (room === null) {
                    throw new Error(`Room '${roomId}' is not available on client`);
                }
                const result = await room.getSubscriptionSettings();
                this.roomSubscriptionSettings.update(roomId, result);
            });
            const signal = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DerivedSignal"].from(()=>{
                const result = resource.get();
                if (result.isLoading || result.error) {
                    return result;
                } else {
                    return ASYNC_OK("settings", (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["nn"])(this.roomSubscriptionSettings.signal.get()[roomId]));
                }
            }, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shallow"]);
            return {
                signal,
                waitUntilLoaded: resource.waitUntilLoaded
            };
        });
        const versionsByRoomId = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DefaultMap"]((roomId)=>{
            const resource = new SinglePageResource(async ()=>{
                const room = this.#client.getRoom(roomId);
                if (room === null) {
                    throw new Error(`Room '${roomId}' is not available on client`);
                }
                const result = await room[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].listTextVersions();
                this.historyVersions.update(roomId, result.versions);
                const lastRequestedAt = this.#roomVersionsLastRequestedAtByRoom.get(roomId);
                if (lastRequestedAt === void 0 || lastRequestedAt > result.requestedAt) {
                    this.#roomVersionsLastRequestedAtByRoom.set(roomId, result.requestedAt);
                }
            });
            const signal = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DerivedSignal"].from(()=>{
                const result = resource.get();
                if (result.isLoading || result.error) {
                    return result;
                } else {
                    return ASYNC_OK("versions", Object.values(this.historyVersions.signal.get()[roomId] ?? {}));
                }
            }, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shallow"]);
            return {
                signal,
                waitUntilLoaded: resource.waitUntilLoaded
            };
        });
        const notificationSettings = {
            signal: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DerivedSignal"].from(()=>{
                const result = this.#notificationSettings.get();
                if (result.isLoading || result.error) {
                    return result;
                }
                return ASYNC_OK("settings", (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["nn"])(this.notificationSettings.signal.get()));
            }, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shallow"]),
            waitUntilLoaded: this.#notificationSettings.waitUntilLoaded
        };
        const aiChats = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DefaultMap"]((queryKey)=>{
            const query = JSON.parse(queryKey);
            const resource = new PaginatedResource(async (cursor)=>{
                const result = await this.#client[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].ai.getChats({
                    cursor,
                    query
                });
                return result.nextCursor;
            });
            const signal = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DerivedSignal"].from(()=>{
                const result = resource.get();
                if (result.isLoading || result.error) {
                    return result;
                }
                const chats = this.#client[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].ai.queryChats(query);
                return {
                    isLoading: false,
                    chats,
                    hasFetchedAll: result.data.hasFetchedAll,
                    isFetchingMore: result.data.isFetchingMore,
                    fetchMore: result.data.fetchMore,
                    fetchMoreError: result.data.fetchMoreError
                };
            }, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shallow"]);
            return {
                signal,
                waitUntilLoaded: resource.waitUntilLoaded
            };
        });
        const messagesByChatId = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DefaultMap"]((chatId)=>{
            const resourceΣ = new SinglePageResource(async ()=>{
                await this.#client[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].ai.getMessageTree(chatId);
            });
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DefaultMap"]((branch)=>{
                const signal = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DerivedSignal"].from(()=>{
                    const result = resourceΣ.get();
                    if (result.isLoading || result.error) {
                        return result;
                    }
                    return ASYNC_OK("messages", this.#client[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].ai.signals.getChatMessagesForBranchΣ(chatId, branch ?? void 0).get());
                });
                return {
                    signal,
                    waitUntilLoaded: resourceΣ.waitUntilLoaded
                };
            });
        });
        const aiChatById = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DefaultMap"]((chatId)=>{
            const resource = new SinglePageResource(async ()=>{
                await this.#client[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].ai.getOrCreateChat(chatId);
            });
            const signal = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DerivedSignal"].from(()=>{
                const chat = this.#client[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].ai.getChatById(chatId);
                if (chat === void 0) {
                    const result = resource.get();
                    if (result.isLoading || result.error) {
                        return result;
                    } else {
                        return ASYNC_OK("chat", (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["nn"])(this.#client[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].ai.getChatById(chatId)));
                    }
                } else {
                    return ASYNC_OK("chat", (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["nn"])(this.#client[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].ai.getChatById(chatId)));
                }
            }, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shallow"]);
            return {
                signal,
                waitUntilLoaded: resource.waitUntilLoaded
            };
        });
        const urlMetadataByUrl = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DefaultMap"]((url)=>{
            const resource = new SinglePageResource(async ()=>{
                const metadata = await this.#client[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].httpClient.getUrlMetadata(url);
                this.urlsMetadata.update(url, metadata);
            }, false);
            const signal = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DerivedSignal"].from(()=>{
                const result = resource.get();
                if (result.isLoading || result.error) {
                    return result;
                }
                return ASYNC_OK("metadata", (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["nn"])(this.urlsMetadata.signal.get()[url]));
            }, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shallow"]);
            return {
                signal,
                waitUntilLoaded: resource.waitUntilLoaded
            };
        });
        this.outputs = {
            threadifications,
            threads,
            loadingRoomThreads,
            loadingUserThreads,
            notifications,
            loadingNotifications,
            unreadNotificationsCount,
            roomSubscriptionSettingsByRoomId,
            versionsByRoomId,
            notificationSettings,
            threadSubscriptions,
            aiChats,
            messagesByChatId,
            aiChatById,
            urlMetadataByUrl
        };
        autobind(this);
    }
    /**
   * Updates an existing inbox notification with a new value, replacing the
   * corresponding optimistic update.
   *
   * This will not update anything if the inbox notification ID isn't found.
   */ markInboxNotificationRead(inboxNotificationId, readAt, optimisticId) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["batch"])(()=>{
            this.optimisticUpdates.remove(optimisticId);
            this.notifications.markRead(inboxNotificationId, readAt);
        });
    }
    markAllInboxNotificationsRead(optimisticId, readAt) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["batch"])(()=>{
            this.optimisticUpdates.remove(optimisticId);
            this.notifications.markAllRead(readAt);
        });
    }
    /**
   * Deletes an existing inbox notification, replacing the corresponding
   * optimistic update.
   */ deleteInboxNotification(inboxNotificationId, optimisticId) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["batch"])(()=>{
            this.optimisticUpdates.remove(optimisticId);
            this.notifications.delete(inboxNotificationId);
        });
    }
    /**
   * Deletes *all* inbox notifications, replacing the corresponding optimistic
   * update.
   */ deleteAllInboxNotifications(optimisticId) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["batch"])(()=>{
            this.optimisticUpdates.remove(optimisticId);
            this.notifications.clear();
        });
    }
    /**
   * Creates an existing subscription, replacing the corresponding
   * optimistic update.
   */ createSubscription(subscription, optimisticId) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["batch"])(()=>{
            this.optimisticUpdates.remove(optimisticId);
            this.subscriptions.create(subscription);
        });
    }
    /**
   * Deletes an existing subscription, replacing the corresponding
   * optimistic update.
   */ deleteSubscription(subscriptionKey, optimisticId) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["batch"])(()=>{
            this.optimisticUpdates.remove(optimisticId);
            this.subscriptions.delete(subscriptionKey);
        });
    }
    /**
   * Creates an new thread, replacing the corresponding optimistic update.
   */ createThread(optimisticId, thread) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["batch"])(()=>{
            this.optimisticUpdates.remove(optimisticId);
            this.threads.upsert(thread);
        });
    }
    /**
   * Updates an existing thread with a new value, replacing the corresponding
   * optimistic update.
   *
   * This will not update anything if:
   * - The thread ID isn't found; or
   * - The thread ID was already deleted; or
   * - The thread ID was updated more recently than the optimistic update's
   *   timestamp (if given)
   */ #updateThread(threadId, optimisticId, callback, updatedAt) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["batch"])(()=>{
            if (optimisticId !== null) {
                this.optimisticUpdates.remove(optimisticId);
            }
            const db = this.threads;
            const existing = db.get(threadId);
            if (!existing) return;
            if (!!updatedAt && existing.updatedAt > updatedAt) return;
            db.upsert(callback(existing));
        });
    }
    patchThread(threadId, optimisticId, patch, updatedAt) {
        return this.#updateThread(threadId, optimisticId, (thread)=>({
                ...thread,
                ...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["compactObject"])(patch)
            }), updatedAt);
    }
    addReaction(threadId, optimisticId, commentId, reaction, createdAt) {
        this.#updateThread(threadId, optimisticId, (thread)=>applyAddReaction(thread, commentId, reaction), createdAt);
    }
    removeReaction(threadId, optimisticId, commentId, emoji, userId, removedAt) {
        this.#updateThread(threadId, optimisticId, (thread)=>applyRemoveReaction(thread, commentId, emoji, userId, removedAt), removedAt);
    }
    /**
   * Soft-deletes an existing thread by setting its `deletedAt` value,
   * replacing the corresponding optimistic update.
   *
   * This will not update anything if:
   * - The thread ID isn't found; or
   * - The thread ID was already deleted
   */ deleteThread(threadId, optimisticId) {
        return this.#updateThread(threadId, optimisticId, // A deletion is actually an update of the deletedAt property internally
        (thread)=>({
                ...thread,
                updatedAt: /* @__PURE__ */ new Date(),
                deletedAt: /* @__PURE__ */ new Date()
            }));
    }
    /**
   * Creates an existing comment and ensures the associated notification is
   * updated correctly, replacing the corresponding optimistic update.
   */ createComment(newComment, optimisticId) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["batch"])(()=>{
            this.optimisticUpdates.remove(optimisticId);
            const existingThread = this.threads.get(newComment.threadId);
            if (!existingThread) {
                return;
            }
            this.threads.upsert(applyUpsertComment(existingThread, newComment));
            this.notifications.updateAssociatedNotification(newComment);
        });
    }
    editComment(threadId, optimisticId, editedComment) {
        return this.#updateThread(threadId, optimisticId, (thread)=>applyUpsertComment(thread, editedComment));
    }
    editCommentMetadata(threadId, commentId, optimisticId, updatedMetadata, updatedAt) {
        return this.#updateThread(threadId, optimisticId, (thread)=>{
            const comment = thread.comments.find((c)=>c.id === commentId);
            if (comment === void 0) {
                return thread;
            }
            return {
                ...thread,
                updatedAt,
                comments: thread.comments.map((c)=>c.id === commentId ? {
                        ...c,
                        metadata: updatedMetadata
                    } : c)
            };
        }, updatedAt);
    }
    deleteComment(threadId, optimisticId, commentId, deletedAt) {
        return this.#updateThread(threadId, optimisticId, (thread)=>applyDeleteComment(thread, commentId, deletedAt), deletedAt);
    }
    updateThreadifications(threads, notifications, subscriptions, deletedThreads = [], deletedNotifications = [], deletedSubscriptions = []) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["batch"])(()=>{
            this.threads.applyDelta(threads, deletedThreads);
            this.notifications.applyDelta(notifications, deletedNotifications);
            this.subscriptions.applyDelta(subscriptions, deletedSubscriptions);
        });
    }
    /**
   * Updates existing subscription settings for a room with a new value,
   * replacing the corresponding optimistic update.
   */ updateRoomSubscriptionSettings(roomId, optimisticId, settings) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["batch"])(()=>{
            this.optimisticUpdates.remove(optimisticId);
            this.roomSubscriptionSettings.update(roomId, settings);
        });
    }
    async fetchNotificationsDeltaUpdate(signal) {
        const lastRequestedAt = this.#notificationsLastRequestedAt;
        if (lastRequestedAt === null) {
            return;
        }
        const result = await this.#client.getInboxNotificationsSince({
            since: lastRequestedAt,
            signal
        });
        if (lastRequestedAt < result.requestedAt) {
            this.#notificationsLastRequestedAt = result.requestedAt;
        }
        this.updateThreadifications(result.threads.updated, result.inboxNotifications.updated, result.subscriptions.updated, result.threads.deleted, result.inboxNotifications.deleted, result.subscriptions.deleted);
    }
    async fetchUnreadNotificationsCount(queryKey, signal) {
        const query = JSON.parse(queryKey);
        const result = await this.#client.getUnreadInboxNotificationsCount({
            query,
            signal
        });
        this.unreadNotificationsCount.update(queryKey, result);
    }
    async fetchRoomThreadsDeltaUpdate(roomId, signal) {
        const lastRequestedAt = this.#roomThreadsLastRequestedAtByRoom.get(roomId);
        if (lastRequestedAt === void 0) {
            return;
        }
        const updates = await this.#client[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].httpClient.getThreadsSince({
            roomId,
            since: lastRequestedAt,
            signal
        });
        this.updateThreadifications(updates.threads.updated, updates.inboxNotifications.updated, updates.subscriptions.updated, updates.threads.deleted, updates.inboxNotifications.deleted, updates.subscriptions.deleted);
        this.permissionHints.update(updates.permissionHints);
        if (lastRequestedAt < updates.requestedAt) {
            this.#roomThreadsLastRequestedAtByRoom.set(roomId, updates.requestedAt);
        }
    }
    async fetchUserThreadsDeltaUpdate(signal) {
        const lastRequestedAt = this.#userThreadsLastRequestedAt;
        if (lastRequestedAt === null) {
            return;
        }
        const result = await this.#client[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].httpClient.getUserThreadsSince_experimental({
            since: lastRequestedAt,
            signal
        });
        if (lastRequestedAt < result.requestedAt) {
            this.#notificationsLastRequestedAt = result.requestedAt;
        }
        this.updateThreadifications(result.threads.updated, result.inboxNotifications.updated, result.subscriptions.updated, result.threads.deleted, result.inboxNotifications.deleted, result.subscriptions.deleted);
        this.permissionHints.update(result.permissionHints);
    }
    async fetchRoomVersionsDeltaUpdate(roomId, signal) {
        const lastRequestedAt = this.#roomVersionsLastRequestedAtByRoom.get(roomId);
        if (lastRequestedAt === void 0) {
            return;
        }
        const room = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["nn"])(this.#client.getRoom(roomId), `Room with id ${roomId} is not available on client`);
        const updates = await room[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].listTextVersionsSince({
            since: lastRequestedAt,
            signal
        });
        this.historyVersions.update(roomId, updates.versions);
        if (lastRequestedAt < updates.requestedAt) {
            this.#roomVersionsLastRequestedAtByRoom.set(roomId, updates.requestedAt);
        }
    }
    async refreshRoomSubscriptionSettings(roomId, signal) {
        const room = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["nn"])(this.#client.getRoom(roomId), `Room with id ${roomId} is not available on client`);
        const result = await room.getSubscriptionSettings({
            signal
        });
        this.roomSubscriptionSettings.update(roomId, result);
    }
    /**
   * Refresh notification settings from poller
   */ async refreshNotificationSettings(signal) {
        const result = await this.#client.getNotificationSettings({
            signal
        });
        this.notificationSettings.update(result);
    }
    /**
   * Updates notification settings with a new value, replacing the
   * corresponding optimistic update.
   */ updateNotificationSettings_confirmOptimisticUpdate(settings, optimisticUpdateId) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["batch"])(()=>{
            this.optimisticUpdates.remove(optimisticUpdateId);
            this.notificationSettings.update(settings);
        });
    }
};
function applyOptimisticUpdates_forThreadifications(baseThreadsDB, notificationsLUT, optimisticUpdates) {
    const threadsDB = baseThreadsDB.clone();
    let notificationsById = Object.fromEntries(notificationsLUT);
    for (const optimisticUpdate of optimisticUpdates){
        switch(optimisticUpdate.type){
            case "create-thread":
                {
                    threadsDB.upsert(optimisticUpdate.thread);
                    break;
                }
            case "edit-thread-metadata":
                {
                    const thread = threadsDB.get(optimisticUpdate.threadId);
                    if (thread === void 0) break;
                    if (thread.updatedAt > optimisticUpdate.updatedAt) {
                        break;
                    }
                    threadsDB.upsert({
                        ...thread,
                        updatedAt: optimisticUpdate.updatedAt,
                        metadata: {
                            ...thread.metadata,
                            ...optimisticUpdate.metadata
                        }
                    });
                    break;
                }
            case "mark-thread-as-resolved":
                {
                    const thread = threadsDB.get(optimisticUpdate.threadId);
                    if (thread === void 0) break;
                    threadsDB.upsert({
                        ...thread,
                        resolved: true
                    });
                    break;
                }
            case "mark-thread-as-unresolved":
                {
                    const thread = threadsDB.get(optimisticUpdate.threadId);
                    if (thread === void 0) break;
                    threadsDB.upsert({
                        ...thread,
                        resolved: false
                    });
                    break;
                }
            case "create-comment":
                {
                    const thread = threadsDB.get(optimisticUpdate.comment.threadId);
                    if (thread === void 0) break;
                    threadsDB.upsert(applyUpsertComment(thread, optimisticUpdate.comment));
                    const inboxNotification = Object.values(notificationsById).find((notification)=>notification.kind === "thread" && notification.threadId === thread.id);
                    if (inboxNotification === void 0) {
                        break;
                    }
                    notificationsById[inboxNotification.id] = {
                        ...inboxNotification,
                        notifiedAt: optimisticUpdate.comment.createdAt,
                        readAt: optimisticUpdate.comment.createdAt
                    };
                    break;
                }
            case "edit-comment":
                {
                    const thread = threadsDB.get(optimisticUpdate.comment.threadId);
                    if (thread === void 0) break;
                    threadsDB.upsert(applyUpsertComment(thread, optimisticUpdate.comment));
                    break;
                }
            case "edit-comment-metadata":
                {
                    const thread = threadsDB.get(optimisticUpdate.threadId);
                    if (thread === void 0) break;
                    if (thread.updatedAt > optimisticUpdate.updatedAt) {
                        break;
                    }
                    const existingComment = thread.comments.find((c)=>c.id === optimisticUpdate.commentId);
                    if (existingComment === void 0) break;
                    threadsDB.upsert(applyUpsertComment(thread, {
                        ...existingComment,
                        metadata: {
                            ...existingComment.metadata,
                            ...optimisticUpdate.metadata
                        }
                    }));
                    break;
                }
            case "delete-comment":
                {
                    const thread = threadsDB.get(optimisticUpdate.threadId);
                    if (thread === void 0) break;
                    threadsDB.upsert(applyDeleteComment(thread, optimisticUpdate.commentId, optimisticUpdate.deletedAt));
                    break;
                }
            case "delete-thread":
                {
                    const thread = threadsDB.get(optimisticUpdate.threadId);
                    if (thread === void 0) break;
                    threadsDB.upsert({
                        ...thread,
                        deletedAt: optimisticUpdate.deletedAt,
                        updatedAt: optimisticUpdate.deletedAt,
                        comments: []
                    });
                    break;
                }
            case "add-reaction":
                {
                    const thread = threadsDB.get(optimisticUpdate.threadId);
                    if (thread === void 0) break;
                    threadsDB.upsert(applyAddReaction(thread, optimisticUpdate.commentId, optimisticUpdate.reaction));
                    break;
                }
            case "remove-reaction":
                {
                    const thread = threadsDB.get(optimisticUpdate.threadId);
                    if (thread === void 0) break;
                    threadsDB.upsert(applyRemoveReaction(thread, optimisticUpdate.commentId, optimisticUpdate.emoji, optimisticUpdate.userId, optimisticUpdate.removedAt));
                    break;
                }
            case "mark-inbox-notification-as-read":
                {
                    const ibn = notificationsById[optimisticUpdate.inboxNotificationId];
                    if (ibn === void 0) {
                        break;
                    }
                    notificationsById[optimisticUpdate.inboxNotificationId] = {
                        ...ibn,
                        readAt: optimisticUpdate.readAt
                    };
                    break;
                }
            case "mark-all-inbox-notifications-as-read":
                {
                    for(const id in notificationsById){
                        const ibn = notificationsById[id];
                        if (ibn === void 0) {
                            break;
                        }
                        notificationsById[id] = {
                            ...ibn,
                            readAt: optimisticUpdate.readAt
                        };
                    }
                    break;
                }
            case "delete-inbox-notification":
                {
                    delete notificationsById[optimisticUpdate.inboxNotificationId];
                    break;
                }
            case "delete-all-inbox-notifications":
                {
                    notificationsById = {};
                    break;
                }
        }
    }
    const sortedNotifications = // Sort so that the most recent notifications are first
    Object.values(notificationsById).filter((ibn)=>ibn.kind === "thread" ? threadsDB.get(ibn.threadId) !== void 0 : true).sort((a, b)=>b.notifiedAt.getTime() - a.notifiedAt.getTime());
    return {
        sortedNotifications,
        notificationsById,
        threadsDB
    };
}
function applyOptimisticUpdates_forRoomSubscriptionSettings(settingsLUT, optimisticUpdates) {
    const roomSubscriptionSettingsByRoomId = Object.fromEntries(settingsLUT);
    for (const optimisticUpdate of optimisticUpdates){
        switch(optimisticUpdate.type){
            case "update-room-subscription-settings":
                {
                    const settings = roomSubscriptionSettingsByRoomId[optimisticUpdate.roomId];
                    if (settings === void 0) {
                        break;
                    }
                    roomSubscriptionSettingsByRoomId[optimisticUpdate.roomId] = {
                        ...settings,
                        ...optimisticUpdate.settings
                    };
                }
        }
    }
    return roomSubscriptionSettingsByRoomId;
}
function applyOptimisticUpdates_forSubscriptions(subscriptionsLUT, threads, optimisticUpdates) {
    const subscriptions = Object.fromEntries(subscriptionsLUT);
    for (const update of optimisticUpdates){
        switch(update.type){
            case "update-room-subscription-settings":
                {
                    if (!update.settings.threads) {
                        continue;
                    }
                    const roomThreads = threads.findMany(update.roomId, void 0, "desc", void 0);
                    for (const thread of roomThreads){
                        const subscriptionKey = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getSubscriptionKey"])("thread", thread.id);
                        switch(update.settings.threads){
                            // Create subscriptions for all existing threads in the room
                            case "all":
                                {
                                    subscriptions[subscriptionKey] = {
                                        kind: "thread",
                                        subjectId: thread.id,
                                        createdAt: /* @__PURE__ */ new Date()
                                    };
                                    break;
                                }
                            // Delete subscriptions for all existing threads in the room
                            case "none":
                                {
                                    delete subscriptions[subscriptionKey];
                                    break;
                                }
                            case "replies_and_mentions":
                                {
                                    break;
                                }
                            default:
                                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assertNever"])(update.settings.threads, "Unexpected thread subscription settings.");
                        }
                    }
                }
        }
    }
    return subscriptions;
}
function applyOptimisticUpdates_forNotificationSettings(settings, optimisticUpdates) {
    let outcoming = settings;
    for (const update of optimisticUpdates){
        if (update.type === "update-notification-settings") {
            outcoming = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["patchNotificationSettings"])(outcoming, update.settings);
        }
    }
    return outcoming;
}
function compareInboxNotifications(inboxNotificationA, inboxNotificationB) {
    if (inboxNotificationA.notifiedAt > inboxNotificationB.notifiedAt) {
        return 1;
    } else if (inboxNotificationA.notifiedAt < inboxNotificationB.notifiedAt) {
        return -1;
    }
    if (inboxNotificationA.readAt && inboxNotificationB.readAt) {
        return inboxNotificationA.readAt > inboxNotificationB.readAt ? 1 : inboxNotificationA.readAt < inboxNotificationB.readAt ? -1 : 0;
    } else if (inboxNotificationA.readAt || inboxNotificationB.readAt) {
        return inboxNotificationA.readAt ? 1 : -1;
    }
    return 0;
}
function applyUpsertComment(thread, comment) {
    if (thread.deletedAt !== void 0) {
        return thread;
    }
    if (comment.threadId !== thread.id) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["console"].warn(`Comment ${comment.id} does not belong to thread ${thread.id}`);
        return thread;
    }
    const existingComment = thread.comments.find((existingComment2)=>existingComment2.id === comment.id);
    if (existingComment === void 0) {
        const updatedAt = new Date(Math.max(thread.updatedAt.getTime(), comment.createdAt.getTime()));
        const updatedThread = {
            ...thread,
            updatedAt,
            comments: [
                ...thread.comments,
                comment
            ]
        };
        return updatedThread;
    }
    if (existingComment.deletedAt !== void 0) {
        const updatedComment = {
            ...existingComment,
            metadata: {
                ...existingComment.metadata,
                ...comment.metadata
            }
        };
        const updatedComments = thread.comments.map((c)=>c.id === comment.id ? updatedComment : c);
        return {
            ...thread,
            comments: updatedComments
        };
    }
    if (existingComment.editedAt === void 0 || comment.editedAt === void 0 || existingComment.editedAt <= comment.editedAt) {
        const updatedComments = thread.comments.map((existingComment2)=>existingComment2.id === comment.id ? comment : existingComment2);
        const updatedThread = {
            ...thread,
            updatedAt: new Date(Math.max(thread.updatedAt.getTime(), comment.editedAt?.getTime() || comment.createdAt.getTime())),
            comments: updatedComments
        };
        return updatedThread;
    }
    return thread;
}
function applyDeleteComment(thread, commentId, deletedAt) {
    if (thread.deletedAt !== void 0) {
        return thread;
    }
    const existingComment = thread.comments.find((comment)=>comment.id === commentId);
    if (existingComment === void 0) {
        return thread;
    }
    if (existingComment.deletedAt !== void 0) {
        return thread;
    }
    const updatedComments = thread.comments.map((comment)=>comment.id === commentId ? {
            ...comment,
            deletedAt,
            // We optimistically remove the comment body and attachments when marking it as deleted
            body: void 0,
            attachments: []
        } : comment);
    if (updatedComments.every((comment)=>comment.deletedAt !== void 0)) {
        return {
            ...thread,
            deletedAt,
            updatedAt: deletedAt
        };
    }
    return {
        ...thread,
        updatedAt: deletedAt,
        comments: updatedComments
    };
}
function applyAddReaction(thread, commentId, reaction) {
    if (thread.deletedAt !== void 0) {
        return thread;
    }
    const existingComment = thread.comments.find((comment)=>comment.id === commentId);
    if (existingComment === void 0) {
        return thread;
    }
    if (existingComment.deletedAt !== void 0) {
        return thread;
    }
    const updatedComments = thread.comments.map((comment)=>comment.id === commentId ? {
            ...comment,
            reactions: upsertReaction(comment.reactions, reaction)
        } : comment);
    return {
        ...thread,
        updatedAt: new Date(Math.max(reaction.createdAt.getTime(), thread.updatedAt.getTime())),
        comments: updatedComments
    };
}
function applyRemoveReaction(thread, commentId, emoji, userId, removedAt) {
    if (thread.deletedAt !== void 0) {
        return thread;
    }
    const existingComment = thread.comments.find((comment)=>comment.id === commentId);
    if (existingComment === void 0) {
        return thread;
    }
    if (existingComment.deletedAt !== void 0) {
        return thread;
    }
    const updatedComments = thread.comments.map((comment)=>comment.id === commentId ? {
            ...comment,
            reactions: comment.reactions.map((reaction)=>reaction.emoji === emoji ? {
                    ...reaction,
                    users: reaction.users.filter((user)=>user.id !== userId)
                } : reaction).filter((reaction)=>reaction.users.length > 0)
        } : comment);
    return {
        ...thread,
        updatedAt: new Date(Math.max(removedAt.getTime(), thread.updatedAt.getTime())),
        comments: updatedComments
    };
}
function upsertReaction(reactions, reaction) {
    const existingReaction = reactions.find((existingReaction2)=>existingReaction2.emoji === reaction.emoji);
    if (existingReaction === void 0) {
        return [
            ...reactions,
            {
                emoji: reaction.emoji,
                createdAt: reaction.createdAt,
                users: [
                    {
                        id: reaction.userId
                    }
                ]
            }
        ];
    }
    if (existingReaction.users.some((user)=>user.id === reaction.userId) === false) {
        return reactions.map((existingReaction2)=>existingReaction2.emoji === reaction.emoji ? {
                ...existingReaction2,
                users: [
                    ...existingReaction2.users,
                    {
                        id: reaction.userId
                    }
                ]
            } : existingReaction2);
    }
    return reactions;
}
;
function missingUserError(userId) {
    return new Error(`resolveUsers didn't return anything for user '${userId}'`);
}
function missingRoomInfoError(roomId) {
    return new Error(`resolveRoomsInfo didn't return anything for room '${roomId}'`);
}
function missingGroupInfoError(groupId) {
    return new Error(`resolveGroupsInfo didn't return anything for group '${groupId}'`);
}
function identity2(x) {
    return x;
}
var _umbrellaStores = /* @__PURE__ */ new WeakMap();
var _extras = /* @__PURE__ */ new WeakMap();
var _bundles = /* @__PURE__ */ new WeakMap();
function selectorFor_useUnreadInboxNotificationsCount(result) {
    if (!("count" in result) || result.count === void 0) {
        return result;
    }
    return ASYNC_OK("count", result.count);
}
function selectorFor_useUser(state, userId) {
    if (state === void 0 || state?.isLoading) {
        return state ?? {
            isLoading: true
        };
    }
    if (state.error) {
        return state;
    }
    if (!state.data) {
        return {
            isLoading: false,
            error: missingUserError(userId)
        };
    }
    return {
        isLoading: false,
        user: state.data
    };
}
function selectorFor_useRoomInfo(state, roomId) {
    if (state === void 0 || state?.isLoading) {
        return state ?? {
            isLoading: true
        };
    }
    if (state.error) {
        return state;
    }
    if (!state.data) {
        return {
            isLoading: false,
            error: missingRoomInfoError(roomId)
        };
    }
    return {
        isLoading: false,
        info: state.data
    };
}
function selectorFor_useGroupInfo(state, groupId) {
    if (state === void 0 || state?.isLoading) {
        return state ?? {
            isLoading: true
        };
    }
    if (state.error) {
        return state;
    }
    if (!state.data) {
        return {
            isLoading: false,
            error: missingGroupInfoError(groupId)
        };
    }
    return {
        isLoading: false,
        info: state.data
    };
}
function getOrCreateContextBundle(client) {
    let bundle = _bundles.get(client);
    if (!bundle) {
        bundle = makeLiveblocksContextBundle(client);
        _bundles.set(client, bundle);
    }
    return bundle;
}
function getUmbrellaStoreForClient(client) {
    let store = _umbrellaStores.get(client);
    if (!store) {
        store = new UmbrellaStore(client);
        _umbrellaStores.set(client, store);
    }
    return store;
}
function getLiveblocksExtrasForClient(client) {
    let extras = _extras.get(client);
    if (!extras) {
        extras = makeLiveblocksExtrasForClient(client);
        _extras.set(client, extras);
    }
    return extras;
}
function useEnsureAiConnection(client) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useEnsureAiConnection.useEffect4": ()=>{
            client[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].ai.connectInitially();
        }
    }["useEnsureAiConnection.useEffect4"], [
        client
    ]);
}
function makeLiveblocksExtrasForClient(client) {
    const store = getUmbrellaStoreForClient(client);
    const notificationsPoller = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["makePoller"])(async (signal)=>{
        try {
            return await store.fetchNotificationsDeltaUpdate(signal);
        } catch (err) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["console"].warn(`Polling new inbox notifications failed: ${String(err)}`);
            throw err;
        }
    }, config.NOTIFICATIONS_POLL_INTERVAL, {
        maxStaleTimeMs: config.NOTIFICATIONS_MAX_STALE_TIME
    });
    const unreadNotificationsCountPollersByQueryKey = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DefaultMap"]((queryKey)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["makePoller"])(async (signal)=>{
            try {
                return await store.fetchUnreadNotificationsCount(queryKey, signal);
            } catch (err) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["console"].warn(`Polling unread inbox notifications countfailed: ${String(err)}`);
                throw err;
            }
        }, config.NOTIFICATIONS_POLL_INTERVAL, {
            maxStaleTimeMs: config.NOTIFICATIONS_MAX_STALE_TIME
        }));
    const userThreadsPoller = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["makePoller"])(async (signal)=>{
        try {
            return await store.fetchUserThreadsDeltaUpdate(signal);
        } catch (err) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["console"].warn(`Polling new user threads failed: ${String(err)}`);
            throw err;
        }
    }, config.USER_THREADS_POLL_INTERVAL, {
        maxStaleTimeMs: config.USER_THREADS_MAX_STALE_TIME
    });
    const notificationSettingsPoller = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["makePoller"])(async (signal)=>{
        try {
            return await store.refreshNotificationSettings(signal);
        } catch (err) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["console"].warn(`Polling new notification settings failed: ${String(err)}`);
            throw err;
        }
    }, config.USER_NOTIFICATION_SETTINGS_INTERVAL, {
        maxStaleTimeMs: config.USER_NOTIFICATION_SETTINGS_MAX_STALE_TIME
    });
    return {
        store,
        notificationsPoller,
        userThreadsPoller,
        notificationSettingsPoller,
        unreadNotificationsCountPollersByQueryKey
    };
}
function makeLiveblocksContextBundle(client) {
    const useInboxNotificationThread2 = (inboxNotificationId)=>useInboxNotificationThread_withClient(client, inboxNotificationId);
    const useMarkInboxNotificationAsRead2 = ()=>useMarkInboxNotificationAsRead_withClient(client);
    const useMarkAllInboxNotificationsAsRead2 = ()=>useMarkAllInboxNotificationsAsRead_withClient(client);
    const useDeleteInboxNotification2 = ()=>useDeleteInboxNotification_withClient(client);
    const useDeleteAllInboxNotifications2 = ()=>useDeleteAllInboxNotifications_withClient(client);
    const useUpdateNotificationSettings2 = ()=>useUpdateNotificationSettings_withClient(client);
    function LiveblocksProvider2(props) {
        useEnsureNoLiveblocksProvider();
        return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(ClientContext.Provider, {
            value: client,
            children: props.children
        });
    }
    const shared = createSharedContext(client);
    const bundle = {
        LiveblocksProvider: LiveblocksProvider2,
        useInboxNotifications: (options)=>useInboxNotifications_withClient(client, identity2, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shallow"], options),
        useUnreadInboxNotificationsCount: (options)=>useUnreadInboxNotificationsCount_withClient(client, options),
        useMarkInboxNotificationAsRead: useMarkInboxNotificationAsRead2,
        useMarkAllInboxNotificationsAsRead: useMarkAllInboxNotificationsAsRead2,
        useDeleteInboxNotification: useDeleteInboxNotification2,
        useDeleteAllInboxNotifications: useDeleteAllInboxNotifications2,
        useNotificationSettings: ()=>useNotificationSettings_withClient(client),
        useUpdateNotificationSettings: useUpdateNotificationSettings2,
        useInboxNotificationThread: useInboxNotificationThread2,
        useUserThreads_experimental,
        useAiChats,
        useAiChat,
        useAiChatMessages,
        useAiChatStatus,
        useCreateAiChat,
        useDeleteAiChat,
        useSendAiMessage,
        useUrlMetadata,
        ...shared.classic,
        suspense: {
            LiveblocksProvider: LiveblocksProvider2,
            useInboxNotifications: (options)=>useInboxNotificationsSuspense_withClient(client, options),
            useUnreadInboxNotificationsCount: (options)=>useUnreadInboxNotificationsCountSuspense_withClient(client, options),
            useMarkInboxNotificationAsRead: useMarkInboxNotificationAsRead2,
            useMarkAllInboxNotificationsAsRead: useMarkAllInboxNotificationsAsRead2,
            useDeleteInboxNotification: useDeleteInboxNotification2,
            useDeleteAllInboxNotifications: useDeleteAllInboxNotifications2,
            useInboxNotificationThread: useInboxNotificationThread2,
            useNotificationSettings: ()=>useNotificationSettingsSuspense_withClient(client),
            useUpdateNotificationSettings: useUpdateNotificationSettings2,
            useUserThreads_experimental: useUserThreadsSuspense_experimental,
            useAiChats: useAiChatsSuspense,
            useAiChat: useAiChatSuspense,
            useAiChatMessages: useAiChatMessagesSuspense,
            useAiChatStatus,
            useCreateAiChat,
            useDeleteAiChat,
            useSendAiMessage,
            useUrlMetadata: useUrlMetadataSuspense,
            ...shared.suspense
        }
    };
    return bundle;
}
function useInboxNotifications_withClient(client, selector, isEqual, options) {
    const { store, notificationsPoller: poller } = getLiveblocksExtrasForClient(client);
    const queryKey = makeInboxNotificationsQueryKey(options?.query);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useInboxNotifications_withClient.useEffect4": ()=>void store.outputs.loadingNotifications.getOrCreate(queryKey).waitUntilLoaded()
    }["useInboxNotifications_withClient.useEffect4"]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useInboxNotifications_withClient.useEffect4": ()=>{
            poller.inc();
            poller.pollNowIfStale();
            return ({
                "useInboxNotifications_withClient.useEffect4": ()=>{
                    poller.dec();
                }
            })["useInboxNotifications_withClient.useEffect4"];
        }
    }["useInboxNotifications_withClient.useEffect4"], [
        poller
    ]);
    return useSignal(store.outputs.loadingNotifications.getOrCreate(queryKey).signal, selector, isEqual);
}
function useInboxNotificationsSuspense_withClient(client, options) {
    ensureNotServerSide();
    const store = getLiveblocksExtrasForClient(client).store;
    const queryKey = makeInboxNotificationsQueryKey(options?.query);
    use(store.outputs.loadingNotifications.getOrCreate(queryKey).waitUntilLoaded());
    const result = useInboxNotifications_withClient(client, identity2, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shallow"], options);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(!result.error, "Did not expect error");
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(!result.isLoading, "Did not expect loading");
    return result;
}
function useUnreadInboxNotificationsCount_withClient(client, options) {
    const { store, unreadNotificationsCountPollersByQueryKey: pollers } = getLiveblocksExtrasForClient(client);
    const queryKey = makeInboxNotificationsQueryKey(options?.query);
    const poller = pollers.getOrCreate(queryKey);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useUnreadInboxNotificationsCount_withClient.useEffect4": ()=>void store.outputs.unreadNotificationsCount.getOrCreate(queryKey).waitUntilLoaded()
    }["useUnreadInboxNotificationsCount_withClient.useEffect4"]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useUnreadInboxNotificationsCount_withClient.useEffect4": ()=>{
            poller.inc();
            poller.pollNowIfStale();
            return ({
                "useUnreadInboxNotificationsCount_withClient.useEffect4": ()=>{
                    poller.dec();
                }
            })["useUnreadInboxNotificationsCount_withClient.useEffect4"];
        }
    }["useUnreadInboxNotificationsCount_withClient.useEffect4"], [
        poller
    ]);
    return useSignal(store.outputs.unreadNotificationsCount.getOrCreate(queryKey).signal, selectorFor_useUnreadInboxNotificationsCount, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shallow"]);
}
function useUnreadInboxNotificationsCountSuspense_withClient(client, options) {
    ensureNotServerSide();
    const store = getLiveblocksExtrasForClient(client).store;
    const queryKey = makeInboxNotificationsQueryKey(options?.query);
    use(store.outputs.unreadNotificationsCount.getOrCreate(queryKey).waitUntilLoaded());
    const result = useUnreadInboxNotificationsCount_withClient(client, options);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(!result.isLoading, "Did not expect loading");
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(!result.error, "Did not expect error");
    return result;
}
function useMarkInboxNotificationAsRead_withClient(client) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useMarkInboxNotificationAsRead_withClient.useCallback2": (inboxNotificationId)=>{
            const { store, unreadNotificationsCountPollersByQueryKey } = getLiveblocksExtrasForClient(client);
            const readAt = /* @__PURE__ */ new Date();
            const optimisticId = store.optimisticUpdates.add({
                type: "mark-inbox-notification-as-read",
                inboxNotificationId,
                readAt
            });
            client.markInboxNotificationAsRead(inboxNotificationId).then({
                "useMarkInboxNotificationAsRead_withClient.useCallback2": ()=>{
                    store.markInboxNotificationRead(inboxNotificationId, readAt, optimisticId);
                    for (const poller of unreadNotificationsCountPollersByQueryKey.values()){
                        poller.markAsStale();
                        poller.pollNowIfStale();
                    }
                }
            }["useMarkInboxNotificationAsRead_withClient.useCallback2"], {
                "useMarkInboxNotificationAsRead_withClient.useCallback2": (err)=>{
                    store.optimisticUpdates.remove(optimisticId);
                    client[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].emitError({
                        type: "MARK_INBOX_NOTIFICATION_AS_READ_ERROR",
                        inboxNotificationId
                    }, err);
                }
            }["useMarkInboxNotificationAsRead_withClient.useCallback2"]);
        }
    }["useMarkInboxNotificationAsRead_withClient.useCallback2"], [
        client
    ]);
}
function useMarkAllInboxNotificationsAsRead_withClient(client) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useMarkAllInboxNotificationsAsRead_withClient.useCallback2": ()=>{
            const { store, unreadNotificationsCountPollersByQueryKey } = getLiveblocksExtrasForClient(client);
            const readAt = /* @__PURE__ */ new Date();
            const optimisticId = store.optimisticUpdates.add({
                type: "mark-all-inbox-notifications-as-read",
                readAt
            });
            client.markAllInboxNotificationsAsRead().then({
                "useMarkAllInboxNotificationsAsRead_withClient.useCallback2": ()=>{
                    store.markAllInboxNotificationsRead(optimisticId, readAt);
                    for (const poller of unreadNotificationsCountPollersByQueryKey.values()){
                        poller.markAsStale();
                        poller.pollNowIfStale();
                    }
                }
            }["useMarkAllInboxNotificationsAsRead_withClient.useCallback2"], {
                "useMarkAllInboxNotificationsAsRead_withClient.useCallback2": (err)=>{
                    store.optimisticUpdates.remove(optimisticId);
                    client[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].emitError(// No roomId, threadId, commentId to include for this error
                    {
                        type: "MARK_ALL_INBOX_NOTIFICATIONS_AS_READ_ERROR"
                    }, err);
                }
            }["useMarkAllInboxNotificationsAsRead_withClient.useCallback2"]);
        }
    }["useMarkAllInboxNotificationsAsRead_withClient.useCallback2"], [
        client
    ]);
}
function useDeleteInboxNotification_withClient(client) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useDeleteInboxNotification_withClient.useCallback2": (inboxNotificationId)=>{
            const { store, unreadNotificationsCountPollersByQueryKey } = getLiveblocksExtrasForClient(client);
            const deletedAt = /* @__PURE__ */ new Date();
            const optimisticId = store.optimisticUpdates.add({
                type: "delete-inbox-notification",
                inboxNotificationId,
                deletedAt
            });
            client.deleteInboxNotification(inboxNotificationId).then({
                "useDeleteInboxNotification_withClient.useCallback2": ()=>{
                    store.deleteInboxNotification(inboxNotificationId, optimisticId);
                    for (const poller of unreadNotificationsCountPollersByQueryKey.values()){
                        poller.markAsStale();
                        poller.pollNowIfStale();
                    }
                }
            }["useDeleteInboxNotification_withClient.useCallback2"], {
                "useDeleteInboxNotification_withClient.useCallback2": (err)=>{
                    store.optimisticUpdates.remove(optimisticId);
                    client[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].emitError({
                        type: "DELETE_INBOX_NOTIFICATION_ERROR",
                        inboxNotificationId
                    }, err);
                }
            }["useDeleteInboxNotification_withClient.useCallback2"]);
        }
    }["useDeleteInboxNotification_withClient.useCallback2"], [
        client
    ]);
}
function useDeleteAllInboxNotifications_withClient(client) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useDeleteAllInboxNotifications_withClient.useCallback2": ()=>{
            const { store, unreadNotificationsCountPollersByQueryKey } = getLiveblocksExtrasForClient(client);
            const deletedAt = /* @__PURE__ */ new Date();
            const optimisticId = store.optimisticUpdates.add({
                type: "delete-all-inbox-notifications",
                deletedAt
            });
            client.deleteAllInboxNotifications().then({
                "useDeleteAllInboxNotifications_withClient.useCallback2": ()=>{
                    store.deleteAllInboxNotifications(optimisticId);
                    for (const poller of unreadNotificationsCountPollersByQueryKey.values()){
                        poller.markAsStale();
                        poller.pollNowIfStale();
                    }
                }
            }["useDeleteAllInboxNotifications_withClient.useCallback2"], {
                "useDeleteAllInboxNotifications_withClient.useCallback2": (err)=>{
                    store.optimisticUpdates.remove(optimisticId);
                    client[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].emitError({
                        type: "DELETE_ALL_INBOX_NOTIFICATIONS_ERROR"
                    }, err);
                }
            }["useDeleteAllInboxNotifications_withClient.useCallback2"]);
        }
    }["useDeleteAllInboxNotifications_withClient.useCallback2"], [
        client
    ]);
}
function useInboxNotificationThread_withClient(client, inboxNotificationId) {
    const { store } = getLiveblocksExtrasForClient(client);
    return useSignal(store.outputs.threadifications, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useInboxNotificationThread_withClient.useSignal.useCallback2": (state)=>{
            const inboxNotification = state.notificationsById[inboxNotificationId] ?? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])(`Inbox notification with ID "${inboxNotificationId}" not found`);
            if (inboxNotification.kind !== "thread") {
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])(`Inbox notification with ID "${inboxNotificationId}" is not of kind "thread"`);
            }
            const thread = state.threadsDB.get(inboxNotification.threadId) ?? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])(`Thread with ID "${inboxNotification.threadId}" not found, this inbox notification might not be of kind "thread"`);
            return thread;
        }
    }["useInboxNotificationThread_withClient.useSignal.useCallback2"], [
        inboxNotificationId
    ]));
}
function useUpdateNotificationSettings_withClient(client) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useUpdateNotificationSettings_withClient.useCallback2": (settings)=>{
            const { store } = getLiveblocksExtrasForClient(client);
            const optimisticUpdateId = store.optimisticUpdates.add({
                type: "update-notification-settings",
                settings
            });
            client.updateNotificationSettings(settings).then({
                "useUpdateNotificationSettings_withClient.useCallback2": (settings2)=>{
                    store.updateNotificationSettings_confirmOptimisticUpdate(settings2, optimisticUpdateId);
                }
            }["useUpdateNotificationSettings_withClient.useCallback2"], {
                "useUpdateNotificationSettings_withClient.useCallback2": (err)=>{
                    store.optimisticUpdates.remove(optimisticUpdateId);
                    if (err instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HttpError"]) {
                        if (err.status === 422) {
                            const msg = [
                                err.details?.error,
                                err.details?.reason
                            ].filter(Boolean).join("\n");
                            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["console"].error(msg);
                        }
                        client[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].emitError({
                            type: "UPDATE_NOTIFICATION_SETTINGS_ERROR"
                        }, err);
                    } else {
                        throw err;
                    }
                }
            }["useUpdateNotificationSettings_withClient.useCallback2"]);
        }
    }["useUpdateNotificationSettings_withClient.useCallback2"], [
        client
    ]);
}
function useNotificationSettings_withClient(client) {
    const updateNotificationSettings = useUpdateNotificationSettings_withClient(client);
    const { store, notificationSettingsPoller: poller } = getLiveblocksExtrasForClient(client);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useNotificationSettings_withClient.useEffect4": ()=>{
            void store.outputs.notificationSettings.waitUntilLoaded();
        }
    }["useNotificationSettings_withClient.useEffect4"]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useNotificationSettings_withClient.useEffect4": ()=>{
            poller.inc();
            poller.pollNowIfStale();
            return ({
                "useNotificationSettings_withClient.useEffect4": ()=>{
                    poller.dec();
                }
            })["useNotificationSettings_withClient.useEffect4"];
        }
    }["useNotificationSettings_withClient.useEffect4"], [
        poller
    ]);
    const result = useSignal(store.outputs.notificationSettings.signal);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "useNotificationSettings_withClient.useMemo3": ()=>{
            return [
                result,
                updateNotificationSettings
            ];
        }
    }["useNotificationSettings_withClient.useMemo3"], [
        result,
        updateNotificationSettings
    ]);
}
function useNotificationSettingsSuspense_withClient(client) {
    ensureNotServerSide();
    const store = getLiveblocksExtrasForClient(client).store;
    use(store.outputs.notificationSettings.waitUntilLoaded());
    const [result, updateNotificationSettings] = useNotificationSettings_withClient(client);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(!result.error, "Did not expect error");
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(!result.isLoading, "Did not expect loading");
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "useNotificationSettingsSuspense_withClient.useMemo3": ()=>{
            return [
                result,
                updateNotificationSettings
            ];
        }
    }["useNotificationSettingsSuspense_withClient.useMemo3"], [
        result,
        updateNotificationSettings
    ]);
}
function useUser_withClient(client, userId) {
    const usersStore = client[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].usersStore;
    const getUserState = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useUser_withClient.useCallback2[getUserState]": ()=>usersStore.getItemState(userId)
    }["useUser_withClient.useCallback2[getUserState]"], [
        usersStore,
        userId
    ]);
    const selector = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useUser_withClient.useCallback2[selector]": (state)=>selectorFor_useUser(state, userId)
    }["useUser_withClient.useCallback2[selector]"], [
        userId
    ]);
    const result = useSyncExternalStoreWithSelector(usersStore.subscribe, getUserState, getUserState, selector, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shallow"]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useUser_withClient.useEffect4": ()=>void usersStore.enqueue(userId)
    }["useUser_withClient.useEffect4"]);
    return result;
}
function useUserSuspense_withClient(client, userId) {
    const usersStore = client[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].usersStore;
    const getUserState = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useUserSuspense_withClient.useCallback2[getUserState]": ()=>usersStore.getItemState(userId)
    }["useUserSuspense_withClient.useCallback2[getUserState]"], [
        usersStore,
        userId
    ]);
    const userState = getUserState();
    if (!userState || userState.isLoading) {
        throw usersStore.enqueue(userId);
    }
    if (userState.error) {
        throw userState.error;
    }
    if (!userState.data) {
        throw missingUserError(userId);
    }
    const state = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useSyncExternalStore"])(usersStore.subscribe, getUserState, getUserState);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(state !== void 0, "Unexpected missing state");
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(!state.isLoading, "Unexpected loading state");
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(!state.error, "Unexpected error state");
    return {
        isLoading: false,
        user: state.data,
        error: void 0
    };
}
function useRoomInfo_withClient(client, roomId) {
    const roomsInfoStore = client[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].roomsInfoStore;
    const getRoomInfoState = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useRoomInfo_withClient.useCallback2[getRoomInfoState]": ()=>roomsInfoStore.getItemState(roomId)
    }["useRoomInfo_withClient.useCallback2[getRoomInfoState]"], [
        roomsInfoStore,
        roomId
    ]);
    const selector = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useRoomInfo_withClient.useCallback2[selector]": (state)=>selectorFor_useRoomInfo(state, roomId)
    }["useRoomInfo_withClient.useCallback2[selector]"], [
        roomId
    ]);
    const result = useSyncExternalStoreWithSelector(roomsInfoStore.subscribe, getRoomInfoState, getRoomInfoState, selector, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shallow"]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useRoomInfo_withClient.useEffect4": ()=>void roomsInfoStore.enqueue(roomId)
    }["useRoomInfo_withClient.useEffect4"]);
    return result;
}
function useRoomInfoSuspense_withClient(client, roomId) {
    const roomsInfoStore = client[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].roomsInfoStore;
    const getRoomInfoState = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useRoomInfoSuspense_withClient.useCallback2[getRoomInfoState]": ()=>roomsInfoStore.getItemState(roomId)
    }["useRoomInfoSuspense_withClient.useCallback2[getRoomInfoState]"], [
        roomsInfoStore,
        roomId
    ]);
    const roomInfoState = getRoomInfoState();
    if (!roomInfoState || roomInfoState.isLoading) {
        throw roomsInfoStore.enqueue(roomId);
    }
    if (roomInfoState.error) {
        throw roomInfoState.error;
    }
    if (!roomInfoState.data) {
        throw missingRoomInfoError(roomId);
    }
    const state = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useSyncExternalStore"])(roomsInfoStore.subscribe, getRoomInfoState, getRoomInfoState);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(state !== void 0, "Unexpected missing state");
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(!state.isLoading, "Unexpected loading state");
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(!state.error, "Unexpected error state");
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(state.data !== void 0, "Unexpected missing room info data");
    return {
        isLoading: false,
        info: state.data,
        error: void 0
    };
}
function useGroupInfo_withClient(client, groupId) {
    const groupsInfoStore = client[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].groupsInfoStore;
    const getGroupInfoState = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useGroupInfo_withClient.useCallback2[getGroupInfoState]": ()=>groupsInfoStore.getItemState(groupId)
    }["useGroupInfo_withClient.useCallback2[getGroupInfoState]"], [
        groupsInfoStore,
        groupId
    ]);
    const selector = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useGroupInfo_withClient.useCallback2[selector]": (state)=>selectorFor_useGroupInfo(state, groupId)
    }["useGroupInfo_withClient.useCallback2[selector]"], [
        groupId
    ]);
    const result = useSyncExternalStoreWithSelector(groupsInfoStore.subscribe, getGroupInfoState, getGroupInfoState, selector, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shallow"]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useGroupInfo_withClient.useEffect4": ()=>void groupsInfoStore.enqueue(groupId)
    }["useGroupInfo_withClient.useEffect4"]);
    return result;
}
function useGroupInfoSuspense_withClient(client, groupId) {
    const groupsInfoStore = client[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].groupsInfoStore;
    const getGroupInfoState = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useGroupInfoSuspense_withClient.useCallback2[getGroupInfoState]": ()=>groupsInfoStore.getItemState(groupId)
    }["useGroupInfoSuspense_withClient.useCallback2[getGroupInfoState]"], [
        groupsInfoStore,
        groupId
    ]);
    const groupInfoState = getGroupInfoState();
    if (!groupInfoState || groupInfoState.isLoading) {
        throw groupsInfoStore.enqueue(groupId);
    }
    if (groupInfoState.error) {
        throw groupInfoState.error;
    }
    if (!groupInfoState.data) {
        throw missingGroupInfoError(groupId);
    }
    const state = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useSyncExternalStore"])(groupsInfoStore.subscribe, getGroupInfoState, getGroupInfoState);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(state !== void 0, "Unexpected missing state");
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(!state.isLoading, "Unexpected loading state");
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(!state.error, "Unexpected error state");
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(state.data !== void 0, "Unexpected missing group info data");
    return {
        isLoading: false,
        info: state.data,
        error: void 0
    };
}
function useAiChats(options) {
    const client = useClient();
    const store = getUmbrellaStoreForClient(client);
    const queryKey = makeAiChatsQueryKey(options?.query);
    useEnsureAiConnection(client);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useAiChats.useEffect4": ()=>void store.outputs.aiChats.getOrCreate(queryKey).waitUntilLoaded()
    }["useAiChats.useEffect4"]);
    return useSignal(store.outputs.aiChats.getOrCreate(queryKey).signal, identity2, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shallow"]);
}
function useAiChatsSuspense(options) {
    ensureNotServerSide();
    const client = useClient();
    const store = getUmbrellaStoreForClient(client);
    useEnsureAiConnection(client);
    const queryKey = makeAiChatsQueryKey(options?.query);
    use(store.outputs.aiChats.getOrCreate(queryKey).waitUntilLoaded());
    const result = useAiChats(options);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(!result.error, "Did not expect error");
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(!result.isLoading, "Did not expect loading");
    return result;
}
function useAiChatMessages(chatId, options) {
    const client = useClient();
    const store = getUmbrellaStoreForClient(client);
    useEnsureAiConnection(client);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useAiChatMessages.useEffect4": ()=>void store.outputs.messagesByChatId.getOrCreate(chatId).getOrCreate(options?.branchId ?? null).waitUntilLoaded()
    }["useAiChatMessages.useEffect4"]);
    return useSignal(store.outputs.messagesByChatId.getOrCreate(chatId).getOrCreate(options?.branchId ?? null).signal);
}
function useAiChatMessagesSuspense(chatId, options) {
    ensureNotServerSide();
    const client = useClient();
    const store = getUmbrellaStoreForClient(client);
    useEnsureAiConnection(client);
    use(store.outputs.messagesByChatId.getOrCreate(chatId).getOrCreate(options?.branchId ?? null).waitUntilLoaded());
    const result = useAiChatMessages(chatId, options);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(!result.error, "Did not expect error");
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(!result.isLoading, "Did not expect loading");
    return result;
}
function useAiChat(chatId) {
    const client = useClient();
    const store = getUmbrellaStoreForClient(client);
    useEnsureAiConnection(client);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useAiChat.useEffect4": ()=>void store.outputs.aiChatById.getOrCreate(chatId).waitUntilLoaded()
    }["useAiChat.useEffect4"]);
    return useSignal(store.outputs.aiChatById.getOrCreate(chatId).signal);
}
function useAiChatSuspense(chatId) {
    ensureNotServerSide();
    const client = useClient();
    const store = getUmbrellaStoreForClient(client);
    useEnsureAiConnection(client);
    use(store.outputs.aiChatById.getOrCreate(chatId).waitUntilLoaded());
    const result = useAiChat(chatId);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(!result.error, "Did not expect error");
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(!result.isLoading, "Did not expect loading");
    return result;
}
function useUrlMetadata(url) {
    const client = useClient();
    const store = getUmbrellaStoreForClient(client);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useUrlMetadata.useEffect4": ()=>void store.outputs.urlMetadataByUrl.getOrCreate(url).waitUntilLoaded()
    }["useUrlMetadata.useEffect4"]);
    return useSignal(store.outputs.urlMetadataByUrl.getOrCreate(url).signal);
}
function useUrlMetadataSuspense(url) {
    ensureNotServerSide();
    const client = useClient();
    const store = getUmbrellaStoreForClient(client);
    use(store.outputs.urlMetadataByUrl.getOrCreate(url).waitUntilLoaded());
    const result = useUrlMetadata(url);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(!result.error, "Did not expect error");
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(!result.isLoading, "Did not expect loading");
    return result;
}
function useCreateAiChat() {
    const client = useClient();
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useCreateAiChat.useCallback2": (options)=>{
            if (typeof options === "string") {
                options = {
                    id: options
                };
            }
            client[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].ai.getOrCreateChat(options.id, {
                title: options.title,
                metadata: options.metadata
            }).catch({
                "useCreateAiChat.useCallback2": (err)=>{
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["console"].error(`Failed to create chat with ID "${options.id}": ${String(err)}`);
                }
            }["useCreateAiChat.useCallback2"]);
        }
    }["useCreateAiChat.useCallback2"], [
        client
    ]);
}
function useDeleteAiChat() {
    const client = useClient();
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useDeleteAiChat.useCallback2": (chatId)=>{
            client[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].ai.deleteChat(chatId).catch({
                "useDeleteAiChat.useCallback2": (err)=>{
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["console"].error(`Failed to delete chat with ID "${chatId}": ${String(err)}`);
                }
            }["useDeleteAiChat.useCallback2"]);
        }
    }["useDeleteAiChat.useCallback2"], [
        client
    ]);
}
var DISCONNECTED = Object.freeze({
    status: "disconnected"
});
var LOADING = Object.freeze({
    status: "loading"
});
var IDLE = Object.freeze({
    status: "idle"
});
function useAiChatStatus(chatId, branchId) {
    const client = useClient();
    const store = getUmbrellaStoreForClient(client);
    useEnsureAiConnection(client);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useAiChatStatus.useEffect4": ()=>void store.outputs.messagesByChatId.getOrCreate(chatId).getOrCreate(branchId ?? null).waitUntilLoaded()
    }["useAiChatStatus.useEffect4"]);
    const isAvailable = useSignal(// Subscribe to connection status signal
    client[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].ai.signals.statusΣ, {
        "useAiChatStatus.useSignal[isAvailable]": // "Disconnected" means the AI service is not available
        // as it represents a final error status.
        (status)=>status !== "disconnected"
    }["useAiChatStatus.useSignal[isAvailable]"]);
    const chatStatus = useSignal(// Signal
    store.outputs.messagesByChatId.getOrCreate(chatId).getOrCreate(branchId ?? null).signal, {
        "useAiChatStatus.useSignal[chatStatus]": // Selector
        (result)=>{
            if (result.isLoading) return LOADING;
            if (result.error) return IDLE;
            const messages = result.messages;
            const lastMessage = messages[messages.length - 1];
            if (lastMessage?.role !== "assistant") return IDLE;
            if (lastMessage.status !== "generating" && lastMessage.status !== "awaiting-tool") return IDLE;
            const contentSoFar = lastMessage.contentSoFar;
            const lastPart = contentSoFar[contentSoFar.length - 1];
            if (lastPart?.type === "tool-invocation") {
                return {
                    status: "generating",
                    partType: "tool-invocation",
                    toolName: lastPart.name
                };
            } else {
                return {
                    status: "generating",
                    partType: lastPart?.type
                };
            }
        }
    }["useAiChatStatus.useSignal[chatStatus]"], // Consider { status: "generating", partType: "text" } and { status: "generating", partType: "text" } equal
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shallow"]);
    if (!isAvailable) {
        return DISCONNECTED;
    }
    return chatStatus;
}
function useSendAiMessage(chatId, options) {
    const client = useClient();
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useSendAiMessage.useCallback2": (message)=>{
            const { text: messageText, chatId: messageOptionsChatId, copilotId: messageOptionsCopilotId, ...messageOptions } = typeof message === "string" ? {
                text: message
            } : message;
            const resolvedChatId = messageOptionsChatId ?? chatId ?? // The `useSendAiMessage` overloads prevent this scenario from happening
            // at the type level, and this error prevents it from happening at runtime.
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])("chatId must be provided to either `useSendAiMessage` or its returned function.");
            const messages = client[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].ai.signals.getChatMessagesForBranchΣ(resolvedChatId).get();
            if (("TURBOPACK compile-time value", "development") !== "production" && !messageOptionsCopilotId && !options?.copilotId) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["console"].warn(`No copilot ID was provided to useSendAiMessage when sending the message "${messageText.slice(0, 20)}\u2026". As a result, the message will use the chat's previous copilot ID, which could lead to unexpected behavior.
To ensure the correct copilot ID is used, specify it either through the hook as 'useSendAiMessage("${resolvedChatId}", { copilotId: "co_xxx" })' or via the function as 'sendAiMessage({ text: "${messageText.slice(0, 20)}\u2026", copilotId: "co_xxx" })'`);
            }
            const resolvedCopilotId = messageOptionsCopilotId ?? options?.copilotId ?? client[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].ai.getLastUsedCopilotId(resolvedChatId);
            const lastMessageId = messages[messages.length - 1]?.id ?? null;
            const content = [
                {
                    type: "text",
                    text: messageText
                }
            ];
            const newMessageId = client[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].ai[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].context.messagesStore.createOptimistically(resolvedChatId, "user", lastMessageId, content);
            const newMessage = client[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].ai[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].context.messagesStore.getMessageById(newMessageId);
            const targetMessageId = client[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].ai[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].context.messagesStore.createOptimistically(resolvedChatId, "assistant", newMessageId, resolvedCopilotId);
            void client[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].ai.askUserMessageInChat(resolvedChatId, {
                id: newMessageId,
                parentMessageId: lastMessageId,
                content
            }, targetMessageId, {
                stream: messageOptions.stream ?? options?.stream,
                copilotId: resolvedCopilotId,
                timeout: messageOptions.timeout ?? options?.timeout
            });
            return newMessage;
        }
    }["useSendAiMessage.useCallback2"], [
        client,
        chatId,
        options?.copilotId,
        options?.stream,
        options?.timeout
    ]);
}
function createSharedContext(client) {
    const useClient2 = ()=>client;
    function useSyncStatus2(options) {
        return useSyncStatus_withClient(client, options);
    }
    return {
        classic: {
            useClient: useClient2,
            useUser: (userId)=>useUser_withClient(client, userId),
            useRoomInfo: (roomId)=>useRoomInfo_withClient(client, roomId),
            useGroupInfo: (groupId)=>useGroupInfo_withClient(client, groupId),
            useIsInsideRoom,
            useErrorListener,
            useSyncStatus: useSyncStatus2,
            RegisterAiKnowledge,
            RegisterAiTool
        },
        suspense: {
            useClient: useClient2,
            useUser: (userId)=>useUserSuspense_withClient(client, userId),
            useRoomInfo: (roomId)=>useRoomInfoSuspense_withClient(client, roomId),
            useGroupInfo: (groupId)=>useGroupInfoSuspense_withClient(client, groupId),
            useIsInsideRoom,
            useErrorListener,
            useSyncStatus: useSyncStatus2,
            RegisterAiKnowledge,
            RegisterAiTool
        }
    };
}
function useEnsureNoLiveblocksProvider(options) {
    const existing = useClientOrNull();
    if (!options?.allowNesting && existing !== null) {
        throw new Error("You cannot nest multiple LiveblocksProvider instances in the same React tree.");
    }
}
function LiveblocksProviderWithClient(props) {
    useEnsureNoLiveblocksProvider(props);
    return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(ClientContext.Provider, {
        value: props.client,
        children: props.children
    });
}
function LiveblocksProvider(props) {
    const { children, ...o } = props;
    const options = {
        publicApiKey: useInitial(o.publicApiKey),
        throttle: useInitial(o.throttle),
        lostConnectionTimeout: useInitial(o.lostConnectionTimeout),
        backgroundKeepAliveTimeout: useInitial(o.backgroundKeepAliveTimeout),
        polyfills: useInitial(o.polyfills),
        unstable_streamData: useInitial(o.unstable_streamData),
        preventUnsavedChanges: useInitial(o.preventUnsavedChanges),
        badgeLocation: useInitial(o.badgeLocation),
        authEndpoint: useInitialUnlessFunction(o.authEndpoint),
        resolveMentionSuggestions: useInitialUnlessFunction(o.resolveMentionSuggestions),
        resolveUsers: useInitialUnlessFunction(o.resolveUsers),
        resolveRoomsInfo: useInitialUnlessFunction(o.resolveRoomsInfo),
        resolveGroupsInfo: useInitialUnlessFunction(o.resolveGroupsInfo),
        baseUrl: useInitial(o.baseUrl),
        enableDebugLogging: useInitial(// @ts-expect-error - Hidden config options
        o.enableDebugLogging)
    };
    const client = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "LiveblocksProvider.useMemo3[client]": ()=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createClient"])(options)
    }["LiveblocksProvider.useMemo3[client]"], []);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "LiveblocksProvider.useEffect4": ()=>{
            return ({
                "LiveblocksProvider.useEffect4": ()=>{
                    client[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].ai.disconnect();
                }
            })["LiveblocksProvider.useEffect4"];
        }
    }["LiveblocksProvider.useEffect4"], [
        client
    ]);
    return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(LiveblocksProviderWithClient, {
        client,
        children
    });
}
function createLiveblocksContext(client) {
    return getOrCreateContextBundle(client);
}
function useUserThreads_experimental(options = {}) {
    const client = useClient();
    const { store, userThreadsPoller: poller } = getLiveblocksExtrasForClient(client);
    const queryKey = makeUserThreadsQueryKey(options.query);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useUserThreads_experimental.useEffect4": ()=>void store.outputs.loadingUserThreads.getOrCreate(queryKey).waitUntilLoaded()
    }["useUserThreads_experimental.useEffect4"]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useUserThreads_experimental.useEffect4": ()=>{
            poller.inc();
            poller.pollNowIfStale();
            return ({
                "useUserThreads_experimental.useEffect4": ()=>{
                    poller.dec();
                }
            })["useUserThreads_experimental.useEffect4"];
        }
    }["useUserThreads_experimental.useEffect4"], [
        poller
    ]);
    return useSignal(store.outputs.loadingUserThreads.getOrCreate(queryKey).signal);
}
function useUserThreadsSuspense_experimental(options = {}) {
    ensureNotServerSide();
    const client = useClient();
    const { store } = getLiveblocksExtrasForClient(client);
    const queryKey = makeUserThreadsQueryKey(options.query);
    use(store.outputs.loadingUserThreads.getOrCreate(queryKey).waitUntilLoaded());
    const result = useUserThreads_experimental(options);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(!result.error, "Did not expect error");
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(!result.isLoading, "Did not expect loading");
    return result;
}
function useInboxNotifications(options) {
    return useInboxNotifications_withClient(useClient(), identity2, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shallow"], options);
}
function useInboxNotificationsSuspense(options) {
    return useInboxNotificationsSuspense_withClient(useClient(), options);
}
function useInboxNotificationThread(inboxNotificationId) {
    return useInboxNotificationThread_withClient(useClient(), inboxNotificationId);
}
function useMarkAllInboxNotificationsAsRead() {
    return useMarkAllInboxNotificationsAsRead_withClient(useClient());
}
function useMarkInboxNotificationAsRead() {
    return useMarkInboxNotificationAsRead_withClient(useClient());
}
function useDeleteAllInboxNotifications() {
    return useDeleteAllInboxNotifications_withClient(useClient());
}
function useDeleteInboxNotification() {
    return useDeleteInboxNotification_withClient(useClient());
}
function useUnreadInboxNotificationsCount(options) {
    return useUnreadInboxNotificationsCount_withClient(useClient(), options);
}
function useUnreadInboxNotificationsCountSuspense(options) {
    return useUnreadInboxNotificationsCountSuspense_withClient(useClient(), options);
}
function useNotificationSettings() {
    return useNotificationSettings_withClient(useClient());
}
function useNotificationSettingsSuspense() {
    return useNotificationSettingsSuspense_withClient(useClient());
}
function useUpdateNotificationSettings() {
    return useUpdateNotificationSettings_withClient(useClient());
}
function useUser(userId) {
    const client = useClient();
    return useUser_withClient(client, userId);
}
function useUserSuspense(userId) {
    const client = useClient();
    return useUserSuspense_withClient(client, userId);
}
function useRoomInfo(roomId) {
    return useRoomInfo_withClient(useClient(), roomId);
}
function useRoomInfoSuspense(roomId) {
    return useRoomInfoSuspense_withClient(useClient(), roomId);
}
function useGroupInfo(groupId) {
    return useGroupInfo_withClient(useClient(), groupId);
}
function useGroupInfoSuspense(groupId) {
    return useGroupInfoSuspense_withClient(useClient(), groupId);
}
var _useInboxNotificationThread = useInboxNotificationThread;
var _useUser = useUser;
var _useUserSuspense = useUserSuspense;
var _useUserThreads_experimental = useUserThreads_experimental;
var _useUserThreadsSuspense_experimental = useUserThreadsSuspense_experimental;
var _useAiChats = useAiChats;
var _useAiChatsSuspense = useAiChatsSuspense;
var _useAiChat = useAiChat;
var _useAiChatSuspense = useAiChatSuspense;
var _useAiChatMessages = useAiChatMessages;
var _useAiChatMessagesSuspense = useAiChatMessagesSuspense;
var _useUrlMetadata = useUrlMetadata;
var _useUrlMetadataSuspense = useUrlMetadataSuspense;
function useSyncStatus_withClient(client, options) {
    const smooth = useInitial(options?.smooth ?? false);
    if (smooth) {
        return useSyncStatusSmooth_withClient(client);
    } else {
        return useSyncStatusImmediate_withClient(client);
    }
}
function useSyncStatusImmediate_withClient(client) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useSyncExternalStore"])(client.events.syncStatus.subscribe, client.getSyncStatus, client.getSyncStatus);
}
function useSyncStatusSmooth_withClient(client) {
    const getter = client.getSyncStatus;
    const [status, setStatus] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])(getter);
    const oldStatus = useLatest(getter());
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useSyncStatusSmooth_withClient.useEffect4": ()=>{
            let timeoutId;
            const unsub = client.events.syncStatus.subscribe({
                "useSyncStatusSmooth_withClient.useEffect4.unsub": ()=>{
                    const newStatus = getter();
                    if (oldStatus.current === "synchronizing" && newStatus === "synchronized") {
                        timeoutId = setTimeout({
                            "useSyncStatusSmooth_withClient.useEffect4.unsub": ()=>setStatus(newStatus)
                        }["useSyncStatusSmooth_withClient.useEffect4.unsub"], config.SMOOTH_DELAY);
                    } else {
                        clearTimeout(timeoutId);
                        setStatus(newStatus);
                    }
                }
            }["useSyncStatusSmooth_withClient.useEffect4.unsub"]);
            return ({
                "useSyncStatusSmooth_withClient.useEffect4": ()=>{
                    clearTimeout(timeoutId);
                    unsub();
                }
            })["useSyncStatusSmooth_withClient.useEffect4"];
        }
    }["useSyncStatusSmooth_withClient.useEffect4"], [
        client,
        getter,
        oldStatus
    ]);
    return status;
}
function useSyncStatus(options) {
    return useSyncStatus_withClient(useClient(), options);
}
function useErrorListener(callback) {
    const client = useClient();
    const savedCallback = useLatest(callback);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useErrorListener.useEffect4": ()=>client.events.error.subscribe({
                "useErrorListener.useEffect4": (e)=>savedCallback.current(e)
            }["useErrorListener.useEffect4"])
    }["useErrorListener.useEffect4"], [
        client,
        savedCallback
    ]);
}
;
;
;
;
function handleScrollToCommentOnLoad(shouldScrollOnLoad, state) {
    if (shouldScrollOnLoad === false) return;
    if (!state.threads) return;
    const isWindowDefined = typeof window !== "undefined";
    if (!isWindowDefined) return;
    const hash = window.location.hash;
    const commentId = hash.slice(1);
    if (!commentId.startsWith("cm_")) return;
    const comment = document.getElementById(commentId);
    if (comment === null) return;
    const comments = state.threads.flatMap((thread)=>thread.comments);
    const isCommentInThreads = comments.some((comment2)=>comment2.id === commentId);
    if (!isCommentInThreads) return;
    comment.scrollIntoView();
}
function useScrollToCommentOnLoadEffect(shouldScrollOnLoad, state) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useScrollToCommentOnLoadEffect.useEffect5": ()=>{
            handleScrollToCommentOnLoad(shouldScrollOnLoad, state);
        }
    }["useScrollToCommentOnLoadEffect.useEffect5"], // eslint-disable-next-line react-hooks/exhaustive-deps -- We only want to run this effect once
    [
        state.isLoading
    ]);
}
;
var noop2 = ()=>{};
var identity3 = (x)=>x;
var STABLE_EMPTY_LIST = Object.freeze([]);
function alwaysEmptyList() {
    return STABLE_EMPTY_LIST;
}
function alwaysNull() {
    return null;
}
function selectorFor_useOthersConnectionIds(others) {
    return others.map((user)=>user.connectionId);
}
function makeMutationContext(room) {
    const cannotUseUntil = "This mutation cannot be used until";
    const needsPresence = `${cannotUseUntil} connected to the Liveblocks room`;
    const needsStorage = `${cannotUseUntil} storage has been loaded`;
    return {
        get storage () {
            const mutableRoot = room.getStorageSnapshot();
            if (mutableRoot === null) {
                throw new Error(needsStorage);
            }
            return mutableRoot;
        },
        get self () {
            const self = room.getSelf();
            if (self === null) {
                throw new Error(needsPresence);
            }
            return self;
        },
        get others () {
            const others = room.getOthers();
            if (room.getSelf() === null) {
                throw new Error(needsPresence);
            }
            return others;
        },
        setMyPresence: room.updatePresence
    };
}
function getCurrentUserId(client) {
    const userId = client[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].currentUserId.get();
    if (userId === void 0) {
        return "anonymous";
    }
    return userId;
}
var _extras2 = /* @__PURE__ */ new WeakMap();
var _bundles2 = /* @__PURE__ */ new WeakMap();
function getOrCreateRoomContextBundle(client) {
    let bundle = _bundles2.get(client);
    if (!bundle) {
        bundle = makeRoomContextBundle(client);
        _bundles2.set(client, bundle);
    }
    return bundle;
}
function getRoomExtrasForClient(client) {
    let extras = _extras2.get(client);
    if (!extras) {
        extras = makeRoomExtrasForClient(client);
        _extras2.set(client, extras);
    }
    return extras;
}
function makeRoomExtrasForClient(client) {
    const store = getUmbrellaStoreForClient(client);
    function onMutationFailure(optimisticId, context, innerError) {
        store.optimisticUpdates.remove(optimisticId);
        if (innerError instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HttpError"]) {
            if (innerError.status === 403) {
                const detailedMessage = [
                    innerError.message,
                    innerError.details?.suggestion,
                    innerError.details?.docs
                ].filter(Boolean).join("\n");
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["console"].error(detailedMessage);
            }
            client[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].emitError(context, innerError);
        } else {
            throw innerError;
        }
    }
    const threadsPollersByRoomId = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DefaultMap"]((roomId)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["makePoller"])(async (signal)=>{
            try {
                return await store.fetchRoomThreadsDeltaUpdate(roomId, signal);
            } catch (err) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["console"].warn(`Polling new threads for '${roomId}' failed: ${String(err)}`);
                throw err;
            }
        }, config.ROOM_THREADS_POLL_INTERVAL, {
            maxStaleTimeMs: config.ROOM_THREADS_MAX_STALE_TIME
        }));
    const versionsPollersByRoomId = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DefaultMap"]((roomId)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["makePoller"])(async (signal)=>{
            try {
                return await store.fetchRoomVersionsDeltaUpdate(roomId, signal);
            } catch (err) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["console"].warn(`Polling new history versions for '${roomId}' failed: ${String(err)}`);
                throw err;
            }
        }, config.HISTORY_VERSIONS_POLL_INTERVAL, {
            maxStaleTimeMs: config.HISTORY_VERSIONS_MAX_STALE_TIME
        }));
    const roomSubscriptionSettingsPollersByRoomId = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DefaultMap"]((roomId)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["makePoller"])(async (signal)=>{
            try {
                return await store.refreshRoomSubscriptionSettings(roomId, signal);
            } catch (err) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["console"].warn(`Polling subscription settings for '${roomId}' failed: ${String(err)}`);
                throw err;
            }
        }, config.ROOM_SUBSCRIPTION_SETTINGS_POLL_INTERVAL, {
            maxStaleTimeMs: config.ROOM_SUBSCRIPTION_SETTINGS_MAX_STALE_TIME
        }));
    return {
        store,
        onMutationFailure,
        pollThreadsForRoomId: (roomId)=>{
            const threadsPoller = threadsPollersByRoomId.getOrCreate(roomId);
            if (threadsPoller) {
                threadsPoller.markAsStale();
                threadsPoller.pollNowIfStale();
            }
        },
        getOrCreateThreadsPollerForRoomId: threadsPollersByRoomId.getOrCreate.bind(threadsPollersByRoomId),
        getOrCreateVersionsPollerForRoomId: versionsPollersByRoomId.getOrCreate.bind(versionsPollersByRoomId),
        getOrCreateSubscriptionSettingsPollerForRoomId: roomSubscriptionSettingsPollersByRoomId.getOrCreate.bind(roomSubscriptionSettingsPollersByRoomId)
    };
}
function makeRoomContextBundle(client) {
    function RoomProvider_withImplicitLiveblocksProvider(props) {
        return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(LiveblocksProviderWithClient, {
            client,
            allowNesting: true,
            children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(RoomProvider, {
                ...props
            })
        });
    }
    const shared = createSharedContext(client);
    const bundle = {
        RoomContext,
        RoomProvider: RoomProvider_withImplicitLiveblocksProvider,
        useRoom,
        useStatus,
        useBroadcastEvent,
        useOthersListener,
        useLostConnectionListener,
        useEventListener,
        useHistory,
        useUndo,
        useRedo,
        useCanRedo,
        useCanUndo,
        useStorageRoot,
        useStorage,
        useSelf,
        useMyPresence,
        useUpdateMyPresence,
        useOthers,
        useOthersMapped,
        useOthersConnectionIds,
        useOther,
        // prettier-ignore
        useMutation,
        useThreads,
        useSearchComments,
        // prettier-ignore
        useCreateThread,
        useDeleteThread,
        useEditThreadMetadata,
        useMarkThreadAsResolved,
        useMarkThreadAsUnresolved,
        useSubscribeToThread,
        useUnsubscribeFromThread,
        useCreateComment,
        useEditComment,
        useEditCommentMetadata,
        useDeleteComment,
        useAddReaction,
        useRemoveReaction,
        useMarkThreadAsRead,
        useThreadSubscription,
        useAttachmentUrl,
        useHistoryVersions,
        useHistoryVersionData,
        useRoomSubscriptionSettings,
        useUpdateRoomSubscriptionSettings,
        ...shared.classic,
        suspense: {
            RoomContext,
            RoomProvider: RoomProvider_withImplicitLiveblocksProvider,
            useRoom,
            useStatus,
            useBroadcastEvent,
            useOthersListener,
            useLostConnectionListener,
            useEventListener,
            useHistory,
            useUndo,
            useRedo,
            useCanRedo,
            useCanUndo,
            useStorageRoot,
            useStorage: useStorageSuspense,
            useSelf: useSelfSuspense,
            useMyPresence,
            useUpdateMyPresence,
            useOthers: useOthersSuspense,
            useOthersMapped: useOthersMappedSuspense,
            useOthersConnectionIds: useOthersConnectionIdsSuspense,
            useOther: useOtherSuspense,
            // prettier-ignore
            useMutation,
            useThreads: useThreadsSuspense,
            // prettier-ignore
            useCreateThread,
            useDeleteThread,
            useEditThreadMetadata,
            useMarkThreadAsResolved,
            useMarkThreadAsUnresolved,
            useSubscribeToThread,
            useUnsubscribeFromThread,
            useCreateComment,
            useEditComment,
            useEditCommentMetadata,
            useDeleteComment,
            useAddReaction,
            useRemoveReaction,
            useMarkThreadAsRead,
            useThreadSubscription,
            useAttachmentUrl: useAttachmentUrlSuspense,
            // TODO: useHistoryVersionData: useHistoryVersionDataSuspense,
            useHistoryVersions: useHistoryVersionsSuspense,
            useRoomSubscriptionSettings: useRoomSubscriptionSettingsSuspense,
            useUpdateRoomSubscriptionSettings,
            ...shared.suspense
        }
    };
    return Object.defineProperty(bundle, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"], {
        enumerable: false
    });
}
function RoomProvider(props) {
    const client = useClient();
    const [cache] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])({
        "RoomProvider.useState3": ()=>/* @__PURE__ */ new Map()
    }["RoomProvider.useState3"]);
    const stableEnterRoom = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "RoomProvider.useCallback3[stableEnterRoom]": (roomId, options)=>{
            const cached = cache.get(roomId);
            if (cached) return cached;
            const rv = client.enterRoom(roomId, options);
            const origLeave = rv.leave;
            rv.leave = ({
                "RoomProvider.useCallback3[stableEnterRoom]": ()=>{
                    origLeave();
                    cache.delete(roomId);
                }
            })["RoomProvider.useCallback3[stableEnterRoom]"];
            cache.set(roomId, rv);
            return rv;
        }
    }["RoomProvider.useCallback3[stableEnterRoom]"], [
        client,
        cache
    ]);
    return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(RoomProviderInner, {
        ...props,
        stableEnterRoom
    });
}
function RoomProviderInner(props) {
    const client = useClient();
    const { id: roomId, stableEnterRoom } = props;
    if ("TURBOPACK compile-time truthy", 1) {
        if (!roomId) {
            throw new Error("RoomProvider id property is required. For more information: https://liveblocks.io/docs/errors/liveblocks-react/RoomProvider-id-property-is-required");
        }
        if (typeof roomId !== "string") {
            throw new Error("RoomProvider id property should be a string.");
        }
        const majorReactVersion = parseInt(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["version"]) || 1;
        const requiredVersion = 18;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["errorIf"])(majorReactVersion < requiredVersion, `React ${requiredVersion} or higher is required (you\u2019re on ${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["version"]})`);
    }
    const frozenProps = useInitial({
        initialPresence: props.initialPresence,
        initialStorage: props.initialStorage,
        autoConnect: props.autoConnect ?? typeof window !== "undefined",
        engine: props.engine
    }, roomId);
    const [{ room }, setRoomLeavePair] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])({
        "RoomProviderInner.useState3": ()=>stableEnterRoom(roomId, {
                ...frozenProps,
                autoConnect: false
            })
    }["RoomProviderInner.useState3"]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "RoomProviderInner.useEffect6": ()=>{
            const { store } = getRoomExtrasForClient(client);
            async function handleCommentEvent(message) {
                if (message.type === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ServerMsgCode"].THREAD_DELETED) {
                    store.deleteThread(message.threadId, null);
                    return;
                }
                const info = await room.getThread(message.threadId);
                if (!info.thread) {
                    store.deleteThread(message.threadId, null);
                    return;
                }
                const { thread, inboxNotification: maybeNotification, subscription: maybeSubscription } = info;
                const existingThread = store.outputs.threads.get().getEvenIfDeleted(message.threadId);
                switch(message.type){
                    case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ServerMsgCode"].COMMENT_EDITED:
                    case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ServerMsgCode"].THREAD_METADATA_UPDATED:
                    case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ServerMsgCode"].THREAD_UPDATED:
                    case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ServerMsgCode"].COMMENT_REACTION_ADDED:
                    case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ServerMsgCode"].COMMENT_REACTION_REMOVED:
                    case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ServerMsgCode"].COMMENT_DELETED:
                    case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ServerMsgCode"].COMMENT_METADATA_UPDATED:
                        if (!existingThread) break;
                        store.updateThreadifications([
                            thread
                        ], maybeNotification ? [
                            maybeNotification
                        ] : [], maybeSubscription ? [
                            maybeSubscription
                        ] : []);
                        break;
                    case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ServerMsgCode"].COMMENT_CREATED:
                        store.updateThreadifications([
                            thread
                        ], maybeNotification ? [
                            maybeNotification
                        ] : [], maybeSubscription ? [
                            maybeSubscription
                        ] : []);
                        break;
                    default:
                        break;
                }
            }
            return room.events.comments.subscribe({
                "RoomProviderInner.useEffect6": (message)=>void handleCommentEvent(message)
            }["RoomProviderInner.useEffect6"]);
        }
    }["RoomProviderInner.useEffect6"], [
        client,
        room
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "RoomProviderInner.useEffect6": ()=>{
            const pair = stableEnterRoom(roomId, frozenProps);
            setRoomLeavePair(pair);
            const { room: room2, leave } = pair;
            if (frozenProps.autoConnect) {
                room2.connect();
            }
            return ({
                "RoomProviderInner.useEffect6": ()=>{
                    leave();
                }
            })["RoomProviderInner.useEffect6"];
        }
    }["RoomProviderInner.useEffect6"], [
        roomId,
        frozenProps,
        stableEnterRoom
    ]);
    return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(RoomContext.Provider, {
        value: room,
        children: props.children
    });
}
function useRoom(options) {
    const room = useRoomOrNull();
    if (room === null && !options?.allowOutsideRoom) {
        throw new Error("RoomProvider is missing from the React tree.");
    }
    return room;
}
function useStatus() {
    const room = useRoom();
    const subscribe = room.events.status.subscribe;
    const getSnapshot = room.getStatus;
    const getServerSnapshot = room.getStatus;
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useSyncExternalStore"])(subscribe, getSnapshot, getServerSnapshot);
}
function useReportTextEditor(editor, rootKey) {
    const isReported = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(false);
    const room = useRoom();
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useReportTextEditor.useEffect6": ()=>{
            if (isReported.current) {
                return;
            }
            const unsubscribe = room.events.status.subscribe({
                "useReportTextEditor.useEffect6.unsubscribe": (status)=>{
                    if (status === "connected" && !isReported.current) {
                        isReported.current = true;
                        void room[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].reportTextEditor(editor, rootKey);
                    }
                }
            }["useReportTextEditor.useEffect6.unsubscribe"]);
            return unsubscribe;
        }
    }["useReportTextEditor.useEffect6"], [
        room,
        editor,
        rootKey
    ]);
}
function useYjsProvider() {
    const room = useRoom();
    const subscribe = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useYjsProvider.useCallback3[subscribe]": (onStoreChange)=>{
            return room[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].yjsProviderDidChange.subscribe(onStoreChange);
        }
    }["useYjsProvider.useCallback3[subscribe]"], [
        room
    ]);
    const getSnapshot = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useYjsProvider.useCallback3[getSnapshot]": ()=>{
            return room[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].getYjsProvider();
        }
    }["useYjsProvider.useCallback3[getSnapshot]"], [
        room
    ]);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useSyncExternalStore"])(subscribe, getSnapshot, getSnapshot);
}
function useCreateTextMention() {
    const room = useRoom();
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useCreateTextMention.useCallback3": (mentionId, mention)=>{
            room[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].createTextMention(mentionId, mention).catch({
                "useCreateTextMention.useCallback3": (err)=>{
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["console"].error(`Cannot create text mention for mention '${mentionId}'`, err);
                }
            }["useCreateTextMention.useCallback3"]);
        }
    }["useCreateTextMention.useCallback3"], [
        room
    ]);
}
function useDeleteTextMention() {
    const room = useRoom();
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useDeleteTextMention.useCallback3": (mentionId)=>{
            room[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].deleteTextMention(mentionId).catch({
                "useDeleteTextMention.useCallback3": (err)=>{
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["console"].error(`Cannot delete text mention '${mentionId}'`, err);
                }
            }["useDeleteTextMention.useCallback3"]);
        }
    }["useDeleteTextMention.useCallback3"], [
        room
    ]);
}
function useResolveMentionSuggestions() {
    const client = useClient();
    return client[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].resolveMentionSuggestions;
}
function useMentionSuggestionsCache() {
    const client = useClient();
    return client[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].mentionSuggestionsCache;
}
function useBroadcastEvent() {
    const room = useRoom();
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useBroadcastEvent.useCallback3": (event, options = {
            shouldQueueEventIfNotReady: false
        })=>{
            room.broadcastEvent(event, options);
        }
    }["useBroadcastEvent.useCallback3"], [
        room
    ]);
}
function useOthersListener(callback) {
    const room = useRoom();
    const savedCallback = useLatest(callback);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useOthersListener.useEffect6": ()=>room.events.others.subscribe({
                "useOthersListener.useEffect6": (event)=>savedCallback.current(event)
            }["useOthersListener.useEffect6"])
    }["useOthersListener.useEffect6"], [
        room,
        savedCallback
    ]);
}
function useLostConnectionListener(callback) {
    const room = useRoom();
    const savedCallback = useLatest(callback);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useLostConnectionListener.useEffect6": ()=>room.events.lostConnection.subscribe({
                "useLostConnectionListener.useEffect6": (event)=>savedCallback.current(event)
            }["useLostConnectionListener.useEffect6"])
    }["useLostConnectionListener.useEffect6"], [
        room,
        savedCallback
    ]);
}
function useEventListener(callback) {
    const room = useRoom();
    const savedCallback = useLatest(callback);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useEventListener.useEffect6": ()=>{
            const listener = {
                "useEventListener.useEffect6.listener": (eventData)=>{
                    savedCallback.current(eventData);
                }
            }["useEventListener.useEffect6.listener"];
            return room.events.customEvent.subscribe(listener);
        }
    }["useEventListener.useEffect6"], [
        room,
        savedCallback
    ]);
}
function useHistory() {
    return useRoom().history;
}
function useUndo() {
    return useHistory().undo;
}
function useRedo() {
    return useHistory().redo;
}
function useCanUndo() {
    const room = useRoom();
    const subscribe = room.events.history.subscribe;
    const canUndo = room.history.canUndo;
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useSyncExternalStore"])(subscribe, canUndo, canUndo);
}
function useCanRedo() {
    const room = useRoom();
    const subscribe = room.events.history.subscribe;
    const canRedo = room.history.canRedo;
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useSyncExternalStore"])(subscribe, canRedo, canRedo);
}
function useSelf(maybeSelector, isEqual) {
    const room = useRoom();
    const subscribe = room.events.self.subscribe;
    const getSnapshot = room.getSelf;
    const selector = maybeSelector ?? identity3;
    const wrappedSelector = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useSelf.useCallback3[wrappedSelector]": (me)=>me !== null ? selector(me) : null
    }["useSelf.useCallback3[wrappedSelector]"], [
        selector
    ]);
    const getServerSnapshot = alwaysNull;
    return useSyncExternalStoreWithSelector(subscribe, getSnapshot, getServerSnapshot, wrappedSelector, isEqual);
}
function useMyPresence() {
    const room = useRoom();
    const subscribe = room.events.myPresence.subscribe;
    const getSnapshot = room.getPresence;
    const presence = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useSyncExternalStore"])(subscribe, getSnapshot, getSnapshot);
    const setPresence = room.updatePresence;
    return [
        presence,
        setPresence
    ];
}
function useUpdateMyPresence() {
    return useRoom().updatePresence;
}
function useOthers(selector, isEqual) {
    const room = useRoom();
    const subscribe = room.events.others.subscribe;
    const getSnapshot = room.getOthers;
    const getServerSnapshot = alwaysEmptyList;
    return useSyncExternalStoreWithSelector(subscribe, getSnapshot, getServerSnapshot, selector ?? identity3, isEqual);
}
function useOthersMapped(itemSelector, itemIsEqual) {
    const wrappedSelector = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useOthersMapped.useCallback3[wrappedSelector]": (others)=>others.map({
                "useOthersMapped.useCallback3[wrappedSelector]": (other)=>[
                        other.connectionId,
                        itemSelector(other)
                    ]
            }["useOthersMapped.useCallback3[wrappedSelector]"])
    }["useOthersMapped.useCallback3[wrappedSelector]"], [
        itemSelector
    ]);
    const wrappedIsEqual = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useOthersMapped.useCallback3[wrappedIsEqual]": (a, b)=>{
            const eq = itemIsEqual ?? Object.is;
            return a.length === b.length && a.every({
                "useOthersMapped.useCallback3[wrappedIsEqual]": (atuple, index)=>{
                    const btuple = b[index];
                    return atuple[0] === btuple[0] && eq(atuple[1], btuple[1]);
                }
            }["useOthersMapped.useCallback3[wrappedIsEqual]"]);
        }
    }["useOthersMapped.useCallback3[wrappedIsEqual]"], [
        itemIsEqual
    ]);
    return useOthers(wrappedSelector, wrappedIsEqual);
}
function useOthersConnectionIds() {
    return useOthers(selectorFor_useOthersConnectionIds, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shallow"]);
}
var NOT_FOUND = Symbol();
function useOther(connectionId, selector, isEqual) {
    const wrappedSelector = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useOther.useCallback3[wrappedSelector]": (others)=>{
            const other2 = others.find({
                "useOther.useCallback3[wrappedSelector].other2": (other3)=>other3.connectionId === connectionId
            }["useOther.useCallback3[wrappedSelector].other2"]);
            return other2 !== void 0 ? selector(other2) : NOT_FOUND;
        }
    }["useOther.useCallback3[wrappedSelector]"], [
        connectionId,
        selector
    ]);
    const wrappedIsEqual = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useOther.useCallback3[wrappedIsEqual]": (prev, curr)=>{
            if (prev === NOT_FOUND || curr === NOT_FOUND) {
                return prev === curr;
            }
            const eq = isEqual ?? Object.is;
            return eq(prev, curr);
        }
    }["useOther.useCallback3[wrappedIsEqual]"], [
        isEqual
    ]);
    const other = useOthers(wrappedSelector, wrappedIsEqual);
    if (other === NOT_FOUND) {
        throw new Error(`No such other user with connection id ${connectionId} exists`);
    }
    return other;
}
function useMutableStorageRoot() {
    const room = useRoom();
    const subscribe = room.events.storageDidLoad.subscribeOnce;
    const getSnapshot = room.getStorageSnapshot;
    const getServerSnapshot = alwaysNull;
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useSyncExternalStore"])(subscribe, getSnapshot, getServerSnapshot);
}
function useStorageRoot() {
    return [
        useMutableStorageRoot()
    ];
}
function useStorage(selector, isEqual) {
    const room = useRoom();
    const rootOrNull = useMutableStorageRoot();
    const wrappedSelector = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useStorage.useCallback3[wrappedSelector]": (rootOrNull2)=>rootOrNull2 !== null ? selector(rootOrNull2) : null
    }["useStorage.useCallback3[wrappedSelector]"], [
        selector
    ]);
    const subscribe = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useStorage.useCallback3[subscribe]": (onStoreChange)=>rootOrNull !== null ? room.subscribe(rootOrNull, onStoreChange, {
                isDeep: true
            }) : noop2
    }["useStorage.useCallback3[subscribe]"], [
        room,
        rootOrNull
    ]);
    const getSnapshot = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useStorage.useCallback3[getSnapshot]": ()=>{
            if (rootOrNull === null) {
                return null;
            } else {
                const root = rootOrNull;
                const imm = root.toImmutable();
                return imm;
            }
        }
    }["useStorage.useCallback3[getSnapshot]"], [
        rootOrNull
    ]);
    const getServerSnapshot = alwaysNull;
    return useSyncExternalStoreWithSelector(subscribe, getSnapshot, getServerSnapshot, wrappedSelector, isEqual);
}
function useMutation(callback, deps) {
    const room = useRoom();
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "useMutation.useMemo4": ()=>{
            return ({
                "useMutation.useMemo4": (...args)=>// eslint-disable-next-line @typescript-eslint/no-unsafe-return
                    room.batch({
                        "useMutation.useMemo4": ()=>// eslint-disable-next-line @typescript-eslint/no-unsafe-return
                            callback(makeMutationContext(room), ...args)
                    }["useMutation.useMemo4"])
            })["useMutation.useMemo4"];
        }
    }["useMutation.useMemo4"], // eslint-disable-next-line react-hooks/exhaustive-deps
    [
        room,
        ...deps
    ]);
}
function useThreads(options = {}) {
    const { scrollOnLoad = true } = options;
    const client = useClient();
    const room = useRoom();
    const { store, getOrCreateThreadsPollerForRoomId } = getRoomExtrasForClient(client);
    const queryKey = makeRoomThreadsQueryKey(room.id, options.query);
    const poller = getOrCreateThreadsPollerForRoomId(room.id);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useThreads.useEffect6": ()=>void store.outputs.loadingRoomThreads.getOrCreate(queryKey).waitUntilLoaded()
    }["useThreads.useEffect6"]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useThreads.useEffect6": ()=>{
            poller.inc();
            poller.pollNowIfStale();
            return ({
                "useThreads.useEffect6": ()=>poller.dec()
            })["useThreads.useEffect6"];
        }
    }["useThreads.useEffect6"], [
        poller
    ]);
    const result = useSignal(store.outputs.loadingRoomThreads.getOrCreate(queryKey).signal);
    useScrollToCommentOnLoadEffect(scrollOnLoad, result);
    return result;
}
function useSearchComments(options) {
    const [result, setResult] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])({
        isLoading: true
    });
    const currentRequestInfo = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(null);
    const timeout = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(null);
    const client = useClient();
    const room = useRoom();
    const queryKey = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["stableStringify"])([
        room.id,
        options.query
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useSearchComments.useEffect6": ()=>{
            const currentRequestId = (currentRequestInfo.current?.id ?? 0) + 1;
            const controller = new AbortController();
            currentRequestInfo.current = {
                id: currentRequestId,
                controller
            };
            setResult({
                "useSearchComments.useEffect6": (result2)=>{
                    if (result2.isLoading) return result2;
                    return {
                        isLoading: true
                    };
                }
            }["useSearchComments.useEffect6"]);
            timeout.current = window.setTimeout({
                "useSearchComments.useEffect6": ()=>{
                    client[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].httpClient.searchComments({
                        roomId: room.id,
                        query: options.query
                    }, {
                        signal: controller.signal
                    }).then({
                        "useSearchComments.useEffect6": ({ data })=>{
                            if (controller.signal.aborted) return;
                            if (currentRequestInfo.current?.id !== currentRequestId) return;
                            setResult({
                                isLoading: false,
                                results: data
                            });
                            currentRequestInfo.current = null;
                        }
                    }["useSearchComments.useEffect6"]).catch({
                        "useSearchComments.useEffect6": (err)=>{
                            if (controller.signal.aborted) return;
                            if (currentRequestInfo.current?.id !== currentRequestId) return;
                            setResult({
                                isLoading: false,
                                error: err
                            });
                            currentRequestInfo.current = null;
                        }
                    }["useSearchComments.useEffect6"]);
                }
            }["useSearchComments.useEffect6"], 300);
            return ({
                "useSearchComments.useEffect6": ()=>{
                    if (timeout.current !== null) {
                        window.clearTimeout(timeout.current);
                    }
                    if (currentRequestInfo.current !== null) {
                        currentRequestInfo.current.controller.abort();
                    }
                }
            })["useSearchComments.useEffect6"];
        }
    }["useSearchComments.useEffect6"], [
        queryKey,
        client,
        room.id
    ]);
    return result;
}
function useCreateThread() {
    return useCreateRoomThread(useRoom().id);
}
function useCreateRoomThread(roomId) {
    const client = useClient();
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useCreateRoomThread.useCallback3": (options)=>{
            const body = options.body;
            const metadata = options.metadata ?? {};
            const commentMetadata = options.commentMetadata ?? {};
            const attachments = options.attachments;
            const threadId = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createThreadId"])();
            const commentId = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createCommentId"])();
            const createdAt = /* @__PURE__ */ new Date();
            const newComment = {
                id: commentId,
                threadId,
                roomId,
                createdAt,
                type: "comment",
                userId: getCurrentUserId(client),
                body,
                reactions: [],
                attachments: attachments ?? [],
                metadata: commentMetadata
            };
            const newThread = {
                id: threadId,
                type: "thread",
                createdAt,
                updatedAt: createdAt,
                roomId,
                metadata,
                comments: [
                    newComment
                ],
                resolved: false
            };
            const { store, onMutationFailure } = getRoomExtrasForClient(client);
            const optimisticId = store.optimisticUpdates.add({
                type: "create-thread",
                thread: newThread,
                roomId
            });
            const attachmentIds = attachments?.map({
                "useCreateRoomThread.useCallback3": (attachment)=>attachment.id
            }["useCreateRoomThread.useCallback3"]);
            client[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].httpClient.createThread({
                roomId,
                threadId,
                commentId,
                body,
                metadata,
                commentMetadata,
                attachmentIds
            }).then({
                "useCreateRoomThread.useCallback3": (thread)=>{
                    store.createThread(optimisticId, thread);
                }
            }["useCreateRoomThread.useCallback3"], {
                "useCreateRoomThread.useCallback3": (err)=>onMutationFailure(optimisticId, {
                        type: "CREATE_THREAD_ERROR",
                        roomId,
                        threadId,
                        commentId,
                        body,
                        metadata,
                        commentMetadata
                    }, err)
            }["useCreateRoomThread.useCallback3"]);
            return newThread;
        }
    }["useCreateRoomThread.useCallback3"], [
        client,
        roomId
    ]);
}
function useDeleteThread() {
    return useDeleteRoomThread(useRoom().id);
}
function useDeleteRoomThread(roomId) {
    const client = useClient();
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useDeleteRoomThread.useCallback3": (threadId)=>{
            const { store, onMutationFailure } = getRoomExtrasForClient(client);
            const userId = getCurrentUserId(client);
            const existing = store.outputs.threads.get().get(threadId);
            if (existing?.comments?.[0]?.userId !== userId) {
                throw new Error("Only the thread creator can delete the thread");
            }
            const optimisticId = store.optimisticUpdates.add({
                type: "delete-thread",
                roomId,
                threadId,
                deletedAt: /* @__PURE__ */ new Date()
            });
            client[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].httpClient.deleteThread({
                roomId,
                threadId
            }).then({
                "useDeleteRoomThread.useCallback3": ()=>{
                    store.deleteThread(threadId, optimisticId);
                }
            }["useDeleteRoomThread.useCallback3"], {
                "useDeleteRoomThread.useCallback3": (err)=>onMutationFailure(optimisticId, {
                        type: "DELETE_THREAD_ERROR",
                        roomId,
                        threadId
                    }, err)
            }["useDeleteRoomThread.useCallback3"]);
        }
    }["useDeleteRoomThread.useCallback3"], [
        client,
        roomId
    ]);
}
function useEditThreadMetadata() {
    return useEditRoomThreadMetadata(useRoom().id);
}
function useEditRoomThreadMetadata(roomId) {
    const client = useClient();
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useEditRoomThreadMetadata.useCallback3": (options)=>{
            if (!options.metadata) {
                return;
            }
            const threadId = options.threadId;
            const metadata = options.metadata;
            const updatedAt = /* @__PURE__ */ new Date();
            const { store, onMutationFailure } = getRoomExtrasForClient(client);
            const optimisticId = store.optimisticUpdates.add({
                type: "edit-thread-metadata",
                metadata,
                threadId,
                updatedAt
            });
            client[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].httpClient.editThreadMetadata({
                roomId,
                threadId,
                metadata
            }).then({
                "useEditRoomThreadMetadata.useCallback3": (metadata2)=>// Replace the optimistic update by the real thing
                    store.patchThread(threadId, optimisticId, {
                        metadata: metadata2
                    }, updatedAt)
            }["useEditRoomThreadMetadata.useCallback3"], {
                "useEditRoomThreadMetadata.useCallback3": (err)=>onMutationFailure(optimisticId, {
                        type: "EDIT_THREAD_METADATA_ERROR",
                        roomId,
                        threadId,
                        metadata
                    }, err)
            }["useEditRoomThreadMetadata.useCallback3"]);
        }
    }["useEditRoomThreadMetadata.useCallback3"], [
        client,
        roomId
    ]);
}
function useEditCommentMetadata() {
    return useEditRoomCommentMetadata(useRoom().id);
}
function useEditRoomCommentMetadata(roomId) {
    const client = useClient();
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useEditRoomCommentMetadata.useCallback3": (options)=>{
            if (!options.metadata) {
                return;
            }
            const threadId = options.threadId;
            const commentId = options.commentId;
            const metadata = options.metadata;
            const updatedAt = /* @__PURE__ */ new Date();
            const { store, onMutationFailure } = getRoomExtrasForClient(client);
            const optimisticId = store.optimisticUpdates.add({
                type: "edit-comment-metadata",
                threadId,
                commentId,
                metadata,
                updatedAt
            });
            client[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].httpClient.editCommentMetadata({
                roomId,
                threadId,
                commentId,
                metadata
            }).then({
                "useEditRoomCommentMetadata.useCallback3": (updatedMetadata)=>// Replace the optimistic update by the real thing
                    store.editCommentMetadata(threadId, commentId, optimisticId, updatedMetadata, updatedAt)
            }["useEditRoomCommentMetadata.useCallback3"], {
                "useEditRoomCommentMetadata.useCallback3": (err)=>onMutationFailure(optimisticId, {
                        type: "EDIT_COMMENT_METADATA_ERROR",
                        roomId,
                        threadId,
                        commentId,
                        metadata
                    }, err)
            }["useEditRoomCommentMetadata.useCallback3"]);
        }
    }["useEditRoomCommentMetadata.useCallback3"], [
        client,
        roomId
    ]);
}
function useCreateComment() {
    return useCreateRoomComment(useRoom().id);
}
function useCreateRoomComment(roomId) {
    const client = useClient();
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useCreateRoomComment.useCallback3": (options)=>{
            const { threadId, body } = options;
            const metadata = options.metadata ?? {};
            const attachments = options.attachments ?? [];
            const commentId = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createCommentId"])();
            const createdAt = /* @__PURE__ */ new Date();
            const comment = {
                id: commentId,
                threadId,
                roomId,
                type: "comment",
                createdAt,
                userId: getCurrentUserId(client),
                body,
                reactions: [],
                attachments: attachments ?? [],
                metadata
            };
            const { store, onMutationFailure } = getRoomExtrasForClient(client);
            const optimisticId = store.optimisticUpdates.add({
                type: "create-comment",
                comment
            });
            const attachmentIds = attachments?.map({
                "useCreateRoomComment.useCallback3": (attachment)=>attachment.id
            }["useCreateRoomComment.useCallback3"]);
            client[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].httpClient.createComment({
                roomId,
                threadId,
                commentId,
                body,
                metadata,
                attachmentIds
            }).then({
                "useCreateRoomComment.useCallback3": (newComment)=>{
                    store.createComment(newComment, optimisticId);
                }
            }["useCreateRoomComment.useCallback3"], {
                "useCreateRoomComment.useCallback3": (err)=>onMutationFailure(optimisticId, {
                        type: "CREATE_COMMENT_ERROR",
                        roomId,
                        threadId,
                        commentId,
                        body,
                        metadata
                    }, err)
            }["useCreateRoomComment.useCallback3"]);
            return comment;
        }
    }["useCreateRoomComment.useCallback3"], [
        client,
        roomId
    ]);
}
function useEditComment() {
    return useEditRoomComment(useRoom().id);
}
function useEditRoomComment(roomId) {
    const client = useClient();
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useEditRoomComment.useCallback3": ({ threadId, commentId, body, attachments, metadata })=>{
            const editedAt = /* @__PURE__ */ new Date();
            const { store, onMutationFailure } = getRoomExtrasForClient(client);
            const existing = store.outputs.threads.get().getEvenIfDeleted(threadId);
            if (existing === void 0) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["console"].warn(`Internal unexpected behavior. Cannot edit comment in thread "${threadId}" because the thread does not exist in the cache.`);
                return;
            }
            const comment = existing.comments.find({
                "useEditRoomComment.useCallback3.comment": (comment2)=>comment2.id === commentId
            }["useEditRoomComment.useCallback3.comment"]);
            if (comment === void 0 || comment.deletedAt !== void 0) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["console"].warn(`Internal unexpected behavior. Cannot edit comment "${commentId}" in thread "${threadId}" because the comment does not exist in the cache.`);
                return;
            }
            const updatedMetadata = metadata !== void 0 ? {
                ...comment.metadata,
                ...metadata
            } : comment.metadata;
            const optimisticId = store.optimisticUpdates.add({
                type: "edit-comment",
                comment: {
                    ...comment,
                    editedAt,
                    body,
                    attachments: attachments ?? [],
                    metadata: updatedMetadata
                }
            });
            const attachmentIds = attachments?.map({
                "useEditRoomComment.useCallback3": (attachment)=>attachment.id
            }["useEditRoomComment.useCallback3"]);
            client[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].httpClient.editComment({
                roomId,
                threadId,
                commentId,
                body,
                attachmentIds,
                metadata
            }).then({
                "useEditRoomComment.useCallback3": (editedComment)=>{
                    store.editComment(threadId, optimisticId, editedComment);
                }
            }["useEditRoomComment.useCallback3"], {
                "useEditRoomComment.useCallback3": (err)=>onMutationFailure(optimisticId, {
                        type: "EDIT_COMMENT_ERROR",
                        roomId,
                        threadId,
                        commentId,
                        body,
                        metadata: updatedMetadata
                    }, err)
            }["useEditRoomComment.useCallback3"]);
        }
    }["useEditRoomComment.useCallback3"], [
        client,
        roomId
    ]);
}
function useDeleteComment() {
    return useDeleteRoomComment(useRoom().id);
}
function useDeleteRoomComment(roomId) {
    const client = useClient();
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useDeleteRoomComment.useCallback3": ({ threadId, commentId })=>{
            const deletedAt = /* @__PURE__ */ new Date();
            const { store, onMutationFailure } = getRoomExtrasForClient(client);
            const optimisticId = store.optimisticUpdates.add({
                type: "delete-comment",
                threadId,
                commentId,
                deletedAt,
                roomId
            });
            client[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].httpClient.deleteComment({
                roomId,
                threadId,
                commentId
            }).then({
                "useDeleteRoomComment.useCallback3": ()=>{
                    store.deleteComment(threadId, optimisticId, commentId, deletedAt);
                }
            }["useDeleteRoomComment.useCallback3"], {
                "useDeleteRoomComment.useCallback3": (err)=>onMutationFailure(optimisticId, {
                        type: "DELETE_COMMENT_ERROR",
                        roomId,
                        threadId,
                        commentId
                    }, err)
            }["useDeleteRoomComment.useCallback3"]);
        }
    }["useDeleteRoomComment.useCallback3"], [
        client,
        roomId
    ]);
}
function useAddReaction() {
    return useAddRoomCommentReaction(useRoom().id);
}
function useAddRoomCommentReaction(roomId) {
    const client = useClient();
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useAddRoomCommentReaction.useCallback3": ({ threadId, commentId, emoji })=>{
            const createdAt = /* @__PURE__ */ new Date();
            const userId = getCurrentUserId(client);
            const { store, onMutationFailure } = getRoomExtrasForClient(client);
            const optimisticId = store.optimisticUpdates.add({
                type: "add-reaction",
                threadId,
                commentId,
                reaction: {
                    emoji,
                    userId,
                    createdAt
                }
            });
            client[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].httpClient.addReaction({
                roomId,
                threadId,
                commentId,
                emoji
            }).then({
                "useAddRoomCommentReaction.useCallback3": (addedReaction)=>{
                    store.addReaction(threadId, optimisticId, commentId, addedReaction, createdAt);
                }
            }["useAddRoomCommentReaction.useCallback3"], {
                "useAddRoomCommentReaction.useCallback3": (err)=>onMutationFailure(optimisticId, {
                        type: "ADD_REACTION_ERROR",
                        roomId,
                        threadId,
                        commentId,
                        emoji
                    }, err)
            }["useAddRoomCommentReaction.useCallback3"]);
        }
    }["useAddRoomCommentReaction.useCallback3"], [
        client,
        roomId
    ]);
}
function useRemoveReaction() {
    return useRemoveRoomCommentReaction(useRoom().id);
}
function useRemoveRoomCommentReaction(roomId) {
    const client = useClient();
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useRemoveRoomCommentReaction.useCallback3": ({ threadId, commentId, emoji })=>{
            const userId = getCurrentUserId(client);
            const removedAt = /* @__PURE__ */ new Date();
            const { store, onMutationFailure } = getRoomExtrasForClient(client);
            const optimisticId = store.optimisticUpdates.add({
                type: "remove-reaction",
                threadId,
                commentId,
                emoji,
                userId,
                removedAt
            });
            client[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].httpClient.removeReaction({
                roomId,
                threadId,
                commentId,
                emoji
            }).then({
                "useRemoveRoomCommentReaction.useCallback3": ()=>{
                    store.removeReaction(threadId, optimisticId, commentId, emoji, userId, removedAt);
                }
            }["useRemoveRoomCommentReaction.useCallback3"], {
                "useRemoveRoomCommentReaction.useCallback3": (err)=>onMutationFailure(optimisticId, {
                        type: "REMOVE_REACTION_ERROR",
                        roomId,
                        threadId,
                        commentId,
                        emoji
                    }, err)
            }["useRemoveRoomCommentReaction.useCallback3"]);
        }
    }["useRemoveRoomCommentReaction.useCallback3"], [
        client,
        roomId
    ]);
}
function useMarkThreadAsRead() {
    return useMarkRoomThreadAsRead(useRoom().id);
}
function useMarkRoomThreadAsRead(roomId) {
    const client = useClient();
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useMarkRoomThreadAsRead.useCallback3": (threadId)=>{
            const { store, onMutationFailure } = getRoomExtrasForClient(client);
            const inboxNotification = Object.values(store.outputs.notifications.get().notificationsById).find({
                "useMarkRoomThreadAsRead.useCallback3.inboxNotification": (inboxNotification2)=>inboxNotification2.kind === "thread" && inboxNotification2.threadId === threadId
            }["useMarkRoomThreadAsRead.useCallback3.inboxNotification"]);
            if (!inboxNotification) return;
            const now = /* @__PURE__ */ new Date();
            const optimisticId = store.optimisticUpdates.add({
                type: "mark-inbox-notification-as-read",
                inboxNotificationId: inboxNotification.id,
                readAt: now
            });
            client[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].httpClient.markRoomInboxNotificationAsRead({
                roomId,
                inboxNotificationId: inboxNotification.id
            }).then({
                "useMarkRoomThreadAsRead.useCallback3": ()=>{
                    store.markInboxNotificationRead(inboxNotification.id, now, optimisticId);
                }
            }["useMarkRoomThreadAsRead.useCallback3"], {
                "useMarkRoomThreadAsRead.useCallback3": (err)=>{
                    onMutationFailure(optimisticId, {
                        type: "MARK_INBOX_NOTIFICATION_AS_READ_ERROR",
                        roomId,
                        inboxNotificationId: inboxNotification.id
                    }, err);
                    return;
                }
            }["useMarkRoomThreadAsRead.useCallback3"]);
        }
    }["useMarkRoomThreadAsRead.useCallback3"], [
        client,
        roomId
    ]);
}
function useMarkThreadAsResolved() {
    return useMarkRoomThreadAsResolved(useRoom().id);
}
function useMarkRoomThreadAsResolved(roomId) {
    const client = useClient();
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useMarkRoomThreadAsResolved.useCallback3": (threadId)=>{
            const updatedAt = /* @__PURE__ */ new Date();
            const { store, onMutationFailure } = getRoomExtrasForClient(client);
            const optimisticId = store.optimisticUpdates.add({
                type: "mark-thread-as-resolved",
                threadId,
                updatedAt
            });
            client[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].httpClient.markThreadAsResolved({
                roomId,
                threadId
            }).then({
                "useMarkRoomThreadAsResolved.useCallback3": ()=>{
                    store.patchThread(threadId, optimisticId, {
                        resolved: true
                    }, updatedAt);
                }
            }["useMarkRoomThreadAsResolved.useCallback3"], {
                "useMarkRoomThreadAsResolved.useCallback3": (err)=>onMutationFailure(optimisticId, {
                        type: "MARK_THREAD_AS_RESOLVED_ERROR",
                        roomId,
                        threadId
                    }, err)
            }["useMarkRoomThreadAsResolved.useCallback3"]);
        }
    }["useMarkRoomThreadAsResolved.useCallback3"], [
        client,
        roomId
    ]);
}
function useMarkThreadAsUnresolved() {
    return useMarkRoomThreadAsUnresolved(useRoom().id);
}
function useMarkRoomThreadAsUnresolved(roomId) {
    const client = useClient();
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useMarkRoomThreadAsUnresolved.useCallback3": (threadId)=>{
            const updatedAt = /* @__PURE__ */ new Date();
            const { store, onMutationFailure } = getRoomExtrasForClient(client);
            const optimisticId = store.optimisticUpdates.add({
                type: "mark-thread-as-unresolved",
                threadId,
                updatedAt
            });
            client[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].httpClient.markThreadAsUnresolved({
                roomId,
                threadId
            }).then({
                "useMarkRoomThreadAsUnresolved.useCallback3": ()=>{
                    store.patchThread(threadId, optimisticId, {
                        resolved: false
                    }, updatedAt);
                }
            }["useMarkRoomThreadAsUnresolved.useCallback3"], {
                "useMarkRoomThreadAsUnresolved.useCallback3": (err)=>onMutationFailure(optimisticId, {
                        type: "MARK_THREAD_AS_UNRESOLVED_ERROR",
                        roomId,
                        threadId
                    }, err)
            }["useMarkRoomThreadAsUnresolved.useCallback3"]);
        }
    }["useMarkRoomThreadAsUnresolved.useCallback3"], [
        client,
        roomId
    ]);
}
function useSubscribeToThread() {
    return useSubscribeToRoomThread(useRoom().id);
}
function useSubscribeToRoomThread(roomId) {
    const client = useClient();
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useSubscribeToRoomThread.useCallback3": (threadId)=>{
            const subscribedAt = /* @__PURE__ */ new Date();
            const { store, onMutationFailure } = getRoomExtrasForClient(client);
            const optimisticId = store.optimisticUpdates.add({
                type: "subscribe-to-thread",
                threadId,
                subscribedAt
            });
            client[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].httpClient.subscribeToThread({
                roomId,
                threadId
            }).then({
                "useSubscribeToRoomThread.useCallback3": (subscription)=>{
                    store.createSubscription(subscription, optimisticId);
                }
            }["useSubscribeToRoomThread.useCallback3"], {
                "useSubscribeToRoomThread.useCallback3": (err)=>onMutationFailure(optimisticId, {
                        type: "SUBSCRIBE_TO_THREAD_ERROR",
                        roomId,
                        threadId
                    }, err)
            }["useSubscribeToRoomThread.useCallback3"]);
        }
    }["useSubscribeToRoomThread.useCallback3"], [
        client,
        roomId
    ]);
}
function useUnsubscribeFromThread() {
    return useUnsubscribeFromRoomThread(useRoom().id);
}
function useUnsubscribeFromRoomThread(roomId) {
    const client = useClient();
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useUnsubscribeFromRoomThread.useCallback3": (threadId)=>{
            const unsubscribedAt = /* @__PURE__ */ new Date();
            const { store, onMutationFailure } = getRoomExtrasForClient(client);
            const optimisticId = store.optimisticUpdates.add({
                type: "unsubscribe-from-thread",
                threadId,
                unsubscribedAt
            });
            client[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].httpClient.unsubscribeFromThread({
                roomId,
                threadId
            }).then({
                "useUnsubscribeFromRoomThread.useCallback3": ()=>{
                    store.deleteSubscription((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getSubscriptionKey"])("thread", threadId), optimisticId);
                }
            }["useUnsubscribeFromRoomThread.useCallback3"], {
                "useUnsubscribeFromRoomThread.useCallback3": (err)=>onMutationFailure(optimisticId, {
                        type: "UNSUBSCRIBE_FROM_THREAD_ERROR",
                        roomId,
                        threadId
                    }, err)
            }["useUnsubscribeFromRoomThread.useCallback3"]);
        }
    }["useUnsubscribeFromRoomThread.useCallback3"], [
        client,
        roomId
    ]);
}
function useThreadSubscription(threadId) {
    return useRoomThreadSubscription(useRoom().id, threadId);
}
function useRoomThreadSubscription(roomId, threadId) {
    const client = useClient();
    const { store } = getRoomExtrasForClient(client);
    const subscriptionKey = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "useRoomThreadSubscription.useMemo4[subscriptionKey]": ()=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getSubscriptionKey"])("thread", threadId)
    }["useRoomThreadSubscription.useMemo4[subscriptionKey]"], [
        threadId
    ]);
    const subscribeToThread = useSubscribeToRoomThread(roomId);
    const unsubscribeFromThread = useUnsubscribeFromRoomThread(roomId);
    const subscribe = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useRoomThreadSubscription.useCallback3[subscribe]": ()=>subscribeToThread(threadId)
    }["useRoomThreadSubscription.useCallback3[subscribe]"], [
        subscribeToThread,
        threadId
    ]);
    const unsubscribe = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useRoomThreadSubscription.useCallback3[unsubscribe]": ()=>unsubscribeFromThread(threadId)
    }["useRoomThreadSubscription.useCallback3[unsubscribe]"], [
        unsubscribeFromThread,
        threadId
    ]);
    const signal = store.outputs.threadSubscriptions;
    const selector = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useRoomThreadSubscription.useCallback3[selector]": (state)=>{
            const subscription = state.subscriptions[subscriptionKey];
            const notification = state.notifications.find({
                "useRoomThreadSubscription.useCallback3[selector].notification": (inboxNotification)=>inboxNotification.kind === "thread" && inboxNotification.threadId === threadId
            }["useRoomThreadSubscription.useCallback3[selector].notification"]);
            if (subscription === void 0) {
                return {
                    status: "not-subscribed",
                    subscribe,
                    unsubscribe
                };
            }
            return {
                status: "subscribed",
                unreadSince: notification?.readAt ?? null,
                subscribe,
                unsubscribe
            };
        }
    }["useRoomThreadSubscription.useCallback3[selector]"], [
        subscriptionKey,
        threadId,
        subscribe,
        unsubscribe
    ]);
    return useSignal(signal, selector, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shallow"]);
}
function useRoomSubscriptionSettings() {
    const updateRoomSubscriptionSettings = useUpdateRoomSubscriptionSettings();
    const client = useClient();
    const room = useRoom();
    const { store, getOrCreateSubscriptionSettingsPollerForRoomId } = getRoomExtrasForClient(client);
    const poller = getOrCreateSubscriptionSettingsPollerForRoomId(room.id);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useRoomSubscriptionSettings.useEffect6": ()=>void store.outputs.roomSubscriptionSettingsByRoomId.getOrCreate(room.id).waitUntilLoaded()
    }["useRoomSubscriptionSettings.useEffect6"]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useRoomSubscriptionSettings.useEffect6": ()=>{
            poller.inc();
            poller.pollNowIfStale();
            return ({
                "useRoomSubscriptionSettings.useEffect6": ()=>{
                    poller.dec();
                }
            })["useRoomSubscriptionSettings.useEffect6"];
        }
    }["useRoomSubscriptionSettings.useEffect6"], [
        poller
    ]);
    const settings = useSignal(store.outputs.roomSubscriptionSettingsByRoomId.getOrCreate(room.id).signal);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "useRoomSubscriptionSettings.useMemo4": ()=>{
            return [
                settings,
                updateRoomSubscriptionSettings
            ];
        }
    }["useRoomSubscriptionSettings.useMemo4"], [
        settings,
        updateRoomSubscriptionSettings
    ]);
}
function useRoomSubscriptionSettingsSuspense() {
    ensureNotServerSide();
    const client = useClient();
    const store = getRoomExtrasForClient(client).store;
    const room = useRoom();
    use(store.outputs.roomSubscriptionSettingsByRoomId.getOrCreate(room.id).waitUntilLoaded());
    const [settings, updateRoomSubscriptionSettings] = useRoomSubscriptionSettings();
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(!settings.error, "Did not expect error");
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(!settings.isLoading, "Did not expect loading");
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "useRoomSubscriptionSettingsSuspense.useMemo4": ()=>{
            return [
                settings,
                updateRoomSubscriptionSettings
            ];
        }
    }["useRoomSubscriptionSettingsSuspense.useMemo4"], [
        settings,
        updateRoomSubscriptionSettings
    ]);
}
function useHistoryVersionData(versionId) {
    const [state, setState] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])({
        isLoading: true
    });
    const room = useRoom();
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useHistoryVersionData.useEffect6": ()=>{
            setState({
                isLoading: true
            });
            const load = {
                "useHistoryVersionData.useEffect6.load": async ()=>{
                    try {
                        const response = await room[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].getTextVersion(versionId);
                        const buffer = await response.arrayBuffer();
                        const data = new Uint8Array(buffer);
                        setState({
                            isLoading: false,
                            data
                        });
                    } catch (error) {
                        setState({
                            isLoading: false,
                            error: error instanceof Error ? error : new Error("An unknown error occurred while loading this version")
                        });
                    }
                }
            }["useHistoryVersionData.useEffect6.load"];
            void load();
        }
    }["useHistoryVersionData.useEffect6"], [
        room,
        versionId
    ]);
    return state;
}
function useHistoryVersions() {
    const client = useClient();
    const room = useRoom();
    const { store, getOrCreateVersionsPollerForRoomId } = getRoomExtrasForClient(client);
    const poller = getOrCreateVersionsPollerForRoomId(room.id);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useHistoryVersions.useEffect6": ()=>{
            poller.inc();
            poller.pollNowIfStale();
            return ({
                "useHistoryVersions.useEffect6": ()=>poller.dec()
            })["useHistoryVersions.useEffect6"];
        }
    }["useHistoryVersions.useEffect6"], [
        poller
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useHistoryVersions.useEffect6": ()=>void store.outputs.versionsByRoomId.getOrCreate(room.id).waitUntilLoaded()
    }["useHistoryVersions.useEffect6"]);
    return useSignal(store.outputs.versionsByRoomId.getOrCreate(room.id).signal);
}
function useHistoryVersionsSuspense() {
    ensureNotServerSide();
    const client = useClient();
    const room = useRoom();
    const store = getRoomExtrasForClient(client).store;
    use(store.outputs.versionsByRoomId.getOrCreate(room.id).waitUntilLoaded());
    const result = useHistoryVersions();
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(!result.error, "Did not expect error");
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(!result.isLoading, "Did not expect loading");
    return result;
}
function useUpdateRoomSubscriptionSettings() {
    const client = useClient();
    const room = useRoom();
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useUpdateRoomSubscriptionSettings.useCallback3": (settings)=>{
            const { store, onMutationFailure, pollThreadsForRoomId } = getRoomExtrasForClient(client);
            const userId = getCurrentUserId(client);
            const optimisticId = store.optimisticUpdates.add({
                type: "update-room-subscription-settings",
                roomId: room.id,
                userId,
                settings
            });
            room.updateSubscriptionSettings(settings).then({
                "useUpdateRoomSubscriptionSettings.useCallback3": (udpatedSettings)=>{
                    store.updateRoomSubscriptionSettings(room.id, optimisticId, udpatedSettings);
                    if (settings.threads) {
                        pollThreadsForRoomId(room.id);
                    }
                }
            }["useUpdateRoomSubscriptionSettings.useCallback3"], {
                "useUpdateRoomSubscriptionSettings.useCallback3": (err)=>onMutationFailure(optimisticId, {
                        type: "UPDATE_ROOM_SUBSCRIPTION_SETTINGS_ERROR",
                        roomId: room.id
                    }, err)
            }["useUpdateRoomSubscriptionSettings.useCallback3"]);
        }
    }["useUpdateRoomSubscriptionSettings.useCallback3"], [
        client,
        room
    ]);
}
function useSuspendUntilPresenceReady() {
    ensureNotServerSide();
    const room = useRoom();
    use(room.waitUntilPresenceReady());
}
function useSelfSuspense(selector, isEqual) {
    useSuspendUntilPresenceReady();
    return useSelf(selector, isEqual);
}
function useOthersSuspense(selector, isEqual) {
    useSuspendUntilPresenceReady();
    return useOthers(selector, isEqual);
}
function useOthersConnectionIdsSuspense() {
    useSuspendUntilPresenceReady();
    return useOthersConnectionIds();
}
function useOthersMappedSuspense(itemSelector, itemIsEqual) {
    useSuspendUntilPresenceReady();
    return useOthersMapped(itemSelector, itemIsEqual);
}
function useOtherSuspense(connectionId, selector, isEqual) {
    useSuspendUntilPresenceReady();
    return useOther(connectionId, selector, isEqual);
}
function useSuspendUntilStorageReady() {
    ensureNotServerSide();
    const room = useRoom();
    use(room.waitUntilStorageReady());
}
function useStorageSuspense(selector, isEqual) {
    useSuspendUntilStorageReady();
    return useStorage(selector, isEqual);
}
function useThreadsSuspense(options = {}) {
    ensureNotServerSide();
    const client = useClient();
    const room = useRoom();
    const { store } = getRoomExtrasForClient(client);
    const queryKey = makeRoomThreadsQueryKey(room.id, options.query);
    use(store.outputs.loadingRoomThreads.getOrCreate(queryKey).waitUntilLoaded());
    const result = useThreads(options);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(!result.error, "Did not expect error");
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(!result.isLoading, "Did not expect loading");
    return result;
}
function selectorFor_useAttachmentUrl(state) {
    if (state === void 0 || state?.isLoading) {
        return state ?? {
            isLoading: true
        };
    }
    if (state.error) {
        return state;
    }
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(state.data !== void 0, "Unexpected missing attachment URL");
    return {
        isLoading: false,
        url: state.data
    };
}
function useAttachmentUrl(attachmentId) {
    const room = useRoom();
    return useRoomAttachmentUrl(attachmentId, room.id);
}
function useRoomAttachmentUrl(attachmentId, roomId) {
    const client = useClient();
    const store = client[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]].httpClient.getOrCreateAttachmentUrlsStore(roomId);
    const getAttachmentUrlState = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useRoomAttachmentUrl.useCallback3[getAttachmentUrlState]": ()=>store.getItemState(attachmentId)
    }["useRoomAttachmentUrl.useCallback3[getAttachmentUrlState]"], [
        store,
        attachmentId
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useRoomAttachmentUrl.useEffect6": ()=>{
            void store.enqueue(attachmentId);
        }
    }["useRoomAttachmentUrl.useEffect6"], [
        store,
        attachmentId
    ]);
    return useSyncExternalStoreWithSelector(store.subscribe, getAttachmentUrlState, getAttachmentUrlState, selectorFor_useAttachmentUrl, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shallow"]);
}
function useAttachmentUrlSuspense(attachmentId) {
    const room = useRoom();
    const { attachmentUrlsStore } = room[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kInternal"]];
    const getAttachmentUrlState = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useAttachmentUrlSuspense.useCallback3[getAttachmentUrlState]": ()=>attachmentUrlsStore.getItemState(attachmentId)
    }["useAttachmentUrlSuspense.useCallback3[getAttachmentUrlState]"], [
        attachmentUrlsStore,
        attachmentId
    ]);
    const attachmentUrlState = getAttachmentUrlState();
    if (!attachmentUrlState || attachmentUrlState.isLoading) {
        throw attachmentUrlsStore.enqueue(attachmentId);
    }
    if (attachmentUrlState.error) {
        throw attachmentUrlState.error;
    }
    const state = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useSyncExternalStore"])(attachmentUrlsStore.subscribe, getAttachmentUrlState, getAttachmentUrlState);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(state !== void 0, "Unexpected missing state");
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(!state.isLoading, "Unexpected loading state");
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$liveblocks$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(!state.error, "Unexpected error state");
    return {
        isLoading: false,
        url: state.data,
        error: void 0
    };
}
function useRoomPermissions(roomId) {
    const client = useClient();
    const store = getRoomExtrasForClient(client).store;
    return useSignal(store.permissionHints.getPermissionForRoomΣ(roomId));
}
function createRoomContext(client) {
    return getOrCreateRoomContextBundle(client);
}
var _RoomProvider = RoomProvider;
var _useBroadcastEvent = useBroadcastEvent;
var _useOthersListener = useOthersListener;
var _useRoom = useRoom;
var _useIsInsideRoom = useIsInsideRoom;
var _useAddReaction = useAddReaction;
var _useMutation = useMutation;
var _useCreateThread = useCreateThread;
var _useDeleteThread = useDeleteThread;
var _useEditThreadMetadata = useEditThreadMetadata;
var _useCreateComment = useCreateComment;
var _useEditComment = useEditComment;
var _useEditCommentMetadata = useEditCommentMetadata;
var _useEventListener = useEventListener;
var _useMyPresence = useMyPresence;
var _useOthersMapped = useOthersMapped;
var _useOthersMappedSuspense = useOthersMappedSuspense;
var _useThreads = useThreads;
var _useSearchComments = useSearchComments;
var _useThreadsSuspense = useThreadsSuspense;
var _useRoomSubscriptionSettings = useRoomSubscriptionSettings;
var _useRoomSubscriptionSettingsSuspense = useRoomSubscriptionSettingsSuspense;
var _useHistoryVersions = useHistoryVersions;
var _useHistoryVersionsSuspense = useHistoryVersionsSuspense;
var _useOther = useOther;
function _useOthers(...args) {
    return useOthers(...args);
}
var _useOtherSuspense = useOtherSuspense;
function _useOthersSuspense(...args) {
    return useOthersSuspense(...args);
}
var _useStorage = useStorage;
var _useStorageSuspense = useStorageSuspense;
function _useSelf(...args) {
    return useSelf(...args);
}
function _useSelfSuspense(...args) {
    return useSelfSuspense(...args);
}
var _useStorageRoot = useStorageRoot;
var _useUpdateMyPresence = useUpdateMyPresence;
;
 //# sourceMappingURL=chunk-SVZO3VVV.js.map
}),
"[project]/node_modules/@liveblocks/react/dist/chunk-GIHA3RC6.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ClientSideSuspense",
    ()=>ClientSideSuspense,
    "PKG_FORMAT",
    ()=>PKG_FORMAT,
    "PKG_NAME",
    ()=>PKG_NAME,
    "PKG_VERSION",
    ()=>PKG_VERSION
]);
// src/ClientSideSuspense.tsx
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)");
// src/version.ts
var PKG_NAME = "@liveblocks/react";
var PKG_VERSION = "3.14.0";
var PKG_FORMAT = "esm";
;
;
function ClientSideSuspense(props) {
    const [mounted, setMounted] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])(false);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "ClientSideSuspense.useEffect": ()=>{
            setMounted(true);
        }
    }["ClientSideSuspense.useEffect"], []);
    return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Suspense"], {
        fallback: props.fallback,
        children: mounted ? typeof props.children === "function" ? props.children() : props.children : props.fallback
    });
}
;
 //# sourceMappingURL=chunk-GIHA3RC6.js.map
}),
]);

//# sourceMappingURL=node_modules_%40liveblocks_react_dist_4d3a1007._.js.map