{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/MAHARSHI%20NATH/OneDrive/Documents/sudoku/node_modules/%40liveblocks/core/src/version.ts","file:///C:/Users/MAHARSHI%20NATH/OneDrive/Documents/sudoku/node_modules/%40liveblocks/core/src/dupe-detection.ts","file:///C:/Users/MAHARSHI%20NATH/OneDrive/Documents/sudoku/node_modules/%40liveblocks/core/src/lib/EventSource.ts","file:///C:/Users/MAHARSHI%20NATH/OneDrive/Documents/sudoku/node_modules/%40liveblocks/core/src/lib/freeze.ts","file:///C:/Users/MAHARSHI%20NATH/OneDrive/Documents/sudoku/node_modules/%40liveblocks/core/src/lib/utils.ts","file:///C:/Users/MAHARSHI%20NATH/OneDrive/Documents/sudoku/node_modules/%40liveblocks/core/src/lib/signals.ts","file:///C:/Users/MAHARSHI%20NATH/OneDrive/Documents/sudoku/node_modules/%40liveblocks/core/src/lib/SortedList.ts","file:///C:/Users/MAHARSHI%20NATH/OneDrive/Documents/sudoku/node_modules/%40liveblocks/core/src/AiChatDB.ts","file:///C:/Users/MAHARSHI%20NATH/OneDrive/Documents/sudoku/node_modules/%40liveblocks/core/src/convert-plain-data.ts","file:///C:/Users/MAHARSHI%20NATH/OneDrive/Documents/sudoku/node_modules/%40liveblocks/core/src/lib/assert.ts","file:///C:/Users/MAHARSHI%20NATH/OneDrive/Documents/sudoku/node_modules/%40liveblocks/core/src/lib/fancy-console.ts","file:///C:/Users/MAHARSHI%20NATH/OneDrive/Documents/sudoku/node_modules/%40liveblocks/core/src/lib/guards.ts","file:///C:/Users/MAHARSHI%20NATH/OneDrive/Documents/sudoku/node_modules/%40liveblocks/core/src/lib/autoRetry.ts","file:///C:/Users/MAHARSHI%20NATH/OneDrive/Documents/sudoku/node_modules/%40liveblocks/core/src/lib/controlledPromise.ts","file:///C:/Users/MAHARSHI%20NATH/OneDrive/Documents/sudoku/node_modules/%40liveblocks/core/src/lib/stringify.ts","file:///C:/Users/MAHARSHI%20NATH/OneDrive/Documents/sudoku/node_modules/%40liveblocks/core/src/lib/batch.ts","file:///C:/Users/MAHARSHI%20NATH/OneDrive/Documents/sudoku/node_modules/%40liveblocks/core/src/lib/chunk.ts","file:///C:/Users/MAHARSHI%20NATH/OneDrive/Documents/sudoku/node_modules/%40liveblocks/core/src/lib/nanoid.ts","file:///C:/Users/MAHARSHI%20NATH/OneDrive/Documents/sudoku/node_modules/%40liveblocks/core/src/lib/createIds.ts","file:///C:/Users/MAHARSHI%20NATH/OneDrive/Documents/sudoku/node_modules/%40liveblocks/core/src/lib/DefaultMap.ts","file:///C:/Users/MAHARSHI%20NATH/OneDrive/Documents/sudoku/node_modules/%40liveblocks/core/src/lib/objectToQuery.ts","file:///C:/Users/MAHARSHI%20NATH/OneDrive/Documents/sudoku/node_modules/%40liveblocks/core/src/lib/url.ts","file:///C:/Users/MAHARSHI%20NATH/OneDrive/Documents/sudoku/node_modules/%40liveblocks/core/src/api-client.ts","file:///C:/Users/MAHARSHI%20NATH/OneDrive/Documents/sudoku/node_modules/%40liveblocks/core/src/lib/fsm.ts","file:///C:/Users/MAHARSHI%20NATH/OneDrive/Documents/sudoku/node_modules/%40liveblocks/core/src/protocol/ServerMsg.ts","file:///C:/Users/MAHARSHI%20NATH/OneDrive/Documents/sudoku/node_modules/%40liveblocks/core/src/types/IWebSocket.ts","file:///C:/Users/MAHARSHI%20NATH/OneDrive/Documents/sudoku/node_modules/%40liveblocks/core/src/connection.ts","file:///C:/Users/MAHARSHI%20NATH/OneDrive/Documents/sudoku/node_modules/%40liveblocks/core/src/internal.ts","file:///C:/Users/MAHARSHI%20NATH/OneDrive/Documents/sudoku/node_modules/%40liveblocks/core/src/lib/IncrementalJsonParser.ts","file:///C:/Users/MAHARSHI%20NATH/OneDrive/Documents/sudoku/node_modules/%40liveblocks/core/src/lib/shallow.ts","file:///C:/Users/MAHARSHI%20NATH/OneDrive/Documents/sudoku/node_modules/%40liveblocks/core/src/lib/TreePool.ts","file:///C:/Users/MAHARSHI%20NATH/OneDrive/Documents/sudoku/node_modules/%40liveblocks/core/src/ai.ts","file:///C:/Users/MAHARSHI%20NATH/OneDrive/Documents/sudoku/node_modules/%40liveblocks/core/src/protocol/AuthToken.ts","file:///C:/Users/MAHARSHI%20NATH/OneDrive/Documents/sudoku/node_modules/%40liveblocks/core/src/auth-manager.ts","file:///C:/Users/MAHARSHI%20NATH/OneDrive/Documents/sudoku/node_modules/%40liveblocks/core/src/constants.ts","file:///C:/Users/MAHARSHI%20NATH/OneDrive/Documents/sudoku/node_modules/%40liveblocks/core/src/devtools/bridge.ts","file:///C:/Users/MAHARSHI%20NATH/OneDrive/Documents/sudoku/node_modules/%40liveblocks/core/src/devtools/index.ts","file:///C:/Users/MAHARSHI%20NATH/OneDrive/Documents/sudoku/node_modules/%40liveblocks/core/src/lib/warnings.ts","file:///C:/Users/MAHARSHI%20NATH/OneDrive/Documents/sudoku/node_modules/%40liveblocks/core/src/protocol/NotificationSettings.ts","file:///C:/Users/MAHARSHI%20NATH/OneDrive/Documents/sudoku/node_modules/%40liveblocks/core/src/brand.ts","file:///C:/Users/MAHARSHI%20NATH/OneDrive/Documents/sudoku/node_modules/%40liveblocks/core/src/lib/position.ts","file:///C:/Users/MAHARSHI%20NATH/OneDrive/Documents/sudoku/node_modules/%40liveblocks/core/src/protocol/Op.ts","file:///C:/Users/MAHARSHI%20NATH/OneDrive/Documents/sudoku/node_modules/%40liveblocks/core/src/crdts/AbstractCrdt.ts","file:///C:/Users/MAHARSHI%20NATH/OneDrive/Documents/sudoku/node_modules/%40liveblocks/core/src/protocol/StorageNode.ts","file:///C:/Users/MAHARSHI%20NATH/OneDrive/Documents/sudoku/node_modules/%40liveblocks/core/src/crdts/LiveRegister.ts","file:///C:/Users/MAHARSHI%20NATH/OneDrive/Documents/sudoku/node_modules/%40liveblocks/core/src/crdts/LiveList.ts","file:///C:/Users/MAHARSHI%20NATH/OneDrive/Documents/sudoku/node_modules/%40liveblocks/core/src/crdts/LiveMap.ts","file:///C:/Users/MAHARSHI%20NATH/OneDrive/Documents/sudoku/node_modules/%40liveblocks/core/src/crdts/LiveObject.ts","file:///C:/Users/MAHARSHI%20NATH/OneDrive/Documents/sudoku/node_modules/%40liveblocks/core/src/crdts/liveblocks-helpers.ts","file:///C:/Users/MAHARSHI%20NATH/OneDrive/Documents/sudoku/node_modules/%40liveblocks/core/src/lib/Deque.ts","file:///C:/Users/MAHARSHI%20NATH/OneDrive/Documents/sudoku/node_modules/%40liveblocks/core/src/lib/Json.ts","file:///C:/Users/MAHARSHI%20NATH/OneDrive/Documents/sudoku/node_modules/%40liveblocks/core/src/lib/stopwatch.ts","file:///C:/Users/MAHARSHI%20NATH/OneDrive/Documents/sudoku/node_modules/%40liveblocks/core/src/protocol/ClientMsg.ts","file:///C:/Users/MAHARSHI%20NATH/OneDrive/Documents/sudoku/node_modules/%40liveblocks/core/src/refs/ManagedOthers.ts","file:///C:/Users/MAHARSHI%20NATH/OneDrive/Documents/sudoku/node_modules/%40liveblocks/core/src/types/LiveblocksError.ts","file:///C:/Users/MAHARSHI%20NATH/OneDrive/Documents/sudoku/node_modules/%40liveblocks/core/src/room.ts","file:///C:/Users/MAHARSHI%20NATH/OneDrive/Documents/sudoku/node_modules/%40liveblocks/core/src/client.ts","file:///C:/Users/MAHARSHI%20NATH/OneDrive/Documents/sudoku/node_modules/%40liveblocks/core/src/comments/comment-body.ts","file:///C:/Users/MAHARSHI%20NATH/OneDrive/Documents/sudoku/node_modules/%40liveblocks/core/src/crdts/utils.ts","file:///C:/Users/MAHARSHI%20NATH/OneDrive/Documents/sudoku/node_modules/%40liveblocks/core/src/immutable.ts","file:///C:/Users/MAHARSHI%20NATH/OneDrive/Documents/sudoku/node_modules/%40liveblocks/core/src/lib/abortController.ts","file:///C:/Users/MAHARSHI%20NATH/OneDrive/Documents/sudoku/node_modules/%40liveblocks/core/src/lib/deprecation.ts","file:///C:/Users/MAHARSHI%20NATH/OneDrive/Documents/sudoku/node_modules/%40liveblocks/core/src/lib/Poller.ts","file:///C:/Users/MAHARSHI%20NATH/OneDrive/Documents/sudoku/node_modules/%40liveblocks/core/src/protocol/Subscriptions.ts","file:///C:/Users/MAHARSHI%20NATH/OneDrive/Documents/sudoku/node_modules/%40liveblocks/core/src/types/Others.ts","file:///C:/Users/MAHARSHI%20NATH/OneDrive/Documents/sudoku/node_modules/%40liveblocks/core/src/index.ts"],"sourcesContent":["declare const __VERSION__: string;\ndeclare const TSUP_FORMAT: string;\n\nexport const PKG_NAME = \"@liveblocks/core\";\nexport const PKG_VERSION = typeof __VERSION__ === \"string\" && __VERSION__;\nexport const PKG_FORMAT = typeof TSUP_FORMAT === \"string\" && TSUP_FORMAT;\n","import { PKG_NAME, PKG_VERSION } from \"./version\";\n\nconst g = (\n  typeof globalThis !== \"undefined\"\n    ? globalThis\n    : typeof window !== \"undefined\"\n      ? window\n      : typeof global !== \"undefined\"\n        ? global\n        : {}\n) as { [key: symbol]: string };\n\nconst crossLinkedDocs = \"https://liveblocks.io/docs/errors/cross-linked\";\nconst dupesDocs = \"https://liveblocks.io/docs/errors/dupes\";\nconst SPACE = \" \"; // Important space to make sure links in errors are clickable in all browsers\n\nfunction error(msg: string): void {\n  if (process.env.NODE_ENV === \"production\") {\n    // eslint-disable-next-line rulesdir/console-must-be-fancy\n    console.error(msg);\n  } else {\n    throw new Error(msg);\n  }\n}\n\n/**\n * Throws an error if multiple copies of a Liveblocks package are being loaded\n * at runtime. This likely indicates a packaging issue with the project.\n */\nexport function detectDupes(\n  pkgName: string,\n  pkgVersion: string | false, // false if not built yet\n  pkgFormat: string | false // false if not built yet\n): void {\n  const pkgId = Symbol.for(pkgName);\n  const pkgBuildInfo = pkgFormat\n    ? `${pkgVersion || \"dev\"} (${pkgFormat})`\n    : pkgVersion || \"dev\";\n\n  if (!g[pkgId]) {\n    g[pkgId] = pkgBuildInfo;\n  } else if (g[pkgId] === pkgBuildInfo) {\n    // Allow it, see https://github.com/liveblocks/liveblocks/pull/1004\n  } else {\n    const msg = [\n      `Multiple copies of Liveblocks are being loaded in your project. This will cause issues! See ${\n        dupesDocs + SPACE\n      }`,\n      \"\",\n      \"Conflicts:\",\n      `- ${pkgName} ${g[pkgId]} (already loaded)`,\n      `- ${pkgName} ${pkgBuildInfo} (trying to load this now)`,\n    ].join(\"\\n\");\n    error(msg);\n  }\n\n  if (pkgVersion && PKG_VERSION && pkgVersion !== PKG_VERSION) {\n    error(\n      [\n        `Cross-linked versions of Liveblocks found, which will cause issues! See ${\n          crossLinkedDocs + SPACE\n        }`,\n        \"\",\n        \"Conflicts:\",\n        `- ${PKG_NAME} is at ${PKG_VERSION}`,\n        `- ${pkgName} is at ${pkgVersion}`,\n        \"\",\n        \"Always upgrade all Liveblocks packages to the same version number.\",\n      ].join(\"\\n\")\n    );\n  }\n}\n","export type Callback<T> = (event: T) => void;\nexport type UnsubscribeCallback = () => void;\n\nexport type Observable<T> = {\n  /**\n   * Register a callback function to be called whenever the event source emits\n   * an event.\n   */\n  subscribe(callback: Callback<T>): UnsubscribeCallback;\n  /**\n   * Register a one-time callback function to be called whenever the event\n   * source emits an event. After the event fires, the callback is\n   * auto-unsubscribed.\n   */\n  subscribeOnce(callback: Callback<T>): UnsubscribeCallback;\n  /**\n   * Returns a promise that will resolve when an event is emitted by this\n   * event source. Optionally, specify a predicate that has to match. The first\n   * event matching that predicate will then resolve the promise.\n   */\n  waitUntil(predicate?: (event: T) => boolean): Promise<T>;\n};\n\nexport type EventSource<T> = Observable<T> & {\n  /**\n   * Notify all subscribers about the event. Will return `false` if there\n   * weren't any subscribers at the time the .notify() was called, or `true` if\n   * there was at least one subscriber.\n   */\n  notify(event: T): boolean;\n  /**\n   * Returns the number of active subscribers.\n   */\n  count(): number;\n  /**\n   * Observable instance, which can be used to subscribe to this event source\n   * in a readonly fashion. Safe to publicly expose.\n   */\n  observable: Observable<T>;\n  /**\n   * Disposes of this event source.\n   *\n   * Will clears all registered event listeners. None of the registered\n   * functions will ever get called again.\n   *\n   * WARNING!\n   * Be careful when using this API, because the subscribers may not have any\n   * idea they won't be notified anymore.\n   */\n  // NOTE: This can eventually become [Symbol.dispose] when it's widely\n  // available in all browsers\n  dispose(): void;\n};\n\nexport type BufferableEventSource<T> = EventSource<T> & {\n  /**\n   * Pauses event delivery until unpaused. Any .notify() calls made while\n   * paused will get buffered into memory and emitted later.\n   */\n  pause(): void;\n  /**\n   * Emits all in-memory buffered events, and unpauses. Any .notify() calls\n   * made after this will be synchronously delivered again.\n   */\n  unpause(): void;\n};\n\nexport type EventEmitter<T> = (event: T) => void;\n\n/**\n * makeEventSource allows you to generate a subscribe/notify pair of functions\n * to make subscribing easy and to get notified about events.\n *\n * The events are anonymous, so you can use it to define events, like so:\n *\n *   const event1 = makeEventSource();\n *   const event2 = makeEventSource();\n *\n *   event1.subscribe(foo);\n *   event1.subscribe(bar);\n *   event2.subscribe(qux);\n *\n *   // Unsubscription is pretty standard\n *   const unsub = event2.subscribe(foo);\n *   unsub();\n *\n *   event1.notify();  // Now foo and bar will get called\n *   event2.notify();  // Now qux will get called (but foo will not, since it's unsubscribed)\n *\n */\nexport function makeEventSource<T>(): EventSource<T> {\n  const _observers = new Set<Callback<T>>();\n\n  function subscribe(callback: Callback<T>): UnsubscribeCallback {\n    _observers.add(callback);\n    return () => _observers.delete(callback);\n  }\n\n  function subscribeOnce(callback: Callback<T>): UnsubscribeCallback {\n    const unsub = subscribe((event: T) => {\n      unsub();\n      return callback(event);\n    });\n    return unsub;\n  }\n\n  async function waitUntil(predicate?: (event: T) => boolean): Promise<T> {\n    let unsub: () => void | undefined;\n    return new Promise<T>((res) => {\n      unsub = subscribe((event) => {\n        if (predicate === undefined || predicate(event)) {\n          res(event);\n        }\n      });\n    }).finally(() => unsub?.());\n  }\n\n  function notify(event: T) {\n    let called = false;\n    for (const callback of _observers) {\n      callback(event);\n      called = true;\n    }\n    return called;\n  }\n\n  function count() {\n    return _observers.size;\n  }\n\n  return {\n    // Private/internal control over event emission\n    notify,\n    subscribe,\n    subscribeOnce,\n    count,\n\n    waitUntil,\n\n    dispose(): void {\n      _observers.clear();\n    },\n\n    // Publicly exposable subscription API\n    observable: {\n      subscribe,\n      subscribeOnce,\n      waitUntil,\n    },\n  };\n}\n\nexport function makeBufferableEventSource<T>(): BufferableEventSource<T> {\n  const eventSource = makeEventSource<T>();\n  let _buffer: T[] | null = null;\n\n  function pause(): void {\n    _buffer = [];\n  }\n\n  function unpause(): void {\n    if (_buffer === null) {\n      // Already unpaused\n      return;\n    }\n\n    for (const event of _buffer) {\n      eventSource.notify(event);\n    }\n    _buffer = null;\n  }\n\n  function notifyOrBuffer(event: T) {\n    if (_buffer !== null) {\n      _buffer.push(event);\n      return false;\n    } else {\n      return eventSource.notify(event);\n    }\n  }\n\n  return {\n    ...eventSource,\n    notify: notifyOrBuffer,\n    pause,\n    unpause,\n\n    dispose(): void {\n      eventSource.dispose();\n      if (_buffer !== null) {\n        _buffer.length = 0;\n      }\n    },\n  };\n}\n","/**\n * Freezes the given argument, but only in development builds. In production\n * builds, this is a no-op for performance reasons.\n */\nexport const freeze: typeof Object.freeze =\n  process.env.NODE_ENV === \"production\"\n    ? /* istanbul ignore next */ (((x: unknown) => x) as typeof Object.freeze)\n    : Object.freeze;\n","import type { Json } from \"./Json\";\n\ndeclare const brand: unique symbol;\nexport type Brand<T, TBrand extends string> = T & { [brand]: TBrand };\n\nexport type ISODateString = Brand<string, \"ISODateString\">;\n\nexport type DistributiveOmit<T, K extends PropertyKey> = T extends any\n  ? Omit<T, K>\n  : never;\n\n// export type DistributivePick<T, K extends keyof T> = T extends any\n//   ? Pick<T, K>\n//   : never;\n\nexport type WithRequired<T, K extends keyof T> = T & { [P in K]-?: T[P] };\n\nexport type WithOptional<T, K extends keyof T> = Omit<T, K> & {\n  [P in K]?: T[P];\n};\n\n/**\n * Throw an error, but as an expression instead of a statement.\n */\nexport function raise(msg: string): never {\n  throw new Error(msg);\n}\n\n/**\n * Drop-in replacement for Object.entries() that retains better types.\n */\nexport function entries<\n  O extends { [key: string]: unknown },\n  K extends keyof O,\n>(obj: O): [K, O[K]][] {\n  return Object.entries(obj) as [K, O[K]][];\n}\n\n/**\n * Drop-in replacement for Object.keys() that retains better types.\n */\nexport function keys<O extends { [key: string]: unknown }, K extends keyof O>(\n  obj: O\n): K[] {\n  return Object.keys(obj) as K[];\n}\n\n/**\n * Drop-in replacement for Object.values() that retains better types.\n */\nexport function values<O extends Record<string, unknown>>(\n  obj: O\n): O[keyof O][] {\n  return Object.values(obj) as O[keyof O][];\n}\n\n/**\n * Drop-in replacement for Object.create() that retains better types.\n */\nexport function create<O extends Record<string, unknown>>(\n  obj: O | null,\n  descriptors?: PropertyDescriptorMap & ThisType<O>\n): O {\n  if (typeof descriptors !== \"undefined\") {\n    return Object.create(obj, descriptors) as O;\n  }\n\n  return Object.create(obj) as O;\n}\n\n/**\n * Creates a new object by mapping a function over all values. Keys remain the\n * same. Think Array.prototype.map(), but for values in an object.\n */\nexport function mapValues<V, O extends Record<string, unknown>>(\n  obj: O,\n  mapFn: (value: O[keyof O], key: keyof O) => V\n): { [K in keyof O]: V } {\n  const result = {} as { [K in keyof O]: V };\n  for (const pair of Object.entries(obj)) {\n    const key: keyof O = pair[0];\n    if (key === \"__proto__\") {\n      // Avoid setting dangerous __proto__ keys\n      continue;\n    }\n    const value = pair[1] as O[keyof O];\n    result[key] = mapFn(value, key);\n  }\n  return result;\n}\n\n/**\n * Alternative to JSON.parse() that will not throw in production. If the passed\n * string cannot be parsed, this will return `undefined`.\n */\nexport function tryParseJson(rawMessage: string): Json | undefined {\n  try {\n    // eslint-disable-next-line no-restricted-syntax\n    return JSON.parse(rawMessage) as Json;\n  } catch (e) {\n    return undefined;\n  }\n}\n\n/**\n * Deep-clones a JSON-serializable value.\n *\n * NOTE: We should be able to replace `deepClone` by `structuredClone` once\n * we've upgraded to Node 18.\n */\nexport function deepClone<T extends Json>(value: T): T {\n  // NOTE: In this case, the combination of JSON.parse() and JSON.stringify\n  // won't lead to type unsafety, so this use case is okay.\n  // eslint-disable-next-line no-restricted-syntax\n  return JSON.parse(JSON.stringify(value)) as T;\n}\n\n/**\n * Decode base64 string.\n */\nexport function b64decode(b64value: string): string {\n  try {\n    const formattedValue = b64value.replace(/-/g, \"+\").replace(/_/g, \"/\");\n    const decodedValue = decodeURIComponent(\n      atob(formattedValue)\n        .split(\"\")\n        .map(function (c) {\n          return \"%\" + (\"00\" + c.charCodeAt(0).toString(16)).slice(-2);\n        })\n        .join(\"\")\n    );\n\n    return decodedValue;\n  } catch (err) {\n    return atob(b64value);\n  }\n}\n\n/**\n * Mutates the array in-place by removing the first occurrence of `item` from\n * the array.\n */\nexport function remove<T>(array: T[], item: T): void {\n  for (let i = 0; i < array.length; i++) {\n    if (array[i] === item) {\n      array.splice(i, 1);\n      break;\n    }\n  }\n}\n\n/**\n * Removes null and undefined values from the array, and reflects this in the\n * output type.\n */\nexport function compact<T>(items: readonly T[]): NonNullable<T>[] {\n  return items.filter(\n    (item: T): item is NonNullable<T> => item !== null && item !== undefined\n  );\n}\n\nexport type RemoveUndefinedValues<T> = {\n  [K in keyof T]-?: Exclude<T[K], undefined>;\n};\n\n/**\n * Returns a new object instance where all explictly-undefined values are\n * removed.\n */\nexport function compactObject<O extends Record<string, unknown>>(\n  obj: O\n): RemoveUndefinedValues<O> {\n  const newObj = { ...obj };\n  Object.keys(obj).forEach((k) => {\n    const key = k as keyof O;\n    if (newObj[key] === undefined) {\n      delete newObj[key];\n    }\n  });\n  return newObj as RemoveUndefinedValues<O>;\n}\n\n/**\n * Returns a promise that resolves after the given number of milliseconds.\n */\nexport function wait(millis: number): Promise<void> {\n  return new Promise((res) => setTimeout(res, millis));\n}\n\n/**\n * Returns whatever the given promise returns, but will be rejected with\n * a \"Timed out\" error if the given promise does not return or reject within\n * the given timeout period (in milliseconds).\n */\nexport async function withTimeout<T>(\n  promise: Promise<T>,\n  millis: number,\n  errmsg: string\n): Promise<T> {\n  let timerID: ReturnType<typeof setTimeout> | undefined;\n  const timer$ = new Promise<never>((_, reject) => {\n    timerID = setTimeout(() => {\n      reject(new Error(errmsg));\n    }, millis);\n  });\n  return (\n    Promise\n      // Race the given promise against the timer. Whichever one finishes\n      // first wins the race.\n      .race([promise, timer$])\n\n      // Either way, clear the timeout, no matter who won\n      .finally(() => clearTimeout(timerID))\n  );\n}\n\n/**\n * Memoize a promise factory, so that each subsequent call will return the same\n * pending or success promise. If the promise rejects, will retain that failed\n * promise for a small time period, after which the next attempt will reset the\n * memoized value.\n */\nexport function memoizeOnSuccess<T>(\n  factoryFn: () => Promise<T>\n): () => Promise<T> {\n  let cached: Promise<T> | null = null;\n  return () => {\n    if (cached === null) {\n      cached = factoryFn().catch((err) => {\n        //\n        // Keep returning the failed promise for any calls to the memoized\n        // promise for the next 5 seconds. This time period is a bit arbitrary,\n        // but exists to make this play nicely with frameworks like React.\n        //\n        // In React, after a component is suspended and its promise is\n        // rejected, React will re-render the component, and expect the next\n        // call to this function to return the rejected promise, so its error\n        // can be shown. If we immediately reset this value, then such next\n        // render would instantly trigger a new promise which would trigger an\n        // infinite loop and keeping the component in loading state forever.\n        //\n        setTimeout(() => {\n          cached = null;\n        }, 5_000);\n        throw err;\n      });\n    }\n    return cached;\n  };\n}\n\n/**\n * Polyfill for Array.prototype.findLastIndex()\n */\nexport function findLastIndex<T>(\n  arr: T[],\n  predicate: (value: T, index: number, obj: T[]) => boolean\n): number {\n  for (let i = arr.length - 1; i >= 0; i--) {\n    if (predicate(arr[i], i, arr)) {\n      return i;\n    }\n  }\n  return -1;\n}\n\nexport function iso(s: string): ISODateString {\n  return new Date(s).toISOString() as ISODateString;\n}\n\nexport function partition<T, N extends T>(\n  iterable: Iterable<T>,\n  predicate: (item: T, index: number) => item is N\n): [N[], Exclude<T, N>[]];\nexport function partition<T>(\n  iterable: Iterable<T>,\n  predicate: (item: T, index: number) => boolean\n): [T[], T[]];\nexport function partition<T>(\n  iterable: Iterable<T>,\n  predicate: (item: T, index: number) => boolean\n): [T[], T[]] {\n  const good = [];\n  const bad = [];\n\n  let index = 0;\n  for (const item of iterable) {\n    if (predicate(item, index++)) {\n      good.push(item);\n    } else {\n      bad.push(item);\n    }\n  }\n\n  return [good, bad];\n}\n","import type {\n  Callback,\n  EventSource,\n  Observable,\n  UnsubscribeCallback,\n} from \"../lib/EventSource\";\nimport { makeEventSource } from \"../lib/EventSource\";\nimport { freeze } from \"../lib/freeze\";\nimport type { JsonObject } from \"../lib/Json\";\nimport { compactObject, raise } from \"../lib/utils\";\n\nconst kSinks = Symbol(\"kSinks\");\nconst kTrigger = Symbol(\"kTrigger\");\n\n//\n// Before the batch is run, all sinks (recursively all the way down) are marked\n// dirty. This already is enough if we only ever use .get() calls.\n//\n// However, to ensure active subscription notifications also work, we need to\n// keep track of which Signals to notify. Any time the value of a Signal\n// changes, the Signal itself will notify its own subscribers, but \"sinks\" are\n// not \"normal\" subscribers.\n//\n// By treating sinks slightly differently, we can keep track of sink uniqueness\n// across the entire signal network, ensuring a sink will only be notified once\n// if more than one of its dependent Signals have changed.\n//\n// For example:\n//\n//      A\n//    /   \\\n//   B     C\n//    \\   /\n//      D - - - - ( has 1 normal subscriber )\n//\n// Here, B and C are sinks of A, and D is a sink of both B and C.\n//\n// Here's what will happen when A changes:\n//\n// - If A changes, then all sinks (B, C, and D) will be marked dirty.\n//\n// - Because some of A's sinks are being watched (in this case, D has at least\n//   one subscriber), A will trigger B and C that its value has changed.\n//\n// - Both B and C re-evaluate and may or may not have changed. Three\n//   possibilities:\n//   1. Neither B and C have changed → D will *NOT* be triggered\n//   2. Either B or C has changed    → D *will* be triggered\n//   3. Both B and C have changed    → D *will* be triggered (but only once!)\n//\n// - If in the previous step D has been triggered, it will re-evaluate. If it\n//   has changed itself, it will notify its normal subscriber.\n//\nlet signalsToTrigger: Set<AbstractSignal<any>> | null = null;\n\n//\n// If a derived signal is currently being computed, there is a global \"signals\n// that have been read\" registry that every call to `someSignal.get()` will\n// register itself under.\n//\nlet trackedReads: Set<AbstractSignal<any>> | null = null;\n\n/**\n * Runs a callback function that is allowed to change multiple signals. At the\n * end of the batch, all changed signals will be notified (at most once).\n *\n * Nesting batches is supported.\n */\nexport function batch(callback: Callback<void>): void {\n  if (signalsToTrigger !== null) {\n    // Already inside another batch, just run this inner callback\n    callback();\n    return;\n  }\n\n  signalsToTrigger = new Set();\n  try {\n    callback();\n  } finally {\n    for (const signal of signalsToTrigger) {\n      signal[kTrigger]();\n    }\n    signalsToTrigger = null;\n  }\n}\n\n/**\n * Ensures that the signal will be notified at the end of the current batch.\n * This should only be called within a batch callback. It's safe to call this\n * while notifications are being rolled out.\n */\nfunction enqueueTrigger(signal: AbstractSignal<any>) {\n  if (!signalsToTrigger) raise(\"Expected to be in an active batch\");\n  signalsToTrigger.add(signal);\n}\n\n/**\n * Patches a target object by \"merging in\" the provided fields. Patch\n * fields that are explicitly-undefined will delete keys from the target\n * object. Will return a new object.\n *\n * Important guarantee:\n * If the patch effectively did not mutate the target object because the\n * patch fields have the same value as the original, then the original\n * object reference will be returned.\n */\nexport function merge<T>(target: T, patch: Partial<T>): T {\n  let updated = false;\n  const newValue = { ...target };\n\n  Object.keys(patch).forEach((k) => {\n    const key = k as keyof T;\n    const val = patch[key];\n    if (newValue[key] !== val) {\n      if (val === undefined) {\n        delete newValue[key];\n      } else {\n        newValue[key] = val as T[keyof T];\n      }\n      updated = true;\n    }\n  });\n\n  return updated ? newValue : target;\n}\n\nexport type SignalType<S extends ISignal<any>> =\n  S extends ISignal<infer T> ? T : never;\n\nexport interface ISignal<T> {\n  get(): T;\n  subscribe(callback: Callback<void>): UnsubscribeCallback;\n  addSink(sink: DerivedSignal<unknown>): void;\n  removeSink(sink: DerivedSignal<unknown>): void;\n}\n\n/**\n * Base functionality every Signal implementation needs.\n */\nabstract class AbstractSignal<T> implements ISignal<T>, Observable<void> {\n  /** @internal */\n  protected readonly equals: (a: T, b: T) => boolean;\n  readonly #eventSource: EventSource<void>;\n  /** @internal */\n  public readonly [kSinks]: Set<DerivedSignal<unknown>>;\n\n  constructor(equals?: (a: T, b: T) => boolean) {\n    this.equals = equals ?? Object.is;\n    this.#eventSource = makeEventSource<void>();\n    this[kSinks] = new Set();\n\n    // Bind common methods to self\n    this.get = this.get.bind(this);\n    this.subscribe = this.subscribe.bind(this);\n    this.subscribeOnce = this.subscribeOnce.bind(this);\n  }\n\n  dispose(): void {\n    this.#eventSource.dispose();\n\n    // @ts-expect-error make disposed object completely unusable\n    this.#eventSource = \"(disposed)\";\n    // @ts-expect-error make disposed object completely unusable\n    this.equals = \"(disposed)\";\n  }\n\n  // Concrete subclasses implement this method in different ways\n  abstract get(): T;\n\n  get hasWatchers(): boolean {\n    if (this.#eventSource.count() > 0) return true;\n\n    for (const sink of this[kSinks]) {\n      if (sink.hasWatchers) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  public [kTrigger](): void {\n    this.#eventSource.notify();\n\n    // While Signals are being triggered in the current unroll, we can enqueue\n    // more signals to trigger (which will get added to the current unroll)\n    for (const sink of this[kSinks]) {\n      enqueueTrigger(sink);\n    }\n  }\n\n  subscribe(callback: Callback<void>): UnsubscribeCallback {\n    // If this is the first subscriber, we need to perform an initial .get()\n    // now in case this is a DerivedSignal that has not been evaluated yet. The\n    // reason we need to do this is that the .get() itself will register this\n    // signal as sinks of the dependent signals, so we will actually get\n    // notified here when one of the dependent signals changes.\n    if (this.#eventSource.count() === 0) {\n      this.get();\n    }\n    return this.#eventSource.subscribe(callback);\n  }\n\n  subscribeOnce(callback: Callback<void>): UnsubscribeCallback {\n    const unsub = this.subscribe(() => {\n      unsub();\n      return callback();\n    });\n    return unsub;\n  }\n\n  waitUntil(): never {\n    throw new Error(\"waitUntil not supported on Signals\");\n  }\n\n  markSinksDirty(): void {\n    for (const sink of this[kSinks]) {\n      sink.markDirty();\n    }\n  }\n\n  addSink(sink: DerivedSignal<unknown>): void {\n    this[kSinks].add(sink);\n  }\n\n  removeSink(sink: DerivedSignal<unknown>): void {\n    this[kSinks].delete(sink);\n  }\n\n  asReadonly(): ISignal<T> {\n    return this;\n  }\n}\n\n// NOTE: This class is pretty similar to the Signal.State proposal\nexport class Signal<T> extends AbstractSignal<T> {\n  #value: T;\n\n  constructor(value: T, equals?: (a: T, b: T) => boolean) {\n    super(equals);\n    this.#value = freeze(value);\n  }\n\n  dispose(): void {\n    super.dispose();\n    // @ts-expect-error make disposed object completely unusable\n    this.#value = \"(disposed)\";\n  }\n\n  get(): T {\n    trackedReads?.add(this);\n    return this.#value;\n  }\n\n  set(newValue: T | ((oldValue: T) => T)): void {\n    batch(() => {\n      if (typeof newValue === \"function\") {\n        newValue = (newValue as (oldValue: T) => T)(this.#value);\n      }\n      if (!this.equals(this.#value, newValue)) {\n        this.#value = freeze(newValue);\n        this.markSinksDirty();\n        enqueueTrigger(this);\n      }\n    });\n  }\n}\n\nexport class PatchableSignal<J extends JsonObject> extends Signal<J> {\n  constructor(data: J) {\n    super(freeze(compactObject(data)));\n  }\n\n  set(): void {\n    throw new Error(\"Don't call .set() directly, use .patch()\");\n  }\n\n  /**\n   * Patches the current object.\n   */\n  patch(patch: Partial<J>): void {\n    super.set((old) => merge(old, patch));\n  }\n}\n\n/**\n * Placeholder for a deferred computation that has yet to happen on-demand in\n * the future.\n */\nconst INITIAL = Symbol();\n\n// NOTE: This class is pretty similar to the Signal.Computed proposal\nexport class DerivedSignal<T> extends AbstractSignal<T> {\n  #prevValue: T;\n  #dirty: boolean; // When true, the value in #value may not be up-to-date and needs re-checking\n\n  #sources: Set<ISignal<unknown>>;\n  readonly #deps: readonly ISignal<unknown>[];\n  readonly #transform: (...values: unknown[]) => T;\n\n  // Overload 1\n  static from<Ts extends unknown[], V>(...args: [...signals: { [K in keyof Ts]: ISignal<Ts[K]> }, transform: (...values: Ts) => V]): DerivedSignal<V>; // prettier-ignore\n  // Overload 2\n  static from<Ts extends unknown[], V>(...args: [...signals: { [K in keyof Ts]: ISignal<Ts[K]> }, transform: (...values: Ts) => V, equals: (a: V, b: V) => boolean]): DerivedSignal<V>; // prettier-ignore\n  static from<Ts extends unknown[], V>(\n    // prettier-ignore\n    ...args: [\n      ...signals: { [K in keyof Ts]: ISignal<Ts[K]> },\n      transform: (...values: Ts) => V,\n      equals?: (a: V, b: V) => boolean,\n    ]\n  ): DerivedSignal<V> {\n    const last = args.pop();\n    if (typeof last !== \"function\")\n      raise(\"Invalid .from() call, last argument expected to be a function\");\n\n    if (typeof args[args.length - 1] === \"function\") {\n      // Overload 2\n      const equals = last as (a: V, b: V) => boolean;\n      const transform = args.pop() as (...values: unknown[]) => V;\n      return new DerivedSignal(args as ISignal<unknown>[], transform, equals);\n    } else {\n      // Overload 1\n      const transform = last as (...values: unknown[]) => V;\n      return new DerivedSignal(args as ISignal<unknown>[], transform);\n    }\n  }\n\n  private constructor(\n    deps: ISignal<unknown>[],\n    transform: (...values: unknown[]) => T,\n    equals?: (a: T, b: T) => boolean\n  ) {\n    super(equals);\n    this.#dirty = true;\n    this.#prevValue = INITIAL as unknown as T;\n    this.#deps = deps;\n    this.#sources = new Set();\n    this.#transform = transform;\n  }\n\n  dispose(): void {\n    for (const src of this.#sources) {\n      src.removeSink(this as DerivedSignal<unknown>);\n    }\n\n    // @ts-expect-error make disposed object completely unusable\n    this.#prevValue = \"(disposed)\";\n    // @ts-expect-error make disposed object completely unusable\n    this.#sources = \"(disposed)\";\n    // @ts-expect-error make disposed object completely unusable\n    this.#deps = \"(disposed)\";\n    // @ts-expect-error make disposed object completely unusable\n    this.#transform = \"(disposed)\";\n  }\n\n  get isDirty(): boolean {\n    return this.#dirty;\n  }\n\n  #recompute(): boolean {\n    const oldTrackedReads = trackedReads;\n\n    let derived;\n    trackedReads = new Set();\n    try {\n      derived = this.#transform(...this.#deps.map((p) => p.get()));\n    } finally {\n      const oldSources = this.#sources;\n      this.#sources = new Set();\n\n      for (const sig of trackedReads) {\n        this.#sources.add(sig);\n        oldSources.delete(sig);\n      }\n\n      for (const oldSource of oldSources) {\n        oldSource.removeSink(this as DerivedSignal<unknown>);\n      }\n      for (const newSource of this.#sources) {\n        newSource.addSink(this as DerivedSignal<unknown>);\n      }\n\n      trackedReads = oldTrackedReads;\n    }\n\n    this.#dirty = false;\n\n    // Only emit a change to watchers if the value actually changed\n    if (!this.equals(this.#prevValue, derived)) {\n      this.#prevValue = derived;\n      return true;\n    }\n    return false;\n  }\n\n  markDirty(): void {\n    if (!this.#dirty) {\n      this.#dirty = true;\n      this.markSinksDirty();\n    }\n  }\n\n  get(): T {\n    if (this.#dirty) {\n      this.#recompute();\n    }\n    trackedReads?.add(this);\n    return this.#prevValue;\n  }\n\n  /**\n   * Called by the Signal system if one or more of the dependent signals have\n   * changed. In the case of a DerivedSignal, we'll only want to re-evaluate\n   * the actual value if it's being watched, or any of their sinks are being\n   * watched actively.\n   */\n  public [kTrigger](): void {\n    if (!this.hasWatchers) {\n      // If there are no watchers for this signal, we don't need to\n      // re-evaluate. We can postpone re-evaluation until the next .get() call.\n      return;\n    }\n\n    // Re-evaluate the current derived signal's value and if needed,\n    // notify sinks. At this point, all sinks should already have been\n    // marked dirty, so we won't have to do that again here now.\n    const updated = this.#recompute();\n    if (updated) {\n      super[kTrigger](); // Actually notify subscribers\n    }\n  }\n}\n\n/**\n * A MutableSignal is a bit like Signal, except its state is managed by\n * a single value whose reference does not change but is mutated.\n *\n * Similar to how useSyncExternalState() works in React, there is a way to read\n * the current state at any point in time synchronously, and a way to update\n * its reference.\n */\nexport class MutableSignal<T extends object> extends AbstractSignal<T> {\n  readonly #state: T;\n\n  constructor(initialState: T) {\n    super();\n    this.#state = initialState;\n  }\n\n  dispose(): void {\n    super.dispose();\n    // @ts-expect-error make disposed object completely unusable\n    this.#state = \"(disposed)\";\n  }\n\n  get(): T {\n    trackedReads?.add(this);\n    return this.#state;\n  }\n\n  /**\n   * Invokes a callback function that is allowed to mutate the given state\n   * value. Do not change the value outside of the callback.\n   *\n   * If the callback explicitly returns `false`, it's assumed that the state\n   * was not changed.\n   */\n  mutate(callback?: (state: T) => void | boolean): void {\n    batch(() => {\n      const result = callback ? callback(this.#state) : true;\n      if (result !== null && typeof result === \"object\" && \"then\" in result) {\n        raise(\"MutableSignal.mutate() does not support async callbacks\");\n      }\n\n      if (result !== false) {\n        this.markSinksDirty();\n        enqueueTrigger(this);\n      }\n    });\n  }\n}\n","/**\n * Returns the insertion index for the given item.\n */\nfunction bisectRight<T>(arr: readonly T[], x: T, lt: (a: T, b: T) => boolean) {\n  let lo = 0;\n  let hi = arr.length;\n  while (lo < hi) {\n    const mid = lo + ((hi - lo) >> 1); // equiv of Math.floor((lo + hi) / 2)\n    if (lt(x, arr[mid])) {\n      hi = mid;\n    } else {\n      lo = mid + 1;\n    }\n  }\n  return lo;\n}\n\n/**\n * A datastructure to keep elements in ascending order, as defined by the \"less\n * than\" function you provide. The elements will be ordered according to\n * whatever you define as the \"less than\" for this element type, so that every\n * element is less than its successor in the list.\n *\n * const sorted = SortedList.from(\n *   [{ id: 4 }, { id: 1 }, { id: 9 }, { id: 4 }],\n *   (a, b) => a.id < b.id)\n * )\n * sorted.add({ id: 5 })\n * sorted.remove({ id: 4 })  // Assuming it's the same obj ref!\n *\n * Array.from(sorted)\n * [{ id: 1 }, { id: 4 }, { id: 5 }, { id: 9 }])\n */\nexport class SortedList<T> {\n  #data: T[];\n  #lt: (a: T, b: T) => boolean;\n\n  private constructor(alreadySortedList: T[], lt: (a: T, b: T) => boolean) {\n    this.#lt = lt;\n    this.#data = alreadySortedList;\n  }\n\n  /**\n   * Creates an empty SortedList with the given \"less than\" function.\n   */\n  public static with<T>(lt: (a: T, b: T) => boolean): SortedList<T> {\n    return SortedList.fromAlreadySorted([], lt);\n  }\n\n  public static from<T>(\n    arr: readonly T[],\n    lt: (a: T, b: T) => boolean\n  ): SortedList<T> {\n    const sorted = new SortedList([], lt);\n    for (const item of arr) {\n      sorted.add(item);\n    }\n    return sorted;\n  }\n\n  public static fromAlreadySorted<T>(\n    alreadySorted: T[],\n    lt: (a: T, b: T) => boolean\n  ): SortedList<T> {\n    return new SortedList(alreadySorted, lt);\n  }\n\n  /**\n   * Clones the sorted list to a new instance.\n   */\n  public clone(): SortedList<T> {\n    return new SortedList(this.#data.slice(), this.#lt);\n  }\n\n  /**\n   * Adds a new item to the sorted list, such that it remains sorted.\n   * Returns the index where the item was inserted.\n   */\n  add(value: T): number {\n    const idx = bisectRight(this.#data, value, this.#lt);\n    this.#data.splice(idx, 0, value);\n    return idx;\n  }\n\n  /**\n   * Removes all values from the sorted list, making it empty again.\n   * Returns whether the list was mutated or not.\n   */\n  clear(): boolean {\n    const hadData = this.#data.length > 0;\n    this.#data.length = 0;\n    return hadData;\n  }\n\n  /**\n   * Removes the first value matching the predicate.\n   * Returns whether the list was mutated or not.\n   */\n  removeBy(\n    predicate: (item: T) => boolean,\n    limit: number = Number.POSITIVE_INFINITY\n  ): boolean {\n    let deleted = 0;\n    for (let i = 0; i < this.#data.length; i++) {\n      if (predicate(this.#data[i])) {\n        this.#data.splice(i, 1);\n        deleted++;\n        if (deleted >= limit) {\n          break;\n        } else {\n          i--;\n        }\n      }\n    }\n    return deleted > 0;\n  }\n\n  /**\n   * Removes the given value from the sorted list, if it exists. The given\n   * value must be `===` to one of the list items. Only the first entry will be\n   * removed if the element exists in the sorted list multiple times.\n   *\n   * Returns whether the list was mutated or not.\n   */\n  remove(value: T): boolean {\n    const idx = this.#data.indexOf(value);\n    if (idx >= 0) {\n      this.#data.splice(idx, 1);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Removes the item at the given index.\n   * Returns the removed item, or undefined if index is out of bounds.\n   */\n  removeAt(index: number): T | undefined {\n    if (index < 0 || index >= this.#data.length) {\n      return undefined;\n    }\n    const [removed] = this.#data.splice(index, 1);\n    return removed;\n  }\n\n  /**\n   * Repositions an item to maintain sorted order after its sort key has\n   * been mutated in-place. For example:\n   *\n   *   const item = sorted.at(3);\n   *   item.updatedAt = new Date();  // mutate the item's sort key in-place\n   *   sorted.reposition(item);      // restore sorted order\n   *\n   * Returns the new index of the item. Throws if the item is not in the list.\n   *\n   * Semantically equivalent to remove(value) + add(value), but optimized\n   * to avoid array shifting when the item only moves a short distance.\n   */\n  reposition(value: T): number {\n    const oldIdx = this.#data.indexOf(value);\n    if (oldIdx < 0) {\n      throw new Error(\"Cannot reposition item that is not in the list\");\n    }\n\n    // Quick check: if already in valid position, no need to move.\n    // Valid means: prev < value < next (matching bisectRight insertion point)\n    const prev = this.#data[oldIdx - 1];\n    const next = this.#data[oldIdx + 1];\n    const validLeft = prev === undefined || this.#lt(prev, value);\n    const validRight = next === undefined || this.#lt(value, next);\n    if (validLeft && validRight) {\n      return oldIdx;\n    }\n\n    let newIdx = oldIdx;\n\n    // Try moving left (value < prev means we're out of order on the left)\n    while (newIdx > 0 && this.#lt(value, this.#data[newIdx - 1])) {\n      this.#data[newIdx] = this.#data[newIdx - 1];\n      newIdx--;\n    }\n\n    if (newIdx < oldIdx) {\n      this.#data[newIdx] = value;\n      return newIdx;\n    }\n\n    // Try moving right (next <= value means we need to move past it)\n    while (\n      newIdx < this.#data.length - 1 &&\n      !this.#lt(value, this.#data[newIdx + 1])\n    ) {\n      this.#data[newIdx] = this.#data[newIdx + 1];\n      newIdx++;\n    }\n\n    if (newIdx !== oldIdx) {\n      this.#data[newIdx] = value;\n    }\n\n    return newIdx;\n  }\n\n  at(index: number): T | undefined {\n    return this.#data[index];\n  }\n\n  get length(): number {\n    return this.#data.length;\n  }\n\n  *filter(predicate: (value: T) => boolean): IterableIterator<T> {\n    for (const item of this.#data) {\n      if (predicate(item)) {\n        yield item;\n      }\n    }\n  }\n\n  // XXXX If we keep this, add unit tests. Or remove it.\n  *findAllRight(\n    predicate: (value: T, index: number) => unknown\n  ): IterableIterator<T> {\n    for (let i = this.#data.length - 1; i >= 0; i--) {\n      const item = this.#data[i];\n      if (predicate(item, i)) {\n        yield item;\n      }\n    }\n  }\n\n  [Symbol.iterator](): IterableIterator<T> {\n    return this.#data[Symbol.iterator]();\n  }\n\n  *iterReversed(): IterableIterator<T> {\n    for (let i = this.#data.length - 1; i >= 0; i--) {\n      yield this.#data[i];\n    }\n  }\n\n  /** Finds the leftmost item that matches the predicate. */\n  find(\n    predicate: (value: T, index: number) => unknown,\n    start?: number\n  ): T | undefined {\n    const idx = this.findIndex(predicate, start);\n    return idx > -1 ? this.#data.at(idx)! : undefined; // eslint-disable-line no-restricted-syntax\n  }\n\n  /** Finds the leftmost index that matches the predicate. */\n  findIndex(\n    predicate: (value: T, index: number) => unknown,\n    start = 0\n  ): number {\n    for (let i = Math.max(0, start); i < this.#data.length; i++) {\n      if (predicate(this.#data[i], i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /** Finds the rightmost item that matches the predicate. */\n  findRight(\n    predicate: (value: T, index: number) => unknown,\n    start?: number\n  ): T | undefined {\n    const idx = this.findIndexRight(predicate, start);\n    return idx > -1 ? this.#data.at(idx)! : undefined; // eslint-disable-line no-restricted-syntax\n  }\n\n  /** Finds the rightmost index that matches the predicate. */\n  findIndexRight(\n    predicate: (value: T, index: number) => unknown,\n    start = this.#data.length - 1\n  ): number {\n    for (let i = Math.min(start, this.#data.length - 1); i >= 0; i--) {\n      if (predicate(this.#data[i], i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  get rawArray(): readonly T[] {\n    return this.#data;\n  }\n}\n","import { MutableSignal } from \"./lib/signals\";\nimport { SortedList } from \"./lib/SortedList\";\nimport type { ISODateString } from \"./lib/utils\";\nimport type { AiChat, AiChatsQuery } from \"./types/ai\";\n\nexport class AiChatDB {\n  #byId: Map<string, AiChat>; // A map of chat id to chat details\n  #chats: SortedList<Omit<AiChat, \"deletedAt\">>; // Sorted list of non-deleted chats, most recent first\n\n  public readonly signal: MutableSignal<this>;\n\n  constructor() {\n    this.#byId = new Map();\n    this.#chats = SortedList.from<Omit<AiChat, \"deletedAt\">>([], (c1, c2) => {\n      // Sort by 'lastMessageAt' if available, otherwise 'createdAt' (most recent first)\n      const d2 = c2.lastMessageAt ?? c2.createdAt;\n      const d1 = c1.lastMessageAt ?? c1.createdAt;\n      return d2 < d1 ? true : d2 === d1 ? c2.id < c1.id : false;\n    });\n\n    this.signal = new MutableSignal(this);\n  }\n\n  public getEvenIfDeleted(chatId: string): AiChat | undefined {\n    this.signal.get(); // Access signal to establish dependency tracking for any derived signals\n    return this.#byId.get(chatId);\n  }\n\n  public markDeleted(chatId: string): void {\n    const chat = this.#byId.get(chatId);\n    if (chat === undefined || chat.deletedAt !== undefined) return;\n    this.upsert({\n      ...chat,\n      deletedAt: new Date().toISOString() as ISODateString,\n    });\n  }\n\n  public upsert(chat: AiChat): void {\n    this.signal.mutate(() => {\n      // If the chat already exists, remove it before deciding whether to add the incoming one\n      const existingThread = this.#byId.get(chat.id);\n      if (existingThread !== undefined) {\n        if (existingThread.deletedAt !== undefined) return false;\n\n        this.#chats.remove(existingThread);\n        this.#byId.delete(existingThread.id);\n      }\n\n      // We only add non-deleted chats to the chat list\n      if (chat.deletedAt === undefined) {\n        this.#chats.add(chat);\n      }\n      this.#byId.set(chat.id, chat);\n      return true;\n    });\n  }\n\n  public findMany(query: AiChatsQuery): Omit<AiChat, \"deletedAt\">[] {\n    return Array.from(\n      this.#chats.filter((chat) => {\n        // If metadata query is not provided, include all chats\n        if (query.metadata === undefined) return true;\n\n        for (const [key, value] of Object.entries(query.metadata)) {\n          // If the value is null, check that the key does not exist in the chat's metadata\n          if (value === null) {\n            if (key in chat.metadata) return false;\n          }\n          // If the metadata key is a string, check for an exact match against the chat's metadata\n          else if (typeof value === \"string\") {\n            if (chat.metadata[key] !== value) return false;\n          }\n          // If the metadata key is an array, ensure all values are present in the chat's metadata array\n          else {\n            const chatValue = chat.metadata[key];\n            if (\n              !Array.isArray(chatValue) ||\n              !value.every((v) => chatValue.includes(v))\n            ) {\n              return false;\n            }\n          }\n        }\n\n        return true;\n      })\n    );\n  }\n}\n","import type {\n  BaseMetadata,\n  CommentData,\n  CommentDataPlain,\n  CommentUserReaction,\n  CommentUserReactionPlain,\n  ThreadData,\n  ThreadDataPlain,\n  ThreadDeleteInfo,\n  ThreadDeleteInfoPlain,\n} from \"./protocol/Comments\";\nimport type { GroupData, GroupDataPlain } from \"./protocol/Groups\";\nimport type {\n  InboxNotificationData,\n  InboxNotificationDataPlain,\n  InboxNotificationDeleteInfo,\n  InboxNotificationDeleteInfoPlain,\n} from \"./protocol/InboxNotifications\";\nimport type {\n  SubscriptionData,\n  SubscriptionDataPlain,\n  SubscriptionDeleteInfo,\n  SubscriptionDeleteInfoPlain,\n  UserSubscriptionData,\n  UserSubscriptionDataPlain,\n} from \"./protocol/Subscriptions\";\n\n/**\n * Converts a plain comment data object (usually returned by the API) to a comment data object that can be used by the client.\n * This is necessary because the plain data object stores dates as ISO strings, but the client expects them as Date objects.\n * @param data The plain comment data object (usually returned by the API)\n * @returns The rich comment data object that can be used by the client.\n */\nexport function convertToCommentData<CM extends BaseMetadata>(\n  data: CommentDataPlain<CM>\n): CommentData<CM> {\n  const editedAt = data.editedAt ? new Date(data.editedAt) : undefined;\n  const createdAt = new Date(data.createdAt);\n  const reactions = data.reactions.map((reaction) => ({\n    ...reaction,\n    createdAt: new Date(reaction.createdAt),\n  }));\n\n  if (data.body) {\n    return {\n      ...data,\n      reactions,\n      createdAt,\n      editedAt,\n    };\n  } else {\n    const deletedAt = new Date(data.deletedAt);\n    return {\n      ...data,\n      reactions,\n      createdAt,\n      editedAt,\n      deletedAt,\n    };\n  }\n}\n\n/**\n * Converts a plain thread data object (usually returned by the API) to a thread data object that can be used by the client.\n * This is necessary because the plain data object stores dates as ISO strings, but the client expects them as Date objects.\n * @param data The plain thread data object (usually returned by the API)\n * @returns The rich thread data object that can be used by the client.\n */\nexport function convertToThreadData<\n  TM extends BaseMetadata,\n  CM extends BaseMetadata,\n>(data: ThreadDataPlain<TM, CM>): ThreadData<TM, CM> {\n  const createdAt = new Date(data.createdAt);\n  const updatedAt = new Date(data.updatedAt);\n\n  const comments = data.comments.map((comment) =>\n    convertToCommentData(comment)\n  );\n\n  return {\n    ...data,\n    createdAt,\n    updatedAt,\n    comments,\n  };\n}\n\n/**\n * Converts a plain comment reaction object (usually returned by the API) to a comment reaction object that can be used by the client.\n * This is necessary because the plain data object stores dates as ISO strings, but the client expects them as Date objects.\n * @param data The plain comment reaction object (usually returned by the API)\n * @returns The rich comment reaction object that can be used by the client.\n */\nexport function convertToCommentUserReaction(\n  data: CommentUserReactionPlain\n): CommentUserReaction {\n  return {\n    ...data,\n    createdAt: new Date(data.createdAt),\n  };\n}\n\n/**\n * Converts a plain inbox notification data object (usually returned by the API) to an inbox notification data object that can be used by the client.\n * This is necessary because the plain data object stores dates as ISO strings, but the client expects them as Date objects.\n * @param data The plain inbox notification data object (usually returned by the API)\n * @returns The rich inbox notification data object that can be used by the client.\n */\nexport function convertToInboxNotificationData(\n  data: InboxNotificationDataPlain\n): InboxNotificationData {\n  const notifiedAt = new Date(data.notifiedAt);\n  const readAt = data.readAt ? new Date(data.readAt) : null;\n\n  if (\"activities\" in data) {\n    const activities = data.activities.map((activity) => ({\n      ...activity,\n      createdAt: new Date(activity.createdAt),\n    }));\n\n    return {\n      ...data,\n      notifiedAt,\n      readAt,\n      activities,\n    };\n  }\n\n  return {\n    ...data,\n    notifiedAt,\n    readAt,\n  };\n}\n\n/**\n * Converts a plain subscription data object (usually returned by the API) to a subscription data object that can be used by the client.\n * This is necessary because the plain data object stores dates as ISO strings, but the client expects them as Date objects.\n * @param data The plain subscription data object (usually returned by the API)\n * @returns The rich subscription data object that can be used by the client.\n */\nexport function convertToSubscriptionData(\n  data: SubscriptionDataPlain\n): SubscriptionData {\n  const createdAt = new Date(data.createdAt);\n\n  return {\n    ...data,\n    createdAt,\n  };\n}\n\n/**\n * Converts a plain user subscription data object (usually returned by the API) to a user subscription data object that can be used by the client.\n * This is necessary because the plain data object stores dates as ISO strings, but the client expects them as Date objects.\n * @param data The plain user subscription data object (usually returned by the API)\n * @returns The rich user subscription data object that can be used by the client.\n */\nexport function convertToUserSubscriptionData(\n  data: UserSubscriptionDataPlain\n): UserSubscriptionData {\n  const createdAt = new Date(data.createdAt);\n\n  return {\n    ...data,\n    createdAt,\n  };\n}\n\nexport function convertToThreadDeleteInfo(\n  data: ThreadDeleteInfoPlain\n): ThreadDeleteInfo {\n  const deletedAt = new Date(data.deletedAt);\n\n  return {\n    ...data,\n    deletedAt,\n  };\n}\n\nexport function convertToInboxNotificationDeleteInfo(\n  data: InboxNotificationDeleteInfoPlain\n): InboxNotificationDeleteInfo {\n  const deletedAt = new Date(data.deletedAt);\n\n  return {\n    ...data,\n    deletedAt,\n  };\n}\n\nexport function convertToSubscriptionDeleteInfo(\n  data: SubscriptionDeleteInfoPlain\n): SubscriptionDeleteInfo {\n  const deletedAt = new Date(data.deletedAt);\n\n  return {\n    ...data,\n    deletedAt,\n  };\n}\n\nexport function convertToGroupData(data: GroupDataPlain): GroupData {\n  const createdAt = new Date(data.createdAt);\n  const updatedAt = new Date(data.updatedAt);\n  const members = data.members.map((member) => ({\n    ...member,\n    addedAt: new Date(member.addedAt),\n  }));\n\n  return {\n    ...data,\n    createdAt,\n    updatedAt,\n    members,\n  };\n}\n","/**\n * Helper function that can be used to implement exhaustive switch statements\n * with TypeScript. Example usage:\n *\n *    type Fruit = \"🍎\" | \"🍌\";\n *\n *    switch (fruit) {\n *      case \"🍎\":\n *      case \"🍌\":\n *        return doSomething();\n *\n *      default:\n *        return assertNever(fruit, \"Unknown fruit\");\n *    }\n *\n * If now the Fruit union is extended (i.e. add \"🍒\"), TypeScript will catch\n * this *statically*, rather than at runtime, and force you to handle the\n * 🍒 case.\n */\n// istanbul ignore next\nexport function assertNever(_value: never, errmsg: string): never {\n  throw new Error(errmsg);\n}\n\n/**\n * Asserts that a certain condition holds. If it does not hold, will throw\n * a runtime error in dev mode.\n *\n * In production, nothing is asserted and this acts as a no-op.\n */\nexport function assert(condition: boolean, errmsg: string): asserts condition {\n  if (process.env.NODE_ENV !== \"production\") {\n    // istanbul ignore if\n    if (!condition) {\n      const err = new Error(errmsg);\n      err.name = \"Assertion failure\";\n      throw err;\n    }\n  }\n}\n\n/**\n * Asserts that a given value is non-nullable. This is similar to TypeScript's\n * `!` operator, but will throw an error at runtime (dev-mode only) indicating\n * an incorrect assumption.\n *\n * Instead of:\n *\n *     foo!.bar\n *\n * Use:\n *\n *     nn(foo).bar\n *\n */\nexport function nn<T>(\n  value: T,\n  errmsg: string = \"Expected value to be non-nullable\"\n): NonNullable<T> {\n  assert(value !== null && value !== undefined, errmsg);\n  return value as NonNullable<T>;\n}\n","/* eslint-disable rulesdir/console-must-be-fancy */\n\nconst badge =\n  \"background:#0e0d12;border-radius:9999px;color:#fff;padding:3px 7px;font-family:sans-serif;font-weight:600;\";\nconst bold = \"font-weight:600\";\n\nfunction wrap(\n  method: \"log\" | \"warn\" | \"error\"\n): (message: string, ...args: readonly unknown[]) => void {\n  return typeof window === \"undefined\" || process.env.NODE_ENV === \"test\"\n    ? console[method]\n    : /* istanbul ignore next */\n      (message, ...args) =>\n        console[method](\"%cLiveblocks\", badge, message, ...args);\n}\n\n// export const log = wrap(\"log\");\nexport const warn = wrap(\"warn\");\nexport const error = wrap(\"error\");\n\nfunction wrapWithTitle(\n  method: \"log\" | \"warn\" | \"error\"\n): (title: string, message: string, ...args: readonly unknown[]) => void {\n  return typeof window === \"undefined\" || process.env.NODE_ENV === \"test\"\n    ? console[method]\n    : /* istanbul ignore next */\n      (title, message, ...args) =>\n        console[method](\n          `%cLiveblocks%c ${title}`,\n          badge,\n          bold,\n          message,\n          ...args\n        );\n}\n\n// export const logWithTitle = wrapWithTitle(\"log\");\nexport const warnWithTitle = wrapWithTitle(\"warn\");\nexport const errorWithTitle = wrapWithTitle(\"error\");\n","export function isDefined<T>(value: T): value is NonNullable<T> {\n  return value !== null && value !== undefined;\n}\n\nexport function isPlainObject(\n  blob: unknown\n): blob is { [key: string]: unknown } {\n  // Implementation borrowed from pojo decoder, see\n  // https://github.com/nvie/decoders/blob/78849f843193647eb6b5307240387bdcff7161fb/src/lib/objects.js#L10-L41\n  return (\n    blob !== null &&\n    typeof blob === \"object\" &&\n    Object.prototype.toString.call(blob) === \"[object Object]\"\n  );\n}\n\n/**\n * Check if value is of shape { startsWith: string }\n */\nexport function isStartsWithOperator(\n  blob: unknown\n): blob is { startsWith: string } {\n  return isPlainObject(blob) && typeof blob.startsWith === \"string\";\n}\n\nexport function isNumberOperator(\n  blob: unknown\n): blob is { lt?: number; gt?: number; lte?: number; gte?: number } {\n  return (\n    isPlainObject(blob) &&\n    (typeof blob.lt === \"number\" ||\n      typeof blob.gt === \"number\" ||\n      typeof blob.lte === \"number\" ||\n      typeof blob.gte === \"number\")\n  );\n}\n","import * as console from \"./fancy-console\";\nimport { isPlainObject } from \"./guards\";\nimport type { JsonObject } from \"./Json\";\nimport { tryParseJson, wait } from \"./utils\";\n\nexport class HttpError extends Error {\n  public response: Response;\n  public details?: JsonObject;\n\n  private constructor(\n    message: string,\n    response: Response,\n    details?: JsonObject\n  ) {\n    super(message);\n    this.name = \"HttpError\";\n    this.response = response;\n    this.details = details;\n  }\n\n  static async fromResponse(response: Response): Promise<HttpError> {\n    // Try to extract `message` and `details` from the response, and\n    // construct the HttpError instance\n    let bodyAsText: string | undefined;\n    try {\n      bodyAsText = await response.text();\n    } catch {\n      // Ignore\n    }\n\n    const bodyAsJson = bodyAsText ? tryParseJson(bodyAsText) : undefined;\n\n    let bodyAsJsonObject: JsonObject | undefined;\n    if (isPlainObject(bodyAsJson)) {\n      bodyAsJsonObject = bodyAsJson;\n    }\n\n    let message = \"\";\n    message ||=\n      typeof bodyAsJsonObject?.message === \"string\"\n        ? bodyAsJsonObject.message\n        : \"\";\n    message ||=\n      typeof bodyAsJsonObject?.error === \"string\" ? bodyAsJsonObject.error : \"\";\n    if (bodyAsJson === undefined) {\n      message ||= bodyAsText || \"\";\n    }\n    message ||= response.statusText;\n\n    let path: string | undefined;\n    try {\n      path = new URL(response.url).pathname;\n    } catch {\n      // Ignore\n    }\n    message +=\n      path !== undefined\n        ? ` (got status ${response.status} from ${path})`\n        : ` (got status ${response.status})`;\n\n    const details = bodyAsJsonObject;\n    return new HttpError(message, response, details);\n  }\n\n  /**\n   * Convenience accessor for response.status.\n   */\n  get status(): number {\n    return this.response.status;\n  }\n}\n\nconst DONT_RETRY_4XX = (x: unknown) =>\n  x instanceof HttpError && x.status >= 400 && x.status < 500;\n\n/**\n * Wraps a promise factory. Will create promises until one succeeds. If\n * a promise rejects, it will retry calling the factory for at most `maxTries`\n * times. Between each attempt, it will inject a a backoff delay (in millis)\n * from the given array. If the array contains fewer items then `maxTries`,\n * then the last backoff number will be used indefinitely.\n *\n * If the last attempt is rejected too, the returned promise will fail too.\n *\n * @param promiseFn The promise factory to execute\n * @param maxTries The number of total tries (must be >=1)\n * @param backoff An array of timings to inject between each promise attempt\n * @param shouldStopRetrying An optional function to not auto-retry on certain errors\n */\nexport async function autoRetry<T>(\n  promiseFn: () => Promise<T>,\n  maxTries: number,\n  backoff: number[],\n  shouldStopRetrying: (err: any) => boolean = DONT_RETRY_4XX\n): Promise<T> {\n  const fallbackBackoff = backoff.length > 0 ? backoff[backoff.length - 1] : 0;\n\n  let attempt = 0;\n\n  while (true) {\n    attempt++;\n\n    try {\n      return await promiseFn();\n    } catch (err) {\n      if (shouldStopRetrying(err)) {\n        throw err;\n      }\n\n      if (attempt >= maxTries) {\n        // Fail the entire promise right now\n        throw new Error(`Failed after ${maxTries} attempts: ${String(err)}`);\n      }\n    }\n\n    // Do another retry\n    const delay = backoff[attempt - 1] ?? fallbackBackoff;\n\n    console.warn(\n      `Attempt ${attempt} was unsuccessful. Retrying in ${delay} milliseconds.`\n    );\n    await wait(delay);\n  }\n}\n","export type ControlledPromise<T> = {\n  promise: Promise<T>;\n  resolve: (value: T) => void;\n  reject: (reason: unknown) => void;\n};\n\n/**\n * Returns a pair of a Promise, and a resolve function that can be passed\n * around to resolve the promise \"from anywhere\".\n *\n * The Promise will remain unresolved, until the resolve function is called.\n * Once the resolve function is called with a value, the Promise will resolve\n * to that value.\n *\n * Calling the resolve function beyond the first time is a no-op.\n */\nexport function controlledPromise<T>(): [\n  promise: Promise<T>,\n  resolve: (value: T) => void,\n  reject: (reason: unknown) => void,\n] {\n  let resolve: ((value: T) => void) | undefined;\n  let reject: ((reason: unknown) => void) | undefined;\n  const promise = new Promise<T>((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n  // eslint-disable-next-line no-restricted-syntax\n  return [promise, resolve!, reject!];\n}\n\n/**\n * Drop-in replacement for the ES2024 Promise.withResolvers() API.\n */\nexport function Promise_withResolvers<T>(): ControlledPromise<T> {\n  const [promise, resolve, reject] = controlledPromise<T>();\n  return { promise, resolve, reject };\n}\n","/* eslint-disable @typescript-eslint/no-unsafe-member-access */\n/* eslint-disable @typescript-eslint/no-unsafe-assignment */\n/* eslint-disable @typescript-eslint/no-unsafe-argument */\n\nfunction replacer(_key: string, value: unknown) {\n  return value !== null && typeof value === \"object\" && !Array.isArray(value)\n    ? Object.keys(value)\n        .sort()\n        .reduce((sorted, key) => {\n          // @ts-expect-error this is fine\n          sorted[key] = value[key];\n          return sorted;\n        }, {})\n    : value;\n}\n\n/**\n * Like JSON.stringify(), but using stable (sorted) object key order, so that\n * it returns the same value for the same keys, no matter their order.\n */\nexport function stableStringify(value: unknown): string {\n  return JSON.stringify(value, replacer);\n}\n\n/**\n * Drop-in replacement for JSON.stringify(), which will log any payload to the\n * console if it could not be stringified somehow.\n */\nexport function stringifyOrLog(value: unknown): string {\n  try {\n    return JSON.stringify(value);\n  } catch (err) {\n    /* eslint-disable rulesdir/console-must-be-fancy */\n    console.error(`Could not stringify: ${(err as Error).message}`);\n    console.error(value);\n    /* eslint-enable rulesdir/console-must-be-fancy */\n    throw err;\n  }\n}\n","import type { AsyncResult } from \"./AsyncResult\";\nimport { Promise_withResolvers } from \"./controlledPromise\";\nimport type { Callback, UnsubscribeCallback } from \"./EventSource\";\nimport { MutableSignal } from \"./signals\";\nimport { stableStringify } from \"./stringify\";\n\nconst DEFAULT_SIZE = 50;\n\ntype Resolve<T> = (value: T) => void;\ntype Reject = (reason?: unknown) => void;\n\nexport type BatchCallback<O, I> = (\n  inputs: I[]\n) => (O | Error)[] | Promise<(O | Error)[]>;\n\nexport type BatchStore<O, I> = {\n  subscribe: (callback: Callback<void>) => UnsubscribeCallback;\n  enqueue: (input: I) => Promise<void>;\n  setData: (entries: [I, O][]) => void;\n  getItemState: (input: I) => AsyncResult<O> | undefined;\n  getData: (input: I) => O | undefined;\n  invalidate: (inputs?: I[]) => void;\n\n  /**\n   * @internal\n   */\n  readonly batch: Batch<O, I>;\n\n  /**\n   * @internal\n   *\n   * Only for testing.\n   */\n  _cacheKeys: () => string[];\n};\n\ninterface BatchOptions {\n  /**\n   * How many calls to batch together at most.\n   */\n  size?: number;\n\n  /**\n   * How long to wait before flushing the batch.\n   */\n  delay: number;\n}\n\nclass BatchCall<O, I> {\n  readonly input: I;\n  readonly resolve: Resolve<O>;\n  readonly reject: Reject;\n  readonly promise: Promise<O>;\n\n  constructor(input: I) {\n    this.input = input;\n\n    const { promise, resolve, reject } = Promise_withResolvers<O>();\n    this.promise = promise;\n    this.resolve = resolve;\n    this.reject = reject;\n  }\n}\n\n/**\n * Batch calls to a function, either by number of calls or by a maximum delay.\n */\nexport class Batch<O, I> {\n  #queue: BatchCall<O, I>[] = [];\n  #callback: BatchCallback<O, I>;\n  #size: number;\n  #delay: number;\n  #delayTimeoutId?: ReturnType<typeof setTimeout>;\n  public error = false;\n\n  constructor(callback: BatchCallback<O, I>, options: BatchOptions) {\n    this.#callback = callback;\n    this.#size = options.size ?? DEFAULT_SIZE;\n    this.#delay = options.delay;\n  }\n\n  #clearDelayTimeout(): void {\n    if (this.#delayTimeoutId !== undefined) {\n      clearTimeout(this.#delayTimeoutId);\n      this.#delayTimeoutId = undefined;\n    }\n  }\n\n  #schedule() {\n    if (this.#queue.length === this.#size) {\n      // If the queue is full, flush it immediately.\n      void this.#flush();\n    } else if (this.#queue.length === 1) {\n      // If the call is the first in the queue, schedule a flush.\n      this.#clearDelayTimeout();\n      this.#delayTimeoutId = setTimeout(() => void this.#flush(), this.#delay);\n    }\n  }\n\n  async #flush(): Promise<void> {\n    // If the queue is empty, don't call the callback.\n    if (this.#queue.length === 0) {\n      return;\n    }\n\n    // Empty the queue and get its calls.\n    const calls = this.#queue.splice(0);\n    const inputs = calls.map((call) => call.input);\n\n    try {\n      // Call the batch callback with the queued arguments.\n      const results = await this.#callback(inputs);\n      this.error = false;\n\n      // Resolve or reject each call.\n      calls.forEach((call, index) => {\n        const result = results?.[index];\n\n        if (!Array.isArray(results)) {\n          call.reject(new Error(\"Callback must return an array.\"));\n        } else if (calls.length !== results.length) {\n          call.reject(\n            new Error(\n              `Callback must return an array of the same length as the number of provided items. Expected ${calls.length}, but got ${results.length}.`\n            )\n          );\n        } else if (result instanceof Error) {\n          call.reject(result);\n        } else {\n          call.resolve(result);\n        }\n      });\n    } catch (error) {\n      this.error = true;\n\n      // Reject all calls if the whole batch errored or was rejected.\n      calls.forEach((call) => {\n        call.reject(error);\n      });\n    }\n  }\n\n  get(input: I): Promise<O> {\n    // Check if there's already an identical call in the queue.\n    const existingCall = this.#queue.find(\n      (call) => stableStringify(call.input) === stableStringify(input)\n    );\n\n    // If an existing call exists, return its promise.\n    if (existingCall) {\n      return existingCall.promise;\n    }\n\n    // If no existing call exists, add the call to the queue and schedule a flush.\n    const call = new BatchCall<O, I>(input);\n    this.#queue.push(call);\n    this.#schedule();\n\n    return call.promise;\n  }\n\n  clear(): void {\n    this.#queue = [];\n    this.error = false;\n    this.#clearDelayTimeout();\n  }\n}\n\n/**\n * Create a store around a Batch.\n * Each call will be cached and get its own state in addition to being batched.\n */\nexport function createBatchStore<O, I>(batch: Batch<O, I>): BatchStore<O, I> {\n  const signal = new MutableSignal(new Map<string, AsyncResult<O>>());\n\n  function getCacheKey(args: I): string {\n    return stableStringify(args);\n  }\n\n  function update(\n    entryOrEntries:\n      | {\n          key: string;\n          state: AsyncResult<O>;\n        }\n      | {\n          key: string;\n          state: AsyncResult<O>;\n        }[]\n  ) {\n    signal.mutate((cache) => {\n      if (Array.isArray(entryOrEntries)) {\n        for (const entry of entryOrEntries) {\n          cache.set(entry.key, entry.state);\n        }\n      } else {\n        cache.set(entryOrEntries.key, entryOrEntries.state);\n      }\n    });\n  }\n\n  function invalidate(inputs?: I[]): void {\n    signal.mutate((cache) => {\n      if (Array.isArray(inputs)) {\n        // Invalidate the specific calls.\n        for (const input of inputs) {\n          cache.delete(getCacheKey(input));\n        }\n      } else {\n        // Invalidate all calls.\n        cache.clear();\n      }\n    });\n  }\n\n  async function enqueue(input: I): Promise<void> {\n    const cacheKey = getCacheKey(input);\n\n    // If this call already has a state, return early.\n    const cache = signal.get();\n    if (cache.has(cacheKey)) {\n      return;\n    }\n\n    try {\n      // Set the state to loading.\n      update({ key: cacheKey, state: { isLoading: true } });\n\n      // Wait for the batch to process this call.\n      const result = await batch.get(input);\n\n      // Set the state to the result.\n      update({ key: cacheKey, state: { isLoading: false, data: result } });\n    } catch (error) {\n      // // TODO: Differentiate whole batch errors from individual errors.\n      // if (batch.error) {\n      //   // If the whole batch errored, clear the state.\n      //   // TODO: Keep track of retries and only clear the state a few times because it will be retried each time.\n      //   //       Also implement exponential backoff to delay retries to avoid hammering `resolveUsers`.\n      //   update(cacheKey, undefined);\n      // } else {\n      //   // Otherwise, keep individual errors to avoid repeatedly loading the same error.\n      //   update(cacheKey, {\n      //     isLoading: false,\n      //     error: error as Error,\n      //   });\n      // }\n\n      // If there was an error (for various reasons), set the state to the error.\n      update({\n        key: cacheKey,\n        state: { isLoading: false, error: error as Error },\n      });\n    }\n  }\n\n  function setData(entries: [I, O][]): void {\n    update(\n      entries.map((entry) => ({\n        key: getCacheKey(entry[0]),\n        state: { isLoading: false, data: entry[1] },\n      }))\n    );\n  }\n\n  function getItemState(input: I): AsyncResult<O> | undefined {\n    const cacheKey = getCacheKey(input);\n    const cache = signal.get();\n    return cache.get(cacheKey);\n  }\n\n  function getData(input: I): O | undefined {\n    const cacheKey = getCacheKey(input);\n    const cache = signal.get();\n    return cache.get(cacheKey)?.data;\n  }\n\n  /** @internal - Only for testing */\n  function _cacheKeys() {\n    const cache = signal.get();\n    return [...cache.keys()];\n  }\n\n  return {\n    subscribe: signal.subscribe,\n    enqueue,\n    setData,\n    getItemState,\n    getData,\n    invalidate,\n\n    batch,\n    _cacheKeys,\n  };\n}\n","export function chunk<T>(array: T[], size: number): T[][] {\n  const chunks: T[][] = [];\n\n  for (let i = 0, j = array.length; i < j; i += size) {\n    chunks.push(array.slice(i, i + size));\n  }\n\n  return chunks;\n}\n","// Inlined version of 3.3.7 of nanoid.js\n// https://www.npmjs.com/package/nanoid/v/3.3.7?activeTab=code\nexport const nanoid = (t = 21): string =>\n  crypto\n    .getRandomValues(new Uint8Array(t))\n    .reduce(\n      (t, e) =>\n        (t +=\n          (e &= 63) < 36\n            ? e.toString(36)\n            : e < 62\n              ? (e - 26).toString(36).toUpperCase()\n              : e < 63\n                ? \"_\"\n                : \"-\"),\n      \"\"\n    );\n","import { nanoid } from \"./nanoid\";\n\nconst THREAD_ID_PREFIX = \"th\";\nconst COMMENT_ID_PREFIX = \"cm\";\nconst COMMENT_ATTACHMENT_ID_PREFIX = \"at\";\nconst INBOX_NOTIFICATION_ID_PREFIX = \"in\";\n\nfunction createOptimisticId(prefix: string): string {\n  return `${prefix}_${nanoid()}`;\n}\n\nexport function createThreadId(): string {\n  return createOptimisticId(THREAD_ID_PREFIX);\n}\n\nexport function createCommentId(): string {\n  return createOptimisticId(COMMENT_ID_PREFIX);\n}\n\nexport function createCommentAttachmentId(): string {\n  return createOptimisticId(COMMENT_ATTACHMENT_ID_PREFIX);\n}\n\nexport function createInboxNotificationId(): string {\n  return createOptimisticId(INBOX_NOTIFICATION_ID_PREFIX);\n}\n","import { raise } from \"./utils\";\n\n/**\n * Like ES6 map, but takes a default (factory) function which will be used\n * to create entries for missing keys on the fly.\n *\n * Useful for code like:\n *\n *   const map = new DefaultMap(() => []);\n *   map.getOrCreate('foo').push('hello');\n *   map.getOrCreate('foo').push('world');\n *   map.getOrCreate('foo')\n *   // ['hello', 'world']\n *\n */\nexport class DefaultMap<K, V> extends Map<K, V> {\n  #defaultFn?: (key: K) => V;\n\n  /**\n   * If the default function is not provided to the constructor, it has to be\n   * provided in each .getOrCreate() call individually.\n   */\n  constructor(\n    defaultFn?: (key: K) => V,\n    entries?: readonly (readonly [K, V])[] | null\n  ) {\n    super(entries);\n    this.#defaultFn = defaultFn;\n  }\n\n  /**\n   * Gets the value at the given key, or creates it.\n   *\n   * Difference from normal Map: if the key does not exist, it will be created\n   * on the fly using the factory function, and that value will get returned\n   * instead of `undefined`.\n   */\n  getOrCreate(key: K, defaultFn?: (key: K) => V): V {\n    if (super.has(key)) {\n      // eslint-disable-next-line no-restricted-syntax\n      return super.get(key)!;\n    } else {\n      const fn =\n        defaultFn ??\n        this.#defaultFn ??\n        raise(\"DefaultMap used without a factory function\");\n\n      const value = fn(key);\n      this.set(key, value);\n      return value;\n    }\n  }\n}\n","import {\n  isNumberOperator,\n  isPlainObject,\n  isStartsWithOperator,\n} from \"./guards\";\n\n/**\n * Converts an object to a query string\n * Example:\n * ```ts\n * const query = objectToQuery({\n *   resolved: true,\n *   subscribed: true,\n *   metadata: {\n *     status: \"open\",\n *     priority: 3,\n *     org: {\n *       startsWith: \"liveblocks:\",\n *     },\n *     posX: {\n *       gt: 100,\n *       lt: 200,\n *     },\n *     posY: {\n *       gte: 50,\n *       lte: 300,\n *     },\n *   },\n * });\n *\n * console.log(query);\n * // resolved:true AND subscribed:true AND metadata[\"status\"]:open AND metadata[\"priority\"]:3 AND metadata[\"org\"]^\"liveblocks:\" AND metadata[\"posX\"]>100 AND metadata[\"posX\"]<200 AND metadata[\"posY\"]>=50 AND metadata[\"posY\"]<=300\n * ```\n */\ntype SimpleFilterValue = string | number | boolean | null;\ntype OperatorFilterValue =\n  | { startsWith: string; gt?: never; lt?: never; gte?: never; lte?: never }\n  | {\n      lt?: number;\n      gt?: number;\n      lte?: number;\n      gte?: number;\n      startsWith?: never;\n    };\n\ntype FilterValue = SimpleFilterValue | OperatorFilterValue;\n\ntype Filter = NumberFilter | StringFilter | BooleanFilter | NullFilter;\n\ntype NumberFilter = {\n  key: string;\n  operator: \":\" | \"<\" | \">\" | \"<=\" | \">=\";\n  value: number;\n};\n\ntype StringFilter = {\n  key: string;\n  operator: \":\" | \"^\";\n  value: string;\n};\n\ntype BooleanFilter = {\n  key: string;\n  operator: \":\";\n  value: boolean;\n};\n\ntype NullFilter = {\n  key: string;\n  operator: \":\";\n  value: null;\n};\n\n/**\n * Converts an object to a query string\n * @example\n * ```ts\n * const query = objectToQuery({\n *  metadata: {\n *    status: \"open\",\n *    priority: 3,\n *    org: {\n *      startsWith: \"liveblocks:\",\n *    },\n *  },\n * });\n * console.log(query);\n * // metadata[\"status\"]:\"open\" AND metadata[\"priority\"]:3 AND metadata[\"org\"]^\"liveblocks:\"\n * ```\n * @example\n * ```ts\n * const query = objectToQuery({\n *  resolved: true,\n *  subscribed: true,\n *  roomId: {\n *   startsWith: \"engineering:\",\n *  },\n * });\n * console.log(query);\n * // resolved:true AND subscribed:true AND roomId^\"engineering:\"\n * ```\n *\n */\n\nconst identifierRegex = /^[a-zA-Z_][a-zA-Z0-9_]*$/;\n\nexport function objectToQuery(obj: {\n  [key: string]:\n    | FilterValue\n    | { [key: string]: FilterValue | undefined }\n    | undefined;\n}): string {\n  let filterList: Filter[] = [];\n  const entries = Object.entries(obj);\n\n  const keyValuePairs: [string, string | number | boolean | null][] = [];\n  const keyValuePairsWithOperator: [string, OperatorFilterValue][] = [];\n  const indexedKeys: [string, Record<string, FilterValue | undefined>][] = [];\n\n  entries.forEach(([key, value]) => {\n    if (!identifierRegex.test(key)) {\n      throw new Error(\"Key must only contain letters, numbers, _\");\n    }\n\n    if (isSimpleValue(value)) {\n      keyValuePairs.push([key, value]);\n    } else if (isPlainObject(value)) {\n      if (isStartsWithOperator(value) || isNumberOperator(value)) {\n        keyValuePairsWithOperator.push([key, value]);\n      } else {\n        indexedKeys.push([key, value]);\n      }\n    }\n  });\n\n  filterList = [\n    ...getFiltersFromKeyValuePairs(keyValuePairs),\n    ...getFiltersFromKeyValuePairsWithOperator(keyValuePairsWithOperator),\n  ];\n\n  indexedKeys.forEach(([key, value]) => {\n    const nestedEntries = Object.entries(value);\n    const nKeyValuePairs: [string, SimpleFilterValue][] = [];\n    const nKeyValuePairsWithOperator: [string, OperatorFilterValue][] = [];\n    nestedEntries.forEach(([nestedKey, nestedValue]) => {\n      if (isStringEmpty(nestedKey)) {\n        throw new Error(\"Key cannot be empty\");\n      }\n\n      if (isSimpleValue(nestedValue)) {\n        nKeyValuePairs.push([formatFilterKey(key, nestedKey), nestedValue]);\n      } else if (\n        isStartsWithOperator(nestedValue) ||\n        isNumberOperator(nestedValue)\n      ) {\n        nKeyValuePairsWithOperator.push([\n          formatFilterKey(key, nestedKey),\n          nestedValue,\n        ]);\n      }\n    });\n    filterList = [\n      ...filterList,\n      ...getFiltersFromKeyValuePairs(nKeyValuePairs),\n      ...getFiltersFromKeyValuePairsWithOperator(nKeyValuePairsWithOperator),\n    ];\n  });\n\n  return filterList\n    .map(({ key, operator, value }) => `${key}${operator}${quote(value)}`)\n    .join(\" \");\n}\n\nconst getFiltersFromKeyValuePairs = (\n  keyValuePairs: [string, string | number | boolean | null][]\n): Filter[] => {\n  const filters: Filter[] = [];\n  keyValuePairs.forEach(([key, value]) => {\n    filters.push({\n      key,\n      operator: \":\",\n      value,\n    });\n  });\n\n  return filters;\n};\n\nconst getFiltersFromKeyValuePairsWithOperator = (\n  keyValuePairsWithOperator: [string, OperatorFilterValue][]\n): Filter[] => {\n  const filters: Filter[] = [];\n  keyValuePairsWithOperator.forEach(([key, value]) => {\n    if (\"startsWith\" in value && typeof value.startsWith === \"string\") {\n      filters.push({\n        key,\n        operator: \"^\",\n        value: value.startsWith,\n      });\n    }\n    if (\"lt\" in value && typeof value.lt === \"number\") {\n      filters.push({\n        key,\n        operator: \"<\",\n        value: value.lt,\n      });\n    }\n    if (\"gt\" in value && typeof value.gt === \"number\") {\n      filters.push({\n        key,\n        operator: \">\",\n        value: value.gt,\n      });\n    }\n    if (\"gte\" in value && typeof value.gte === \"number\") {\n      filters.push({\n        key,\n        operator: \">=\",\n        value: value.gte,\n      });\n    }\n    if (\"lte\" in value && typeof value.lte === \"number\") {\n      filters.push({\n        key,\n        operator: \"<=\",\n        value: value.lte,\n      });\n    }\n  });\n\n  return filters;\n};\n\nconst isSimpleValue = (value: unknown) => {\n  return (\n    typeof value === \"string\" ||\n    typeof value === \"number\" ||\n    typeof value === \"boolean\" ||\n    value === null\n  );\n};\n\nconst formatFilterKey = (key: string, nestedKey?: string) => {\n  if (nestedKey) {\n    return `${key}[${quote(nestedKey)}]`;\n  }\n  return key;\n};\n\nconst isStringEmpty = (value: string) => {\n  return !value || value.toString().trim() === \"\";\n};\n\n/**\n * Quotes and escapes a string. Prefer to use single quotes when possible, but\n * falls back to JSON.stringify() (which uses double-quotes) when necessary.\n */\nexport function quote(input: unknown): string {\n  const result = JSON.stringify(input);\n  if (typeof input !== \"string\") {\n    return result;\n  }\n\n  if (result.includes(\"'\")) {\n    return result;\n  }\n\n  // See if we can turn this string into a single-quoted string, because those\n  // generally are more readable in URLs\n  return `'${result.slice(1, -1).replace(/\\\\\"/g, '\"')}'`;\n}\n","import type { Brand } from \"./utils\";\n\nconst PLACEHOLDER_BASE_URL = \"https://localhost:9999\";\nconst ABSOLUTE_URL_REGEX = /^[a-zA-Z][a-zA-Z\\d+\\-.]*?:/;\nconst TRAILING_SLASH_URL_REGEX = /\\/(?:(?:\\?|#).*)?$/;\n\nexport type QueryParams =\n  | Record<string, string | number | null | undefined>\n  | URLSearchParams;\n\n/**\n * Safely but conveniently build a URLSearchParams instance from a given\n * dictionary of values. For example:\n *\n *   {\n *     \"foo\": \"bar+qux/baz\",\n *     \"empty\": \"\",\n *     \"n\": 42,\n *     \"nope\": undefined,\n *     \"alsonope\": null,\n *   }\n *\n * Will produce a value that will get serialized as\n * `foo=bar%2Bqux%2Fbaz&empty=&n=42`.\n *\n * Notice how the number is converted to its string representation\n * automatically and the `null`/`undefined` values simply don't end up in the\n * URL.\n */\nfunction toURLSearchParams(\n  params: Record<string, string | number | null | undefined>\n): URLSearchParams {\n  const result = new URLSearchParams();\n  for (const [key, value] of Object.entries(params)) {\n    if (value !== undefined && value !== null) {\n      result.set(key, value.toString());\n    }\n  }\n  return result;\n}\n\n/**\n * Concatenates a path to an existing URL.\n */\nexport function urljoin(\n  baseUrl: string | URL,\n  path: string,\n  params?: QueryParams\n): string {\n  // First, sanitize by removing user/passwd/search/hash parts from the URL\n  const url = new URL(path, baseUrl);\n  if (params !== undefined) {\n    url.search = (\n      params instanceof URLSearchParams ? params : toURLSearchParams(params)\n    ).toString();\n  }\n  return url.toString();\n}\n\n/**\n * A string that is guaranteed to be URL safe (where all arguments are properly\n * encoded), only obtainable as the result of using `url` template strings.\n */\nexport type URLSafeString = Brand<string, \"URLSafeString\">;\n\n/**\n * Builds a URL where each \"hole\" in the template string will automatically be\n * encodeURIComponent()-escaped, so it's impossible to build invalid URLs.\n */\nexport function url(\n  strings: TemplateStringsArray,\n  ...values: string[]\n): URLSafeString {\n  return strings.reduce(\n    (result, str, i) => result + encodeURIComponent(values[i - 1] ?? \"\") + str\n  ) as URLSafeString;\n}\n\n/**\n * Sanitize a URL (normalize www URLs, handle relative URLs, prevent XSS attacks, etc.)\n *\n * Accepted URLs:\n * - Absolute URLs with an http or https protocol (e.g. https://liveblocks.io)\n * - Absolute URLs with a `www` prefix (e.g. www.liveblocks.io)\n * - Relative URLs (e.g. /path/to/page)\n * - Hash-only URLs (e.g. #hash)\n *\n * The presence/absence of trailing slashes is preserved.\n * Rejected URLs are returned as `null`.\n */\nexport function sanitizeUrl(url: string): string | null {\n  // If the URL starts with \"www.\", normalize it as an HTTPS URL\n  if (url.startsWith(\"www.\")) {\n    url = \"https://\" + url;\n  }\n\n  // If the URL is an empty hash, return it as is.\n  if (url === \"#\") {\n    return url;\n  }\n\n  try {\n    const isAbsolute = ABSOLUTE_URL_REGEX.test(url);\n    const urlObject = new URL(\n      url,\n      isAbsolute ? undefined : PLACEHOLDER_BASE_URL\n    );\n\n    if (urlObject.protocol !== \"http:\" && urlObject.protocol !== \"https:\") {\n      return null;\n    }\n\n    const hasTrailingSlash = TRAILING_SLASH_URL_REGEX.test(url);\n\n    // Instead of using URL.toString(), we rebuild the URL manually\n    // to preserve the presence/absence of trailing slashes.\n    const sanitizedUrl =\n      // 1. Origin, only for absolute URLs\n      (isAbsolute ? urlObject.origin : \"\") +\n      // 2. Pathname, with a trailing slash if the original URL had one\n      (urlObject.pathname === \"/\"\n        ? // 2.a. Domain-only URLs, they always have their pathname set to \"/\"\n          hasTrailingSlash\n          ? \"/\"\n          : \"\"\n        : // 2.b. URLs with a path\n          hasTrailingSlash && !urlObject.pathname.endsWith(\"/\")\n          ? urlObject.pathname + \"/\"\n          : urlObject.pathname) +\n      // 3. Search params\n      urlObject.search +\n      // 4. Hash\n      urlObject.hash;\n\n    return sanitizedUrl !== \"\" ? sanitizedUrl : null;\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Construct a URL with optional parameters and hash.\n */\nexport function generateUrl(\n  url: string,\n  params?: Record<string, string | number | undefined>,\n  hash?: string\n): string {\n  const isAbsolute = ABSOLUTE_URL_REGEX.test(url);\n  const urlObject = new URL(url, isAbsolute ? undefined : PLACEHOLDER_BASE_URL);\n\n  if (params !== undefined) {\n    for (const [param, value] of Object.entries(params)) {\n      if (value) {\n        urlObject.searchParams.set(param, String(value));\n      }\n    }\n  }\n\n  // Only add the new hash if the URL does not already have one\n  if (!urlObject.hash && hash !== undefined) {\n    urlObject.hash = `#${hash}`;\n  }\n\n  return isAbsolute\n    ? urlObject.href\n    : urlObject.href.replace(PLACEHOLDER_BASE_URL, \"\");\n}\n\nexport function isUrl(string: string): boolean {\n  try {\n    new URL(string);\n    return true;\n  } catch (_) {\n    return false;\n  }\n}\n","import type { AuthManager, AuthValue } from \"./auth-manager\";\nimport {\n  convertToCommentData,\n  convertToCommentUserReaction,\n  convertToGroupData,\n  convertToInboxNotificationData,\n  convertToInboxNotificationDeleteInfo,\n  convertToSubscriptionData,\n  convertToSubscriptionDeleteInfo,\n  convertToThreadData,\n  convertToThreadDeleteInfo,\n} from \"./convert-plain-data\";\nimport { assertNever } from \"./lib/assert\";\nimport { autoRetry, HttpError } from \"./lib/autoRetry\";\nimport type { BatchStore } from \"./lib/batch\";\nimport { Batch, createBatchStore } from \"./lib/batch\";\nimport { chunk } from \"./lib/chunk\";\nimport { createCommentId, createThreadId } from \"./lib/createIds\";\nimport type { DateToString } from \"./lib/DateToString\";\nimport { DefaultMap } from \"./lib/DefaultMap\";\nimport * as console from \"./lib/fancy-console\";\nimport type { JsonObject } from \"./lib/Json\";\nimport { objectToQuery } from \"./lib/objectToQuery\";\nimport type { Signal } from \"./lib/signals\";\nimport { stringifyOrLog as stringify } from \"./lib/stringify\";\nimport type { QueryParams, URLSafeString } from \"./lib/url\";\nimport { url, urljoin } from \"./lib/url\";\nimport { raise } from \"./lib/utils\";\nimport type {\n  ContextualPromptContext,\n  ContextualPromptResponse,\n} from \"./protocol/Ai\";\nimport type { Permission } from \"./protocol/AuthToken\";\nimport type {\n  BaseMetadata,\n  CommentAttachment,\n  CommentBody,\n  CommentData,\n  CommentDataPlain,\n  CommentLocalAttachment,\n  CommentUserReaction,\n  CommentUserReactionPlain,\n  QueryMetadata,\n  SearchCommentsResult,\n  ThreadData,\n  ThreadDataPlain,\n  ThreadDeleteInfo,\n  ThreadDeleteInfoPlain,\n} from \"./protocol/Comments\";\nimport type { GroupData, GroupDataPlain } from \"./protocol/Groups\";\nimport type {\n  InboxNotificationData,\n  InboxNotificationDataPlain,\n  InboxNotificationDeleteInfo,\n  InboxNotificationDeleteInfoPlain,\n} from \"./protocol/InboxNotifications\";\nimport type { MentionData } from \"./protocol/MentionData\";\nimport type {\n  NotificationSettingsPlain,\n  PartialNotificationSettings,\n} from \"./protocol/NotificationSettings\";\nimport type { RoomSubscriptionSettings } from \"./protocol/RoomSubscriptionSettings\";\nimport type { StorageNode } from \"./protocol/StorageNode\";\nimport type {\n  SubscriptionData,\n  SubscriptionDataPlain,\n  SubscriptionDeleteInfo,\n  SubscriptionDeleteInfoPlain,\n} from \"./protocol/Subscriptions\";\nimport type { UrlMetadata } from \"./protocol/UrlMetadata\";\nimport type { HistoryVersion } from \"./protocol/VersionHistory\";\nimport type { TextEditorType } from \"./types/Others\";\nimport type { Patchable } from \"./types/Patchable\";\nimport { PKG_VERSION } from \"./version\";\n\nexport interface RoomHttpApi<TM extends BaseMetadata, CM extends BaseMetadata> {\n  getThreads(options: {\n    roomId: string;\n    cursor?: string;\n    query?: {\n      resolved?: boolean;\n      subscribed?: boolean;\n      metadata?: Partial<QueryMetadata<TM>>;\n    };\n  }): Promise<{\n    threads: ThreadData<TM, CM>[];\n    inboxNotifications: InboxNotificationData[];\n    subscriptions: SubscriptionData[];\n    requestedAt: Date;\n    nextCursor: string | null;\n    permissionHints: Record<string, Permission[]>;\n  }>;\n\n  getThreadsSince(options: {\n    roomId: string;\n    since: Date;\n    signal?: AbortSignal;\n  }): Promise<{\n    threads: {\n      updated: ThreadData<TM, CM>[];\n      deleted: ThreadDeleteInfo[];\n    };\n    inboxNotifications: {\n      updated: InboxNotificationData[];\n      deleted: InboxNotificationDeleteInfo[];\n    };\n    subscriptions: {\n      updated: SubscriptionData[];\n      deleted: SubscriptionDeleteInfo[];\n    };\n    requestedAt: Date;\n    permissionHints: Record<string, Permission[]>;\n  }>;\n\n  searchComments(\n    options: {\n      roomId: string;\n      query: {\n        threadMetadata?: Partial<QueryMetadata<TM>>;\n        threadResolved?: boolean;\n        hasAttachments?: boolean;\n        hasMentions?: boolean;\n        text: string;\n      };\n    },\n    requestOptions?: {\n      signal?: AbortSignal;\n    }\n  ): Promise<{\n    data: Array<SearchCommentsResult>;\n  }>;\n\n  createThread({\n    roomId,\n    metadata,\n    body,\n    commentId,\n    threadId,\n    commentMetadata,\n    attachmentIds,\n  }: {\n    roomId: string;\n    threadId?: string;\n    commentId?: string;\n    metadata: TM | undefined;\n    commentMetadata: CM | undefined;\n    body: CommentBody;\n    attachmentIds?: string[];\n  }): Promise<ThreadData<TM, CM>>;\n\n  getThread(options: { roomId: string; threadId: string }): Promise<{\n    thread?: ThreadData<TM, CM>;\n    inboxNotification?: InboxNotificationData;\n    subscription?: SubscriptionData;\n  }>;\n\n  deleteThread({\n    roomId,\n    threadId,\n  }: {\n    roomId: string;\n    threadId: string;\n  }): Promise<void>;\n\n  editThreadMetadata({\n    roomId,\n    metadata,\n    threadId,\n  }: {\n    roomId: string;\n    metadata: Patchable<TM>;\n    threadId: string;\n  }): Promise<TM>;\n\n  editCommentMetadata({\n    roomId,\n    threadId,\n    commentId,\n    metadata,\n  }: {\n    roomId: string;\n    threadId: string;\n    commentId: string;\n    metadata: Patchable<CM>;\n  }): Promise<CM>;\n\n  createComment({\n    roomId,\n    threadId,\n    commentId,\n    body,\n    metadata,\n    attachmentIds,\n  }: {\n    roomId: string;\n    threadId: string;\n    commentId?: string;\n    body: CommentBody;\n    metadata?: CM;\n    attachmentIds?: string[];\n  }): Promise<CommentData<CM>>;\n\n  editComment({\n    roomId,\n    threadId,\n    commentId,\n    body,\n    attachmentIds,\n    metadata,\n  }: {\n    roomId: string;\n    threadId: string;\n    commentId: string;\n    body: CommentBody;\n    attachmentIds?: string[];\n    metadata?: Patchable<CM>;\n  }): Promise<CommentData<CM>>;\n\n  deleteComment({\n    roomId,\n    threadId,\n    commentId,\n  }: {\n    roomId: string;\n    threadId: string;\n    commentId: string;\n  }): Promise<void>;\n\n  addReaction({\n    roomId,\n    threadId,\n    commentId,\n    emoji,\n  }: {\n    roomId: string;\n    threadId: string;\n    commentId: string;\n    emoji: string;\n  }): Promise<CommentUserReaction>;\n\n  removeReaction({\n    roomId,\n    threadId,\n    commentId,\n    emoji,\n  }: {\n    roomId: string;\n    threadId: string;\n    commentId: string;\n    emoji: string;\n  }): Promise<void>;\n\n  markThreadAsResolved({\n    roomId,\n    threadId,\n  }: {\n    roomId: string;\n    threadId: string;\n  }): Promise<void>;\n\n  markThreadAsUnresolved({\n    roomId,\n    threadId,\n  }: {\n    roomId: string;\n    threadId: string;\n  }): Promise<void>;\n\n  subscribeToThread({\n    roomId,\n    threadId,\n  }: {\n    roomId: string;\n    threadId: string;\n  }): Promise<SubscriptionData>;\n\n  unsubscribeFromThread({\n    roomId,\n    threadId,\n  }: {\n    roomId: string;\n    threadId: string;\n  }): Promise<void>;\n\n  // Notifications\n  markRoomInboxNotificationAsRead({\n    roomId,\n    inboxNotificationId,\n  }: {\n    roomId: string;\n    inboxNotificationId: string;\n  }): Promise<string>;\n\n  getSubscriptionSettings({\n    roomId,\n    signal,\n  }: {\n    roomId: string;\n    signal?: AbortSignal;\n  }): Promise<RoomSubscriptionSettings>;\n\n  updateSubscriptionSettings({\n    roomId,\n    settings,\n  }: {\n    roomId: string;\n    settings: Partial<RoomSubscriptionSettings>;\n  }): Promise<RoomSubscriptionSettings>;\n\n  // Attachments\n  getAttachmentUrl(options: {\n    roomId: string;\n    attachmentId: string;\n  }): Promise<string>;\n\n  uploadAttachment({\n    roomId,\n    attachment,\n    signal,\n  }: {\n    roomId: string;\n    attachment: CommentLocalAttachment;\n    signal?: AbortSignal;\n  }): Promise<CommentAttachment>;\n\n  getOrCreateAttachmentUrlsStore(roomId: string): BatchStore<string, string>;\n\n  uploadChatAttachment({\n    chatId,\n    attachment,\n    signal,\n  }: {\n    chatId: string;\n    attachment: { id: string; file: File };\n    signal?: AbortSignal;\n  }): Promise<void>;\n\n  getOrCreateChatAttachmentUrlsStore(\n    chatId: string\n  ): BatchStore<string, string>;\n  getChatAttachmentUrl(options: { attachmentId: string }): Promise<string>;\n\n  // Text editor\n  createTextMention({\n    roomId,\n    mentionId,\n    mention,\n  }: {\n    roomId: string;\n    mentionId: string;\n    mention: MentionData;\n  }): Promise<void>;\n\n  deleteTextMention({\n    roomId,\n    mentionId,\n  }: {\n    roomId: string;\n    mentionId: string;\n  }): Promise<void>;\n\n  getTextVersion({\n    roomId,\n    versionId,\n  }: {\n    roomId: string;\n    versionId: string;\n  }): Promise<Response>;\n\n  createTextVersion({ roomId }: { roomId: string }): Promise<void>;\n\n  reportTextEditor({\n    roomId,\n    type,\n    rootKey,\n  }: {\n    roomId: string;\n    type: TextEditorType;\n    rootKey: string;\n  }): Promise<void>;\n\n  listTextVersions({ roomId }: { roomId: string }): Promise<{\n    versions: {\n      type: \"historyVersion\";\n      kind: \"yjs\";\n      id: string;\n      authors: {\n        id: string;\n      }[];\n      createdAt: Date;\n    }[];\n    requestedAt: Date;\n  }>;\n\n  listTextVersionsSince({\n    roomId,\n    since,\n    signal,\n  }: {\n    roomId: string;\n    since: Date;\n    signal?: AbortSignal;\n  }): Promise<{\n    versions: {\n      type: \"historyVersion\";\n      kind: \"yjs\";\n      id: string;\n      authors: {\n        id: string;\n      }[];\n      createdAt: Date;\n    }[];\n    requestedAt: Date;\n  }>;\n\n  streamStorage(options: { roomId: string }): Promise<StorageNode[]>;\n\n  executeContextualPrompt({\n    roomId,\n    prompt,\n    context,\n    signal,\n  }: {\n    roomId: string;\n    prompt: string;\n    context: ContextualPromptContext;\n    previous?: {\n      prompt: string;\n      response: ContextualPromptResponse;\n    };\n    signal: AbortSignal;\n  }): Promise<string>;\n}\n\nexport interface NotificationHttpApi<\n  TM extends BaseMetadata,\n  CM extends BaseMetadata,\n> {\n  getInboxNotifications(options?: {\n    cursor?: string;\n    query?: { roomId?: string; kind?: string };\n  }): Promise<{\n    inboxNotifications: InboxNotificationData[];\n    threads: ThreadData<TM, CM>[];\n    subscriptions: SubscriptionData[];\n    nextCursor: string | null;\n    requestedAt: Date;\n  }>;\n\n  getInboxNotificationsSince(options: {\n    since: Date;\n    query?: { roomId?: string; kind?: string };\n    signal?: AbortSignal;\n  }): Promise<{\n    inboxNotifications: {\n      updated: InboxNotificationData[];\n      deleted: InboxNotificationDeleteInfo[];\n    };\n    threads: {\n      updated: ThreadData<TM, CM>[];\n      deleted: ThreadDeleteInfo[];\n    };\n    subscriptions: {\n      updated: SubscriptionData[];\n      deleted: SubscriptionDeleteInfo[];\n    };\n    requestedAt: Date;\n  }>;\n\n  getUnreadInboxNotificationsCount(options?: {\n    query?: {\n      roomId?: string;\n      kind?: string;\n    };\n    signal?: AbortSignal;\n  }): Promise<number>;\n\n  markAllInboxNotificationsAsRead(): Promise<void>;\n\n  markInboxNotificationAsRead(inboxNotificationId: string): Promise<void>;\n\n  deleteAllInboxNotifications(): Promise<void>;\n\n  deleteInboxNotification(inboxNotificationId: string): Promise<void>;\n\n  getNotificationSettings(options?: {\n    signal?: AbortSignal;\n  }): Promise<NotificationSettingsPlain>;\n\n  updateNotificationSettings(\n    settings: PartialNotificationSettings\n  ): Promise<NotificationSettingsPlain>;\n}\n\nexport interface LiveblocksHttpApi<\n  TM extends BaseMetadata,\n  CM extends BaseMetadata,\n> extends RoomHttpApi<TM, CM>,\n    NotificationHttpApi<TM, CM> {\n  getUrlMetadata(url: string): Promise<UrlMetadata>;\n\n  getUserThreads_experimental(options?: {\n    cursor?: string;\n    query?: {\n      resolved?: boolean;\n      metadata?: Partial<QueryMetadata<TM>>;\n    };\n  }): Promise<{\n    threads: ThreadData<TM, CM>[];\n    inboxNotifications: InboxNotificationData[];\n    subscriptions: SubscriptionData[];\n    nextCursor: string | null;\n    requestedAt: Date;\n    permissionHints: Record<string, Permission[]>;\n  }>;\n\n  getUserThreadsSince_experimental(options: {\n    since: Date;\n    signal?: AbortSignal;\n  }): Promise<{\n    inboxNotifications: {\n      updated: InboxNotificationData[];\n      deleted: InboxNotificationDeleteInfo[];\n    };\n    threads: {\n      updated: ThreadData<TM, CM>[];\n      deleted: ThreadDeleteInfo[];\n    };\n    subscriptions: {\n      updated: SubscriptionData[];\n      deleted: SubscriptionDeleteInfo[];\n    };\n    requestedAt: Date;\n    permissionHints: Record<string, Permission[]>;\n  }>;\n\n  groupsStore: BatchStore<GroupData | undefined, string>;\n\n  getGroup(groupId: string): Promise<GroupData | undefined>;\n}\n\nexport function createApiClient<\n  TM extends BaseMetadata,\n  CM extends BaseMetadata,\n>({\n  baseUrl,\n  authManager,\n  currentUserId,\n  fetchPolyfill,\n}: {\n  baseUrl: string;\n  authManager: AuthManager;\n  currentUserId: Signal<string | undefined>;\n  fetchPolyfill: typeof fetch;\n}): LiveblocksHttpApi<TM, CM> {\n  const httpClient = new HttpClient(baseUrl, fetchPolyfill);\n\n  /* -------------------------------------------------------------------------------------------------\n   * Threads (Room level)\n   * -----------------------------------------------------------------------------------------------*/\n  async function getThreadsSince(options: {\n    roomId: string;\n    since: Date;\n    signal?: AbortSignal;\n  }) {\n    const result = await httpClient.get<{\n      data: ThreadDataPlain<TM, CM>[];\n      inboxNotifications: InboxNotificationDataPlain[];\n      subscriptions: SubscriptionDataPlain[];\n      deletedThreads: ThreadDeleteInfoPlain[];\n      deletedInboxNotifications: InboxNotificationDeleteInfoPlain[];\n      deletedSubscriptions: SubscriptionDeleteInfoPlain[];\n      meta: {\n        requestedAt: string;\n        permissionHints: Record<string, Permission[]>;\n      };\n    }>(\n      url`/v2/c/rooms/${options.roomId}/threads/delta`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId,\n      }),\n      {\n        since: options.since.toISOString(),\n      },\n      { signal: options.signal }\n    );\n\n    return {\n      threads: {\n        updated: result.data.map(convertToThreadData),\n        deleted: result.deletedThreads.map(convertToThreadDeleteInfo),\n      },\n      inboxNotifications: {\n        updated: result.inboxNotifications.map(convertToInboxNotificationData),\n        deleted: result.deletedInboxNotifications.map(\n          convertToInboxNotificationDeleteInfo\n        ),\n      },\n      subscriptions: {\n        updated: result.subscriptions.map(convertToSubscriptionData),\n        deleted: result.deletedSubscriptions.map(\n          convertToSubscriptionDeleteInfo\n        ),\n      },\n      requestedAt: new Date(result.meta.requestedAt),\n      permissionHints: result.meta.permissionHints,\n    };\n  }\n\n  async function getThreads(options: {\n    roomId: string;\n    cursor?: string;\n    query?: {\n      resolved?: boolean;\n      subscribed?: boolean;\n      metadata?: Partial<QueryMetadata<TM>>;\n    };\n  }) {\n    let query: string | undefined;\n\n    if (options.query) {\n      query = objectToQuery(options.query);\n    }\n\n    const PAGE_SIZE = 50;\n\n    try {\n      const result = await httpClient.get<{\n        data: ThreadDataPlain<TM, CM>[];\n        inboxNotifications: InboxNotificationDataPlain[];\n        subscriptions: SubscriptionDataPlain[];\n        deletedThreads: ThreadDeleteInfoPlain[];\n        deletedInboxNotifications: InboxNotificationDeleteInfoPlain[];\n        deletedSubscriptions: SubscriptionDeleteInfoPlain[];\n        meta: {\n          requestedAt: string;\n          nextCursor: string | null;\n          permissionHints: Record<string, Permission[]>;\n        };\n      }>(\n        url`/v2/c/rooms/${options.roomId}/threads`,\n        await authManager.getAuthValue({\n          requestedScope: \"comments:read\",\n          roomId: options.roomId,\n        }),\n        {\n          cursor: options.cursor,\n          query,\n          limit: PAGE_SIZE,\n        }\n      );\n\n      return {\n        threads: result.data.map(convertToThreadData),\n        inboxNotifications: result.inboxNotifications.map(\n          convertToInboxNotificationData\n        ),\n        subscriptions: result.subscriptions.map(convertToSubscriptionData),\n        nextCursor: result.meta.nextCursor,\n        requestedAt: new Date(result.meta.requestedAt),\n        permissionHints: result.meta.permissionHints,\n      };\n    } catch (err) {\n      if (err instanceof HttpError && err.status === 404) {\n        // If the room does (not) yet exist, the response will be a 404 error\n        // response which we'll interpret as an empty list of threads.\n        return {\n          threads: [],\n          inboxNotifications: [],\n          subscriptions: [],\n          nextCursor: null,\n          //\n          // HACK\n          // requestedAt needs to be a *server* timestamp here. However, on\n          // this 404 error response, there is no such timestamp. So out of\n          // pure necessity we'll fall back to a local timestamp instead (and\n          // allow for a possible 6 hour clock difference between client and\n          // server).\n          //\n          requestedAt: new Date(Date.now() - 6 * 60 * 60 * 1000),\n          permissionHints: {},\n        };\n      }\n\n      throw err;\n    }\n  }\n\n  async function searchComments(\n    options: {\n      roomId: string;\n      query: {\n        threadMetadata?: Partial<QueryMetadata<TM>>;\n        threadResolved?: boolean;\n        hasAttachments?: boolean;\n        hasMentions?: boolean;\n        text: string;\n      };\n    },\n    requestOptions?: {\n      signal?: AbortSignal;\n    }\n  ) {\n    const result = await httpClient.get<{\n      data: Array<SearchCommentsResult>;\n    }>(\n      url`/v2/c/rooms/${options.roomId}/threads/comments/search`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId,\n      }),\n      {\n        text: options.query.text,\n        query: objectToQuery({\n          threadMetadata: options.query.threadMetadata,\n          threadResolved: options.query.threadResolved,\n          hasAttachments: options.query.hasAttachments,\n          hasMentions: options.query.hasMentions,\n        }),\n      },\n      { signal: requestOptions?.signal }\n    );\n    return result;\n  }\n\n  async function createThread(options: {\n    roomId: string;\n    threadId?: string;\n    commentId?: string;\n    metadata: TM | undefined;\n    body: CommentBody;\n    commentMetadata?: CM;\n    attachmentIds?: string[];\n  }) {\n    const commentId = options.commentId ?? createCommentId();\n    const threadId = options.threadId ?? createThreadId();\n\n    const thread = await httpClient.post<ThreadDataPlain<TM, CM>>(\n      url`/v2/c/rooms/${options.roomId}/threads`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId,\n      }),\n      {\n        id: threadId,\n        comment: {\n          id: commentId,\n          body: options.body,\n          metadata: options.commentMetadata,\n          attachmentIds: options.attachmentIds,\n        },\n        metadata: options.metadata,\n      }\n    );\n\n    return convertToThreadData<TM, CM>(thread);\n  }\n\n  async function deleteThread(options: { roomId: string; threadId: string }) {\n    await httpClient.delete(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId,\n      })\n    );\n  }\n\n  async function getThread(options: { roomId: string; threadId: string }) {\n    const response = await httpClient.rawGet(\n      url`/v2/c/rooms/${options.roomId}/thread-with-notification/${options.threadId}`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId,\n      })\n    );\n\n    if (response.ok) {\n      const json = (await response.json()) as {\n        thread: ThreadDataPlain<TM, CM>;\n        inboxNotification?: InboxNotificationDataPlain;\n        subscription?: SubscriptionDataPlain;\n      };\n\n      return {\n        thread: convertToThreadData(json.thread),\n        inboxNotification: json.inboxNotification\n          ? convertToInboxNotificationData(json.inboxNotification)\n          : undefined,\n        subscription: json.subscription\n          ? convertToSubscriptionData(json.subscription)\n          : undefined,\n      };\n    } else if (response.status === 404) {\n      return {\n        thread: undefined,\n        inboxNotification: undefined,\n        subscription: undefined,\n      };\n    } else {\n      throw new Error(\n        `There was an error while getting thread ${options.threadId}.`\n      );\n    }\n  }\n\n  async function editThreadMetadata(options: {\n    roomId: string;\n    metadata: Patchable<TM>;\n    threadId: string;\n  }) {\n    return await httpClient.post<TM>(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/metadata`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId,\n      }),\n      options.metadata\n    );\n  }\n\n  async function editCommentMetadata(options: {\n    roomId: string;\n    threadId: string;\n    commentId: string;\n    metadata: Patchable<CM>;\n  }) {\n    return await httpClient.post<CM>(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/comments/${options.commentId}/metadata`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId,\n      }),\n      options.metadata\n    );\n  }\n\n  async function createComment(options: {\n    roomId: string;\n    threadId: string;\n    commentId?: string;\n    body: CommentBody;\n    metadata?: CM;\n    attachmentIds?: string[];\n  }) {\n    const commentId = options.commentId ?? createCommentId();\n    const comment = await httpClient.post<CommentDataPlain<CM>>(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/comments`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId,\n      }),\n      {\n        id: commentId,\n        body: options.body,\n        metadata: options.metadata,\n        attachmentIds: options.attachmentIds,\n      }\n    );\n    return convertToCommentData(comment);\n  }\n\n  async function editComment(options: {\n    roomId: string;\n    threadId: string;\n    commentId: string;\n    body: CommentBody;\n    attachmentIds?: string[];\n    metadata?: Patchable<CM>;\n  }) {\n    const comment = await httpClient.post<CommentDataPlain<CM>>(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/comments/${options.commentId}`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId,\n      }),\n      {\n        body: options.body,\n        attachmentIds: options.attachmentIds,\n        metadata: options.metadata,\n      }\n    );\n\n    return convertToCommentData(comment);\n  }\n\n  async function deleteComment(options: {\n    roomId: string;\n    threadId: string;\n    commentId: string;\n  }) {\n    await httpClient.delete(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/comments/${options.commentId}`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId,\n      })\n    );\n  }\n\n  async function addReaction(options: {\n    roomId: string;\n    threadId: string;\n    commentId: string;\n    emoji: string;\n  }) {\n    const reaction = await httpClient.post<CommentUserReactionPlain>(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/comments/${options.commentId}/reactions`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId,\n      }),\n      { emoji: options.emoji }\n    );\n\n    return convertToCommentUserReaction(reaction);\n  }\n\n  async function removeReaction(options: {\n    roomId: string;\n    threadId: string;\n    commentId: string;\n    emoji: string;\n  }) {\n    await httpClient.delete<CommentDataPlain<CM>>(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/comments/${options.commentId}/reactions/${options.emoji}`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId,\n      })\n    );\n  }\n\n  async function markThreadAsResolved(options: {\n    roomId: string;\n    threadId: string;\n  }) {\n    await httpClient.post(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/mark-as-resolved`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId,\n      })\n    );\n  }\n\n  async function markThreadAsUnresolved(options: {\n    roomId: string;\n    threadId: string;\n  }) {\n    await httpClient.post(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/mark-as-unresolved`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId,\n      })\n    );\n  }\n\n  async function subscribeToThread(options: {\n    roomId: string;\n    threadId: string;\n  }) {\n    const subscription = await httpClient.post<SubscriptionDataPlain>(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/subscribe`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId,\n      })\n    );\n\n    return convertToSubscriptionData(subscription);\n  }\n\n  async function unsubscribeFromThread(options: {\n    roomId: string;\n    threadId: string;\n  }) {\n    await httpClient.post(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/unsubscribe`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId,\n      })\n    );\n  }\n\n  /* -------------------------------------------------------------------------------------------------\n   * Attachments (Room level)\n   * -----------------------------------------------------------------------------------------------*/\n  async function uploadAttachment(options: {\n    roomId: string;\n    attachment: CommentLocalAttachment;\n    signal?: AbortSignal;\n  }): Promise<CommentAttachment> {\n    const roomId = options.roomId;\n    const abortSignal = options.signal;\n    const attachment = options.attachment;\n\n    const abortError = abortSignal\n      ? new DOMException(\n          `Upload of attachment ${options.attachment.id} was aborted.`,\n          \"AbortError\"\n        )\n      : undefined;\n\n    if (abortSignal?.aborted) {\n      throw abortError;\n    }\n\n    const handleRetryError = (err: Error) => {\n      if (abortSignal?.aborted) {\n        throw abortError;\n      }\n\n      if (err instanceof HttpError && err.status === 413) {\n        throw err;\n      }\n\n      return false;\n    };\n\n    const ATTACHMENT_PART_SIZE = 5 * 1024 * 1024; // 5 MB\n    const RETRY_ATTEMPTS = 10;\n    const RETRY_DELAYS = [\n      2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000,\n    ];\n\n    function splitFileIntoParts(file: File) {\n      const parts: { partNumber: number; part: Blob }[] = [];\n\n      let start = 0;\n\n      while (start < file.size) {\n        const end = Math.min(start + ATTACHMENT_PART_SIZE, file.size);\n\n        parts.push({\n          partNumber: parts.length + 1,\n          part: file.slice(start, end),\n        });\n\n        start = end;\n      }\n\n      return parts;\n    }\n\n    if (attachment.size <= ATTACHMENT_PART_SIZE) {\n      // If the file is small enough, upload it in a single request\n      return autoRetry(\n        async () =>\n          httpClient.putBlob<CommentAttachment>(\n            url`/v2/c/rooms/${roomId}/attachments/${attachment.id}/upload/${encodeURIComponent(attachment.name)}`,\n            await authManager.getAuthValue({\n              requestedScope: \"comments:read\",\n              roomId,\n            }),\n            attachment.file,\n            { fileSize: attachment.size },\n            { signal: abortSignal }\n          ),\n        RETRY_ATTEMPTS,\n        RETRY_DELAYS,\n        handleRetryError\n      );\n    } else {\n      // Otherwise, upload it in multiple parts\n      let uploadId: string | undefined;\n      const uploadedParts: {\n        etag: string;\n        partNumber: number;\n      }[] = [];\n\n      // Create a multi-part upload\n      const createMultiPartUpload = await autoRetry(\n        async () =>\n          httpClient.post<{\n            uploadId: string;\n            key: string;\n          }>(\n            url`/v2/c/rooms/${roomId}/attachments/${attachment.id}/multipart/${encodeURIComponent(attachment.name)}`,\n            await authManager.getAuthValue({\n              requestedScope: \"comments:read\",\n              roomId,\n            }),\n            undefined,\n            { signal: abortSignal },\n            { fileSize: attachment.size }\n          ),\n        RETRY_ATTEMPTS,\n        RETRY_DELAYS,\n        handleRetryError\n      );\n\n      try {\n        uploadId = createMultiPartUpload.uploadId;\n\n        const parts = splitFileIntoParts(attachment.file);\n\n        // Check if the upload was aborted\n        if (abortSignal?.aborted) {\n          throw abortError;\n        }\n\n        const batches = chunk(parts, 5);\n\n        // Batches are uploaded one after the other\n        for (const parts of batches) {\n          const uploadedPartsPromises: Promise<{\n            partNumber: number;\n            etag: string;\n          }>[] = [];\n\n          for (const { part, partNumber } of parts) {\n            uploadedPartsPromises.push(\n              autoRetry(\n                async () =>\n                  httpClient.putBlob<{\n                    partNumber: number;\n                    etag: string;\n                  }>(\n                    url`/v2/c/rooms/${roomId}/attachments/${attachment.id}/multipart/${createMultiPartUpload.uploadId}/${String(partNumber)}`,\n                    await authManager.getAuthValue({\n                      requestedScope: \"comments:read\",\n                      roomId,\n                    }),\n                    part,\n                    undefined,\n                    { signal: abortSignal }\n                  ),\n                RETRY_ATTEMPTS,\n                RETRY_DELAYS,\n                handleRetryError\n              )\n            );\n          }\n\n          // Parts are uploaded in parallel\n          uploadedParts.push(...(await Promise.all(uploadedPartsPromises)));\n        }\n\n        // Check if the upload was aborted\n        if (abortSignal?.aborted) {\n          throw abortError;\n        }\n\n        const sortedUploadedParts = uploadedParts.sort(\n          (a, b) => a.partNumber - b.partNumber\n        );\n\n        return httpClient.post<CommentAttachment>(\n          url`/v2/c/rooms/${roomId}/attachments/${attachment.id}/multipart/${uploadId}/complete`,\n          await authManager.getAuthValue({\n            requestedScope: \"comments:read\",\n            roomId,\n          }),\n          { parts: sortedUploadedParts },\n          { signal: abortSignal }\n        );\n      } catch (error) {\n        if (\n          uploadId &&\n          (error as Error)?.name &&\n          ((error as Error).name === \"AbortError\" ||\n            (error as Error).name === \"TimeoutError\")\n        ) {\n          try {\n            // Abort the multi-part upload if it was created\n            await httpClient.rawDelete(\n              url`/v2/c/rooms/${roomId}/attachments/${attachment.id}/multipart/${uploadId}`,\n              await authManager.getAuthValue({\n                requestedScope: \"comments:read\",\n                roomId,\n              })\n            );\n          } catch (error) {\n            // Ignore the error, we are probably offline\n          }\n        }\n\n        throw error;\n      }\n    }\n  }\n\n  const attachmentUrlsBatchStoresByRoom = new DefaultMap<\n    string,\n    BatchStore<string, string>\n  >((roomId) => {\n    const batch = new Batch<string, string>(\n      async (batchedAttachmentIds) => {\n        const attachmentIds = batchedAttachmentIds.flat();\n        const { urls } = await httpClient.post<{\n          urls: (string | null)[];\n        }>(\n          url`/v2/c/rooms/${roomId}/attachments/presigned-urls`,\n          await authManager.getAuthValue({\n            requestedScope: \"comments:read\",\n            roomId,\n          }),\n          { attachmentIds }\n        );\n\n        return urls.map(\n          (url) =>\n            url ??\n            new Error(\"There was an error while getting this attachment's URL\")\n        );\n      },\n      { delay: 50 }\n    );\n    return createBatchStore(batch);\n  });\n\n  function getOrCreateAttachmentUrlsStore(\n    roomId: string\n  ): BatchStore<string, string> {\n    return attachmentUrlsBatchStoresByRoom.getOrCreate(roomId);\n  }\n\n  function getAttachmentUrl(options: { roomId: string; attachmentId: string }) {\n    const batch = getOrCreateAttachmentUrlsStore(options.roomId).batch;\n    return batch.get(options.attachmentId);\n  }\n\n  /* -------------------------------------------------------------------------------------------------\n   * Attachments (Chat level)\n   * -----------------------------------------------------------------------------------------------*/\n  async function uploadChatAttachment(options: {\n    chatId: string;\n    attachment: {\n      id: string;\n      file: File;\n    };\n    signal?: AbortSignal;\n  }): Promise<void> {\n    const { chatId, attachment, signal } = options;\n    const userId = currentUserId.get();\n    if (userId === undefined) {\n      throw new Error(\"Attachment upload requires an authenticated user.\");\n    }\n    const ATTACHMENT_PART_SIZE = 5 * 1024 * 1024; // 5 MB\n\n    if (options.attachment.file.size <= ATTACHMENT_PART_SIZE) {\n      await httpClient.putBlob(\n        url`/v2/c/chats/${chatId}/attachments/${attachment.id}/upload/${encodeURIComponent(attachment.file.name)}`,\n        await authManager.getAuthValue({ requestedScope: \"comments:read\" }),\n        attachment.file,\n        { fileSize: attachment.file.size },\n        { signal }\n      );\n    } else {\n      const multipartUpload = await httpClient.post<{\n        uploadId: string;\n        key: string;\n      }>(\n        url`/v2/c/chats/${chatId}/attachments/${attachment.id}/multipart/${encodeURIComponent(attachment.file.name)}`,\n        await authManager.getAuthValue({ requestedScope: \"comments:read\" }),\n        undefined,\n        { signal },\n        { fileSize: attachment.file.size }\n      );\n\n      try {\n        const uploadedParts: { etag: string; number: number }[] = [];\n\n        const parts: { number: number; part: Blob }[] = [];\n        let start = 0;\n        while (start < attachment.file.size) {\n          const end = Math.min(\n            start + ATTACHMENT_PART_SIZE,\n            attachment.file.size\n          );\n          parts.push({\n            number: parts.length + 1,\n            part: attachment.file.slice(start, end),\n          });\n          start = end;\n        }\n\n        uploadedParts.push(\n          ...(await Promise.all(\n            parts.map(async ({ number, part }) => {\n              return await httpClient.putBlob<{\n                etag: string;\n                number: number;\n              }>(\n                url`/v2/c/chats/${chatId}/attachments/${attachment.id}/multipart/${multipartUpload.uploadId}/${String(number)}`,\n                await authManager.getAuthValue({\n                  requestedScope: \"comments:read\",\n                }),\n                part,\n                undefined,\n                { signal }\n              );\n            })\n          ))\n        );\n\n        await httpClient.post(\n          url`/v2/c/chats/${chatId}/attachments/${attachment.id}/multipart/${multipartUpload.uploadId}/complete`,\n          await authManager.getAuthValue({ requestedScope: \"comments:read\" }),\n          { parts: uploadedParts.sort((a, b) => a.number - b.number) },\n          { signal }\n        );\n      } catch (err) {\n        try {\n          await httpClient.delete(\n            url`/v2/c/chats/${chatId}/attachments/${attachment.id}/multipart/${multipartUpload.uploadId}`,\n            await authManager.getAuthValue({ requestedScope: \"comments:read\" })\n          );\n        } catch (err) {\n          // Ignore the error, we are probably offline\n        }\n        throw err;\n      }\n    }\n  }\n\n  const attachmentUrlsBatchStoresByChat = new DefaultMap<\n    string,\n    BatchStore<string, string>\n  >((chatId) => {\n    const batch = new Batch<string, string>(\n      async (batchedAttachmentIds) => {\n        const attachmentIds = batchedAttachmentIds.flat();\n        const { urls } = await httpClient.post<{\n          urls: (string | null)[];\n        }>(\n          url`/v2/c/chats/${chatId}/attachments/presigned-urls`,\n          await authManager.getAuthValue({\n            requestedScope: \"comments:read\",\n          }),\n          { attachmentIds }\n        );\n\n        return urls.map(\n          (url) =>\n            url ??\n            new Error(\"There was an error while getting this attachment's URL\")\n        );\n      },\n      { delay: 50 }\n    );\n    return createBatchStore(batch);\n  });\n\n  function getOrCreateChatAttachmentUrlsStore(\n    chatId: string\n  ): BatchStore<string, string> {\n    return attachmentUrlsBatchStoresByChat.getOrCreate(chatId);\n  }\n\n  function getChatAttachmentUrl(options: {\n    chatId: string;\n    attachmentId: string;\n  }) {\n    const batch = getOrCreateChatAttachmentUrlsStore(options.chatId).batch;\n    return batch.get(options.attachmentId);\n  }\n\n  /* -------------------------------------------------------------------------------------------------\n   * Notifications (Room level)\n   * -----------------------------------------------------------------------------------------------*/\n  async function getSubscriptionSettings(options: {\n    roomId: string;\n    signal?: AbortSignal;\n  }): Promise<RoomSubscriptionSettings> {\n    return httpClient.get<RoomSubscriptionSettings>(\n      url`/v2/c/rooms/${options.roomId}/subscription-settings`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId,\n      }),\n      undefined,\n      {\n        signal: options.signal,\n      }\n    );\n  }\n\n  async function updateSubscriptionSettings(options: {\n    roomId: string;\n    settings: Partial<RoomSubscriptionSettings>;\n  }): Promise<RoomSubscriptionSettings> {\n    return httpClient.post<RoomSubscriptionSettings>(\n      url`/v2/c/rooms/${options.roomId}/subscription-settings`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId,\n      }),\n      options.settings\n    );\n  }\n\n  const markAsReadBatchesByRoom = new DefaultMap<string, Batch<string, string>>(\n    (roomId) =>\n      new Batch<string, string>(\n        async (batchedInboxNotificationIds) => {\n          const inboxNotificationIds = batchedInboxNotificationIds.flat();\n          // This method (and the following batch handling) isn't the same as the one in\n          // src/notifications.ts, this one is room-based: /v2/c/rooms/<roomId>/inbox-notifications/read.\n          //\n          // The reason for this is that unlike the room-based Comments ones, the Notifications endpoints\n          // don't work with a public key. Since `markThreadAsRead` needs to mark the related inbox notifications\n          // as read, this room-based method is necessary to keep all Comments features working with a public key.\n          await httpClient.post(\n            url`/v2/c/rooms/${roomId}/inbox-notifications/read`,\n            await authManager.getAuthValue({\n              requestedScope: \"comments:read\",\n              roomId,\n            }),\n            { inboxNotificationIds }\n          );\n          return inboxNotificationIds;\n        },\n        { delay: 50 }\n      )\n  );\n\n  async function markRoomInboxNotificationAsRead(options: {\n    roomId: string;\n    inboxNotificationId: string;\n  }) {\n    const batch = markAsReadBatchesByRoom.getOrCreate(options.roomId);\n    return batch.get(options.inboxNotificationId);\n  }\n\n  /* -------------------------------------------------------------------------------------------------\n   * Text editor (Room level)\n   * -----------------------------------------------------------------------------------------------*/\n  async function createTextMention(options: {\n    roomId: string;\n    mentionId: string;\n    mention: MentionData;\n  }) {\n    if (options.mention.kind !== \"user\" && options.mention.kind !== \"group\") {\n      return assertNever(options.mention, \"Unexpected mention kind\");\n    }\n\n    await httpClient.rawPost(\n      url`/v2/c/rooms/${options.roomId}/text-mentions`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId,\n      }),\n      {\n        userId:\n          options.mention.kind === \"user\" ? options.mention.id : undefined,\n        groupId:\n          options.mention.kind === \"group\" ? options.mention.id : undefined,\n        userIds:\n          options.mention.kind === \"group\"\n            ? options.mention.userIds\n            : undefined,\n        mentionId: options.mentionId,\n      }\n    );\n  }\n\n  async function deleteTextMention(options: {\n    roomId: string;\n    mentionId: string;\n  }) {\n    await httpClient.rawDelete(\n      url`/v2/c/rooms/${options.roomId}/text-mentions/${options.mentionId}`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId,\n      })\n    );\n  }\n\n  async function getTextVersion(options: {\n    roomId: string;\n    versionId: string;\n  }) {\n    return httpClient.rawGet(\n      url`/v2/c/rooms/${options.roomId}/y-version/${options.versionId}`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId,\n      })\n    );\n  }\n\n  async function createTextVersion(options: { roomId: string }) {\n    await httpClient.rawPost(\n      url`/v2/c/rooms/${options.roomId}/version`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId,\n      })\n    );\n  }\n\n  async function reportTextEditor(options: {\n    roomId: string;\n    type: TextEditorType;\n    rootKey: string;\n  }) {\n    await httpClient.rawPost(\n      url`/v2/c/rooms/${options.roomId}/text-metadata`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId,\n      }),\n      {\n        type: options.type,\n        rootKey: options.rootKey,\n      }\n    );\n  }\n\n  async function executeContextualPrompt(options: {\n    roomId: string;\n    prompt: string;\n    context: ContextualPromptContext;\n    previous?: {\n      prompt: string;\n      response: ContextualPromptResponse;\n    };\n    signal: AbortSignal;\n  }): Promise<string> {\n    const result = await httpClient.post<{\n      content: { type: \"text\"; text: string }[];\n    }>(\n      url`/v2/c/rooms/${options.roomId}/ai/contextual-prompt`,\n      await authManager.getAuthValue({\n        requestedScope: \"room:read\",\n        roomId: options.roomId,\n      }),\n      {\n        prompt: options.prompt,\n        context: {\n          beforeSelection: options.context.beforeSelection,\n          selection: options.context.selection,\n          afterSelection: options.context.afterSelection,\n        },\n        previous: options.previous,\n      },\n      { signal: options.signal }\n    );\n    if (!result || result.content.length === 0) {\n      throw new Error(\"No content returned from server\");\n    }\n    return result.content[0].text;\n  }\n\n  async function listTextVersions(options: { roomId: string }) {\n    const result = await httpClient.get<{\n      versions: DateToString<HistoryVersion>[];\n      meta: {\n        requestedAt: string;\n      };\n    }>(\n      url`/v2/c/rooms/${options.roomId}/versions`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId,\n      })\n    );\n\n    return {\n      versions: result.versions.map(({ createdAt, ...version }) => {\n        return {\n          createdAt: new Date(createdAt),\n          ...version,\n        };\n      }),\n      requestedAt: new Date(result.meta.requestedAt),\n    };\n  }\n\n  async function listTextVersionsSince(options: {\n    roomId: string;\n    since: Date;\n    signal?: AbortSignal;\n  }) {\n    const result = await httpClient.get<{\n      versions: DateToString<HistoryVersion>[];\n      meta: {\n        requestedAt: string;\n      };\n    }>(\n      url`/v2/c/rooms/${options.roomId}/versions/delta`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId,\n      }),\n      { since: options.since.toISOString() },\n      { signal: options.signal }\n    );\n\n    return {\n      versions: result.versions.map(({ createdAt, ...version }) => {\n        return {\n          createdAt: new Date(createdAt),\n          ...version,\n        };\n      }),\n      requestedAt: new Date(result.meta.requestedAt),\n    };\n  }\n\n  async function streamStorage(options: { roomId: string }) {\n    const result = await httpClient.rawGet(\n      url`/v2/c/rooms/${options.roomId}/storage`,\n      await authManager.getAuthValue({\n        requestedScope: \"room:read\",\n        roomId: options.roomId,\n      })\n    );\n    return (await result.json()) as StorageNode[];\n  }\n\n  /* -------------------------------------------------------------------------------------------------\n   * Inbox notifications (User-level)\n   * -----------------------------------------------------------------------------------------------*/\n  async function getInboxNotifications(options?: {\n    cursor?: string;\n    query?: { roomId?: string; kind?: string };\n  }) {\n    const PAGE_SIZE = 50;\n\n    let query: string | undefined;\n\n    if (options?.query) {\n      query = objectToQuery(options.query);\n    }\n\n    const json = await httpClient.get<{\n      threads: ThreadDataPlain<TM, CM>[];\n      inboxNotifications: InboxNotificationDataPlain[];\n      subscriptions: SubscriptionDataPlain[];\n      groups: GroupDataPlain[];\n      meta: {\n        requestedAt: string;\n        nextCursor: string | null;\n      };\n    }>(\n      url`/v2/c/inbox-notifications`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" }),\n      {\n        cursor: options?.cursor,\n        limit: PAGE_SIZE,\n        query,\n      }\n    );\n\n    const groups = json.groups.map(convertToGroupData);\n\n    // Instead of being returned publicly, the user's groups are put in\n    // a separate store which is also used for on-demand fetching.\n    groupsStore.setData(groups.map((group) => [group.id, group]));\n\n    return {\n      inboxNotifications: json.inboxNotifications.map(\n        convertToInboxNotificationData\n      ),\n      threads: json.threads.map(convertToThreadData),\n      subscriptions: json.subscriptions.map(convertToSubscriptionData),\n      nextCursor: json.meta.nextCursor,\n      requestedAt: new Date(json.meta.requestedAt),\n    };\n  }\n\n  async function getInboxNotificationsSince(options: {\n    since: Date;\n    query?: { roomId?: string; kind?: string };\n    signal?: AbortSignal;\n  }) {\n    let query: string | undefined;\n\n    if (options?.query) {\n      query = objectToQuery(options.query);\n    }\n\n    const json = await httpClient.get<{\n      threads: ThreadDataPlain<TM, CM>[];\n      inboxNotifications: InboxNotificationDataPlain[];\n      subscriptions: SubscriptionDataPlain[];\n      deletedThreads: ThreadDeleteInfoPlain[];\n      deletedInboxNotifications: InboxNotificationDeleteInfoPlain[];\n      deletedSubscriptions: SubscriptionDeleteInfoPlain[];\n      meta: {\n        requestedAt: string;\n      };\n    }>(\n      url`/v2/c/inbox-notifications/delta`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" }),\n      { since: options.since.toISOString(), query },\n      { signal: options.signal }\n    );\n    return {\n      inboxNotifications: {\n        updated: json.inboxNotifications.map(convertToInboxNotificationData),\n        deleted: json.deletedInboxNotifications.map(\n          convertToInboxNotificationDeleteInfo\n        ),\n      },\n      threads: {\n        updated: json.threads.map(convertToThreadData),\n        deleted: json.deletedThreads.map(convertToThreadDeleteInfo),\n      },\n      subscriptions: {\n        updated: json.subscriptions.map(convertToSubscriptionData),\n        deleted: json.deletedSubscriptions.map(convertToSubscriptionDeleteInfo),\n      },\n      requestedAt: new Date(json.meta.requestedAt),\n    };\n  }\n\n  async function getUnreadInboxNotificationsCount(options: {\n    query?: {\n      roomId?: string;\n      kind?: string;\n    };\n    signal?: AbortSignal;\n  }) {\n    let query: string | undefined;\n\n    if (options?.query) {\n      query = objectToQuery(options.query);\n    }\n\n    const { count } = await httpClient.get<{ count: number }>(\n      url`/v2/c/inbox-notifications/count`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" }),\n      { query },\n      { signal: options?.signal }\n    );\n    return count;\n  }\n\n  async function markAllInboxNotificationsAsRead() {\n    await httpClient.post(\n      url`/v2/c/inbox-notifications/read`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" }),\n      {\n        inboxNotificationIds: \"all\",\n      }\n    );\n  }\n\n  async function markInboxNotificationsAsRead(inboxNotificationIds: string[]) {\n    await httpClient.post(\n      url`/v2/c/inbox-notifications/read`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" }),\n      {\n        inboxNotificationIds,\n      }\n    );\n  }\n\n  const batchedMarkInboxNotificationsAsRead = new Batch<string, string>(\n    async (batchedInboxNotificationIds) => {\n      const inboxNotificationIds = batchedInboxNotificationIds.flat();\n\n      await markInboxNotificationsAsRead(inboxNotificationIds);\n\n      return inboxNotificationIds;\n    },\n    { delay: 50 }\n  );\n\n  async function markInboxNotificationAsRead(inboxNotificationId: string) {\n    await batchedMarkInboxNotificationsAsRead.get(inboxNotificationId);\n  }\n\n  async function deleteAllInboxNotifications() {\n    await httpClient.delete(\n      url`/v2/c/inbox-notifications`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" })\n    );\n  }\n\n  async function deleteInboxNotification(inboxNotificationId: string) {\n    await httpClient.delete(\n      url`/v2/c/inbox-notifications/${inboxNotificationId}`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" })\n    );\n  }\n\n  /* -------------------------------------------------------------------------------------------------\n   * Notifications settings (Project level)\n   * -------------------------------------------------------------------------------------------------\n   */\n  async function getNotificationSettings(options?: {\n    signal?: AbortSignal;\n  }): Promise<NotificationSettingsPlain> {\n    return httpClient.get<NotificationSettingsPlain>(\n      url`/v2/c/notification-settings`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" }),\n      undefined,\n      { signal: options?.signal }\n    );\n  }\n\n  async function updateNotificationSettings(\n    settings: PartialNotificationSettings\n  ): Promise<NotificationSettingsPlain> {\n    return httpClient.post<NotificationSettingsPlain>(\n      url`/v2/c/notification-settings`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" }),\n      settings\n    );\n  }\n\n  /* -------------------------------------------------------------------------------------------------\n   * User threads\n   * -------------------------------------------------------------------------------------------------\n   */\n  async function getUserThreads_experimental(options?: {\n    cursor?: string;\n    query?: {\n      resolved?: boolean;\n      metadata?: Partial<QueryMetadata<TM>>;\n    };\n  }) {\n    let query: string | undefined;\n\n    if (options?.query) {\n      query = objectToQuery(options.query);\n    }\n\n    const PAGE_SIZE = 50;\n\n    const json = await httpClient.get<{\n      threads: ThreadDataPlain<TM, CM>[];\n      inboxNotifications: InboxNotificationDataPlain[];\n      subscriptions: SubscriptionDataPlain[];\n      deletedThreads: ThreadDeleteInfoPlain[];\n      deletedInboxNotifications: InboxNotificationDeleteInfoPlain[];\n      deletedSubscriptions: SubscriptionDeleteInfoPlain[];\n      meta: {\n        requestedAt: string;\n        nextCursor: string | null;\n        permissionHints: Record<string, Permission[]>;\n      };\n    }>(\n      url`/v2/c/threads`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" }),\n      {\n        cursor: options?.cursor,\n        query,\n        limit: PAGE_SIZE,\n      }\n    );\n\n    return {\n      threads: json.threads.map(convertToThreadData),\n      inboxNotifications: json.inboxNotifications.map(\n        convertToInboxNotificationData\n      ),\n      subscriptions: json.subscriptions.map(convertToSubscriptionData),\n      nextCursor: json.meta.nextCursor,\n      requestedAt: new Date(json.meta.requestedAt),\n      permissionHints: json.meta.permissionHints,\n    };\n  }\n\n  async function getUserThreadsSince_experimental(options: {\n    since: Date;\n    signal?: AbortSignal;\n  }) {\n    const json = await httpClient.get<{\n      threads: ThreadDataPlain<TM, CM>[];\n      inboxNotifications: InboxNotificationDataPlain[];\n      subscriptions: SubscriptionDataPlain[];\n      deletedThreads: ThreadDeleteInfoPlain[];\n      deletedInboxNotifications: InboxNotificationDeleteInfoPlain[];\n      deletedSubscriptions: SubscriptionDeleteInfoPlain[];\n      meta: {\n        requestedAt: string;\n        permissionHints: Record<string, Permission[]>;\n      };\n    }>(\n      url`/v2/c/threads/delta`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" }),\n      { since: options.since.toISOString() },\n      { signal: options.signal }\n    );\n\n    return {\n      threads: {\n        updated: json.threads.map(convertToThreadData),\n        deleted: json.deletedThreads.map(convertToThreadDeleteInfo),\n      },\n      inboxNotifications: {\n        updated: json.inboxNotifications.map(convertToInboxNotificationData),\n        deleted: json.deletedInboxNotifications.map(\n          convertToInboxNotificationDeleteInfo\n        ),\n      },\n      subscriptions: {\n        updated: json.subscriptions.map(convertToSubscriptionData),\n        deleted: json.deletedSubscriptions.map(convertToSubscriptionDeleteInfo),\n      },\n      requestedAt: new Date(json.meta.requestedAt),\n      permissionHints: json.meta.permissionHints,\n    };\n  }\n\n  /* -------------------------------------------------------------------------------------------------\n   * Groups\n   * -------------------------------------------------------------------------------------------------\n   */\n\n  const batchedGetGroups = new Batch(\n    async (batchedGroupIds: string[]) => {\n      const groupIds = batchedGroupIds.flat();\n      const { groups: plainGroups } = await httpClient.post<{\n        groups: GroupDataPlain[];\n      }>(\n        url`/v2/c/groups/find`,\n        await authManager.getAuthValue({\n          requestedScope: \"comments:read\",\n        }),\n        { groupIds }\n      );\n\n      const groups = new Map<string, GroupData>();\n\n      for (const group of plainGroups) {\n        groups.set(group.id, convertToGroupData(group));\n      }\n\n      return groupIds.map((groupId) => groups.get(groupId));\n    },\n    { delay: 50 }\n  );\n  const groupsStore = createBatchStore(batchedGetGroups);\n\n  function getGroup(groupId: string) {\n    return batchedGetGroups.get(groupId);\n  }\n\n  /* -------------------------------------------------------------------------------------------------\n   * URL metadata\n   * -------------------------------------------------------------------------------------------------\n   */\n  async function getUrlMetadata(_url: string) {\n    const { metadata } = await httpClient.get<{ metadata: UrlMetadata }>(\n      url`/v2/c/urls/metadata`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" }),\n      { url: _url }\n    );\n\n    return metadata;\n  }\n\n  return {\n    // Room threads\n    getThreads,\n    getThreadsSince,\n    searchComments,\n    createThread,\n    getThread,\n    deleteThread,\n    editThreadMetadata,\n    createComment,\n    editComment,\n    editCommentMetadata,\n    deleteComment,\n    addReaction,\n    removeReaction,\n    markThreadAsResolved,\n    markThreadAsUnresolved,\n    subscribeToThread,\n    unsubscribeFromThread,\n    markRoomInboxNotificationAsRead,\n    // Room subscription settings\n    getSubscriptionSettings,\n    updateSubscriptionSettings,\n    // Room text editor\n    createTextMention,\n    deleteTextMention,\n    getTextVersion,\n    createTextVersion,\n    reportTextEditor,\n    listTextVersions,\n    listTextVersionsSince,\n    // Room attachments\n    getAttachmentUrl,\n    uploadAttachment,\n    getOrCreateAttachmentUrlsStore,\n    // User attachments\n    uploadChatAttachment,\n    getOrCreateChatAttachmentUrlsStore,\n    getChatAttachmentUrl,\n    // Room storage\n    streamStorage,\n    // Notifications\n    getInboxNotifications,\n    getInboxNotificationsSince,\n    getUnreadInboxNotificationsCount,\n    markAllInboxNotificationsAsRead,\n    markInboxNotificationAsRead,\n    deleteAllInboxNotifications,\n    deleteInboxNotification,\n    getNotificationSettings,\n    updateNotificationSettings,\n    // User threads\n    getUserThreads_experimental,\n    getUserThreadsSince_experimental,\n    // Groups\n    groupsStore,\n    getGroup,\n    // AI\n    executeContextualPrompt,\n    // URL metadata\n    getUrlMetadata,\n  };\n}\n\nexport function getBearerTokenFromAuthValue(authValue: AuthValue): string {\n  if (authValue.type === \"public\") {\n    return authValue.publicApiKey;\n  } else {\n    return authValue.token.raw;\n  }\n}\n\n/**\n * @internal\n *\n * Small HTTP client for client-only REST API requests (e.g. /v2/c/* URLs).\n * These URLs all use public key, ID token, or access token authorization. This\n * HTTP client can be shared and used by both the Liveblocks Client and\n * Liveblocks Room instances internally to talk to our client-only REST API\n * backend.\n */\nclass HttpClient {\n  #baseUrl: string;\n  #fetchPolyfill: typeof fetch;\n\n  constructor(baseUrl: string, fetchPolyfill: typeof fetch) {\n    this.#baseUrl = baseUrl;\n    this.#fetchPolyfill = fetchPolyfill;\n  }\n\n  // ------------------------------------------------------------------\n  // Public methods\n  // ------------------------------------------------------------------\n\n  /**\n   * Constructs and makes the HTTP request, but does not handle the response.\n   *\n   * This is what .rawFetch() does:    👈 This method!\n   *   1. Set Content-Type header\n   *   2. Set Authorization header\n   *   3. Call the callback to obtain the `authValue` to use in the Authorization header\n   *\n   * This is what .fetch() does ON TOP of that:\n   *   4. Parse response body as Json\n   *   5. ...but silently return `{}` if that parsing fails\n   *   6. Throw HttpError if response is an error\n   */\n  async #rawFetch(\n    endpoint: URLSafeString,\n    authValue: AuthValue,\n    options?: RequestInit,\n    params?: QueryParams\n  ): Promise<Response> {\n    if (!endpoint.startsWith(\"/v2/c/\")) {\n      raise(\"This client can only be used to make /v2/c/* requests\");\n    }\n\n    const url = urljoin(this.#baseUrl, endpoint, params);\n    const response = await this.#fetchPolyfill(url, {\n      ...options,\n      headers: {\n        // These headers are default, but can be overriden by custom headers\n        \"Content-Type\": \"application/json; charset=utf-8\",\n\n        // Possible header overrides\n        ...options?.headers,\n\n        // Cannot be overriden by custom headers\n        Authorization: `Bearer ${getBearerTokenFromAuthValue(authValue)}`,\n        \"X-LB-Client\": PKG_VERSION || \"dev\",\n      },\n    });\n\n    // Surface dev-server warnings to the developer\n    const xwarn = response.headers.get(\"X-LB-Warn\");\n    if (xwarn) {\n      const method = options?.method?.toUpperCase() ?? \"GET\";\n      const msg = `${xwarn} (${method} ${endpoint})`;\n      if (response.ok) {\n        console.warn(msg);\n      } else {\n        console.error(msg);\n      }\n    }\n\n    return response;\n  }\n\n  /**\n   * Constructs, makes the HTTP request, and handles the response by parsing\n   * JSON and/or throwing an HttpError if it failed.\n   *\n   * This is what .rawFetch() does:\n   *   1. Set Content-Type header\n   *   2. Set Authorization header\n   *   3. Call the callback to obtain the `authValue` to use in the Authorization header\n   *\n   * This is what .fetch() does ON TOP of that:   👈 This method!\n   *   4. Parse response body as Json\n   *   5. ...but silently return `{}` if that parsing fails (🤔)\n   *   6. Throw HttpError if response is an error\n   */\n  async #fetch<T extends JsonObject>(\n    endpoint: URLSafeString,\n    authValue: AuthValue,\n    options?: RequestInit,\n    params?: QueryParams\n  ): Promise<T> {\n    const response = await this.#rawFetch(endpoint, authValue, options, params);\n\n    if (!response.ok) {\n      throw await HttpError.fromResponse(response);\n    }\n\n    let body;\n    try {\n      body = (await response.json()) as T;\n    } catch {\n      // TODO This looks wrong 🤔 !\n      // TODO Should we not be throwing this error if something fails to parse?\n      body = {} as T;\n    }\n    return body;\n  }\n\n  /**\n   * Makes a GET request and returns the raw response.\n   * Won't throw if the reponse is a non-2xx.\n   * @deprecated Ideally, use .get() instead.\n   */\n  public async rawGet(\n    endpoint: URLSafeString,\n    authValue: AuthValue,\n    params?: QueryParams,\n    options?: Omit<RequestInit, \"body\" | \"method\" | \"headers\">\n  ): Promise<Response> {\n    return await this.#rawFetch(endpoint, authValue, options, params);\n  }\n\n  /**\n   * Makes a POST request and returns the raw response.\n   * Won't throw if the reponse is a non-2xx.\n   * @deprecated Ideally, use .post() instead.\n   */\n  public async rawPost(\n    endpoint: URLSafeString,\n    authValue: AuthValue,\n    body?: JsonObject\n  ): Promise<Response> {\n    return await this.#rawFetch(endpoint, authValue, {\n      method: \"POST\",\n      body: stringify(body),\n    });\n  }\n\n  /**\n   * Makes a DELETE request and returns the raw response.\n   * Won't throw if the reponse is a non-2xx.\n   * @deprecated Ideally, use .delete() instead.\n   */\n  public async rawDelete(\n    endpoint: URLSafeString,\n    authValue: AuthValue\n  ): Promise<Response> {\n    return await this.#rawFetch(endpoint, authValue, { method: \"DELETE\" });\n  }\n\n  /**\n   * Makes a GET request, and return the JSON response.\n   * Will throw if the reponse is a non-2xx.\n   */\n  public async get<T extends JsonObject>(\n    endpoint: URLSafeString,\n    authValue: AuthValue,\n    params?: QueryParams,\n    options?: Omit<RequestInit, \"body\" | \"method\" | \"headers\">\n  ): Promise<T> {\n    return await this.#fetch<T>(endpoint, authValue, options, params);\n  }\n\n  /**\n   * Makes a POST request, and return the JSON response.\n   * Will throw if the reponse is a non-2xx.\n   */\n  public async post<T extends JsonObject>(\n    endpoint: URLSafeString,\n    authValue: AuthValue,\n    body?: JsonObject,\n    options?: Omit<RequestInit, \"body\" | \"method\" | \"headers\">,\n    params?: QueryParams\n  ): Promise<T> {\n    return await this.#fetch<T>(\n      endpoint,\n      authValue,\n      {\n        ...options,\n        method: \"POST\",\n        body: stringify(body),\n      },\n      params\n    );\n  }\n\n  /**\n   * Makes a DELETE request, and return the JSON response.\n   * Will throw if the reponse is a non-2xx.\n   */\n  public async delete<T extends JsonObject>(\n    endpoint: URLSafeString,\n    authValue: AuthValue\n  ): Promise<T> {\n    return await this.#fetch<T>(endpoint, authValue, { method: \"DELETE\" });\n  }\n\n  /**\n   * Makes a PUT request for a Blob body, and return the JSON response.\n   * Will throw if the reponse is a non-2xx.\n   */\n  public async putBlob<T extends JsonObject>(\n    endpoint: URLSafeString,\n    authValue: AuthValue,\n    blob?: Blob,\n    params?: QueryParams,\n    options?: Omit<RequestInit, \"body\" | \"method\" | \"headers\">\n  ): Promise<T> {\n    return await this.#fetch<T>(\n      endpoint,\n      authValue,\n      {\n        ...options,\n        method: \"PUT\",\n        headers: {\n          \"Content-Type\": \"application/octet-stream\",\n        },\n        body: blob,\n      },\n      params\n    );\n  }\n}\n","/**\n * A generic Finite State Machine (FSM) implementation.\n *\n * This is a generic implementation that is not Liveblocks specific. We could\n * put this in a separate NPM package if we wanted to make this more reusable.\n */\n\nimport type { EventSource, Observable } from \"./EventSource\";\nimport { makeEventSource } from \"./EventSource\";\n\n/**\n * Built-in event sent by .addTimedTransition().\n */\nexport type TimerEvent = { readonly type: \"TIMER\" };\n\n/**\n * Built-in events sent by .onEnterAsync().\n */\nexport type AsyncOKEvent<T> = {\n  readonly type: \"ASYNC_OK\";\n  readonly data: T;\n};\nexport type AsyncErrorEvent = {\n  readonly type: \"ASYNC_ERROR\";\n  readonly reason: unknown;\n};\n\nexport type BaseEvent = { readonly type: string };\nexport type BuiltinEvent = TimerEvent | AsyncOKEvent<unknown> | AsyncErrorEvent;\n\nexport type Patchable<TContext> = Readonly<TContext> & {\n  patch(patch: Partial<TContext>): void;\n};\n\nexport type CleanupFn<TContext> = (context: Patchable<TContext>) => void;\nexport type EnterFn<TContext> = (\n  context: Patchable<TContext>\n) => void | CleanupFn<TContext>;\n\nexport type TargetFn<\n  TContext extends object,\n  TEvent extends BaseEvent,\n  TState extends string,\n> = (\n  event: TEvent,\n  context: Readonly<TContext>\n) => TState | TargetObject<TContext, TEvent, TState> | null;\n\nexport type Effect<TContext, TEvent extends BaseEvent> = (\n  context: Patchable<TContext>,\n  event: TEvent\n) => void;\n\n/**\n * \"Expanded\" object form to specify a target state with.\n */\nexport type TargetObject<\n  TContext extends object,\n  TEvent extends BaseEvent,\n  TState extends string,\n> = {\n  target: TState;\n\n  /**\n   * Emit a side effect (other than assigning to the context) when this\n   * transition is taken.\n   */\n  effect: Effect<TContext, TEvent> | Effect<TContext, TEvent>[];\n};\n\nexport type Target<\n  TContext extends object,\n  TEvent extends BaseEvent,\n  TState extends string,\n> =\n  | TState // Static, e.g. 'complete'\n  | TargetObject<TContext, TEvent, TState>\n  | TargetFn<TContext, TEvent, TState>; // Dynamic, e.g. (context) => context.x ? 'complete' : 'other'\n\ntype Groups<T extends string> = T extends `${infer G}.${infer Rest}`\n  ? G | `${G}.${Groups<Rest>}`\n  : never;\nexport type Wildcard<T extends string> = \"*\" | `${Groups<T>}.*`;\n\n/** State or one of its parent group patterns (e.g., \"foo.bar.baz\" | \"foo.bar.*\" | \"foo.*\") */\nexport type StateOrGroupPattern<T extends string> = T | `${Groups<T>}.*`;\n\nfunction distance(state1: string, state2: string): [number, number] {\n  if (state1 === state2) {\n    return [0, 0];\n  }\n\n  const chunks1 = state1.split(\".\");\n  const chunks2 = state2.split(\".\");\n  const minLen = Math.min(chunks1.length, chunks2.length);\n  let shared = 0;\n  for (; shared < minLen; shared++) {\n    if (chunks1[shared] !== chunks2[shared]) {\n      break;\n    }\n  }\n\n  const up = chunks1.length - shared;\n  const down = chunks2.length - shared;\n  return [up, down];\n}\n\nfunction patterns<TState extends string>(\n  targetState: TState,\n  levels: number\n): (Wildcard<TState> | TState)[] {\n  const parts = targetState.split(\".\");\n  if (levels < 1 || levels > parts.length + 1) {\n    throw new Error(\"Invalid number of levels\");\n  }\n\n  const result: (Wildcard<TState> | TState)[] = [];\n  if (levels > parts.length) {\n    result.push(\"*\");\n  }\n\n  for (let i = parts.length - levels + 1; i < parts.length; i++) {\n    const slice = parts.slice(0, i);\n    if (slice.length > 0) {\n      result.push((slice.join(\".\") + \".*\") as Wildcard<TState>);\n    }\n  }\n\n  result.push(targetState);\n\n  return result;\n}\n\nclass SafeContext<TContext extends object> {\n  #curr: Readonly<TContext>;\n\n  constructor(initialContext: TContext) {\n    this.#curr = initialContext;\n  }\n\n  get current(): Readonly<TContext> {\n    return this.#curr;\n  }\n\n  /**\n   * Call a callback function that allows patching of the context, by\n   * calling `context.patch()`. Patching is only allowed for the duration\n   * of this window.\n   */\n  allowPatching(callback: (context: Patchable<TContext>) => void): void {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this;\n    let allowed = true;\n\n    const patchableContext = {\n      ...this.#curr,\n      patch(patch: Partial<TContext>): void {\n        if (allowed) {\n          self.#curr = Object.assign({}, self.#curr, patch);\n\n          // Also patch the temporary mutable context helper itself, in case\n          // there are multiple calls in a succession that need\n          for (const pair of Object.entries(patch)) {\n            const [key, value] = pair as [\n              keyof TContext,\n              TContext[keyof TContext],\n            ];\n            if (key !== \"patch\") {\n              (this as TContext)[key] = value;\n            }\n          }\n        } else {\n          throw new Error(\"Can no longer patch stale context\");\n        }\n      },\n    };\n    callback(patchableContext);\n\n    // If ever the patch function is called after this temporary window,\n    // disallow it\n    allowed = false;\n    return;\n  }\n}\n\nenum RunningState {\n  NOT_STARTED_YET, // Machine can be set up during this phase\n  STARTED,\n  STOPPED,\n}\n\nlet nextId = 1;\n\nexport class FSM<\n  TContext extends object,\n  TEvent extends BaseEvent,\n  TState extends string,\n> {\n  public id: number;\n\n  // Indicates whether this state machine is still being configured, has\n  // started, or has terminated\n  #runningState: RunningState;\n\n  readonly #currentContext: SafeContext<TContext>;\n\n  #states: Set<TState>;\n  #currentStateOrNull: TState | null;\n\n  #allowedTransitions: Map<\n    TState,\n    Map<TEvent[\"type\"], TargetFn<TContext, TEvent, TState>>\n  >;\n\n  readonly #eventHub: {\n    readonly didReceiveEvent: EventSource<TEvent | BuiltinEvent>;\n    readonly willTransition: EventSource<{ from: TState; to: TState }>;\n    readonly didIgnoreEvent: EventSource<TEvent | BuiltinEvent>;\n    readonly willExitState: EventSource<TState>;\n    readonly didEnterState: EventSource<TState>;\n    readonly didExitState: EventSource<{\n      state: StateOrGroupPattern<TState>;\n      durationMs: number;\n    }>;\n  };\n\n  public readonly events: {\n    readonly didReceiveEvent: Observable<TEvent | BuiltinEvent>;\n    readonly willTransition: Observable<{ from: TState; to: TState }>;\n    readonly didIgnoreEvent: Observable<TEvent | BuiltinEvent>;\n    readonly willExitState: Observable<TState>;\n    readonly didEnterState: Observable<TState>;\n    readonly didExitState: Observable<{\n      state: StateOrGroupPattern<TState>;\n      durationMs: number;\n    }>;\n  };\n\n  //\n  // The cleanup stack is a stack of (optional) callback functions that will\n  // be run when exiting the current state. If a state (or state group) does\n  // not have an exit handler, then the entry for that level may be\n  // `undefined`, but there will be an explicit entry in the stack for it.\n  //\n  // This will always be true:\n  //\n  //   cleanupStack.length == currentState.split('.').length + 1\n  //\n  // Each stack level represents a different state \"group\".\n  //\n  // For example, if you are in a state named `foo.bar.qux`, then the stack\n  // will contain the exit handler for `foo.bar.qux` (at the top), then\n  // `foo.bar.*`, then `foo.*`, and finally, `*`.\n  //\n  #cleanupStack: (CleanupFn<TContext> | null)[];\n\n  //\n  // The entry times stack tracks when each state level was entered, using\n  // performance.now() timestamps. This parallels the cleanup stack structure.\n  //\n  // For example, if you are in state `foo.bar.qux`, the stack contains:\n  // [timestamp for *, timestamp for foo.*, timestamp for foo.bar.*, timestamp for foo.bar.qux]\n  //\n  #entryTimesStack: number[];\n\n  #enterFns: Map<TState | Wildcard<TState>, EnterFn<TContext>>;\n\n  // Used to provide better error messages\n  #knownEventTypes: Set<string>;\n\n  /**\n   * Returns the initial state, which is defined by the first call made to\n   * .addState().\n   */\n  get #initialState(): TState {\n    // Return the first state ever defined as the initial state\n    const result = this.#states.values()[Symbol.iterator]().next();\n    if (result.done) {\n      throw new Error(\"No states defined yet\");\n    } else {\n      return result.value;\n    }\n  }\n\n  public get currentState(): TState {\n    if (this.#currentStateOrNull === null) {\n      if (this.#runningState === RunningState.NOT_STARTED_YET) {\n        throw new Error(\"Not started yet\");\n      } else {\n        throw new Error(\"Already stopped\");\n      }\n    }\n    return this.#currentStateOrNull;\n  }\n\n  /**\n   * Starts the machine by entering the initial state.\n   */\n  public start(): this {\n    if (this.#runningState !== RunningState.NOT_STARTED_YET) {\n      throw new Error(\"State machine has already started\");\n    }\n\n    this.#runningState = RunningState.STARTED;\n    this.#currentStateOrNull = this.#initialState;\n    this.#enter(null);\n    return this;\n  }\n\n  /**\n   * Stops the state machine. Stopping the state machine will call exit\n   * handlers for the current state, but not enter a new state.\n   */\n  public stop(): void {\n    if (this.#runningState !== RunningState.STARTED) {\n      throw new Error(\"Cannot stop a state machine that hasn't started yet\");\n    }\n    this.#exit(null);\n    this.#runningState = RunningState.STOPPED;\n    this.#currentStateOrNull = null;\n  }\n\n  constructor(initialContext: Readonly<TContext>) {\n    this.id = nextId++;\n    this.#runningState = RunningState.NOT_STARTED_YET;\n    this.#currentStateOrNull = null;\n    this.#states = new Set();\n    this.#enterFns = new Map();\n    this.#cleanupStack = [];\n    this.#entryTimesStack = [];\n    this.#knownEventTypes = new Set();\n    this.#allowedTransitions = new Map();\n    this.#currentContext = new SafeContext(initialContext);\n    this.#eventHub = {\n      didReceiveEvent: makeEventSource(),\n      willTransition: makeEventSource(),\n      didIgnoreEvent: makeEventSource(),\n      willExitState: makeEventSource(),\n      didEnterState: makeEventSource(),\n      didExitState: makeEventSource(),\n    };\n    this.events = {\n      didReceiveEvent: this.#eventHub.didReceiveEvent.observable,\n      willTransition: this.#eventHub.willTransition.observable,\n      didIgnoreEvent: this.#eventHub.didIgnoreEvent.observable,\n      willExitState: this.#eventHub.willExitState.observable,\n      didEnterState: this.#eventHub.didEnterState.observable,\n      didExitState: this.#eventHub.didExitState.observable,\n    };\n  }\n\n  public get context(): Readonly<TContext> {\n    return this.#currentContext.current;\n  }\n\n  /**\n   * Define an explicit finite state in the state machine.\n   */\n  public addState(state: TState): this {\n    if (this.#runningState !== RunningState.NOT_STARTED_YET) {\n      throw new Error(\"Already started\");\n    }\n    this.#states.add(state);\n    return this;\n  }\n\n  public onEnter(\n    nameOrPattern: TState | Wildcard<TState>,\n    enterFn: EnterFn<TContext>\n  ): this {\n    if (this.#runningState !== RunningState.NOT_STARTED_YET) {\n      throw new Error(\"Already started\");\n    } else if (this.#enterFns.has(nameOrPattern)) {\n      throw new Error(\n        // TODO We _currently_ don't support multiple .onEnters() for the same\n        // state, but this is not a fundamental limitation. Just not\n        // implemented yet. If we wanted to, we could make this an array.\n        `enter/exit function for ${nameOrPattern} already exists`\n      );\n    }\n\n    this.#enterFns.set(nameOrPattern, enterFn);\n    return this;\n  }\n\n  /**\n   * Defines a promise-based state. When the state is entered, the promise is\n   * created. When the promise resolves, the machine will transition to the\n   * provided `onOK` target state. When the promise rejects, the machine will\n   * transition to the `onError` target state.\n   *\n   * Optionally, a `maxTimeout` can be set. If the timeout happens before the\n   * promise is settled, then the machine will also transition to the `onError`\n   * target state.\n   *\n   * @param stateOrPattern  The state name, or state group pattern name.\n   * @param promiseFn       The callback to be invoked when the state is entered.\n   * @param onOK            The state to transition to when the promise resolves.\n   * @param onError         The state to transition to when the promise\n   *                        rejects, or when the timeout happens before the\n   *                        promise has been settled.\n   * @param maxTimeout      Optional timeout in milliseconds.\n   *\n   * When the promise callback function is invoked, it's provided with an\n   * AbortSignal (2nd argument).\n   * If a state transition happens while the promise is pending (for example,\n   * an event, or a timeout happens), then an abort signal will be used to\n   * indicate this. Implementers can use this abort signal to terminate the\n   * in-flight promise, or ignore its results, etc.\n   */\n  public onEnterAsync<T>(\n    nameOrPattern: TState | Wildcard<TState>,\n    promiseFn: (context: Readonly<TContext>, signal: AbortSignal) => Promise<T>,\n    onOK: Target<TContext, AsyncOKEvent<T>, TState>,\n    onError: Target<TContext, AsyncErrorEvent, TState>,\n    maxTimeout?: number\n  ): this {\n    return this.onEnter(nameOrPattern, () => {\n      const abortController = new AbortController();\n      const signal = abortController.signal;\n\n      const timeoutId = maxTimeout\n        ? setTimeout(() => {\n            const reason = new Error(\"Timed out\");\n            this.#transition({ type: \"ASYNC_ERROR\", reason }, onError);\n          }, maxTimeout)\n        : undefined;\n\n      let done = false;\n      void promiseFn(this.#currentContext.current, signal).then(\n        // On OK\n        (data: T) => {\n          if (!signal.aborted) {\n            done = true;\n            this.#transition({ type: \"ASYNC_OK\", data }, onOK);\n          }\n        },\n\n        // On Error\n        (reason: unknown) => {\n          if (!signal.aborted) {\n            done = true;\n            this.#transition({ type: \"ASYNC_ERROR\", reason }, onError);\n          }\n        }\n      );\n\n      return () => {\n        clearTimeout(timeoutId);\n        if (!done) {\n          abortController.abort();\n        }\n      };\n    });\n  }\n\n  #getStatesMatching(nameOrPattern: TState | Wildcard<TState>): TState[] {\n    const matches: TState[] = [];\n\n    // We're trying to match a group pattern here, i.e. `foo.*` (which might\n    // match `foo.bar` and `foo.qux` states)\n    if (nameOrPattern === \"*\") {\n      for (const state of this.#states) {\n        matches.push(state);\n      }\n    } else if (nameOrPattern.endsWith(\".*\")) {\n      const prefix = nameOrPattern.slice(0, -1); // Strip only the \"*\", keep the \".\"\n      for (const state of this.#states) {\n        if (state.startsWith(prefix)) {\n          matches.push(state);\n        }\n      }\n    } else {\n      // Just a single, explicit state name\n      const name = nameOrPattern as TState;\n      if (this.#states.has(name)) {\n        matches.push(name);\n      }\n    }\n\n    if (matches.length === 0) {\n      throw new Error(`No states match ${JSON.stringify(nameOrPattern)}`);\n    }\n\n    return matches;\n  }\n\n  /**\n   * Define all allowed outgoing transitions for a state.\n   *\n   * The targets for each event can be defined as a function which returns the\n   * next state to transition to. These functions can look at the `event` or\n   * `context` params to conditionally decide which next state to transition\n   * to.\n   *\n   * If you set it to `null`, then the transition will be explicitly forbidden\n   * and throw an error. If you don't define a target for a transition, then\n   * such events will get ignored.\n   */\n  public addTransitions(\n    nameOrPattern: TState | Wildcard<TState>,\n    mapping: {\n      [E in TEvent as E[\"type\"]]?: Target<TContext, E, TState> | null;\n    }\n  ): this {\n    if (this.#runningState !== RunningState.NOT_STARTED_YET) {\n      throw new Error(\"Already started\");\n    }\n\n    for (const srcState of this.#getStatesMatching(nameOrPattern)) {\n      let map = this.#allowedTransitions.get(srcState);\n      if (map === undefined) {\n        map = new Map();\n        this.#allowedTransitions.set(srcState, map);\n      }\n\n      for (const [type, target_] of Object.entries(mapping)) {\n        if (map.has(type)) {\n          throw new Error(\n            `Trying to set transition \"${type}\" on \"${srcState}\" (via \"${nameOrPattern}\"), but a transition already exists there.`\n          );\n        }\n\n        const target = target_ as\n          | Target<TContext, TEvent, TState>\n          | null\n          | undefined;\n        this.#knownEventTypes.add(type);\n\n        if (target !== undefined) {\n          const targetFn = typeof target === \"function\" ? target : () => target;\n          map.set(type, targetFn);\n        }\n      }\n    }\n    return this;\n  }\n\n  /**\n   * Like `.addTransition()`, but takes an (anonymous) transition whenever the\n   * timer fires.\n   *\n   * @param stateOrPattern  The state name, or state group pattern name.\n   * @param after           Number of milliseconds after which to take the\n   *                        transition. If in the mean time, another transition\n   *                        is taken, the timer will get cancelled.\n   * @param target          The target state to go to.\n   */\n  public addTimedTransition(\n    stateOrPattern: TState | Wildcard<TState>,\n    after: number | ((context: Readonly<TContext>) => number),\n    target: Target<TContext, TimerEvent, TState>\n  ): this {\n    return this.onEnter(stateOrPattern, () => {\n      const ms =\n        typeof after === \"function\"\n          ? after(this.#currentContext.current)\n          : after;\n      const timeoutID = setTimeout(() => {\n        this.#transition({ type: \"TIMER\" }, target);\n      }, ms);\n\n      return () => {\n        clearTimeout(timeoutID);\n      };\n    });\n  }\n\n  #getTargetFn(\n    eventName: TEvent[\"type\"]\n  ): TargetFn<TContext, TEvent, TState> | undefined {\n    return this.#allowedTransitions.get(this.currentState)?.get(eventName);\n  }\n\n  /**\n   * Exits the current state, and executes any necessary cleanup functions.\n   * Call this before changing the current state to the next state.\n   *\n   * @param levels Defines how many \"levels\" of nesting will be\n   * exited. For example, if you transition from `foo.bar.qux` to\n   * `foo.bar.baz`, then the level is 1. But if you transition from\n   * `foo.bar.qux` to `bla.bla`, then the level is 3.\n   * If `null`, it will exit all levels.\n   */\n  #exit(levels: number | null) {\n    this.#eventHub.willExitState.notify(this.currentState);\n\n    const now = performance.now();\n    const parts = this.currentState.split(\".\");\n\n    this.#currentContext.allowPatching((patchableContext) => {\n      levels = levels ?? this.#cleanupStack.length;\n      for (let i = 0; i < levels; i++) {\n        this.#cleanupStack.pop()?.(patchableContext);\n\n        // Emit timing info for the exited state level\n        const entryTime = this.#entryTimesStack.pop();\n        if (\n          entryTime !== undefined &&\n          // ...but avoid computing state names if nobody is listening\n          this.#eventHub.didExitState.count() > 0\n        ) {\n          // Compute the state prefix for this level\n          // Stack depth corresponds to: *, foo.*, foo.bar.*, foo.bar.baz\n          // So current stack length after pop tells us which prefix we exited\n          const depth = this.#entryTimesStack.length;\n\n          // Skip the root wildcard level (depth === 0)\n          if (depth === 0) continue;\n\n          const state: StateOrGroupPattern<TState> =\n            depth === parts.length\n              ? this.currentState // Leaf state: use exact name\n              : (`${parts.slice(0, depth).join(\".\")}.*` as `${Groups<TState>}.*`);\n          this.#eventHub.didExitState.notify({\n            state,\n            durationMs: now - entryTime,\n          });\n        }\n      }\n    });\n  }\n\n  /**\n   * Enters the current state, and executes any necessary onEnter handlers.\n   * Call this directly _after_ setting the current state to the next state.\n   */\n  #enter(levels: number | null) {\n    const enterPatterns = patterns(\n      this.currentState,\n      levels ?? this.currentState.split(\".\").length + 1\n    );\n\n    const now = performance.now();\n\n    this.#currentContext.allowPatching((patchableContext) => {\n      for (const pattern of enterPatterns) {\n        const enterFn = this.#enterFns.get(pattern);\n        const cleanupFn = enterFn?.(patchableContext);\n        if (typeof cleanupFn === \"function\") {\n          this.#cleanupStack.push(cleanupFn);\n        } else {\n          this.#cleanupStack.push(null);\n        }\n        // Track entry time for this state level\n        this.#entryTimesStack.push(now);\n      }\n    });\n\n    this.#eventHub.didEnterState.notify(this.currentState);\n  }\n\n  /**\n   * Sends an event to the machine, which may cause an internal state\n   * transition to happen. When that happens, will trigger side effects.\n   */\n  public send(event: TEvent): void {\n    // Throw if the event is unknown, which may likely be a configuration error\n    if (!this.#knownEventTypes.has(event.type)) {\n      throw new Error(`Invalid event ${JSON.stringify(event.type)}`);\n    }\n\n    if (this.#runningState === RunningState.STOPPED) {\n      // Ignore all events sent to the machine after it has stopped. This is\n      // similar to how we ignore events sent to the machine after it\n      // transitioned to a phase in which the event won't be handled: it would\n      // also get ignored.\n      // However, if the machine _hasn't started yet_, we still let it throw an\n      // error, because then it's most likely a usage error.\n      return;\n    }\n\n    const targetFn = this.#getTargetFn(event.type);\n    if (targetFn !== undefined) {\n      return this.#transition(event, targetFn);\n    } else {\n      // Ignore the event otherwise\n      this.#eventHub.didIgnoreEvent.notify(event);\n    }\n  }\n\n  #transition<E extends TEvent | BuiltinEvent>(\n    event: E,\n    target: Target<TContext, E, TState>\n  ) {\n    this.#eventHub.didReceiveEvent.notify(event);\n\n    const oldState = this.currentState;\n\n    const targetFn = typeof target === \"function\" ? target : () => target;\n    const nextTarget = targetFn(event, this.#currentContext.current);\n    let nextState: TState;\n    let effects: Effect<TContext, E>[] | undefined = undefined;\n    if (nextTarget === null) {\n      // Do not transition\n      this.#eventHub.didIgnoreEvent.notify(event);\n      return;\n    }\n\n    if (typeof nextTarget === \"string\") {\n      nextState = nextTarget;\n    } else {\n      nextState = nextTarget.target;\n      effects = Array.isArray(nextTarget.effect)\n        ? nextTarget.effect\n        : [nextTarget.effect];\n    }\n\n    if (!this.#states.has(nextState)) {\n      throw new Error(`Invalid next state name: ${JSON.stringify(nextState)}`);\n    }\n\n    this.#eventHub.willTransition.notify({ from: oldState, to: nextState });\n\n    const [up, down] = distance(this.currentState, nextState);\n    if (up > 0) {\n      this.#exit(up);\n    }\n\n    this.#currentStateOrNull = nextState; // NOTE: Could stay the same, but... there could be an action to execute here\n    if (effects !== undefined) {\n      const effectsToRun = effects;\n      this.#currentContext.allowPatching((patchableContext) => {\n        for (const effect of effectsToRun) {\n          if (typeof effect === \"function\") {\n            // May mutate context\n            effect(patchableContext, event);\n          } else {\n            patchableContext.patch(effect);\n          }\n        }\n      });\n    }\n\n    if (down > 0) {\n      this.#enter(down);\n    }\n  }\n}\n\n/** @internal - For unit tests only */\nexport { distance, patterns };\n","import type { Json, JsonObject } from \"../lib/Json\";\nimport type { BaseUserMeta } from \"./BaseUserMeta\";\nimport type { ServerWireOp } from \"./Op\";\nimport type { CompactNode, StorageNode } from \"./StorageNode\";\n\nexport type ServerMsgCode = (typeof ServerMsgCode)[keyof typeof ServerMsgCode];\nexport const ServerMsgCode = Object.freeze({\n  // For Presence\n  UPDATE_PRESENCE: 100,\n  USER_JOINED: 101,\n  USER_LEFT: 102,\n  BROADCASTED_EVENT: 103,\n  ROOM_STATE: 104,\n\n  // For Storage\n  STORAGE_STATE_V7: 200, // Only sent in V7\n  STORAGE_CHUNK: 210, // Used in V8+\n  STORAGE_STREAM_END: 211, // Used in V8+\n  UPDATE_STORAGE: 201,\n\n  // For Yjs Docs\n  UPDATE_YDOC: 300,\n\n  // For Comments\n  THREAD_CREATED: 400,\n  THREAD_DELETED: 407,\n  THREAD_METADATA_UPDATED: 401,\n  THREAD_UPDATED: 408,\n  COMMENT_CREATED: 402,\n  COMMENT_EDITED: 403,\n  COMMENT_DELETED: 404,\n  COMMENT_REACTION_ADDED: 405,\n  COMMENT_REACTION_REMOVED: 406,\n  COMMENT_METADATA_UPDATED: 409,\n\n  // Error codes\n  REJECT_STORAGE_OP: 299, // Sent if a mutation was not allowed on the server (i.e. due to permissions, limit exceeded, etc)\n});\n\nexport namespace ServerMsgCode {\n  export type UPDATE_PRESENCE = typeof ServerMsgCode.UPDATE_PRESENCE;\n  export type USER_JOINED = typeof ServerMsgCode.USER_JOINED;\n  export type USER_LEFT = typeof ServerMsgCode.USER_LEFT;\n  export type BROADCASTED_EVENT = typeof ServerMsgCode.BROADCASTED_EVENT;\n  export type ROOM_STATE = typeof ServerMsgCode.ROOM_STATE;\n  export type STORAGE_STATE_V7 = typeof ServerMsgCode.STORAGE_STATE_V7;\n  export type STORAGE_CHUNK = typeof ServerMsgCode.STORAGE_CHUNK;\n  export type STORAGE_STREAM_END = typeof ServerMsgCode.STORAGE_STREAM_END;\n  export type UPDATE_STORAGE = typeof ServerMsgCode.UPDATE_STORAGE;\n  export type UPDATE_YDOC = typeof ServerMsgCode.UPDATE_YDOC;\n  export type THREAD_CREATED = typeof ServerMsgCode.THREAD_CREATED;\n  export type THREAD_DELETED = typeof ServerMsgCode.THREAD_DELETED;\n  export type THREAD_METADATA_UPDATED =\n    typeof ServerMsgCode.THREAD_METADATA_UPDATED;\n  export type THREAD_UPDATED = typeof ServerMsgCode.THREAD_UPDATED;\n  export type COMMENT_CREATED = typeof ServerMsgCode.COMMENT_CREATED;\n  export type COMMENT_EDITED = typeof ServerMsgCode.COMMENT_EDITED;\n  export type COMMENT_DELETED = typeof ServerMsgCode.COMMENT_DELETED;\n  export type COMMENT_REACTION_ADDED =\n    typeof ServerMsgCode.COMMENT_REACTION_ADDED;\n  export type COMMENT_REACTION_REMOVED =\n    typeof ServerMsgCode.COMMENT_REACTION_REMOVED;\n  export type COMMENT_METADATA_UPDATED =\n    typeof ServerMsgCode.COMMENT_METADATA_UPDATED;\n  export type REJECT_STORAGE_OP = typeof ServerMsgCode.REJECT_STORAGE_OP;\n}\n\n/**\n * Messages that can be sent from the server to the client.\n */\nexport type ServerMsg<\n  P extends JsonObject,\n  U extends BaseUserMeta,\n  E extends Json,\n> =\n  // For Presence\n  | UpdatePresenceServerMsg<P> // Broadcasted\n  | UserJoinServerMsg<U> // Broadcasted\n  | UserLeftServerMsg // Broadcasted\n  | BroadcastedEventServerMsg<E> // Broadcasted\n  | RoomStateServerMsg<U> // For a single client\n\n  // For Storage\n  | StorageStateServerMsg_V7 // Only used in protocol v7\n  | StorageChunkServerMsg // Used in protocol v8+\n  | StorageEndServerMsg // Used in protocol v8+\n  | UpdateStorageServerMsg // Broadcasted\n  | YDocUpdateServerMsg // For receiving doc from backend\n  | RejectedStorageOpServerMsg // For a single client\n\n  // Comments\n  | CommentsEventServerMsg;\n\nexport type CommentsEventServerMsg =\n  | ThreadCreatedEvent\n  | ThreadDeletedEvent\n  | ThreadMetadataUpdatedEvent\n  | ThreadUpdatedEvent\n  | CommentCreatedEvent\n  | CommentEditedEvent\n  | CommentDeletedEvent\n  | CommentReactionAdded\n  | CommentReactionRemoved\n  | CommentMetadataUpdatedEvent;\n\ntype ThreadCreatedEvent = {\n  type: ServerMsgCode.THREAD_CREATED;\n  threadId: string;\n};\n\ntype ThreadDeletedEvent = {\n  type: ServerMsgCode.THREAD_DELETED;\n  threadId: string;\n};\n\ntype ThreadMetadataUpdatedEvent = {\n  type: ServerMsgCode.THREAD_METADATA_UPDATED;\n  threadId: string;\n};\n\ntype ThreadUpdatedEvent = {\n  type: ServerMsgCode.THREAD_UPDATED;\n  threadId: string;\n};\n\ntype CommentCreatedEvent = {\n  type: ServerMsgCode.COMMENT_CREATED;\n  threadId: string;\n  commentId: string;\n};\n\ntype CommentEditedEvent = {\n  type: ServerMsgCode.COMMENT_EDITED;\n  threadId: string;\n  commentId: string;\n};\n\ntype CommentDeletedEvent = {\n  type: ServerMsgCode.COMMENT_DELETED;\n  threadId: string;\n  commentId: string;\n};\n\ntype CommentReactionAdded = {\n  type: ServerMsgCode.COMMENT_REACTION_ADDED;\n  threadId: string;\n  commentId: string;\n  emoji: string;\n};\n\ntype CommentReactionRemoved = {\n  type: ServerMsgCode.COMMENT_REACTION_REMOVED;\n  threadId: string;\n  commentId: string;\n  emoji: string;\n};\n\ntype CommentMetadataUpdatedEvent = {\n  type: ServerMsgCode.COMMENT_METADATA_UPDATED;\n  threadId: string;\n  commentId: string;\n};\n\n/**\n * Sent by the WebSocket server and broadcasted to all clients to announce that\n * a User updated their presence. For example, when a user moves their cursor.\n *\n * In most cases, the data payload will only include the fields from the\n * Presence that have been changed since the last announcement. However, after\n * a new user joins a room, a \"full presence\" will be announced so the newly\n * connected user will get each other's user full presence at least once. In\n * those cases, the `targetActor` field indicates the newly connected client,\n * so all other existing clients can ignore this broadcasted message.\n */\nexport type UpdatePresenceServerMsg<P extends JsonObject> =\n  //\n  // Full Presence™ message\n  //\n  | {\n      readonly type: ServerMsgCode.UPDATE_PRESENCE;\n      /**\n       * The User whose Presence has changed.\n       */\n      readonly actor: number;\n      /**\n       * When set, signifies that this is a Full Presence™ update, not a patch.\n       *\n       * The numeric value itself no longer has specific meaning. Historically,\n       * this field was intended so that clients could ignore these broadcasted\n       * full presence messages, but it turned out that getting a full presence\n       * \"keyframe\" from time to time was useful.\n       *\n       * So nowadays, the presence (pun intended) of this `targetActor` field\n       * is a backward-compatible way of expressing that the `data` contains\n       * all presence fields, and isn't a partial \"patch\".\n       */\n      readonly targetActor: number;\n      /**\n       * The partial or full Presence of a User. If the `targetActor` field is set,\n       * this will be the full Presence, otherwise it only contain the fields that\n       * have changed since the last broadcast.\n       */\n      readonly data: P;\n    }\n\n  //\n  // Partial Presence™ message\n  //\n  | {\n      readonly type: ServerMsgCode.UPDATE_PRESENCE;\n      /**\n       * The User whose Presence has changed.\n       */\n      readonly actor: number;\n      /**\n       * Not set for partial presence updates.\n       */\n      readonly targetActor?: undefined;\n      /**\n       * A partial Presence patch to apply to the User. It will only contain the\n       * fields that have changed since the last broadcast.\n       */\n      readonly data: Partial<P>;\n    };\n\n/**\n * Sent by the WebSocket server and broadcasted to all clients to announce that\n * a new User has joined the Room.\n */\nexport type UserJoinServerMsg<U extends BaseUserMeta> = {\n  readonly type: ServerMsgCode.USER_JOINED;\n  readonly actor: number;\n  /**\n   * The id of the User that has been set in the authentication endpoint.\n   * Useful to get additional information about the connected user.\n   */\n  readonly id: U[\"id\"];\n  /**\n   * Additional user information that has been set in the authentication\n   * endpoint.\n   */\n  readonly info: U[\"info\"];\n  /**\n   * Informs the client what (public) permissions this (other) User has.\n   */\n  readonly scopes: string[];\n};\n\n/**\n * Sent by the WebSocket server and broadcasted to all clients to announce that\n * a new User has left the Room.\n */\nexport type UserLeftServerMsg = {\n  readonly type: ServerMsgCode.USER_LEFT;\n  readonly actor: number;\n};\n\n/**\n * Sent by the WebSocket server when the ydoc is updated or when requested based on stateVector passed.\n * Contains a base64 encoded update\n */\nexport type YDocUpdateServerMsg = {\n  readonly type: ServerMsgCode.UPDATE_YDOC;\n  readonly update: string;\n  readonly isSync: boolean; // dropped after 1.2, we use presence of stateVector instead\n  readonly stateVector: string | null; // server's state vector, sent in response to fetch\n  readonly guid?: string; // an optional guid to identify which subdoc this update to\n  readonly v2?: boolean; // whether this is a v2 update\n  readonly remoteSnapshotHash: string; // The hash of snapshot of server's document. Used to detect if the client has the latest version of the document.\n};\n\n/**\n * Sent by the WebSocket server and broadcasted to all clients to announce that\n * a User broadcasted an Event to everyone in the Room.\n */\nexport type BroadcastedEventServerMsg<E extends Json> = {\n  readonly type: ServerMsgCode.BROADCASTED_EVENT;\n  /**\n   * The User who broadcast the Event. Absent when this event is broadcast from\n   * the REST API in the backend.\n   */\n  readonly actor: number;\n  /**\n   * The arbitrary payload of the Event. This can be any JSON value. Clients\n   * will have to manually verify/decode this event.\n   */\n  readonly event: E;\n};\n\n/**\n * Sent by the WebSocket server to a single client in response to the client\n * joining the Room, to provide the initial state of the Room. The payload\n * includes a list of all other Users that already are in the Room.\n */\nexport type RoomStateServerMsg<U extends BaseUserMeta> = {\n  readonly type: ServerMsgCode.ROOM_STATE;\n  /** Informs the client what their actor ID is going to be. */\n  readonly actor: number;\n  /** Secure nonce for the current session. */\n  readonly nonce: string;\n  /** Informs the client what permissions the current User (self) has. */\n  readonly scopes: string[];\n  readonly users: {\n    readonly [otherActor: number]: U & { scopes: string[] };\n  };\n  /** Metadata sent from the server to the client. */\n  readonly meta: JsonObject;\n};\n\n/**\n * No longer used as of WS API v8.\n */\nexport type StorageStateServerMsg_V7 = {\n  readonly type: ServerMsgCode.STORAGE_STATE_V7;\n  readonly items: StorageNode[];\n};\n\n/**\n * Sent by the WebSocket server to a single client in response to the client\n * sending a FetchStorageClientMsg message, to provide one chunk of the initial\n * Storage state of the Room.\n *\n * The server will respond with 1+ STORAGE_CHUNK messages, followed by exactly\n * one STORAGE_STREAM_END message to mark the end of the transmission.\n *\n * If the room is using the new storage engine that supports streaming, then\n * potentially multiple chunks might get sent. If the room is using the old\n * storage engine, then all nodes will be sent in a single/large chunk\n * (non-streaming).\n */\nexport type StorageChunkServerMsg = {\n  readonly type: ServerMsgCode.STORAGE_CHUNK;\n  readonly nodes: CompactNode[];\n};\n\nexport type StorageEndServerMsg = {\n  readonly type: ServerMsgCode.STORAGE_STREAM_END;\n};\n\n/**\n * Sent by the WebSocket server and broadcasted to all clients to announce that\n * a change occurred in the Storage document.\n *\n * The payload of this message contains a list of Ops (aka incremental\n * mutations to make to the initially loaded document).\n */\nexport type UpdateStorageServerMsg = {\n  readonly type: ServerMsgCode.UPDATE_STORAGE;\n  readonly ops: ServerWireOp[];\n};\n\n/**\n * Sent by the WebSocket server to the client to indicate that certain opIds\n * have been rejected, possibly due to lack of permissions or exceeding\n * a limit.\n */\nexport type RejectedStorageOpServerMsg = {\n  readonly type: ServerMsgCode.REJECT_STORAGE_OP;\n  readonly opIds: string[];\n  readonly reason: string;\n};\n","export interface IWebSocketEvent {\n  type: string;\n}\n\nexport interface IWebSocketCloseEvent extends IWebSocketEvent {\n  readonly code: WebsocketCloseCodes;\n  readonly wasClean: boolean;\n  readonly reason: string;\n}\n\nexport interface IWebSocketMessageEvent extends IWebSocketEvent {\n  readonly data: string | Buffer | ArrayBuffer | readonly Buffer[];\n}\n\nexport interface IWebSocketInstance {\n  readonly CONNECTING: number; // 0\n  readonly OPEN: number; // 1\n  readonly CLOSING: number; // 2\n  readonly CLOSED: number; // 3\n\n  readonly readyState: number;\n\n  addEventListener(type: \"close\", listener: (this: IWebSocketInstance, ev: IWebSocketCloseEvent) => unknown): void; // prettier-ignore\n  addEventListener(type: \"message\", listener: (this: IWebSocketInstance, ev: IWebSocketMessageEvent) => unknown): void; // prettier-ignore\n  addEventListener(type: \"open\" | \"error\", listener: (this: IWebSocketInstance, ev: IWebSocketEvent) => unknown): void; // prettier-ignore\n\n  removeEventListener(type: \"close\", listener: (this: IWebSocketInstance, ev: IWebSocketCloseEvent) => unknown): void; // prettier-ignore\n  removeEventListener(type: \"message\", listener: (this: IWebSocketInstance, ev: IWebSocketMessageEvent) => unknown): void; // prettier-ignore\n  removeEventListener(type: \"open\" | \"error\", listener: (this: IWebSocketInstance, ev: IWebSocketEvent) => unknown): void; // prettier-ignore\n\n  close(): void;\n  send(data: string): void;\n}\n\n/**\n * Either the browser-based WebSocket API or Node.js' WebSocket API (from the\n * 'ws' package).\n *\n * This type defines the minimal WebSocket API that Liveblocks needs from\n * a WebSocket implementation, and is a minimal subset of the browser-based\n * WebSocket APIs and Node.js' WebSocket API so that both implementations are\n * assignable to this type.\n */\nexport interface IWebSocket {\n  new (address: string): IWebSocketInstance;\n}\n\n/**\n * The following ranges will be respected by the client:\n *\n *   10xx: client will reauthorize (just like 41xx)\n *   40xx: client will disconnect\n *   41xx: client will reauthorize\n *   42xx: client will retry without reauthorizing (currently not used)\n *\n */\nexport enum WebsocketCloseCodes {\n  /** Normal close of connection, the connection fulfilled its purpose. */\n  CLOSE_NORMAL = 1000,\n  /** Unexpected error happened with the network/infra level. In spirit akin to HTTP 503 */\n  CLOSE_ABNORMAL = 1006,\n  /** Unexpected error happened. In spirit akin to HTTP 500 */\n  UNEXPECTED_CONDITION = 1011,\n  /** Please back off for now, but try again in a few moments */\n  TRY_AGAIN_LATER = 1013,\n  /** Message wasn't understood, disconnect */\n  INVALID_MESSAGE_FORMAT = 4000,\n  /** Server refused to allow connection. Re-authorizing won't help. Disconnect. In spirit akin to HTTP 403 */\n  NOT_ALLOWED = 4001,\n  /** Unused */\n  MAX_NUMBER_OF_MESSAGES_PER_SECONDS = 4002,\n  /** Unused */\n  MAX_NUMBER_OF_CONCURRENT_CONNECTIONS = 4003,\n  /** Unused */\n  MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP = 4004,\n  /** Room is full, disconnect */\n  MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM = 4005,\n  /** The room's ID was updated, disconnect */\n  ROOM_ID_UPDATED = 4006,\n  /** The server kicked the connection from the room. */\n  KICKED = 4100,\n  /** The auth token is expired, reauthorize to get a fresh one. In spirit akin to HTTP 401 */\n  TOKEN_EXPIRED = 4109,\n  /** Disconnect immediately */\n  CLOSE_WITHOUT_RETRY = 4999,\n}\n\nexport function shouldDisconnect(code: WebsocketCloseCodes): boolean {\n  return (\n    code === WebsocketCloseCodes.CLOSE_WITHOUT_RETRY ||\n    ((code as number) >= 4000 && (code as number) < 4100)\n  );\n}\n\nexport function shouldReauth(code: WebsocketCloseCodes): boolean {\n  return (code as number) >= 4100 && (code as number) < 4200;\n}\n\nexport function shouldRetryWithoutReauth(code: WebsocketCloseCodes): boolean {\n  return (\n    code === WebsocketCloseCodes.TRY_AGAIN_LATER ||\n    ((code as number) >= 4200 && (code as number) < 4300)\n  );\n}\n","import { assertNever } from \"./lib/assert\";\nimport { controlledPromise } from \"./lib/controlledPromise\";\nimport type { Observable } from \"./lib/EventSource\";\nimport { makeBufferableEventSource, makeEventSource } from \"./lib/EventSource\";\nimport * as console from \"./lib/fancy-console\";\nimport type { BuiltinEvent, Patchable, Target } from \"./lib/fsm\";\nimport { FSM } from \"./lib/fsm\";\nimport type { Json } from \"./lib/Json\";\nimport { tryParseJson, withTimeout } from \"./lib/utils\";\nimport { ServerMsgCode } from \"./protocol/ServerMsg\";\nimport type {\n  IWebSocketCloseEvent,\n  IWebSocketEvent,\n  IWebSocketInstance,\n  IWebSocketMessageEvent,\n} from \"./types/IWebSocket\";\nimport {\n  shouldDisconnect,\n  shouldReauth,\n  shouldRetryWithoutReauth,\n  WebsocketCloseCodes,\n} from \"./types/IWebSocket\";\n\n/**\n * Returns a human-readable status indicating the current connection status of\n * a Room, as returned by `room.getStatus()`. Can be used to implement\n * a connection status badge.\n */\nexport type Status =\n  | \"initial\"\n  | \"connecting\"\n  | \"connected\"\n  | \"reconnecting\"\n  | \"disconnected\";\n\n/**\n * Whether or not the status is an \"idle\" state. Here, idle means that nothing\n * will happen until some action is taken. Unsurprisingly, these statuses match\n * the start and end states of the state machine.\n */\nexport function isIdle(status: Status): status is \"initial\" | \"disconnected\" {\n  return status === \"initial\" || status === \"disconnected\";\n}\n\n/**\n * Used to report about app-level reconnection issues.\n *\n * Normal (quick) reconnects won't be reported as a \"lost connection\". Instead,\n * the application will only get an event if the reconnection attempts by the\n * client are taking (much) longer than usual. Definitely a situation you want\n * to inform your users about, for example, by throwing a toast message on\n * screen, or show a \"trying to reconnect\" banner.\n */\nexport type LostConnectionEvent =\n  | \"lost\" // the client is trying to reconnect to Liveblocks, but it's taking (much) longer than usual\n  | \"restored\" // the client did reconnect after all\n  | \"failed\"; // the client was told to stop trying\n\n/**\n * Maps internal machine state to the public Status API.\n */\nfunction toNewConnectionStatus(machine: FSM<Context, Event, State>): Status {\n  const state = machine.currentState;\n  switch (state) {\n    case \"@ok.connected\":\n    case \"@ok.awaiting-pong\":\n      return \"connected\";\n\n    case \"@idle.initial\":\n      return \"initial\";\n\n    case \"@auth.busy\":\n    case \"@auth.backoff\":\n    case \"@connecting.busy\":\n    case \"@connecting.backoff\":\n    case \"@idle.zombie\":\n      return machine.context.successCount > 0 ? \"reconnecting\" : \"connecting\";\n\n    case \"@idle.failed\":\n      return \"disconnected\";\n\n    // istanbul ignore next\n    default:\n      return assertNever(state, \"Unknown state\");\n  }\n}\n\n/**\n * Events that can be sent to the machine externally.\n */\ntype Event =\n  // Public events that can be called on the connection manager\n  | { type: \"CONNECT\" } // e.g. when trying to enter a room\n  | { type: \"RECONNECT\" } // e.g. user asking for an explicit reconnect of the socket\n  | { type: \"DISCONNECT\" } // e.g. leaving the room\n  | { type: \"WINDOW_GOT_FOCUS\" } // e.g. user's browser tab is refocused\n  | { type: \"NAVIGATOR_ONLINE\" } // e.g. browser gets back online\n  | { type: \"NAVIGATOR_OFFLINE\" } // e.g. browser goes offline\n\n  // Events that the connection manager will internally deal with\n  | { type: \"PONG\" }\n  | { type: \"EXPLICIT_SOCKET_ERROR\"; event: IWebSocketEvent }\n  | { type: \"EXPLICIT_SOCKET_CLOSE\"; event: IWebSocketCloseEvent }\n\n  // Only used by the E2E testing app, to simulate a pong timeout :(\n  | { type: \"PONG_TIMEOUT\" };\n\ntype State =\n  | \"@idle.initial\"\n  | \"@idle.failed\"\n  | \"@idle.zombie\"\n  | \"@auth.busy\"\n  | \"@auth.backoff\"\n  | \"@connecting.busy\"\n  | \"@connecting.backoff\"\n  | \"@ok.connected\"\n  | \"@ok.awaiting-pong\";\n\n/**\n * Arbitrary record that will be used as the authentication \"authValue\". It's the\n * value that is returned by calling the authentication delegate, and will get\n * passed to the connection factory delegate. This value will be remembered by\n * the connection manager, but its value will not be interpreted, so it can be\n * any value (except null).\n */\nexport type BaseAuthResult = NonNullable<Json>;\n\ntype Context = {\n  /**\n   * Count the number of times the machine reaches an \"@ok.*\" state. Once the\n   * machine reaches idle state again, this count is reset to 0 again.\n   *\n   * This lets us distinguish:\n   * - If successCount = 0, then it's an initial \"connecting\" state.\n   * - If successCount > 0, then it's an \"reconnecting\" state.\n   */\n  successCount: number;\n\n  /**\n   * Will be populated with the last known auth authValue.\n   */\n  authValue: BaseAuthResult | null;\n\n  /**\n   * The current active WebSocket connection to the room. If this is not null\n   * on the context, then the socket has successfully been opened.\n   */\n  socket: IWebSocketInstance | null;\n\n  /**\n   * The current retry delay when automatically retrying. Will get bumped to\n   * the next \"tier\" every time a connection attempt fails. Reset every time\n   * a connection succeeded.\n   */\n  backoffDelay: number;\n};\n\nconst BACKOFF_DELAYS = [250, 500, 1_000, 2_000, 4_000, 8_000, 10_000] as const;\n\n// Resetting the delay happens upon success. We could reset to 0, but that\n// would risk no delay, which generally isn't wise. Instead, we'll reset it to\n// the lowest safe delay minus 1 millisecond. The reason is that every time\n// a retry happens, the retry delay will first be bumped to the next \"tier\".\nconst RESET_DELAY = BACKOFF_DELAYS[0] - 1;\n\n/**\n * Used to back off from WebSocket reconnection attempts after a known\n * Liveblocks issue, like \"room full\" or a \"rate limit\" error.\n */\nconst BACKOFF_DELAYS_SLOW = [2_000, 30_000, 60_000, 300_000] as const;\n\n/**\n * The client will send a PING to the server every 30 seconds, after which it\n * must receive a PONG back within the next 2 seconds. If that doesn't happen,\n * this is interpreted as an implicit connection loss event.\n */\nconst HEARTBEAT_INTERVAL = 30_000;\nconst PONG_TIMEOUT = 2_000;\n\n/**\n * Maximum amount of time that the authentication delegate take to return an\n * auth authValue, or else we consider authentication timed out.\n */\nconst AUTH_TIMEOUT = 10_000;\n\n/**\n * Maximum amount of time that the socket connect delegate may take to return\n * an opened WebSocket connection, or else we consider the attempt timed out.\n */\nconst SOCKET_CONNECT_TIMEOUT = 20_000;\n\n/**\n * Special error class that can be thrown during authentication to stop the\n * connection manager from retrying.\n */\nexport class StopRetrying extends Error {\n  constructor(reason: string) {\n    super(reason);\n  }\n}\n\nfunction nextBackoffDelay(\n  currentDelay: number,\n  delays: readonly number[]\n): number {\n  return (\n    delays.find((delay) => delay > currentDelay) ?? delays[delays.length - 1]\n  );\n}\n\nfunction increaseBackoffDelay(context: Patchable<Context>) {\n  context.patch({\n    backoffDelay: nextBackoffDelay(context.backoffDelay, BACKOFF_DELAYS),\n  });\n}\n\nfunction increaseBackoffDelayAggressively(context: Patchable<Context>) {\n  context.patch({\n    backoffDelay: nextBackoffDelay(context.backoffDelay, BACKOFF_DELAYS_SLOW),\n  });\n}\n\nfunction resetSuccessCount(context: Patchable<Context>) {\n  context.patch({ successCount: 0 });\n}\n\nenum LogLevel {\n  INFO,\n  WARN,\n  ERROR,\n}\n\n/**\n * Generic \"log\" effect. Use it in `effect` handlers of state transitions.\n */\nfunction log(level: LogLevel, message: string) {\n  const logger =\n    level === LogLevel.ERROR\n      ? console.error\n      : level === LogLevel.WARN\n        ? console.warn\n        : /* black hole */ () => {};\n  return () => {\n    logger(message);\n  };\n}\n\nfunction logPrematureErrorOrCloseEvent(e: IWebSocketEvent | Error) {\n  // Produce a useful log message\n  const conn = \"Connection to Liveblocks websocket server\";\n  return (ctx: Readonly<Context>) => {\n    if (isCloseEvent(e)) {\n      console.warn(\n        `${conn} closed prematurely (code: ${e.code}). Retrying in ${ctx.backoffDelay}ms.`\n      );\n    } else {\n      console.warn(`${conn} could not be established.`, e);\n    }\n  };\n}\n\nfunction logCloseEvent(event: IWebSocketCloseEvent) {\n  const details = [`code: ${event.code}`];\n  if (event.reason) {\n    details.push(`reason: ${event.reason}`);\n  }\n  return (ctx: Readonly<Context>) => {\n    console.warn(\n      `Connection to Liveblocks websocket server closed (${details.join(\", \")}). Retrying in ${ctx.backoffDelay}ms.`\n    );\n  };\n}\n\nconst logPermanentClose = log(\n  LogLevel.WARN,\n  \"Connection to WebSocket closed permanently. Won't retry.\"\n);\n\nfunction isCloseEvent(\n  error: IWebSocketEvent | Error\n): error is IWebSocketCloseEvent {\n  return !(error instanceof Error) && error.type === \"close\";\n}\n\nexport type Delegates<T extends BaseAuthResult> = {\n  authenticate: () => Promise<T>;\n  createSocket: (authValue: T) => IWebSocketInstance;\n  canZombie: () => boolean;\n};\n\n// istanbul ignore next\nfunction enableTracing(machine: FSM<Context, Event, State>) {\n  function log(...args: unknown[]) {\n    console.warn(`[FSM #${machine.id}]`, ...args);\n  }\n\n  const unsubs = [\n    machine.events.didReceiveEvent.subscribe((e) => log(`Event ${e.type}`)),\n    machine.events.willTransition.subscribe(({ from, to }) =>\n      log(\"Transitioning\", from, \"→\", to)\n    ),\n    machine.events.didExitState.subscribe(({ state, durationMs }) =>\n      log(`Exited ${state} after ${durationMs.toFixed(0)}ms`)\n    ),\n    machine.events.didIgnoreEvent.subscribe((e) =>\n      log(\"Ignored event\", e.type, e, \"(current state won't handle it)\")\n    ),\n  ];\n  return () => {\n    for (const unsub of unsubs) {\n      unsub();\n    }\n  };\n}\n\nfunction defineConnectivityEvents(machine: FSM<Context, Event, State>) {\n  // Emitted whenever a new WebSocket connection attempt succeeds\n  const statusDidChange = makeEventSource<Status>();\n  const didConnect = makeEventSource<void>();\n  const didDisconnect = makeEventSource<void>();\n\n  let lastStatus: Status | null = null;\n\n  const unsubscribe = machine.events.didEnterState.subscribe(() => {\n    const currStatus = toNewConnectionStatus(machine);\n    if (currStatus !== lastStatus) {\n      statusDidChange.notify(currStatus);\n    }\n\n    if (lastStatus === \"connected\" && currStatus !== \"connected\") {\n      didDisconnect.notify();\n    } else if (lastStatus !== \"connected\" && currStatus === \"connected\") {\n      didConnect.notify();\n    }\n    lastStatus = currStatus;\n  });\n\n  return {\n    statusDidChange: statusDidChange.observable,\n    didConnect: didConnect.observable,\n    didDisconnect: didDisconnect.observable,\n    unsubscribe,\n  };\n}\n\nconst assign = (patch: Partial<Context>) => (ctx: Patchable<Context>) =>\n  ctx.patch(patch);\n\n/**\n * A ConnectionError is a partial data structure to help build a proper\n * LiveblocksError down the line.\n */\ntype ConnectionError = { message: string; code: number };\n\nfunction createConnectionStateMachine<T extends BaseAuthResult>(\n  delegates: Delegates<T>,\n  options: {\n    enableDebugLogging: boolean;\n    /** In protocol V7, the actor will no longer be available on the token.\n     * Instead, the `actor` will be sent to the client via a ROOM_STATE message\n     * over an established WebSocket connection. If this setting is set to\n     * `true`, the state machine will only jump to \"connected\" state _after_\n     * this message has been received. If this setting is `false`, the machine\n     * won't wait for the actor to be received, and instead jump to \"connected\"\n     * as soon as the WebSocket connection is established. */\n    waitForActorId: boolean;\n  }\n) {\n  // Create observable event sources, which this machine will call into when\n  // specific events happen\n  const onMessage = makeBufferableEventSource<IWebSocketMessageEvent>();\n  onMessage.pause(); // Pause all message delivery until status is OPEN\n\n  // Emitted whenever the server deliberately closes the connection for\n  // a specific Liveblocks reason\n  const onConnectionError = makeEventSource<ConnectionError>();\n\n  function fireErrorEvent(message: string, code: number) {\n    return () => {\n      onConnectionError.notify({ message, code });\n    };\n  }\n\n  const initialContext: Context & { authValue: T | null } = {\n    successCount: 0,\n    authValue: null,\n    socket: null,\n    backoffDelay: RESET_DELAY,\n  };\n\n  // The `machine` is the actual finite state machine instance that will\n  // maintain the WebSocket's connection\n  const machine = new FSM<Context, Event, State>(initialContext)\n    .addState(\"@idle.initial\")\n    .addState(\"@idle.failed\")\n    .addState(\"@idle.zombie\")\n    .addState(\"@auth.busy\")\n    .addState(\"@auth.backoff\")\n    .addState(\"@connecting.busy\")\n    .addState(\"@connecting.backoff\")\n    .addState(\"@ok.connected\")\n    .addState(\"@ok.awaiting-pong\");\n\n  //\n  // Configure events that can happen from anywhere\n  //\n  // It's always possible to explicitly get a .reconnect() or .disconnect()\n  // from the user.\n  //\n  machine.addTransitions(\"*\", {\n    RECONNECT: {\n      target: \"@auth.backoff\",\n      effect: [increaseBackoffDelay, resetSuccessCount],\n    },\n\n    DISCONNECT: \"@idle.initial\",\n  });\n\n  //\n  // Configure the @idle.* states\n  //\n  machine\n    .onEnter(\"@idle.*\", resetSuccessCount)\n\n    .addTransitions(\"@idle.*\", {\n      CONNECT: (_, ctx) =>\n        // If we still have a known authValue, try to reconnect to the socket directly,\n        // otherwise, try to obtain a new authValue\n        ctx.authValue !== null ? \"@connecting.busy\" : \"@auth.busy\",\n    });\n\n  //\n  // Configure the @auth.* states\n  //\n  machine\n    .addTransitions(\"@auth.backoff\", {\n      NAVIGATOR_ONLINE: {\n        target: \"@auth.busy\",\n        effect: assign({ backoffDelay: RESET_DELAY }),\n      },\n    })\n    .addTimedTransition(\n      \"@auth.backoff\",\n      (ctx) => ctx.backoffDelay,\n      \"@auth.busy\"\n    )\n\n    .onEnterAsync(\n      \"@auth.busy\",\n\n      () =>\n        withTimeout(\n          delegates.authenticate(),\n          AUTH_TIMEOUT,\n          \"Timed out during auth\"\n        ),\n\n      // On successful authentication\n      (okEvent) => ({\n        target: \"@connecting.busy\",\n        effect: assign({\n          authValue: okEvent.data,\n        }),\n      }),\n\n      // Auth failed\n      (failedEvent) => {\n        if (failedEvent.reason instanceof StopRetrying) {\n          return {\n            target: \"@idle.failed\",\n            effect: [\n              log(LogLevel.ERROR, failedEvent.reason.message),\n              fireErrorEvent(failedEvent.reason.message, -1),\n            ],\n          };\n        }\n\n        return {\n          target: \"@auth.backoff\",\n          effect: [\n            increaseBackoffDelay,\n            log(\n              LogLevel.ERROR,\n              `Authentication failed: ${\n                failedEvent.reason instanceof Error\n                  ? failedEvent.reason.message\n                  : String(failedEvent.reason)\n              }`\n            ),\n          ],\n        };\n      }\n    );\n\n  //\n  // Configure the @connecting.* states\n  //\n\n  // Function references\n  const onSocketError = (event: IWebSocketEvent) =>\n    machine.send({ type: \"EXPLICIT_SOCKET_ERROR\", event });\n\n  const onSocketClose = (event: IWebSocketCloseEvent) =>\n    machine.send({ type: \"EXPLICIT_SOCKET_CLOSE\", event });\n\n  const onSocketMessage = (event: IWebSocketMessageEvent) =>\n    event.data === \"pong\"\n      ? machine.send({ type: \"PONG\" })\n      : onMessage.notify(event);\n\n  function teardownSocket(socket: IWebSocketInstance | null) {\n    if (socket) {\n      socket.removeEventListener(\"error\", onSocketError);\n      socket.removeEventListener(\"close\", onSocketClose);\n      socket.removeEventListener(\"message\", onSocketMessage);\n      socket.close();\n    }\n  }\n\n  machine\n    .addTransitions(\"@connecting.backoff\", {\n      NAVIGATOR_ONLINE: {\n        target: \"@connecting.busy\",\n        effect: assign({ backoffDelay: RESET_DELAY }),\n      },\n    })\n    .addTimedTransition(\n      \"@connecting.backoff\",\n      (ctx) => ctx.backoffDelay,\n      \"@connecting.busy\"\n    )\n\n    .onEnterAsync(\n      \"@connecting.busy\",\n\n      //\n      // Use the \"createSocket\" delegate function (provided to the\n      // ManagedSocket) to create the actual WebSocket connection instance.\n      // Then, set up all the necessary event listeners, and wait for the\n      // \"open\" event to occur.\n      //\n      // When the \"open\" event happens, we're ready to transition to the\n      // OK state. This is done by resolving the Promise.\n      //\n      async (ctx, signal) => {\n        const socketEpoch = performance.now();\n        let socketOpenAt: number | null = null;\n\n        let capturedPrematureEvent: IWebSocketEvent | null = null;\n        let unconfirmedSocket: IWebSocketInstance | null = null;\n\n        const connect$ = new Promise<[IWebSocketInstance, () => void]>(\n          (resolve, rej) => {\n            // istanbul ignore next\n            if (ctx.authValue === null) {\n              throw new Error(\"No auth authValue\"); // This should never happen\n            }\n\n            const socket = delegates.createSocket(ctx.authValue as T);\n            unconfirmedSocket = socket;\n\n            function reject(event: IWebSocketEvent) {\n              capturedPrematureEvent = event;\n              socket.removeEventListener(\"message\", onSocketMessage);\n              rej(event);\n            }\n\n            const [actor$, didReceiveActor] = controlledPromise<void>();\n            if (!options.waitForActorId) {\n              // Mark the promise as \"resolved\" immediately, so we won't wait\n              // for a ROOM_STATE message to happen.\n              didReceiveActor();\n            }\n\n            /** Waits until actor is received (from the ROOM_STATE message) */\n            function waitForActorId(event: IWebSocketMessageEvent) {\n              const serverMsg = tryParseJson(event.data as string) as\n                | Record<string, Json>\n                | undefined;\n              if (serverMsg?.type === ServerMsgCode.ROOM_STATE) {\n                if (options.enableDebugLogging && socketOpenAt !== null) {\n                  const elapsed = performance.now() - socketOpenAt;\n                  console.warn(\n                    `[FSM #${machine.id}] Socket open → ROOM_STATE: ${elapsed.toFixed(0)}ms`\n                  );\n                }\n                didReceiveActor();\n              }\n            }\n\n            //\n            // Part 1:\n            // The `error` and `close` event handlers marked (*) are installed\n            // here only temporarily, just to handle this promise-based state.\n            // When those get triggered, we reject this promise.\n            //\n            socket.addEventListener(\"message\", onSocketMessage);\n            if (options.waitForActorId) {\n              socket.addEventListener(\"message\", waitForActorId);\n            }\n            socket.addEventListener(\"error\", reject); // (*)\n            socket.addEventListener(\"close\", reject); // (*)\n            socket.addEventListener(\"open\", () => {\n              socketOpenAt = performance.now();\n              if (options.enableDebugLogging) {\n                const elapsed = socketOpenAt - socketEpoch;\n                console.warn(\n                  `[FSM #${machine.id}] Socket epoch → open: ${elapsed.toFixed(0)}ms`\n                );\n              }\n\n              //\n              // Part 2:\n              // The \"open\" event just fired, so the server accepted our\n              // attempt to connect. We'll go on and resolve() our promise as\n              // a result.\n              //\n              // However, we cannot safely remove our error/close rejection\n              // handlers _just yet_. There is a small, unlikely-but-possible\n              // edge case: if (and only if) any close/error events are\n              // _already_ queued up in the event queue before this handler is\n              // invoked, then those will fire before our promise will be\n              // resolved.\n              //\n              // Scenario:\n              // - Event queue is empty, listeners are installed\n              // - Two events synchronously get scheduled in the event queue: [<open event>, <close event>]\n              // - The open handler is invoked (= this very callback)\n              // - Event queue now looks like: [<close event>]\n              // - We happily continue and resolve the promise\n              // - Event queue now looks like: [<close event>, <our resolved promise>]\n              // - Close event handler fires, but we already resolved promise! 😣\n              //\n              // This is what's called a \"premature\" event here, we'll deal\n              // with it in part 3.\n              //\n              socket.addEventListener(\"error\", onSocketError);\n              socket.addEventListener(\"close\", onSocketClose);\n              const unsub = () => {\n                socket.removeEventListener(\"error\", reject); // Remove (*)\n                socket.removeEventListener(\"close\", reject); // Remove (*)\n                socket.removeEventListener(\"message\", waitForActorId);\n              };\n\n              // Resolve the promise only once we received the actor ID from\n              // the server. This will act like a traffic light, going green\n              // only once the actor is received. If the machine is configured\n              // not to wait for the actor, the traffic light will already be\n              // green.\n              // All messages received in the mean time while waiting for the\n              // green light will be played back to the client after the\n              // transition to \"connected\".\n              void actor$.then(() => {\n                resolve([socket, unsub]);\n              });\n            });\n          }\n        );\n\n        return withTimeout(\n          connect$,\n          SOCKET_CONNECT_TIMEOUT,\n          \"Timed out during websocket connection\"\n        )\n          .then(\n            //\n            // Part 3:\n            // By now, our \"open\" event has fired, and the promise has been\n            // resolved. Two possible scenarios:\n            //\n            // 1. The happy path. Most likely.\n            // 2. Uh-oh. A premature close/error event has been observed. Let's\n            //    reject the promise after all.\n            //\n            // Any close/error event that will get scheduled after this point\n            // onwards, will be caught in the OK state, and dealt with\n            // accordingly.\n            //\n            ([socket, unsub]) => {\n              unsub();\n\n              if (signal.aborted) {\n                // Trigger cleanup logic in .catch() below. At this point, the\n                // promise is already cancelled, so none of the ok/err\n                // transitions will take place.\n                throw new Error(\"Aborted\");\n              }\n\n              if (capturedPrematureEvent) {\n                throw capturedPrematureEvent; // Take failure transition\n              }\n\n              return socket;\n            }\n          )\n          .catch((e) => {\n            teardownSocket(unconfirmedSocket);\n            throw e;\n          });\n      },\n\n      // Only transition to OK state after a successfully opened WebSocket connection\n      (okEvent) => ({\n        target: \"@ok.connected\",\n        effect: assign({\n          socket: okEvent.data,\n          backoffDelay: RESET_DELAY,\n        }),\n      }),\n\n      // If the WebSocket connection cannot be established\n      (failure) => {\n        const err = failure.reason as IWebSocketEvent | StopRetrying | Error;\n\n        // Stop retrying if this promise explicitly tells us so. This should,\n        // in the case of a WebSocket connection attempt only be the case if\n        // there is a configuration error.\n        if (err instanceof StopRetrying) {\n          return {\n            target: \"@idle.failed\",\n            effect: [\n              log(LogLevel.ERROR, err.message),\n              fireErrorEvent(err.message, -1),\n            ],\n          };\n        }\n\n        // If the server actively refuses the connection attempt, stop trying.\n        if (isCloseEvent(err)) {\n          // The default fall-through behavior is going to be reauthorizing\n          // with a back-off strategy. If we know the token was expired however\n          // we can reauthorize immediately (without back-off).\n          if (err.code === WebsocketCloseCodes.TOKEN_EXPIRED) {\n            return \"@auth.busy\";\n          }\n\n          if (shouldRetryWithoutReauth(err.code)) {\n            // Retry after backoff, but don't get a new token\n            return {\n              target: \"@connecting.backoff\",\n              effect: [\n                increaseBackoffDelayAggressively,\n                logPrematureErrorOrCloseEvent(err),\n              ],\n            };\n          }\n\n          // If the token was not allowed we can stop trying because getting\n          // another token for the same user won't help\n          if (shouldDisconnect(err.code)) {\n            return {\n              target: \"@idle.failed\",\n              effect: [\n                log(LogLevel.ERROR, err.reason),\n                fireErrorEvent(err.reason, err.code),\n              ],\n            };\n          }\n        }\n\n        // In all other (unknown) cases, always re-authenticate (but after a back-off)\n        return {\n          target: \"@auth.backoff\",\n          effect: [increaseBackoffDelay, logPrematureErrorOrCloseEvent(err)],\n        };\n      }\n    );\n\n  //\n  // Configure the @ok.* states\n  //\n  // Keeps a heartbeat alive with the server whenever in the @ok.* state group.\n  // 30 seconds after entering the \"@ok.connected\" state, it will emit\n  // a heartbeat, and awaits a PONG back that should arrive within 2 seconds.\n  // If this happens, then it transitions back to normal \"connected\" state, and\n  // the cycle repeats. If the PONG is not received timely, then we interpret\n  // it as an implicit connection loss, and transition to reconnect (throw away\n  // this socket, and open a new one).\n  //\n\n  const sendHeartbeat: Target<Context, Event | BuiltinEvent, State> = {\n    target: \"@ok.awaiting-pong\",\n    effect: (ctx) => {\n      ctx.socket?.send(\"ping\");\n    },\n  };\n\n  const maybeHeartbeat: Target<Context, Event | BuiltinEvent, State> = () => {\n    // If the browser tab isn't visible currently, ask the application if going\n    // zombie is fine\n    const doc = typeof document !== \"undefined\" ? document : undefined;\n    const canZombie =\n      doc?.visibilityState === \"hidden\" && delegates.canZombie();\n    return canZombie ? \"@idle.zombie\" : sendHeartbeat;\n  };\n\n  machine\n    .addTimedTransition(\"@ok.connected\", HEARTBEAT_INTERVAL, maybeHeartbeat)\n    .addTransitions(\"@ok.connected\", {\n      NAVIGATOR_OFFLINE: maybeHeartbeat, // Don't take the browser's word for it when it says it's offline. Do a ping/pong to make sure.\n      WINDOW_GOT_FOCUS: sendHeartbeat,\n    });\n\n  machine.addTransitions(\"@idle.zombie\", {\n    WINDOW_GOT_FOCUS: \"@connecting.backoff\", // When in zombie state, the client will try to wake up automatically when the window regains focus\n  });\n\n  machine\n    .onEnter(\"@ok.*\", (ctx) => {\n      ctx.patch({ successCount: ctx.successCount + 1 });\n\n      const timerID = setTimeout(\n        // On the next tick, start delivering all messages that have already\n        // been received, and continue synchronous delivery of all future\n        // incoming messages.\n        onMessage.unpause,\n        0\n      );\n\n      // ...but when *leaving* OK state, always tear down the old socket. It's\n      // no longer valid.\n      return (ctx) => {\n        teardownSocket(ctx.socket);\n        ctx.patch({ socket: null });\n        clearTimeout(timerID);\n        onMessage.pause();\n      };\n    })\n\n    .addTransitions(\"@ok.awaiting-pong\", { PONG: \"@ok.connected\" })\n    .addTimedTransition(\"@ok.awaiting-pong\", PONG_TIMEOUT, {\n      target: \"@connecting.busy\",\n      // Log implicit connection loss and drop the current open socket\n      effect: log(\n        LogLevel.WARN,\n        \"Received no pong from server, assume implicit connection loss.\"\n      ),\n    })\n\n    .addTransitions(\"@ok.*\", {\n      // When a socket receives an error, this can cause the closing of the\n      // socket, or not. So always check to see if the socket is still OPEN or\n      // not. When still OPEN, don't transition.\n      EXPLICIT_SOCKET_ERROR: (_, context) => {\n        if (context.socket?.readyState === 1 /* WebSocket.OPEN */) {\n          // TODO Do we need to forward this error to the client?\n          return null; /* Do not leave OK state, socket is still usable */\n        }\n\n        return {\n          target: \"@connecting.backoff\",\n          effect: increaseBackoffDelay,\n        };\n      },\n\n      EXPLICIT_SOCKET_CLOSE: (e) => {\n        // Server instructed us to stop retrying, so move to failed state\n        if (shouldDisconnect(e.event.code)) {\n          return {\n            target: \"@idle.failed\",\n            effect: [\n              logPermanentClose,\n              fireErrorEvent(e.event.reason, e.event.code),\n            ],\n          };\n        }\n\n        if (shouldReauth(e.event.code)) {\n          if (e.event.code === WebsocketCloseCodes.TOKEN_EXPIRED) {\n            // Token expiry is a special case, we can reauthorize immediately\n            // (without back-off)\n            return \"@auth.busy\";\n          } else {\n            return {\n              target: \"@auth.backoff\",\n              effect: [increaseBackoffDelay, logCloseEvent(e.event)],\n            };\n          }\n        }\n\n        if (shouldRetryWithoutReauth(e.event.code)) {\n          // If this is a custom Liveblocks server close reason, back off more\n          // aggressively, and emit a Liveblocks error event...\n          return {\n            target: \"@connecting.backoff\",\n            effect: [increaseBackoffDelayAggressively, logCloseEvent(e.event)],\n          };\n        }\n\n        // Consider any other close event a temporary network hiccup, and retry\n        // after a normal backoff delay\n        return {\n          target: \"@connecting.backoff\",\n          effect: [increaseBackoffDelay, logCloseEvent(e.event)],\n        };\n      },\n    });\n\n  // Lastly, register an event handler to listen for window-focus events as\n  // soon as the machine starts, and use it to send itself \"WINDOW_GOT_FOCUS\"\n  // events.\n  if (typeof document !== \"undefined\") {\n    const doc = typeof document !== \"undefined\" ? document : undefined;\n    const win = typeof window !== \"undefined\" ? window : undefined;\n    const root = win ?? doc;\n\n    machine.onEnter(\"*\", (ctx) => {\n      function onNetworkOffline() {\n        machine.send({ type: \"NAVIGATOR_OFFLINE\" });\n      }\n\n      function onNetworkBackOnline() {\n        machine.send({ type: \"NAVIGATOR_ONLINE\" });\n      }\n\n      function onVisibilityChange() {\n        if (doc?.visibilityState === \"visible\") {\n          machine.send({ type: \"WINDOW_GOT_FOCUS\" });\n        }\n      }\n\n      win?.addEventListener(\"online\", onNetworkBackOnline);\n      win?.addEventListener(\"offline\", onNetworkOffline);\n      root?.addEventListener(\"visibilitychange\", onVisibilityChange);\n      return () => {\n        root?.removeEventListener(\"visibilitychange\", onVisibilityChange);\n        win?.removeEventListener(\"online\", onNetworkBackOnline);\n        win?.removeEventListener(\"offline\", onNetworkOffline);\n\n        // Also tear down the old socket when stopping the machine, if there is one\n        teardownSocket(ctx.socket);\n      };\n    });\n  }\n\n  const cleanups = [];\n\n  const { statusDidChange, didConnect, didDisconnect, unsubscribe } =\n    defineConnectivityEvents(machine);\n  cleanups.push(unsubscribe);\n\n  // Install debug logging\n  // istanbul ignore next\n  if (options.enableDebugLogging) {\n    cleanups.push(enableTracing(machine));\n  }\n\n  // Start the machine\n  machine.start();\n\n  return {\n    machine,\n    cleanups,\n\n    // Observable events that will be emitted by this machine\n    events: {\n      statusDidChange,\n      didConnect,\n      didDisconnect,\n      onMessage: onMessage.observable,\n      onConnectionError: onConnectionError.observable,\n    },\n  };\n}\n\n/**\n * The ManagedSocket will set up a WebSocket connection to a room, and maintain\n * that connection over time.\n *\n * It's a light wrapper around the actual FSM that implements the logic,\n * exposing just a few safe actions and events that can be called or observed\n * from the outside.\n */\nexport class ManagedSocket<T extends BaseAuthResult> {\n  #machine: FSM<Context, Event, State>;\n  #cleanups: (() => void)[];\n\n  public readonly events: {\n    /**\n     * Emitted when the WebSocket connection goes in or out of \"connected\"\n     * state.\n     */\n    readonly statusDidChange: Observable<Status>;\n    /**\n     * Emitted when the WebSocket connection is first opened.\n     */\n    readonly didConnect: Observable<void>;\n    /**\n     * Emitted when the current WebSocket connection is lost and the socket\n     * becomes useless. A new WebSocket connection must be made after this to\n     * restore connectivity.\n     */\n    readonly didDisconnect: Observable<void>; // Deliberate close, a connection loss, etc.\n\n    /**\n     * Emitted for every incoming message from the currently active WebSocket\n     * connection.\n     */\n    readonly onMessage: Observable<IWebSocketMessageEvent>;\n\n    /**\n     * Emitted whenever a connection gets closed for a known error reason, e.g.\n     * max number of connections, max number of messages, etc.\n     */\n    readonly onConnectionError: Observable<ConnectionError>;\n  };\n\n  constructor(\n    delegates: Delegates<T>,\n    enableDebugLogging: boolean = false,\n    waitForActorId: boolean = true\n  ) {\n    const { machine, events, cleanups } = createConnectionStateMachine(\n      delegates,\n      { waitForActorId, enableDebugLogging }\n    );\n    this.#machine = machine;\n    this.events = events;\n    this.#cleanups = cleanups;\n  }\n\n  getStatus(): Status {\n    try {\n      return toNewConnectionStatus(this.#machine);\n    } catch {\n      return \"initial\";\n    }\n  }\n\n  /**\n   * Returns the current auth authValue.\n   */\n  get authValue(): T | null {\n    return this.#machine.context.authValue as T | null;\n  }\n\n  /**\n   * Call this method to try to connect to a WebSocket. This only has an effect\n   * if the machine is idle at the moment, otherwise this is a no-op.\n   */\n  public connect(): void {\n    this.#machine.send({ type: \"CONNECT\" });\n  }\n\n  /**\n   * If idle, will try to connect. Otherwise, it will attempt to reconnect to\n   * the socket, potentially obtaining a new authValue first, if needed.\n   */\n  public reconnect(): void {\n    this.#machine.send({ type: \"RECONNECT\" });\n  }\n\n  /**\n   * Call this method to disconnect from the current WebSocket. Is going to be\n   * a no-op if there is no active connection.\n   */\n  public disconnect(): void {\n    this.#machine.send({ type: \"DISCONNECT\" });\n  }\n\n  /**\n   * Call this to stop the machine and run necessary cleanup functions. After\n   * calling destroy(), you can no longer use this instance. Call this before\n   * letting the instance get garbage collected.\n   */\n  public destroy(): void {\n    this.#machine.stop();\n\n    let cleanup: (() => void) | undefined;\n    while ((cleanup = this.#cleanups.pop())) {\n      cleanup();\n    }\n  }\n\n  /**\n   * Safely send a message to the current WebSocket connection. Will emit a log\n   * message if this is somehow impossible.\n   */\n  public send(data: string): void {\n    const socket = this.#machine.context?.socket;\n    if (socket === null) {\n      console.warn(\"Cannot send: not connected yet\", data);\n    } else if (socket.readyState !== 1 /* WebSocket.OPEN */) {\n      console.warn(\"Cannot send: WebSocket no longer open\", data);\n    } else {\n      socket.send(data);\n    }\n  }\n\n  /**\n   * NOTE: Used by the E2E app only, to simulate explicit events.\n   * Not ideal to keep exposed :(\n   */\n  public _privateSendMachineEvent(event: Event): void {\n    this.#machine.send(event);\n  }\n}\n","/**\n * Use this symbol to brand an object property as internal.\n *\n * @example\n * Object.defineProperty(\n *   {\n *     public,\n *     [kInternal]: {\n *       private\n *     },\n *   },\n *   kInternal,\n *   {\n *     enumerable: false,\n *   }\n * );\n */\nexport const kInternal = Symbol();\n","import type { JsonObject } from \"./Json\";\nimport { tryParseJson } from \"./utils\";\n\nconst EMPTY_OBJECT = Object.freeze({}) as JsonObject;\n\n// Characters that can end partial keywords: n, u, l, t, r, e, f, a, s\nconst NULL_KEYWORD_CHARS = Array.from(new Set(\"null\"));\nconst TRUE_KEYWORD_CHARS = Array.from(new Set(\"true\"));\nconst FALSE_KEYWORD_CHARS = Array.from(new Set(\"false\"));\nconst ALL_KEYWORD_CHARS = Array.from(new Set(\"nulltruefalse\"));\n\n/**\n * Strips the last character from `str` if it is one of the chars in the given\n * `chars` string.\n */\nfunction stripChar(str: string, chars: string): string {\n  const lastChar = str[str.length - 1];\n  if (chars.includes(lastChar)) {\n    return str.slice(0, -1);\n  }\n  return str;\n}\n\nexport class IncrementalJsonParser {\n  // Input\n  #sourceText: string = \"\";\n\n  // Output\n  #cachedJson?: JsonObject;\n\n  /** How much we've already parsed */\n  #scanIndex: number = 0;\n  /** Whether the last char processed was a backslash */\n  #escaped: boolean = false;\n  /**\n   * Start position of the last unterminated string, -1 if we're not inside\n   * a string currently.\n   *\n   * Example: '{\"a\": \"foo'\n   *                 ^\n   */\n  #lastUnterminatedString: number = -1;\n  /**\n   * Start position of the last fully terminated string we've seen.\n   *\n   * Example: '{\"a\": \"foo'\n   *            ^\n   */\n  #lastTerminatedString: number = -1;\n  /** The bracket stack of expected closing chars. For input '{\"a\": [\"foo', the stack would be ['}', ']']. */\n  #stack: string[] = [];\n\n  constructor(text: string = \"\") {\n    this.append(text);\n  }\n\n  get source(): string {\n    return this.#sourceText;\n  }\n\n  get json(): JsonObject {\n    if (this.#cachedJson === undefined) {\n      this.#cachedJson = this.#parse();\n    }\n    return this.#cachedJson;\n  }\n\n  /** Whether we're currently inside an unterminated string, e.g. '{\"hello' */\n  get #inString(): boolean {\n    return this.#lastUnterminatedString >= 0;\n  }\n\n  append(delta: string): void {\n    if (delta) {\n      // Trim leading whitespace only on the first delta\n      if (this.#sourceText === \"\") {\n        delta = delta.trimStart();\n      }\n      this.#sourceText += delta;\n      this.#cachedJson = undefined; // Invalidate the cache\n    }\n  }\n\n  #autocompleteTail(output: string): string {\n    // Complete unambiguous partial JSON keywords,\n    // e.g. '{\"a\": -' → '{\"a\": -0'\n    //      '{\"a\": n' → '{\"a\": null'\n    //      '{\"a\": t' → '{\"a\": true'\n    //      '{\"a\": f' → '{\"a\": false'\n\n    if (this.#inString) {\n      return \"\"; // Don't complete anything if we're in an unterminated string\n    }\n\n    const lastChar = output.charAt(output.length - 1);\n    if (lastChar === \"\") return \"\";\n\n    // Handle incomplete negative numbers\n    if (lastChar === \"-\") {\n      return \"0\"; // Complete to -0\n    }\n\n    // Skip keyword completion for most characters that can't be part of keywords\n    if (!ALL_KEYWORD_CHARS.includes(lastChar)) return \"\";\n\n    // Check the last few characters directly\n    if (NULL_KEYWORD_CHARS.includes(lastChar)) {\n      if (output.endsWith(\"nul\")) return \"l\";\n      if (output.endsWith(\"nu\")) return \"ll\";\n      if (output.endsWith(\"n\")) return \"ull\";\n    }\n\n    if (TRUE_KEYWORD_CHARS.includes(lastChar)) {\n      if (output.endsWith(\"tru\")) return \"e\";\n      if (output.endsWith(\"tr\")) return \"ue\";\n      if (output.endsWith(\"t\")) return \"rue\";\n    }\n\n    if (FALSE_KEYWORD_CHARS.includes(lastChar)) {\n      if (output.endsWith(\"fals\")) return \"e\";\n      if (output.endsWith(\"fal\")) return \"se\";\n      if (output.endsWith(\"fa\")) return \"lse\";\n      if (output.endsWith(\"f\")) return \"alse\";\n    }\n\n    return \"\";\n  }\n\n  /**\n   * Updates the internal parsing state by processing any new content\n   * that has been appended since the last parse. This updates the state with\n   * facts only. Any interpretation is left to the #parse() method.\n   */\n  #catchup(): void {\n    const newContent = this.#sourceText.slice(this.#scanIndex);\n\n    // Update internal parsing state by processing only the new content character by character\n    for (let i = 0; i < newContent.length; i++) {\n      const ch = newContent[i];\n      const absolutePos = this.#scanIndex + i;\n\n      if (this.#inString) {\n        if (this.#escaped) {\n          this.#escaped = false;\n        } else if (ch === \"\\\\\") {\n          this.#escaped = true;\n        } else if (ch === '\"') {\n          this.#lastTerminatedString = this.#lastUnterminatedString; // Save the terminated string's start\n          this.#lastUnterminatedString = -1; // Exit string\n        }\n      } else {\n        if (ch === '\"') {\n          this.#lastUnterminatedString = absolutePos; // Enter string\n        } else if (ch === \"{\") {\n          this.#stack.push(\"}\");\n        } else if (ch === \"[\") {\n          this.#stack.push(\"]\");\n        } else if (\n          ch === \"}\" &&\n          this.#stack.length > 0 &&\n          this.#stack[this.#stack.length - 1] === \"}\"\n        ) {\n          this.#stack.pop();\n        } else if (\n          ch === \"]\" &&\n          this.#stack.length > 0 &&\n          this.#stack[this.#stack.length - 1] === \"]\"\n        ) {\n          this.#stack.pop();\n        }\n      }\n    }\n\n    this.#scanIndex = this.#sourceText.length;\n  }\n\n  #parse(): JsonObject {\n    this.#catchup();\n\n    let result = this.#sourceText; // Already trimmed on first append\n\n    if (result.charAt(0) !== \"{\") {\n      // Not an object, don't even try to parse it\n      return EMPTY_OBJECT;\n    }\n\n    // If it's already valid JSON, return as-is\n    if (result.endsWith(\"}\")) {\n      const quickCheck = tryParseJson(result);\n      if (quickCheck) {\n        // Due to the '{' check above, we can safely assume it's an object\n        return quickCheck as JsonObject;\n      }\n    }\n\n    // Fix unterminated strings by appending a '\"' if needed\n    // Use our tracked state instead of recalculating\n    if (this.#inString) {\n      // If we're in an escaped state (last char was \\), remove that incomplete escape\n      if (this.#escaped) {\n        result = result.slice(0, -1); // Remove the trailing backslash\n      }\n      result += '\"';\n    }\n\n    // If the last char is a ',' or '.', we can strip it, because it won't\n    // change the value. Trim whitespace first, then check for comma/period.\n    result = result.trimEnd();\n    result = stripChar(result, \",.\");\n\n    // Complete partial keywords at the end (if umambiguous)\n    result = result + this.#autocompleteTail(result);\n\n    // Use the bracket stack to compute the suffix\n    const suffix = this.#stack.reduceRight((acc, ch) => acc + ch, \"\");\n\n    // Attempt to \"just\" add the missing ] and }'s.\n    {\n      const attempt = tryParseJson(result + suffix);\n      if (attempt) {\n        // If it parses, return the result\n        return attempt as JsonObject;\n      }\n    }\n\n    // If there is a parse failure above, it's likely because we're missing\n    // a \"value\" for a key in an object.\n\n    if (this.#inString) {\n      // We're in an unterminated string, just remove it - e.g. '{\"abc'\n      result = result.slice(0, this.#lastUnterminatedString);\n    } else {\n      // If the last char is a \":\", just remove it - e.g. '{\"abc\"' or '{\"abc\":'\n      result = stripChar(result, \":\");\n\n      // If the last char is a '\"', remove that last string\n      if (result.endsWith('\"')) {\n        result = result.slice(0, this.#lastTerminatedString);\n      }\n    }\n\n    // If the last char now is a trailing comma, strip it\n    result = stripChar(result, \",\");\n\n    // Re-add the missing brackets/braces\n    result += suffix;\n\n    // Run JSON.parse on the result again. it should now work!\n    return (tryParseJson(result) as JsonObject | undefined) ?? EMPTY_OBJECT; // Still invalid JSON\n  }\n}\n","import { isPlainObject } from \"./guards\";\n\nfunction shallowArray(xs: unknown[], ys: unknown[]): boolean {\n  if (xs.length !== ys.length) {\n    return false;\n  }\n\n  for (let i = 0; i < xs.length; i++) {\n    if (!Object.is(xs[i], ys[i])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction shallowObj(objA: unknown, objB: unknown): boolean {\n  // Only try to compare keys/values if these objects are both \"pojos\" (plain\n  // old JavaScript objects)\n  if (!isPlainObject(objA) || !isPlainObject(objB)) {\n    return false;\n  }\n\n  const keysA = Object.keys(objA);\n  if (keysA.length !== Object.keys(objB).length) {\n    return false;\n  }\n\n  return keysA.every(\n    (key) =>\n      Object.prototype.hasOwnProperty.call(objB, key) &&\n      Object.is(objA[key], objB[key])\n  );\n}\n\n/**\n * Shallowly compares two given values.\n *\n * - Two simple values are considered equal if they're strictly equal\n * - Two arrays are considered equal if their members are strictly equal\n * - Two objects are considered equal if their values are strictly equal\n *\n * Testing goes one level deep.\n */\nexport function shallow(a: unknown, b: unknown): boolean {\n  if (Object.is(a, b)) {\n    return true;\n  }\n\n  const isArrayA = Array.isArray(a);\n  const isArrayB = Array.isArray(b);\n  if (isArrayA || isArrayB) {\n    if (!isArrayA || !isArrayB) {\n      return false;\n    }\n\n    return shallowArray(a, b);\n  }\n\n  return shallowObj(a, b);\n}\n\n/**\n * Two-level deep shallow check.\n * Useful for checking equality of { isLoading: false, myData: [ ... ] } like\n * data structures, where you want to do a shallow comparison on the \"data\"\n * key.\n *\n * NOTE: Works on objects only, not on arrays!\n */\nexport function shallow2(a: unknown, b: unknown): boolean {\n  if (!isPlainObject(a) || !isPlainObject(b)) {\n    return shallow(a, b);\n  }\n\n  const keysA = Object.keys(a);\n  if (keysA.length !== Object.keys(b).length) {\n    return false;\n  }\n\n  return keysA.every(\n    (key) =>\n      Object.prototype.hasOwnProperty.call(b, key) && shallow(a[key], b[key])\n  );\n}\n","import { DefaultMap } from \"./DefaultMap\";\nimport { SortedList } from \"./SortedList\";\nimport { raise } from \"./utils\";\n\ntype PK = string;\n\n/**\n * A \"tree pool\" is a data structure that allows for easy insertion, deletion,\n * mutation, sorting, and accessing of an object pool of objects that have\n * tree-like relationships.\n *\n *   const pool = new TreePool<Simpson>(\n *     x => x.id,\n *     x => x.parent,\n *     (a, b) => a.name < b.name,\n *   );\n *\n * The first argument is a function that returns the primary key of an item.\n * The second argument is a function that returns the parent ID for an item (or null if its a root).\n * The third argument is a function that returns how to compare two items, to\n *   return queries in sorted order.\n *\n * To insert elements into the pool:\n *\n *   pool.upsert({ id: \"1\", name: \"Homer\" });\n *   pool.upsert({ id: \"2\", name: \"Marge\" });\n *   pool.upsert({ id: \"3\", name: \"Bart\", parent: \"2\" });\n *   pool.upsert({ id: \"4\", name: \"Lisa\", parent: \"2\" });\n *   pool.upsert({ id: \"5\", name: \"Maggie\", parent: \"2\" });\n *\n * To get all items in the pool:\n *\n *   // Items are sorted by the given comparison function, in this case\n *   // alphabetically, so: Bart, Homer, Lisa, Maggie, Marge\n *   Array.from(pool)  // [{ id: \"3\", name: \"Bart\", parent: \"2\" }, ...]\n *\n * To get all children:\n *\n *   // All kids are added as children of Marge\n *   pool.getChildren(\"1\")  // [] (Homer has no kids)\n *   pool.getChildren(\"2\")  // [Bart, Lisa, Maggie] (= alphabetically)\n *\n * To get all \"roots\":\n *   pool.getChildren(null)  // [Homer, Marge] (= alphabetically)\n *\n * To get all siblings:\n *   pool.getSiblings(\"3\")  // [Lisa, Maggie]\n *   pool.getSiblings(\"4\")  // [Bart, Maggie]\n *   pool.getSiblings(\"5\")  // [Bart, Lisa]\n *\n * A bit weird maybe, but Homer and Marge are siblings in this example:\n *   pool.getSiblings(\"1\")  // [Marge]\n *   pool.getSiblings(\"2\")  // [Homer]\n *\n * Changing data is no problem, as long as the primary key and parent key don't change:\n *   pool.upsert({ id: \"1\", name: \"Homer Simpson\" });\n *   pool.upsert({ id: \"3\", name: \"Bart, son of Marge\", parent: \"2\" });\n *\n * But... this will throw an error:\n *   pool.upsert({ id: \"3\", name: \"Bart, son of Homer\", parent: \"1\" });\n *   //                                                         ^^^\n *   //                                Cannot change parent ID. If you want to ever\n *   //                                do this, remove the entry, and recreate it!\n *\n * XXXX Idea for the API to iterate nodes in this tree in arbitrary ways:\n * Traversal can be done in all directions:\n *   pool.walk(\"4\", \"up\", { includeSelf: true })   // Iterates: Lisa, Marge\n *   pool.walk(\"4\", \"up\", { includeSelf: false })  // Iterates: Marge\n *   pool.walk(\"4\", \"left\")                        // Iterates: Bart    // Prev\n *   pool.walk(\"4\", \"right\")                       // Iterates: Maggie  // Next\n *   pool.walk(\"4\", \"depth-first\")\n *   pool.walk(\"4\", \"breadth-first\")\n *   pool.walk(\"4\", \"depth-first-reversed\")\n *   pool.walk(\"4\", \"breadth-first-reversed\")\n *\n */\nexport class TreePool<T> {\n  #_items: Map<PK, T>;\n  #_childrenOf: DefaultMap</* parent */ PK | null, /* children */ Set<PK>>;\n  #_sorted: SortedList<T>;\n\n  #_primaryKey: (item: T) => PK;\n  #_parentKeyFn: (item: T) => PK | null;\n  #_lt: (a: T, b: T) => boolean;\n\n  constructor(\n    primaryKey: (item: T) => PK,\n    parentKey: (item: T) => PK | null,\n    lt: (a: T, b: T) => boolean\n  ) {\n    this.#_primaryKey = primaryKey;\n    this.#_parentKeyFn = parentKey;\n    this.#_lt = lt;\n\n    this.#_items = new Map();\n    this.#_childrenOf = new DefaultMap(() => new Set());\n    this.#_sorted = SortedList.with(lt);\n  }\n\n  public get(id: PK): T | undefined {\n    return this.#_items.get(id);\n  }\n\n  public getOrThrow(id: PK): T {\n    return this.get(id) ?? raise(`Item with id ${id} not found`);\n  }\n\n  public get sorted(): SortedList<T> {\n    // XXXX While it's fine to expose this SortedList for efficiency, really we\n    // should be exposing it as a readonly value.\n    return this.#_sorted;\n  }\n\n  public getParentId(id: PK): PK | null {\n    const item = this.getOrThrow(id);\n    return this.#_parentKeyFn(item);\n  }\n\n  public getParent(id: PK): T | null {\n    const parentId = this.getParentId(id);\n    return parentId ? this.getOrThrow(parentId) : null;\n  }\n\n  public getChildren(id: PK | null): T[] {\n    const childIds = this.#_childrenOf.get(id);\n    if (!childIds) return [];\n\n    // XXXX Should we return a sorted list here? From previous note: Think about *storing* it as a sorted list here!\n    return Array.from(childIds).map(\n      (id) => this.#_items.get(id)! // eslint-disable-line no-restricted-syntax\n    );\n  }\n\n  public *walkUp(\n    id: PK,\n    predicate?: (item: T) => boolean\n    // options?: { includeSelf?: boolean },\n  ): IterableIterator<T> {\n    // const includeSelf = options?.includeSelf ?? true;\n    const includeSelf = true; // XXXX Generalize\n    let nodeId: PK | null = id;\n    do {\n      const item = this.getOrThrow(nodeId);\n      if (includeSelf || nodeId !== id) {\n        if (!predicate || predicate(item)) {\n          yield item;\n        }\n      }\n      nodeId = this.#_parentKeyFn(item);\n    } while (nodeId !== null);\n  }\n\n  // XXXX Generalize\n  public *walkLeft(\n    id: PK,\n    predicate?: (item: T) => boolean\n  ): IterableIterator<T> {\n    // XXXX Calling getSiblings is too inefficient, optimize later!\n    // XXXX But first make it work\n    const self = this.getOrThrow(id);\n    const siblings = SortedList.from(this.getSiblings(id), this.#_lt);\n    for (const sibling of siblings.iterReversed()) {\n      // Skip over all the \"right\" siblings\n      if (this.#_lt(self, sibling)) continue;\n\n      // If we get here, it's a \"left\" sibling\n      if (!predicate || predicate(sibling)) {\n        yield sibling;\n      }\n    }\n  }\n\n  // XXXX Generalize\n  public *walkRight(\n    id: PK,\n    predicate?: (item: T) => boolean\n  ): IterableIterator<T> {\n    // XXXX Calling getSiblings is too inefficient, optimize later!\n    // XXXX But first make it work\n    const self = this.getOrThrow(id);\n    const siblings = SortedList.from(this.getSiblings(id), this.#_lt);\n    for (const sibling of siblings) {\n      // Skip over all the \"left\" siblings\n      if (this.#_lt(sibling, self)) continue;\n\n      // If we get here, it's a \"right\" sibling\n      if (!predicate || predicate(sibling)) {\n        yield sibling;\n      }\n    }\n  }\n\n  // XXXX Generalize\n  public *walkDown(\n    id: PK,\n    predicate?: (item: T) => boolean\n    // _direction?: \"depth-first\",\n    // _reversed?: true\n    // | \"depth-first\"\n    // | \"breadth-first\"\n    // | \"breadth-first-rev\"\n    // options?: {\n    //   _direction: \"depth-first\";\n    //   _reversed: true;\n    //   // _includeSelf?: boolean;\n    // }\n  ): IterableIterator<T> {\n    const children = SortedList.from(this.getChildren(id), this.#_lt).rawArray;\n    for (let i = children.length - 1; i >= 0; i--) {\n      const child = children[i];\n      yield* this.walkDown(\n        this.#_primaryKey(child),\n        predicate\n        // \"depth-first\",\n        // true\n      );\n      if (!predicate || predicate(child)) {\n        yield child;\n      }\n    }\n\n    // if (options?.includeSelf) {\n    //   yield this.getOrThrow(id);\n    // }\n  }\n\n  /** Returns all siblings, not including the item itself. */\n  public getSiblings(id: PK): readonly T[] {\n    const self = this.getOrThrow(id);\n    const parentId = this.getParentId(id);\n    return this.getChildren(parentId).filter((item) => item !== self);\n  }\n\n  public [Symbol.iterator](): IterableIterator<T> {\n    return this.#_sorted[Symbol.iterator]();\n  }\n\n  public upsert(item: T): void {\n    const pk = this.#_primaryKey(item);\n    const existing = this.#_items.get(pk);\n    if (existing) {\n      // Allow upserts if the parent ID hasn't changed, otherwise, remove the\n      // entry and replace it with the new item\n      if (this.#_parentKeyFn(existing) !== this.#_parentKeyFn(item)) {\n        throw new Error(\n          \"Cannot upsert parent ID changes that change the tree structure. Remove the entry first, and recreate it\"\n        );\n      }\n\n      this.#_sorted.remove(existing);\n    }\n\n    this.#_items.set(pk, item);\n    this.#_sorted.add(item);\n\n    const parentId = this.#_parentKeyFn(item);\n    this.#_childrenOf.getOrCreate(parentId).add(pk);\n  }\n\n  public remove(pk: PK): boolean {\n    const item = this.#_items.get(pk);\n    if (!item) return false;\n\n    const childIds = this.#_childrenOf.get(pk);\n    if (childIds) {\n      throw new Error(\n        `Cannot remove item '${pk}' while it still has children. Remove children first.`\n      );\n    }\n\n    const parentId = this.#_parentKeyFn(item);\n    const siblings = this.#_childrenOf.get(parentId);\n    if (siblings) {\n      siblings.delete(pk);\n      if (siblings.size === 0) {\n        this.#_childrenOf.delete(parentId);\n      }\n    }\n\n    this.#_sorted.remove(item);\n    this.#_childrenOf.delete(pk);\n    this.#_items.delete(pk);\n    return true;\n  }\n\n  public clear(): boolean {\n    if (this.#_items.size === 0) return false;\n\n    this.#_childrenOf.clear();\n    this.#_items.clear();\n    this.#_sorted.clear();\n    return true;\n  }\n}\n","import { AiChatDB } from \"./AiChatDB\";\nimport { getBearerTokenFromAuthValue } from \"./api-client\";\nimport type { AuthValue } from \"./auth-manager\";\nimport type { Delegates, Status } from \"./connection\";\nimport { ManagedSocket, StopRetrying } from \"./connection\";\nimport { kInternal } from \"./internal\";\nimport { assertNever } from \"./lib/assert\";\nimport { Promise_withResolvers } from \"./lib/controlledPromise\";\nimport { DefaultMap } from \"./lib/DefaultMap\";\nimport * as console from \"./lib/fancy-console\";\nimport { isDefined } from \"./lib/guards\";\nimport { IncrementalJsonParser } from \"./lib/IncrementalJsonParser\";\nimport type { JsonObject } from \"./lib/Json\";\nimport { nanoid } from \"./lib/nanoid\";\nimport type { Resolve } from \"./lib/Resolve\";\nimport { shallow, shallow2 } from \"./lib/shallow\";\nimport { batch, DerivedSignal, MutableSignal, Signal } from \"./lib/signals\";\nimport { TreePool } from \"./lib/TreePool\";\nimport type { Brand, DistributiveOmit, ISODateString } from \"./lib/utils\";\nimport { findLastIndex, raise, tryParseJson } from \"./lib/utils\";\nimport type {\n  DynamicSessionInfo,\n  OptionalTupleUnless,\n  Polyfills,\n  StaticSessionInfo,\n  TimeoutID,\n} from \"./room\";\nimport type {\n  AbortAiResponse,\n  AiAssistantContentPart,\n  AiAssistantDeltaUpdate,\n  AiAssistantMessage,\n  AiChat,\n  AiChatMessage,\n  AiChatsQuery,\n  AiFailedAssistantMessage,\n  AiGeneratingAssistantMessage,\n  AiGenerationOptions,\n  AiKnowledgeSource,\n  AiReceivingToolInvocationPart,\n  AiToolDescription,\n  AiToolInvocationPart,\n  AiUserContentPart,\n  AiUserMessage,\n  AskInChatResponse,\n  ClearChatResponse,\n  ClientAiMsg,\n  CmdId,\n  CopilotId,\n  CreateChatOptions,\n  DeleteChatResponse,\n  DeleteMessageResponse,\n  GetChatsOptions,\n  GetChatsResponse,\n  GetMessageTreeResponse,\n  GetOrCreateChatResponse,\n  MessageId,\n  ServerAiMsg,\n  SetToolResultResponse,\n  ToolResultResponse,\n} from \"./types/ai\";\nimport type { Awaitable } from \"./types/Awaitable\";\nimport type {\n  InferFromSchema,\n  JSONObjectSchema7,\n} from \"./types/InferFromSchema\";\nimport type {\n  IWebSocket,\n  IWebSocketInstance,\n  IWebSocketMessageEvent,\n} from \"./types/IWebSocket\";\nimport { PKG_VERSION } from \"./version\";\n\n// Server must respond to any command within 4 seconds. Note that this timeout\n// isn't related to the timeout for long-running AI tasks. If a long-running AI\n// task is started, the initial command response from the server is \"okay, I'll\n// keep you posted about this long-running task\". That okay is the response\n// which must happen within 4 seconds. In practice it should only take a few\n// milliseconds at most.\nconst DEFAULT_REQUEST_TIMEOUT = 4_000;\n\nexport type AiToolTypePack<\n  A extends JsonObject = JsonObject,\n  R extends JsonObject = JsonObject,\n> = {\n  A: A;\n  R: R;\n};\n\nexport type AskUserMessageInChatOptions = Omit<AiGenerationOptions, \"tools\">;\n\nexport type SetToolResultOptions = Omit<\n  AiGenerationOptions,\n  \"tools\" | \"knowledge\"\n>;\n\nexport type AiToolInvocationProps<\n  A extends JsonObject,\n  R extends JsonObject,\n> = Resolve<\n  DistributiveOmit<AiToolInvocationPart<A, R>, \"type\"> & {\n    respond: (\n      ...args: OptionalTupleUnless<R, [result: ToolResultResponse<R>]>\n    ) => void;\n\n    /**\n     * These are the inferred types for your tool call which you can pass down\n     * to UI components, like so:\n     *\n     *     <AiTool.Confirmation\n     *       types={types}\n     *       confirm={\n     *         // Now fully type-safe!\n     *         (args) => result\n     *       } />\n     *\n     * This will make your AiTool.Confirmation component aware of the types for\n     * `args` and `result`.\n     */\n    types: AiToolTypePack<A, R>;\n\n    // Private APIs\n    [kInternal]: {\n      execute: AiToolExecuteCallback<A, R> | undefined;\n      messageStatus: AiAssistantMessage[\"status\"];\n    };\n  }\n>;\n\nexport type AiOpaqueToolInvocationProps = AiToolInvocationProps<\n  JsonObject,\n  JsonObject\n>;\n\nexport type AiToolExecuteContext = {\n  name: string;\n  invocationId: string;\n};\n\nexport type AiToolExecuteCallback<\n  A extends JsonObject,\n  R extends JsonObject,\n> = (\n  args: A,\n  context: AiToolExecuteContext\n) => Record<string, never> extends R\n  ? Awaitable<ToolResultResponse<R> | undefined | void>\n  : Awaitable<ToolResultResponse<R>>;\n\nexport type AiToolDefinition<\n  S extends JSONObjectSchema7,\n  A extends JsonObject,\n  R extends JsonObject,\n> = {\n  description?: string;\n  parameters: S;\n  execute?: AiToolExecuteCallback<A, R>;\n  render?: (props: AiToolInvocationProps<A, R>) => unknown;\n  enabled?: boolean;\n};\n\nexport type AiOpaqueToolDefinition = AiToolDefinition<\n  JSONObjectSchema7,\n  JsonObject,\n  JsonObject\n>;\n\n/**\n * Helper function to help infer the types of `args`, `render`, and `result`.\n * This function has no runtime implementation and is only needed to make it\n * possible for TypeScript to infer types.\n */\nexport function defineAiTool<R extends JsonObject>() {\n  return <const S extends JSONObjectSchema7>(\n    def: AiToolDefinition<\n      S,\n      InferFromSchema<S> extends JsonObject ? InferFromSchema<S> : JsonObject,\n      R\n    >\n  ): AiOpaqueToolDefinition => {\n    return def as AiOpaqueToolDefinition;\n  };\n}\n\ntype NavigationInfo = {\n  /**\n   * The message ID of the parent message, or null if there is no parent.\n   */\n  parent: MessageId | null;\n  /**\n   * The message ID of the left sibling message, or null if there is no left sibling.\n   */\n  prev: MessageId | null;\n  /**\n   * The message ID of the right sibling message, or null if there is no right sibling.\n   */\n  next: MessageId | null;\n};\n\nexport type WithNavigation<T> = T & { navigation: NavigationInfo };\n\ntype UiChatMessage = WithNavigation<AiChatMessage>;\n\ntype AiContext = {\n  staticSessionInfoSig: Signal<StaticSessionInfo | null>;\n  dynamicSessionInfoSig: Signal<DynamicSessionInfo | null>;\n  pendingCmds: Map<\n    CmdId,\n    {\n      resolve: (value: ServerAiMsg) => void;\n      reject: (reason: unknown) => void;\n    }\n  >;\n  chatsStore: ReturnType<typeof createStore_forUserAiChats>;\n  toolsStore: ReturnType<typeof createStore_forTools>;\n  messagesStore: ReturnType<typeof createStore_forChatMessages>;\n  knowledgeStore: ReturnType<typeof createStore_forKnowledge>;\n};\n\nexport type LayerKey = Brand<string, \"LayerKey\">;\n\nexport class KnowledgeStack {\n  #_layers: Set<LayerKey>;\n\n  #stack: DefaultMap<string, Map<LayerKey, AiKnowledgeSource | null>>;\n  //                 /                \\\n  //      knowledge key               \"layer\" key\n  //      (random, or optionally      (one entry per mounted component)\n  //       set by user)\n  #_cache: AiKnowledgeSource[] | undefined;\n\n  constructor() {\n    this.#_layers = new Set<LayerKey>();\n    this.#stack = new DefaultMap(\n      () => new Map<LayerKey, AiKnowledgeSource | null>()\n    );\n    this.#_cache = undefined;\n  }\n\n  // Typically a useId()\n  registerLayer(uniqueLayerId: string): LayerKey {\n    const layerKey = uniqueLayerId as LayerKey;\n    if (this.#_layers.has(layerKey))\n      raise(`Layer '${layerKey}' already exists, provide a unique layer id`);\n    this.#_layers.add(layerKey);\n    return layerKey;\n  }\n\n  deregisterLayer(layerKey: LayerKey): void {\n    this.#_layers.delete(layerKey);\n    let deleted = false;\n    for (const [key, knowledge] of this.#stack) {\n      if (knowledge.delete(layerKey)) {\n        deleted = true;\n      }\n      if (knowledge.size === 0)\n        // Just memory cleanup\n        this.#stack.delete(key);\n    }\n    if (deleted) {\n      this.invalidate();\n    }\n  }\n\n  get(): AiKnowledgeSource[] {\n    return (this.#_cache ??= this.#recompute());\n  }\n\n  invalidate(): void {\n    this.#_cache = undefined;\n  }\n\n  #recompute(): AiKnowledgeSource[] {\n    return Array.from(this.#stack.values()).flatMap((layer) =>\n      // Return only the last item (returns [] when empty)\n      Array.from(layer.values()).slice(-1).filter(isDefined)\n    );\n  }\n\n  updateKnowledge(\n    layerKey: LayerKey,\n    key: string,\n    data: AiKnowledgeSource | null\n  ): void {\n    if (!this.#_layers.has(layerKey)) raise(`Unknown layer key: ${layerKey}`);\n    this.#stack.getOrCreate(key).set(layerKey, data);\n    this.invalidate();\n  }\n}\n\nfunction createStore_forKnowledge() {\n  const knowledgeByChatId = new DefaultMap(\n    (_chatId: string | typeof kWILDCARD) => new KnowledgeStack()\n  );\n\n  function getKnowledgeStack(chatId?: string): KnowledgeStack {\n    return knowledgeByChatId.getOrCreate(chatId ?? kWILDCARD);\n  }\n\n  function getKnowledgeForChat(chatId: string): AiKnowledgeSource[] {\n    const globalKnowledge = knowledgeByChatId.getOrCreate(kWILDCARD).get();\n    const scopedKnowledge = knowledgeByChatId.get(chatId)?.get() ?? [];\n    return [...globalKnowledge, ...scopedKnowledge];\n  }\n\n  return {\n    getKnowledgeStack,\n    getKnowledgeForChat,\n  };\n}\n\nexport type GetOrCreateChatOptions = {\n  name: string;\n  metadata?: AiChat[\"metadata\"];\n};\n\nfunction now(): ISODateString {\n  return new Date().toISOString() as ISODateString;\n}\n\n// Symbol used to register tools globally. These tools are not scoped to\n// a particular chatId and made available to any AiChat instance.\nconst kWILDCARD = Symbol(\"*\");\n\nfunction createStore_forTools() {\n  const toolsByChatIdΣ = new DefaultMap(\n    (_chatId: string | typeof kWILDCARD) => {\n      return new DefaultMap((_name: string) => {\n        return new Signal<AiOpaqueToolDefinition | undefined>(undefined);\n      });\n    }\n  );\n\n  //\n  // TODO This administration is pretty ugly at the moment.\n  // Would be nice to have some kind of helper for constructing these\n  // structures. Maintaining them in all these different DefaultMaps is pretty\n  // getting pretty tricky. Ideas are very welcomed!\n  //\n  // Key here is: '[\"my-tool\",\"my-chat\"]' or just '[\"my-tool\"]' (for global tools)\n  //\n  const globalOrScopedToolΣ = new DefaultMap((nameAndChat: string) => {\n    const [name, chatId] = tryParseJson(nameAndChat) as [\n      string,\n      string | undefined,\n    ];\n    return DerivedSignal.from(() => {\n      return (\n        // A tool that's registered and scoped to a specific chat ID...\n        (chatId !== undefined\n          ? toolsByChatIdΣ.getOrCreate(chatId).getOrCreate(name)\n          : undefined\n        )?.get() ??\n        // ...or a globally registered tool\n        toolsByChatIdΣ.getOrCreate(kWILDCARD).getOrCreate(name).get()\n      );\n    });\n  });\n\n  function getToolΣ(name: string, chatId?: string) {\n    const key = JSON.stringify(chatId !== undefined ? [name, chatId] : [name]);\n    return globalOrScopedToolΣ.getOrCreate(key);\n  }\n\n  function registerTool(\n    name: string,\n    tool: AiOpaqueToolDefinition,\n    chatId?: string\n  ) {\n    if (!tool.execute && !tool.render) {\n      throw new Error(\n        \"A tool definition must have an execute() function, a render() function, or both.\"\n      );\n    }\n\n    const key = chatId ?? kWILDCARD;\n    toolsByChatIdΣ.getOrCreate(key).getOrCreate(name).set(tool);\n\n    return () => unregisterTool(key, name);\n  }\n\n  function unregisterTool(chatId: string | typeof kWILDCARD, name: string) {\n    const tools = toolsByChatIdΣ.get(chatId);\n    if (tools === undefined) return;\n    const tool = tools.get(name);\n    if (tool === undefined) return;\n    tool.set(undefined);\n  }\n\n  function getToolDescriptions(chatId: string): AiToolDescription[] {\n    const globalToolsΣ = toolsByChatIdΣ.get(kWILDCARD);\n    const scopedToolsΣ = toolsByChatIdΣ.get(chatId);\n    return Array.from([\n      ...(globalToolsΣ?.entries() ?? []),\n      ...(scopedToolsΣ?.entries() ?? []),\n    ]).flatMap(([name, toolΣ]) => {\n      const tool = toolΣ.get();\n      return tool && (tool.enabled ?? true)\n        ? [{ name, description: tool.description, parameters: tool.parameters }]\n        : [];\n    });\n  }\n\n  return {\n    getToolDescriptions,\n\n    getToolΣ,\n    registerTool,\n  };\n}\n\nfunction createStore_forChatMessages(\n  toolsStore: ReturnType<typeof createStore_forTools>,\n  setToolResultFn: (\n    chatId: string,\n    messageId: MessageId,\n    invocationId: string,\n    result: ToolResultResponse,\n    options?: SetToolResultOptions\n  ) => Promise<void>\n) {\n  // Keeps track of all message IDs that are originated from this client. We\n  // use this concept of \"ownership\" to determine which client instance is\n  // allowed to auto-execute tool invocations for this message.\n  const myMessages = new Set<MessageId>();\n\n  // Keeps track of any tool invocations that have been auto-executed by this\n  // client. Note that this can also record invocations that don't have an\n  // execute() function. In that case, we also handled it (by kicking off nothing).\n  const handledInvocations = new Set<string>();\n\n  // We maintain a Map with mutable signals. Each such signal contains\n  // a mutable automatically-sorted list of chat messages by chat ID.\n  const messagePoolByChatIdΣ = new DefaultMap(\n    (_chatId: string) =>\n      new MutableSignal(\n        new TreePool<AiChatMessage>(\n          (x) => x.id,\n          (x) => x.parentId,\n          (x, y) => x.createdAt < y.createdAt\n        )\n      )\n  );\n\n  // Separately from that, we track all _generating_ signals in a separate\n  // administration. Because generating messages are likely to receive\n  // many/frequent updates, updating them in a separate administration makes\n  // rendering streaming contents much more efficient than if we had to\n  // re-create and re-render the entire chat list on every such update.\n  const generatingMessagesΣ = new MutableSignal(\n    new Map<MessageId, AiGeneratingAssistantMessage>()\n  );\n\n  function createOptimistically(\n    chatId: string,\n    role: \"user\",\n    parentId: MessageId | null,\n    content: AiUserContentPart[]\n  ): MessageId;\n  function createOptimistically(\n    chatId: string,\n    role: \"assistant\",\n    parentId: MessageId | null,\n    copilotId?: CopilotId\n  ): MessageId;\n  function createOptimistically(\n    chatId: string,\n    role: \"user\" | \"assistant\",\n    parentId: MessageId | null,\n    third?: AiUserContentPart[] | CopilotId\n  ) {\n    const id = `ms_${nanoid()}` as MessageId;\n    const createdAt = now();\n    if (role === \"user\") {\n      const content = third as AiUserContentPart[];\n      upsert({\n        id,\n        chatId,\n        role,\n        parentId,\n        createdAt,\n        content,\n        _optimistic: true,\n      } satisfies AiUserMessage);\n    } else {\n      const copilotId = third as CopilotId | undefined;\n      upsert({\n        id,\n        chatId,\n        role,\n        parentId,\n        createdAt,\n        status: \"generating\",\n        contentSoFar: [],\n        copilotId,\n        _optimistic: true,\n      } satisfies AiGeneratingAssistantMessage);\n    }\n    return id;\n  }\n\n  function upsertMany(messages: AiChatMessage[]): void {\n    batch(() => {\n      for (const message of messages) {\n        upsert(message);\n      }\n    });\n  }\n\n  function remove(chatId: string, messageId: MessageId): void {\n    const chatMsgsΣ = messagePoolByChatIdΣ.get(chatId);\n    if (!chatMsgsΣ) return;\n\n    const existing = chatMsgsΣ.get().get(messageId);\n    if (!existing || existing.deletedAt) return;\n\n    if (existing.role === \"assistant\" && existing.status !== \"completed\") {\n      upsert({ ...existing, deletedAt: now(), contentSoFar: [] });\n    } else {\n      upsert({ ...existing, deletedAt: now(), content: [] });\n    }\n  }\n\n  function removeByChatId(chatId: string): void {\n    const chatMsgsΣ = messagePoolByChatIdΣ.get(chatId);\n    if (chatMsgsΣ === undefined) return;\n    chatMsgsΣ.mutate((pool) => pool.clear());\n  }\n\n  function upsert(message: AiChatMessage): void {\n    batch(() => {\n      const chatMsgsΣ = messagePoolByChatIdΣ.getOrCreate(message.chatId);\n      chatMsgsΣ.mutate((pool) => pool.upsert(message));\n\n      // If the message is a pending update, write it to the generating\n      // messages LUT. If not, remove it from there.\n      if (message.role === \"assistant\" && message.status === \"generating\") {\n        generatingMessagesΣ.mutate((lut) => {\n          lut.set(message.id, structuredClone(message));\n        });\n      } else {\n        generatingMessagesΣ.mutate((lut) => {\n          lut.delete(message.id);\n        });\n      }\n\n      //\n      // If this message has \"awaiting-tool\" status, it may be the client's\n      // move to trigger an action / call an execute function.\n      //\n      // We will automatically invoke execute()...\n      // - only if such function is provided by the user\n      // - at most once (which is why we track it in seenToolCallIds)\n      // - and only if the current client ID is the designated client ID\n      //\n      if (message.role === \"assistant\" && message.status === \"awaiting-tool\") {\n        if (myMessages.has(message.id)) {\n          for (const toolInvocation of message.contentSoFar.filter(\n            (part) =>\n              part.type === \"tool-invocation\" && part.stage === \"executing\"\n          )) {\n            if (!handledInvocations.has(toolInvocation.invocationId)) {\n              handledInvocations.add(toolInvocation.invocationId);\n            } else {\n              // Do nothing, we already kicked this one off\n              continue;\n            }\n\n            const executeFn = toolsStore\n              .getToolΣ(toolInvocation.name, message.chatId)\n              .get()?.execute;\n            if (executeFn) {\n              (async () => {\n                const result = await executeFn(toolInvocation.args, {\n                  name: toolInvocation.name,\n                  invocationId: toolInvocation.invocationId,\n                });\n                return await setToolResultFn(\n                  message.chatId,\n                  message.id,\n                  toolInvocation.invocationId,\n                  result ?? { data: {} },\n                  { copilotId: message.copilotId } // TODO: Should we pass the other generation options (tools, knowledge) as well?\n                );\n              })().catch((err) => {\n                console.error(\n                  `Error trying to respond to tool-call: ${String(err)} (in execute())`\n                );\n              });\n            }\n          }\n        }\n      } else {\n        // Clean up the ownership administration\n        if (message.role === \"assistant\" && message.status === \"generating\") {\n          // ...unless it's still generating\n        } else {\n          myMessages.delete(message.id);\n        }\n      }\n    });\n  }\n\n  function addDelta(messageId: MessageId, delta: AiAssistantDeltaUpdate): void {\n    generatingMessagesΣ.mutate((lut) => {\n      const message = lut.get(messageId);\n      if (message === undefined) return false;\n\n      patchContentWithDelta(message.contentSoFar, delta);\n      lut.set(messageId, message);\n      return true;\n    });\n  }\n\n  function* iterGeneratingMessages() {\n    for (const chatMsgsΣ of messagePoolByChatIdΣ.values()) {\n      for (const m of chatMsgsΣ.get()) {\n        if (\n          m.role === \"assistant\" &&\n          m.status === \"generating\" &&\n          !m._optimistic\n        ) {\n          yield m;\n        }\n      }\n    }\n  }\n\n  function failAllPending(): void {\n    batch(() => {\n      generatingMessagesΣ.mutate((lut) => {\n        let deleted = false;\n        for (const [k, v] of lut) {\n          if (!v._optimistic) {\n            lut.delete(k);\n            deleted = true;\n          }\n        }\n        return deleted;\n      });\n\n      upsertMany(\n        Array.from(iterGeneratingMessages()).map(\n          (message) =>\n            ({\n              ...message,\n              status: \"failed\",\n              errorReason: \"Lost connection\",\n            }) as AiFailedAssistantMessage\n        )\n      );\n    });\n  }\n\n  function getMessageById(messageId: MessageId): AiChatMessage | undefined {\n    for (const messagesΣ of messagePoolByChatIdΣ.values()) {\n      const message = messagesΣ.get().get(messageId);\n      if (message) {\n        return message;\n      }\n    }\n    return undefined;\n  }\n\n  function first<T>(iterable: IterableIterator<T>): T | undefined {\n    const result = iterable.next();\n    return result.done ? undefined : result.value;\n  }\n\n  function selectBranch(\n    pool: TreePool<AiChatMessage>,\n    preferredBranch: MessageId | null\n  ): UiChatMessage[] {\n    function isAlive(message: AiChatMessage): boolean {\n      // This could be generalized by doing a walk(\n      //   { direction: 'down',\n      //     type: 'breadth-first',\n      //     includeSelf: true,\n      //     predicate: m => !m.deletedAt,\n      //   })\n\n      // If it's a non-deleted message, it's alive\n      if (!message.deletedAt) {\n        return true;\n      }\n      for (const _ of pool.walkDown(message.id, (m) => !m.deletedAt)) {\n        return true;\n      }\n      return false;\n    }\n\n    function selectSpine(leaf: AiChatMessage): UiChatMessage[] {\n      const spine = [];\n\n      let lastVisitedMessage: UiChatMessage | null = null;\n      for (const message of pool.walkUp(leaf.id)) {\n        const prev = first(pool.walkLeft(message.id, isAlive))?.id ?? null;\n        const next = first(pool.walkRight(message.id, isAlive))?.id ?? null;\n\n        // Remove deleted messages only if they don't have any non-deleted\n        // children, and also don't have a next/prev link, requiring the\n        // deleted node to have an on-screen presence.\n        if (!message.deletedAt || prev || next) {\n          const node: UiChatMessage = {\n            ...message,\n            navigation: { parent: null, prev, next },\n          };\n          // Set the parent of the last visited to the id of the current node.\n          if (lastVisitedMessage !== null) {\n            lastVisitedMessage.navigation.parent = node.id;\n          }\n          lastVisitedMessage = node;\n          spine.push(node);\n        }\n      }\n      return spine.reverse();\n    }\n\n    function fallback(): UiChatMessage[] {\n      const latest = pool.sorted.findRight((m) => !m.deletedAt);\n      return latest ? selectSpine(latest) : [];\n    }\n\n    if (preferredBranch === null) {\n      return fallback();\n    }\n\n    const message = pool.get(preferredBranch);\n    if (!message) {\n      return fallback();\n    }\n\n    // Find the first non-deleted grand child. If one doesn't exist, keep\n    // walking up the tree and repeat, until we find one.\n    for (const current of pool.walkUp(message.id)) {\n      // If a non-deleted grandchild exists, select it.\n      for (const desc of pool.walkDown(current.id, (m) => !m.deletedAt)) {\n        return selectSpine(desc);\n      }\n\n      // If the current node is not deleted, select it.\n      if (!current.deletedAt) {\n        return selectSpine(current);\n      }\n\n      // Otherwise, continue looping by walking up one level and repeating.\n    }\n\n    return fallback();\n  }\n\n  const immutableMessagesByBranch = new DefaultMap((chatId: string) => {\n    return new DefaultMap((branchId: MessageId | null) => {\n      const messagesΣ = DerivedSignal.from(() => {\n        const pool = messagePoolByChatIdΣ.getOrCreate(chatId).get();\n        return selectBranch(pool, branchId);\n      }, shallow2);\n\n      return DerivedSignal.from((): UiChatMessage[] => {\n        const generatingMessages = generatingMessagesΣ.get();\n        return messagesΣ.get().map((message) => {\n          if (message.role !== \"assistant\" || message.status !== \"generating\") {\n            return message;\n          }\n          const generatingMessage = generatingMessages.get(message.id);\n          if (generatingMessage === undefined) return message;\n          return {\n            ...message,\n            contentSoFar: generatingMessage.contentSoFar,\n          } satisfies AiGeneratingAssistantMessage;\n        });\n      }, shallow);\n    });\n  });\n\n  function getChatMessagesForBranchΣ(chatId: string, branch?: MessageId) {\n    return immutableMessagesByBranch\n      .getOrCreate(chatId)\n      .getOrCreate(branch || null);\n  }\n\n  function getLastUsedCopilotId(chatId: string): CopilotId | undefined {\n    const pool = messagePoolByChatIdΣ.getOrCreate(chatId).get();\n    // Find the most recent non-deleted assistant message\n    const latest = pool.sorted.findRight(\n      (m) => m.role === \"assistant\" && !m.deletedAt\n    );\n    return latest?.copilotId;\n  }\n\n  return {\n    // Readers\n    getMessageById,\n    getChatMessagesForBranchΣ,\n    getLastUsedCopilotId,\n\n    // Mutations\n    createOptimistically,\n    upsert,\n    upsertMany,\n    remove,\n    removeByChatId,\n    addDelta,\n    failAllPending,\n\n    markMine(messageId: MessageId) {\n      myMessages.add(messageId);\n    },\n\n    /**\n     * Iterates over all my auto-executing messages.\n     *\n     * These are messages that match all these conditions:\n     * - The message is an assistant message\n     * - The message is owned by this client (\"mine\")\n     * - The message is currently in \"awaiting-tool\" status\n     * - The message has at least one tool invocation in \"executing\" stage\n     * - The tool invocation has an execute() function defined\n     */\n    *getAutoExecutingMessageIds(): Iterable<MessageId> {\n      for (const messageId of myMessages) {\n        const message = getMessageById(messageId);\n        if (\n          message?.role === \"assistant\" &&\n          message.status === \"awaiting-tool\"\n        ) {\n          const isAutoExecuting = message.contentSoFar.some((part) => {\n            if (part.type === \"tool-invocation\" && part.stage === \"executing\") {\n              const tool = toolsStore.getToolΣ(part.name, message.chatId).get();\n              return typeof tool?.execute === \"function\";\n            }\n            return false;\n          });\n\n          if (isAutoExecuting) {\n            yield message.id;\n          }\n        }\n      }\n    },\n  };\n}\n\nfunction createStore_forUserAiChats() {\n  const chatsDB = new AiChatDB();\n\n  function upsertMany(chats: AiChat[]) {\n    batch(() => {\n      for (const chat of chats) {\n        chatsDB.upsert(chat);\n      }\n    });\n  }\n\n  function upsert(chat: AiChat) {\n    chatsDB.upsert(chat);\n  }\n\n  /**\n   * \"Just\" deleting a chat we already know about might break assumptions in\n   * clients that are currently displaying the chat on-screen. So instead,\n   * we'll re-render those so they can display the chat is deleted.\n   */\n  function markDeleted(chatId: string) {\n    chatsDB.markDeleted(chatId);\n  }\n\n  function getChatById(chatId: string) {\n    return chatsDB.getEvenIfDeleted(chatId);\n  }\n\n  function findMany(query: AiChatsQuery): AiChat[] {\n    return chatsDB.signal.get().findMany(query);\n  }\n\n  return {\n    getChatById,\n\n    findMany,\n\n    // Mutations\n    upsert,\n    upsertMany,\n    markDeleted,\n  };\n}\n\n/** @private This API will change, and is not considered stable. DO NOT RELY on it. */\nexport type Ai = {\n  [kInternal]: {\n    context: AiContext;\n  };\n  connectInitially: () => void;\n  // connect: () => void;\n  // reconnect: () => void;\n  disconnect: () => void;\n  getStatus: () => Status;\n\n  /** @private This API will change, and is not considered stable. DO NOT RELY on it. */\n  getChats: (options?: GetChatsOptions) => Promise<GetChatsResponse>;\n  /** @private This API will change, and is not considered stable. DO NOT RELY on it. */\n  getOrCreateChat: (\n    /** A unique identifier for the chat. */\n    chatId: string,\n    options?: CreateChatOptions\n  ) => Promise<GetOrCreateChatResponse>;\n  /** @private This API will change, and is not considered stable. DO NOT RELY on it. */\n  deleteChat: (chatId: string) => Promise<DeleteChatResponse>;\n  /** @private This API will change, and is not considered stable. DO NOT RELY on it. */\n  getMessageTree: (chatId: string) => Promise<GetMessageTreeResponse>;\n  /** @private This API will change, and is not considered stable. DO NOT RELY on it. */\n  deleteMessage: (\n    chatId: string,\n    messageId: MessageId\n  ) => Promise<DeleteMessageResponse>;\n  /** @private This API will change, and is not considered stable. DO NOT RELY on it. */\n  clearChat: (chatId: string) => Promise<ClearChatResponse>;\n  /** @private This API will change, and is not considered stable. DO NOT RELY on it. */\n  askUserMessageInChat: (\n    chatId: string,\n    userMessage:\n      | MessageId\n      | {\n          id: MessageId;\n          parentMessageId: MessageId | null;\n          content: AiUserContentPart[];\n        },\n    targetMessageId: MessageId,\n    options?: AskUserMessageInChatOptions\n  ) => Promise<AskInChatResponse>;\n  /** @private This API will change, and is not considered stable. DO NOT RELY on it. */\n  abort: (messageId: MessageId) => Promise<AbortAiResponse>;\n  /** @private This API will change, and is not considered stable. DO NOT RELY on it. */\n  setToolResult: (\n    chatId: string,\n    messageId: MessageId,\n    invocationId: string,\n    result: ToolResultResponse,\n    options?: SetToolResultOptions\n  ) => Promise<void>;\n  /** @private This API will change, and is not considered stable. DO NOT RELY on it. */\n  signals: {\n    getChatMessagesForBranchΣ(\n      chatId: string,\n      branch?: MessageId\n    ): DerivedSignal<UiChatMessage[]>;\n    getToolΣ(\n      name: string,\n      chatId?: string\n    ): DerivedSignal<AiOpaqueToolDefinition | undefined>;\n    statusΣ: Signal<Status>;\n  };\n  /** @private This API will change, and is not considered stable. DO NOT RELY on it. */\n  getChatById: (chatId: string) => AiChat | undefined;\n  /** @private This API will change, and is not considered stable. DO NOT RELY on it. */\n  queryChats: (query: AiChatsQuery) => AiChat[];\n  /** @private This API will change, and is not considered stable. DO NOT RELY on it. */\n  getLastUsedCopilotId: (chatId: string) => CopilotId | undefined;\n  /** @private This API will change, and is not considered stable. DO NOT RELY on it. */\n  registerKnowledgeLayer: (\n    uniqueLayerId: string,\n    chatId?: string\n  ) => {\n    layerKey: LayerKey;\n    deregister: () => void;\n  };\n  /** @private This API will change, and is not considered stable. DO NOT RELY on it. */\n  updateKnowledge: (\n    layerKey: LayerKey,\n    data: AiKnowledgeSource,\n    key?: string,\n    chatId?: string\n  ) => void;\n  /** @private This API will change, and is not considered stable. DO NOT RELY on it. */\n  registerTool: (\n    name: string,\n    tool: AiOpaqueToolDefinition,\n    chatId?: string\n  ) => () => void;\n};\n\n/** @internal */\nexport type AiConfig = {\n  delegates: Delegates<AuthValue>;\n\n  userId?: string;\n  lostConnectionTimeout: number;\n  backgroundKeepAliveTimeout?: number;\n  polyfills?: Polyfills;\n\n  enableDebugLogging?: boolean;\n};\n\nexport function createAi(config: AiConfig): Ai {\n  const managedSocket: ManagedSocket<AuthValue> = new ManagedSocket(\n    config.delegates,\n    config.enableDebugLogging,\n    false // AI doesn't have actors (yet, but it will)\n  );\n\n  const chatsStore = createStore_forUserAiChats();\n  const toolsStore = createStore_forTools();\n  const knowledgeStore = createStore_forKnowledge();\n  const messagesStore = createStore_forChatMessages(toolsStore, setToolResult);\n  const context: AiContext = {\n    staticSessionInfoSig: new Signal<StaticSessionInfo | null>(null),\n    dynamicSessionInfoSig: new Signal<DynamicSessionInfo | null>(null),\n    pendingCmds: new Map(),\n    chatsStore,\n    messagesStore,\n    toolsStore,\n    knowledgeStore,\n  };\n\n  const statusΣ = new Signal<Status>(\"initial\");\n\n  // Delta batch processing system to throttle incoming delta updates. Incoming\n  // deltas are buffered and only let through every every 25ms. This creates\n  // a ceiling of max 40 rerenders/second during streaming.\n  const DELTA_THROTTLE = 25;\n  let pendingDeltas: { id: MessageId; delta: AiAssistantDeltaUpdate }[] = [];\n  let deltaBatchTimer: ReturnType<typeof setTimeout> | null = null;\n\n  function flushPendingDeltas() {\n    const currentQueue = pendingDeltas;\n\n    pendingDeltas = [];\n    if (deltaBatchTimer !== null) {\n      clearTimeout(deltaBatchTimer);\n      deltaBatchTimer = null;\n    }\n\n    // Process all pending deltas in a single batch\n    batch(() => {\n      for (const { id, delta } of currentQueue) {\n        context.messagesStore.addDelta(id, delta);\n      }\n    });\n  }\n\n  function enqueueDelta(id: MessageId, delta: AiAssistantDeltaUpdate) {\n    pendingDeltas.push({ id, delta });\n\n    // If no timer is running, start one to process the batch\n    if (deltaBatchTimer === null) {\n      deltaBatchTimer = setTimeout(flushPendingDeltas, DELTA_THROTTLE);\n    }\n  }\n\n  let lastTokenKey: string | undefined;\n  function onStatusDidChange(newStatus: Status) {\n    const authValue = managedSocket.authValue;\n    if (authValue !== null) {\n      const tokenKey = getBearerTokenFromAuthValue(authValue);\n\n      if (tokenKey !== lastTokenKey) {\n        lastTokenKey = tokenKey;\n\n        if (authValue.type === \"secret\") {\n          const token = authValue.token.parsed;\n          context.staticSessionInfoSig.set({\n            userId: token.uid,\n            userInfo: token.ui,\n          });\n        } else {\n          context.staticSessionInfoSig.set({\n            userId: undefined,\n            userInfo: undefined,\n          });\n        }\n      }\n    }\n\n    // Forward to the outside world\n    statusΣ.set(newStatus);\n  }\n  let _connectionLossTimerId: TimeoutID | undefined;\n  let _hasLostConnection = false;\n\n  function handleConnectionLossEvent(newStatus: Status) {\n    if (newStatus === \"reconnecting\") {\n      _connectionLossTimerId = setTimeout(() => {\n        _hasLostConnection = true;\n      }, config.lostConnectionTimeout);\n    } else {\n      clearTimeout(_connectionLossTimerId);\n\n      if (_hasLostConnection) {\n        _hasLostConnection = false;\n      }\n    }\n  }\n\n  function onDidConnect() {\n    // NoOp for now, but we should maybe fetch messages or something?\n  }\n\n  function onDidDisconnect() {\n    // Flush any pending deltas before disconnect to prevent data loss\n    flushPendingDeltas();\n  }\n\n  function handleServerMessage(event: IWebSocketMessageEvent) {\n    if (typeof event.data !== \"string\")\n      // Ignore binary (non-string) WebSocket messages\n      return;\n\n    const msg = tryParseJson(event.data) as ServerAiMsg | undefined;\n    if (!msg)\n      // Ignore non-JSON messages\n      return;\n\n    // If the current msg carries a cmdId, check to see if it's a known one,\n    // and if it's still exists in our pendingRequest administration. If not,\n    // it may have timed out already, or it wasn't intended for us.\n    const cmdId =\n      \"cmdId\" in msg\n        ? msg.cmdId\n        : msg.event === \"cmd-failed\"\n          ? msg.failedCmdId\n          : undefined;\n    const pendingCmd = context.pendingCmds.get(cmdId!); // eslint-disable-line no-restricted-syntax\n\n    if (cmdId && !pendingCmd) {\n      console.warn(\"Ignoring unexpected command response. Already timed out, or not for us?\", msg); // prettier-ignore\n      return;\n    }\n\n    if (\"event\" in msg) {\n      // Delta's are handled separately\n      if (msg.event === \"delta\") {\n        const { id, delta } = msg;\n        enqueueDelta(id, delta);\n      } else {\n        batch(() => {\n          flushPendingDeltas();\n\n          switch (msg.event) {\n            case \"cmd-failed\":\n              pendingCmd?.reject(new Error(msg.error));\n              break;\n\n            case \"settle\": {\n              context.messagesStore.upsert(msg.message);\n              break;\n            }\n\n            case \"warning\":\n              console.warn(msg.message);\n              break;\n\n            case \"error\":\n              console.error(msg.error);\n              break;\n\n            case \"rebooted\":\n              context.messagesStore.failAllPending();\n              break;\n\n            case \"sync\":\n              // Delete any resources?\n              for (const m of msg[\"-messages\"] ?? []) {\n                context.messagesStore.remove(m.chatId, m.id);\n              }\n              for (const chatId of msg[\"-chats\"] ?? []) {\n                context.chatsStore.markDeleted(chatId);\n                context.messagesStore.removeByChatId(chatId);\n              }\n              for (const chatId of msg.clear ?? []) {\n                context.messagesStore.removeByChatId(chatId);\n              }\n\n              // Add any new resources?\n              if (msg.chats) {\n                context.chatsStore.upsertMany(msg.chats);\n              }\n              if (msg.messages) {\n                context.messagesStore.upsertMany(msg.messages);\n              }\n              break;\n\n            default:\n              return assertNever(msg, \"Unhandled case\");\n          }\n        });\n      }\n    } else {\n      switch (msg.cmd) {\n        case \"get-chats\":\n          context.chatsStore.upsertMany(msg.chats);\n          break;\n\n        case \"get-or-create-chat\":\n          context.chatsStore.upsert(msg.chat);\n          break;\n\n        case \"delete-chat\":\n          context.chatsStore.markDeleted(msg.chatId);\n          context.messagesStore.removeByChatId(msg.chatId);\n          break;\n\n        case \"get-message-tree\":\n          context.chatsStore.upsert(msg.chat);\n          context.messagesStore.upsertMany(msg.messages);\n          break;\n\n        case \"delete-message\":\n          context.messagesStore.remove(msg.chatId, msg.messageId);\n          break;\n\n        case \"clear-chat\":\n          context.messagesStore.removeByChatId(msg.chatId);\n          break;\n\n        case \"ask-in-chat\":\n          if (msg.sourceMessage) {\n            // This field will only be returned if the ask-in-chat command\n            // created a new source message\n            context.messagesStore.upsert(msg.sourceMessage);\n          }\n          context.messagesStore.upsert(msg.targetMessage);\n          break;\n\n        case \"abort-ai\":\n          // TODO Not handled yet\n          break;\n\n        case \"set-tool-result\":\n          if (msg.ok) {\n            context.messagesStore.upsert(msg.message);\n          }\n          break;\n\n        default:\n          return assertNever(msg, \"Unhandled case\");\n      }\n    }\n\n    // After handling the side-effects above, we can resolve the promise\n    pendingCmd?.resolve(msg);\n  }\n\n  managedSocket.events.onMessage.subscribe(handleServerMessage);\n  managedSocket.events.statusDidChange.subscribe(onStatusDidChange);\n  managedSocket.events.statusDidChange.subscribe(handleConnectionLossEvent);\n  managedSocket.events.didConnect.subscribe(onDidConnect);\n  managedSocket.events.didDisconnect.subscribe(onDidDisconnect);\n  managedSocket.events.onConnectionError.subscribe(({ message, code }) => {\n    //const type = \"AI_CONNECTION_ERROR\";\n    // const err = new LiveblocksError(message, { type, code });\n    if (process.env.NODE_ENV !== \"production\") {\n      console.error(\n        `Connection to websocket server closed. Reason: ${message} (code: ${code}).`\n      );\n    }\n  });\n\n  function connectInitially() {\n    if (managedSocket.getStatus() === \"initial\") {\n      managedSocket.connect();\n    }\n  }\n\n  async function sendClientMsgWithResponse<T extends ServerAiMsg>(\n    msg: DistributiveOmit<ClientAiMsg, \"cmdId\">\n  ): Promise<T> {\n    connectInitially();\n    if (managedSocket.getStatus() !== \"connected\") {\n      await managedSocket.events.didConnect.waitUntil();\n    }\n\n    const { promise, resolve, reject } = Promise_withResolvers<ServerAiMsg>();\n\n    // Automatically calls reject() when signal is aborted\n    const abortSignal = AbortSignal.timeout(DEFAULT_REQUEST_TIMEOUT);\n    abortSignal.addEventListener(\"abort\", () => reject(abortSignal.reason), {\n      once: true,\n    });\n\n    const cmdId = nanoid(7) as CmdId;\n    context.pendingCmds.set(cmdId, { resolve, reject });\n\n    sendClientMsg({ ...msg, cmdId });\n    return (\n      (promise as Promise<T>)\n        .finally(() => {\n          // Always cleanup\n          context.pendingCmds.delete(cmdId);\n        })\n        // Make sure these promises don't go uncaught (in contrast to the\n        // promise instance we return to the caller)\n        .catch((err: Error) => {\n          console.error(err.message);\n          throw err;\n        })\n    );\n  }\n\n  function sendClientMsg(msg: ClientAiMsg) {\n    managedSocket.send(\n      JSON.stringify({\n        ...msg,\n      })\n    );\n  }\n\n  function getChats(options: GetChatsOptions = {}) {\n    return sendClientMsgWithResponse<GetChatsResponse>({\n      cmd: \"get-chats\",\n      cursor: options.cursor,\n      query: options.query,\n    });\n  }\n\n  function getOrCreateChat(id: string, options?: CreateChatOptions) {\n    return sendClientMsgWithResponse<GetOrCreateChatResponse>({\n      cmd: \"get-or-create-chat\",\n      id,\n      options,\n    });\n  }\n\n  function getMessageTree(chatId: string) {\n    return sendClientMsgWithResponse<GetMessageTreeResponse>({\n      cmd: \"get-message-tree\",\n      chatId,\n    });\n  }\n\n  async function setToolResult(\n    chatId: string,\n    messageId: MessageId,\n    invocationId: string,\n    result: ToolResultResponse,\n    options?: SetToolResultOptions\n  ): Promise<void> {\n    const knowledge = context.knowledgeStore.getKnowledgeForChat(chatId);\n    const tools = context.toolsStore.getToolDescriptions(chatId);\n\n    const resp: SetToolResultResponse = await sendClientMsgWithResponse({\n      cmd: \"set-tool-result\",\n      chatId,\n      messageId,\n      invocationId,\n      result,\n      generationOptions: {\n        copilotId: options?.copilotId,\n        stream: options?.stream,\n        timeout: options?.timeout,\n\n        // Knowledge and tools aren't coming from the options, but retrieved\n        // from the global context\n        knowledge: knowledge.length > 0 ? knowledge : undefined,\n        tools: tools.length > 0 ? tools : undefined,\n      },\n    });\n    if (resp.ok) {\n      messagesStore.markMine(resp.message.id);\n    }\n  }\n\n  // Abort all my auto-executing messages when the page is unloaded\n  function handleBeforeUnload() {\n    for (const messageId of context.messagesStore.getAutoExecutingMessageIds()) {\n      sendClientMsgWithResponse({ cmd: \"abort-ai\", messageId }).catch(() => {\n        // Ignore errors during page unload\n      });\n    }\n  }\n\n  const win = typeof window !== \"undefined\" ? window : undefined;\n  win?.addEventListener(\"beforeunload\", handleBeforeUnload, { once: true });\n\n  return Object.defineProperty(\n    {\n      [kInternal]: {\n        context,\n      },\n\n      connectInitially,\n      // reconnect: () => managedSocket.reconnect(),\n      disconnect: () => managedSocket.disconnect(),\n\n      getChats,\n      getOrCreateChat,\n\n      deleteChat: (chatId: string) => {\n        return sendClientMsgWithResponse({ cmd: \"delete-chat\", chatId });\n      },\n\n      getMessageTree,\n\n      deleteMessage: (chatId: string, messageId: MessageId) =>\n        sendClientMsgWithResponse({ cmd: \"delete-message\", chatId, messageId }),\n      clearChat: (chatId: string) =>\n        sendClientMsgWithResponse({ cmd: \"clear-chat\", chatId }),\n\n      askUserMessageInChat: async (\n        chatId: string,\n        userMessage:\n          | MessageId\n          | {\n              id: MessageId;\n              parentMessageId: MessageId | null;\n              content: AiUserContentPart[];\n            },\n        targetMessageId: MessageId,\n        options?: AskUserMessageInChatOptions\n      ): Promise<AskInChatResponse> => {\n        const knowledge = context.knowledgeStore.getKnowledgeForChat(chatId);\n        const requestKnowledge = options?.knowledge || [];\n        const combinedKnowledge = [...knowledge, ...requestKnowledge];\n        const tools = context.toolsStore.getToolDescriptions(chatId);\n\n        messagesStore.markMine(targetMessageId);\n        const resp: AskInChatResponse = await sendClientMsgWithResponse({\n          cmd: \"ask-in-chat\",\n          chatId,\n          sourceMessage: userMessage,\n          targetMessageId,\n          generationOptions: {\n            copilotId: options?.copilotId,\n            stream: options?.stream,\n            timeout: options?.timeout,\n\n            // Combine global knowledge with request-specific knowledge\n            knowledge:\n              combinedKnowledge.length > 0 ? combinedKnowledge : undefined,\n            tools: tools.length > 0 ? tools : undefined,\n          },\n        });\n        return resp;\n      },\n\n      abort: (messageId: MessageId) =>\n        sendClientMsgWithResponse({ cmd: \"abort-ai\", messageId }),\n\n      setToolResult,\n\n      getStatus: () => managedSocket.getStatus(),\n\n      signals: {\n        getChatMessagesForBranchΣ:\n          context.messagesStore.getChatMessagesForBranchΣ,\n        getToolΣ: context.toolsStore.getToolΣ,\n        statusΣ,\n      },\n\n      getChatById: context.chatsStore.getChatById,\n      queryChats: context.chatsStore.findMany,\n      getLastUsedCopilotId: context.messagesStore.getLastUsedCopilotId,\n      registerKnowledgeLayer: (uniqueLayerId: string, chatId?: string) => {\n        const stack = context.knowledgeStore.getKnowledgeStack(chatId);\n        const layerKey = stack.registerLayer(uniqueLayerId);\n        const deregister = () => stack.deregisterLayer(layerKey);\n        return {\n          layerKey,\n          deregister,\n        };\n      },\n      updateKnowledge: (\n        layerKey: LayerKey,\n        data: AiKnowledgeSource,\n        key?: string,\n        chatId?: string\n      ) => {\n        context.knowledgeStore\n          .getKnowledgeStack(chatId)\n          .updateKnowledge(layerKey, key ?? nanoid(), data);\n      },\n\n      registerTool: context.toolsStore.registerTool,\n    } satisfies Ai,\n    kInternal,\n    { enumerable: false }\n  );\n}\n\nexport function makeCreateSocketDelegateForAi(\n  baseUrl: string,\n  WebSocketPolyfill?: IWebSocket\n) {\n  return (authValue: AuthValue): IWebSocketInstance => {\n    const ws: IWebSocket | undefined =\n      WebSocketPolyfill ??\n      (typeof WebSocket === \"undefined\" ? undefined : WebSocket);\n\n    if (ws === undefined) {\n      throw new StopRetrying(\n        \"To use Liveblocks client in a non-DOM environment, you need to provide a WebSocket polyfill.\"\n      );\n    }\n\n    const url = new URL(baseUrl);\n    url.protocol = url.protocol === \"http:\" ? \"ws\" : \"wss\";\n    url.pathname = \"/ai/v7\";\n    // TODO: don't allow public key to do this\n    if (authValue.type === \"secret\") {\n      url.searchParams.set(\"tok\", authValue.token.raw);\n    } else if (authValue.type === \"public\") {\n      throw new Error(\"Public key not supported with AI Copilots\");\n    } else {\n      return assertNever(authValue, \"Unhandled case\");\n    }\n    url.searchParams.set(\"version\", PKG_VERSION || \"dev\");\n    return new ws(url.toString());\n  };\n}\n\n/**\n * Finds the last item in the content array that matches the type and the given\n * keyFn. If found, replaces that item with newItem in the content array. If\n * not found, appends newItem to the content array.\n * Mutates the content array in-place.\n */\nfunction replaceOrAppend<const T extends AiAssistantContentPart>(\n  content: AiAssistantContentPart[],\n  newItem: T,\n  keyFn: (item: T) => string,\n  now: ISODateString\n): void {\n  const existingIndex = findLastIndex(\n    content,\n    (item) => item.type === newItem.type && keyFn(item as T) === keyFn(newItem)\n  );\n\n  if (existingIndex > -1) {\n    // Replace the existing one\n    content[existingIndex] = newItem;\n  } else {\n    // No existing one found, just append\n    closePart(content[content.length - 1], now);\n    content.push(newItem);\n  }\n}\n\n/**\n * Given a part, mutates it in-place by setting its endedAt timestamp.\n */\nfunction closePart(\n  prevPart: AiAssistantContentPart | undefined,\n  endedAt: ISODateString\n) {\n  // Currently, only reasoning parts have an endedAt timestamp\n  if (prevPart?.type === \"reasoning\") {\n    prevPart.endedAt ??= endedAt;\n  }\n}\n\nexport function patchContentWithDelta(\n  content: AiAssistantContentPart[],\n  delta: AiAssistantDeltaUpdate | null\n): void {\n  if (delta === null)\n    // Nothing to do\n    return;\n\n  // Filter out sources parts from the content array to ensure we only process the other parts and handle sources separately\n  const parts: AiAssistantContentPart[] = content.filter(\n    (part) => part.type !== \"sources\"\n  );\n\n  // Collect all sources from the content array and flatten them so that we can add them to the content array at the end\n  const sources = content\n    .filter((part) => part.type === \"sources\")\n    .flatMap((part) => part.sources);\n\n  const now = new Date().toISOString() as ISODateString;\n  const lastPart = parts[parts.length - 1];\n\n  // Otherwise, append a new part type to the array, which we can start\n  // writing into\n  switch (delta.type) {\n    case \"text-delta\":\n      if (lastPart?.type === \"text\") {\n        lastPart.text += delta.textDelta;\n      } else {\n        closePart(lastPart, now);\n        parts.push({ type: \"text\", text: delta.textDelta });\n      }\n      break;\n\n    case \"reasoning-delta\":\n      if (lastPart?.type === \"reasoning\") {\n        lastPart.text += delta.textDelta;\n      } else {\n        closePart(lastPart, now);\n        parts.push({\n          type: \"reasoning\",\n          text: delta.textDelta,\n          startedAt: now,\n        });\n      }\n      break;\n\n    case \"tool-stream\": {\n      const toolInvocation = createReceivingToolInvocation(\n        delta.invocationId,\n        delta.name\n      );\n      parts.push(toolInvocation);\n      break;\n    }\n\n    case \"tool-delta\": {\n      // Take the last part, expect it to be a tool invocation in receiving\n      // stage. If not, ignore this delta. If it is, append the delta to the\n      // parser\n      if (\n        lastPart?.type === \"tool-invocation\" &&\n        lastPart.stage === \"receiving\"\n      ) {\n        lastPart.__appendDelta?.(delta.delta);\n      }\n      // Otherwise ignore the delta - it's out of order or unexpected\n      break;\n    }\n\n    case \"tool-invocation\":\n      replaceOrAppend(parts, delta, (x) => x.invocationId, now);\n      break;\n\n    case \"retrieval\":\n      replaceOrAppend(parts, delta, (x) => x.id, now);\n      break;\n\n    case \"source\": {\n      sources.push(delta);\n      break;\n    }\n\n    default:\n      return assertNever(delta, \"Unhandled case\");\n  }\n\n  // Add the sources part to the parts array at the end if there are any sources\n  if (sources.length > 0) {\n    parts.push({\n      type: \"sources\",\n      sources,\n    });\n  }\n\n  // Replace the content array with the parts array\n  content.length = 0;\n  content.push(...parts);\n}\n\n/**\n * Creates a receiving tool invocation part for testing purposes.\n * This helper eliminates the need to manually create fake tool invocation objects\n * and provides a clean API for tests.\n */\nexport function createReceivingToolInvocation(\n  invocationId: string,\n  name: string,\n  partialArgsText: string = \"\"\n): AiReceivingToolInvocationPart {\n  const parser = new IncrementalJsonParser(partialArgsText); // FRONTEND only\n  return {\n    type: \"tool-invocation\",\n    stage: \"receiving\",\n    invocationId,\n    name,\n    // --- Alternative implementation for FRONTEND only ------------------------\n    get partialArgsText(): string { return parser.source; }, // prettier-ignore\n    get partialArgs(): JsonObject { return parser.json; }, // prettier-ignore\n    __appendDelta(delta: string) { parser.append(delta); }, // prettier-ignore\n    // ------------------------------------------------------------------------\n  } satisfies AiReceivingToolInvocationPart;\n}\n","import { isPlainObject } from \"../lib/guards\";\nimport type { Json } from \"../lib/Json\";\nimport { b64decode, tryParseJson } from \"../lib/utils\";\nimport type { IUserInfo } from \"./BaseUserMeta\";\n\nexport enum Permission {\n  Read = \"room:read\",\n  Write = \"room:write\",\n  PresenceWrite = \"room:presence:write\",\n  CommentsWrite = \"comments:write\",\n  CommentsRead = \"comments:read\",\n}\n\nexport type LiveblocksPermissions = Record<string, Permission[]>;\n\nexport enum TokenKind {\n  ACCESS_TOKEN = \"acc\",\n  ID_TOKEN = \"id\",\n}\n\n/**\n * Infers from the given scopes whether the user can write the document (e.g.\n * Storage and/or YDoc).\n */\nexport function canWriteStorage(scopes: readonly string[]): boolean {\n  return scopes.includes(Permission.Write);\n}\n\nexport function canComment(scopes: readonly string[]): boolean {\n  return (\n    scopes.includes(Permission.CommentsWrite) ||\n    scopes.includes(Permission.Write)\n  );\n}\n\ntype JwtMeta = {\n  iat: number;\n  exp: number;\n};\n\n/**\n * Access Token.\n */\nexport type AccessToken = {\n  k: TokenKind.ACCESS_TOKEN;\n  pid: string; // project id\n  uid: string; // user id\n  perms: LiveblocksPermissions; // permissions\n  ui?: IUserInfo; // user info\n} & JwtMeta;\n\n/**\n * New authorization ID Token.\n */\nexport type IDToken = {\n  k: TokenKind.ID_TOKEN;\n  pid: string; // project id\n  uid: string; // user id\n  gids?: string[]; // group ids\n  ui?: IUserInfo; // user info\n} & JwtMeta;\n\nexport type AuthToken = AccessToken | IDToken;\n\n// The \"rich\" token is data we obtain by parsing the JWT token and making all\n// metadata on it accessible. It's done right after hitting the backend, but\n// before the promise will get returned, so it's an inherent part of the\n// authentication step.\nexport type ParsedAuthToken = {\n  readonly raw: string; // The raw JWT value, unchanged\n  readonly parsed: AuthToken; // Rich data on the JWT value\n};\n\nfunction isValidAuthTokenPayload(data: Json): data is AccessToken | IDToken {\n  return (\n    isPlainObject(data) &&\n    (data.k === TokenKind.ACCESS_TOKEN || data.k === TokenKind.ID_TOKEN)\n  );\n}\n\n/**\n * Parses a raw JWT token string, which allows reading the metadata/payload of\n * the token.\n *\n * NOTE: Doesn't do any validation, so always treat the metadata as other user\n * input: never trust these values for anything important.\n */\nexport function parseAuthToken(rawTokenString: string): ParsedAuthToken {\n  const tokenParts = rawTokenString.split(\".\");\n  if (tokenParts.length !== 3) {\n    throw new Error(\"Authentication error: invalid JWT token\");\n  }\n\n  const payload = tryParseJson(b64decode(tokenParts[1]));\n  if (!(payload && isValidAuthTokenPayload(payload))) {\n    throw new Error(\n      \"Authentication error: expected a valid token but did not get one. Hint: if you are using a callback, ensure the room is passed when creating the token. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientCallback\"\n    );\n  }\n\n  return {\n    raw: rawTokenString,\n    parsed: payload,\n  };\n}\n","import { StopRetrying } from \"./connection\";\nimport { isPlainObject } from \"./lib/guards\";\nimport type { Json } from \"./lib/Json\";\nimport type { Relax } from \"./lib/Relax\";\nimport { stringifyOrLog as stringify } from \"./lib/stringify\";\nimport type {\n  Authentication,\n  CustomAuthenticationResult,\n} from \"./protocol/Authentication\";\nimport type { AuthToken, ParsedAuthToken } from \"./protocol/AuthToken\";\nimport { parseAuthToken, Permission, TokenKind } from \"./protocol/AuthToken\";\nimport type { Polyfills } from \"./room\";\n\nexport type AuthValue =\n  | { type: \"secret\"; token: ParsedAuthToken }\n  | { type: \"public\"; publicApiKey: string };\n\nexport type RequestedScope = \"room:read\" | \"comments:read\";\n\nexport type AuthManager = {\n  reset(): void;\n  getAuthValue(requestOptions: {\n    requestedScope: RequestedScope;\n    roomId?: string;\n  }): Promise<AuthValue>;\n};\n\ntype AuthEndpoint =\n  | string\n  | ((room?: string) => Promise<CustomAuthenticationResult>);\n\nexport type AuthenticationOptions = {\n  polyfills?: Polyfills;\n} & Relax<{ publicApiKey: string } | { authEndpoint: AuthEndpoint }>;\n\nconst NON_RETRY_STATUS_CODES = [\n  400, 401, 403, 404, 405, 410, 412, 414, 422, 431, 451,\n];\n\nexport function createAuthManager(\n  authOptions: AuthenticationOptions,\n  onAuthenticate?: (token: AuthToken) => void\n): AuthManager {\n  const authentication = prepareAuthentication(authOptions);\n\n  const seenTokens: Set<string> = new Set();\n\n  const tokens: ParsedAuthToken[] = [];\n  const expiryTimes: number[] = []; // Supposed to always contain the same number of elements as `tokens`\n\n  const requestPromises = new Map<string, Promise<ParsedAuthToken>>();\n\n  function reset() {\n    seenTokens.clear();\n    tokens.length = 0;\n    expiryTimes.length = 0;\n    requestPromises.clear();\n  }\n\n  function hasCorrespondingScopes(\n    requestedScope: RequestedScope,\n    scopes: Permission[]\n  ) {\n    if (requestedScope === \"comments:read\") {\n      return (\n        scopes.includes(Permission.CommentsRead) ||\n        scopes.includes(Permission.CommentsWrite) ||\n        scopes.includes(Permission.Read) ||\n        scopes.includes(Permission.Write)\n      );\n    } else if (requestedScope === \"room:read\") {\n      return (\n        scopes.includes(Permission.Read) || scopes.includes(Permission.Write)\n      );\n    }\n\n    return false;\n  }\n\n  function getCachedToken(requestOptions: {\n    requestedScope: RequestedScope;\n    roomId?: string;\n  }): ParsedAuthToken | undefined {\n    const now = Math.ceil(Date.now() / 1000);\n\n    for (let i = tokens.length - 1; i >= 0; i--) {\n      const token = tokens[i];\n      const expiresAt = expiryTimes[i];\n\n      // If this token is expired, remove it from cache, as if it never existed\n      // in the first place\n      if (expiresAt <= now) {\n        tokens.splice(i, 1);\n        expiryTimes.splice(i, 1);\n        continue;\n      }\n\n      if (token.parsed.k === TokenKind.ID_TOKEN) {\n        // When ID token method is used, only one token per user should be used and cached at the same time.\n        return token;\n      } else if (token.parsed.k === TokenKind.ACCESS_TOKEN) {\n        // In this version, we accept access tokens with zero permission when issuing token for resources outside a room.\n        if (\n          !requestOptions.roomId &&\n          Object.entries(token.parsed.perms).length === 0\n        ) {\n          return token;\n        }\n\n        for (const [resource, scopes] of Object.entries(token.parsed.perms)) {\n          // If the requester didn't pass a roomId,\n          // it means they need the token to access the user's resources (inbox notifications for example).\n          // We return any access token that contains a wildcard for the requested scope.\n          if (!requestOptions.roomId) {\n            if (\n              resource.includes(\"*\") &&\n              hasCorrespondingScopes(requestOptions.requestedScope, scopes)\n            ) {\n              return token;\n            }\n          } else if (\n            (resource.includes(\"*\") &&\n              requestOptions.roomId.startsWith(resource.replace(\"*\", \"\"))) ||\n            (requestOptions.roomId === resource &&\n              hasCorrespondingScopes(requestOptions.requestedScope, scopes))\n          ) {\n            return token;\n          }\n        }\n      }\n    }\n\n    return undefined;\n  }\n\n  async function makeAuthRequest(options: {\n    requestedScope: RequestedScope;\n    roomId?: string;\n  }): Promise<ParsedAuthToken> {\n    const fetcher =\n      authOptions.polyfills?.fetch ??\n      (typeof window === \"undefined\" ? undefined : window.fetch);\n\n    if (authentication.type === \"private\") {\n      if (fetcher === undefined) {\n        throw new StopRetrying(\n          \"To use Liveblocks client in a non-DOM environment with a url as auth endpoint, you need to provide a fetch polyfill.\"\n        );\n      }\n\n      const response = await fetchAuthEndpoint(fetcher, authentication.url, {\n        room: options.roomId,\n      });\n      const parsed = parseAuthToken(response.token);\n\n      if (seenTokens.has(parsed.raw)) {\n        throw new StopRetrying(\n          \"The same Liveblocks auth token was issued from the backend before. Caching Liveblocks tokens is not supported.\"\n        );\n      }\n\n      onAuthenticate?.(parsed.parsed);\n      return parsed;\n    }\n\n    if (authentication.type === \"custom\") {\n      const response = await authentication.callback(options.roomId);\n      if (response && typeof response === \"object\") {\n        if (typeof response.token === \"string\") {\n          const parsed = parseAuthToken(response.token);\n\n          onAuthenticate?.(parsed.parsed);\n          return parsed;\n        } else if (typeof response.error === \"string\") {\n          const reason = `Authentication failed: ${\n            \"reason\" in response && typeof response.reason === \"string\"\n              ? response.reason\n              : \"Forbidden\"\n          }`;\n\n          // istanbul ignore else\n          if (response.error === \"forbidden\") {\n            throw new StopRetrying(reason);\n          } else {\n            throw new Error(reason);\n          }\n        }\n      }\n\n      throw new Error(\n        'Your authentication callback function should return a token, but it did not. Hint: the return value should look like: { token: \"...\" }'\n      );\n    }\n\n    // istanbul ignore next\n    throw new Error(\n      \"Unexpected authentication type. Must be private or custom.\"\n    );\n  }\n\n  async function getAuthValue(requestOptions: {\n    requestedScope: RequestedScope;\n    roomId?: string;\n  }): Promise<AuthValue> {\n    if (authentication.type === \"public\") {\n      return { type: \"public\", publicApiKey: authentication.publicApiKey };\n    }\n\n    const cachedToken = getCachedToken(requestOptions);\n    if (cachedToken !== undefined) {\n      return { type: \"secret\", token: cachedToken };\n    }\n\n    let currentPromise;\n    if (requestOptions.roomId) {\n      currentPromise = requestPromises.get(requestOptions.roomId);\n      if (currentPromise === undefined) {\n        currentPromise = makeAuthRequest(requestOptions);\n        requestPromises.set(requestOptions.roomId, currentPromise);\n      }\n    } else {\n      currentPromise = requestPromises.get(\"liveblocks-user-token\");\n      if (currentPromise === undefined) {\n        currentPromise = makeAuthRequest(requestOptions);\n        requestPromises.set(\"liveblocks-user-token\", currentPromise);\n      }\n    }\n\n    try {\n      const token = await currentPromise;\n      // Translate \"server timestamps\" to \"local timestamps\" in case clocks aren't in sync\n      const BUFFER = 30; // Expire tokens 30 seconds sooner than they have to\n      const expiresAt =\n        Math.floor(Date.now() / 1000) +\n        (token.parsed.exp - token.parsed.iat) -\n        BUFFER;\n\n      seenTokens.add(token.raw);\n      tokens.push(token);\n      expiryTimes.push(expiresAt);\n\n      return { type: \"secret\", token };\n    } finally {\n      if (requestOptions.roomId) {\n        requestPromises.delete(requestOptions.roomId);\n      } else {\n        requestPromises.delete(\"liveblocks-user-token\");\n      }\n    }\n  }\n\n  return {\n    reset,\n    getAuthValue,\n  };\n}\n\nfunction prepareAuthentication(\n  authOptions: AuthenticationOptions\n): Authentication {\n  const { publicApiKey, authEndpoint } = authOptions;\n\n  if (authEndpoint !== undefined && publicApiKey !== undefined) {\n    throw new Error(\n      \"You cannot simultaneously use `publicApiKey` and `authEndpoint` options. Please pick one and leave the other option unspecified. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClient\"\n    );\n  }\n\n  if (typeof publicApiKey === \"string\") {\n    if (publicApiKey.startsWith(\"sk_\")) {\n      throw new Error(\n        \"Invalid `publicApiKey` option. The value you passed is a secret key, which should not be used from the client. Please only ever pass a public key here. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientPublicKey\"\n      );\n    } else if (!publicApiKey.startsWith(\"pk_\")) {\n      throw new Error(\n        \"Invalid key. Please use the public key format: pk_<public key>. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientPublicKey\"\n      );\n    }\n    return {\n      type: \"public\",\n      publicApiKey,\n    };\n  }\n\n  if (typeof authEndpoint === \"string\") {\n    return {\n      type: \"private\",\n      url: authEndpoint,\n    };\n  } else if (typeof authEndpoint === \"function\") {\n    return {\n      type: \"custom\",\n      callback: authEndpoint,\n    };\n  } else if (authEndpoint !== undefined) {\n    throw new Error(\n      \"The `authEndpoint` option must be a string or a function. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientAuthEndpoint\"\n    );\n  }\n\n  throw new Error(\n    \"Invalid Liveblocks client options. Please provide either a `publicApiKey` or `authEndpoint` option. They cannot both be empty. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClient\"\n  );\n}\n\nasync function fetchAuthEndpoint(\n  fetch: typeof window.fetch,\n  endpoint: string,\n  body: {\n    room?: string;\n  }\n): Promise<{ token: string }> {\n  const res = await fetch(endpoint, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: stringify(body),\n  });\n  if (!res.ok) {\n    const reason = `${\n      (await res.text()).trim() || \"reason not provided in auth response\"\n    } (${res.status} returned by POST ${endpoint})`;\n\n    if (NON_RETRY_STATUS_CODES.includes(res.status)) {\n      // Throw a special error instance, which the connection manager will\n      // recognize and understand that retrying will have no effect\n      throw new StopRetrying(`Unauthorized: ${reason}`);\n    } else {\n      throw new Error(`Failed to authenticate: ${reason}`);\n    }\n  }\n\n  let data: Json;\n  try {\n    data = await (res.json() as Promise<Json>);\n  } catch (er) {\n    throw new Error(\n      `Expected a JSON response when doing a POST request on \"${endpoint}\". ${String(\n        er\n      )}`\n    );\n  }\n\n  if (!isPlainObject(data) || typeof data.token !== \"string\") {\n    throw new Error(\n      `Expected a JSON response of the form \\`{ token: \"...\" }\\` when doing a POST request on \"${endpoint}\", but got ${stringify(\n        data\n      )}`\n    );\n  }\n  const { token } = data;\n  return { token };\n}\n","export const DEFAULT_BASE_URL = \"https://api.liveblocks.io\";\n\nexport const MENTION_CHARACTER = \"@\";\n","import { makeEventSource } from \"../lib/EventSource\";\nimport type * as DevTools from \"./protocol\";\n\ntype SendToPanelOptions = {\n  /**\n   * We'll only want to send messages from the client to the panel if the panel\n   * has shown interest in this. To allow message passing to the dev panel,\n   * call allowMessagePassing().\n   */\n  force: boolean;\n};\n\nlet _bridgeActive = false;\nexport function activateBridge(allowed: boolean): void {\n  _bridgeActive = allowed;\n}\n\nexport function sendToPanel(\n  message: DevTools.ClientToPanelMessage,\n  options?: SendToPanelOptions\n): void {\n  // DevTools communication only happens on the client side\n  // Define it as a no-op in production environments or when run outside of a browser context\n  if (process.env.NODE_ENV === \"production\" || typeof window === \"undefined\") {\n    return;\n  }\n\n  const fullMsg = {\n    ...message,\n    source: \"liveblocks-devtools-client\",\n  };\n\n  if (!(options?.force || _bridgeActive)) {\n    /*\n    // eslint-disable-next-line rulesdir/console-must-be-fancy\n    console.log(\n      \"%c[client → panel] %c%s\",\n      \"color: green\",\n      \"color: gray; font-weight: bold\",\n      fullMsg.msg,\n      \"[🚫 NOT sent!]\"\n    );\n    */\n    return;\n  }\n  /*\n  // eslint-disable-next-line rulesdir/console-must-be-fancy\n  console.log(\n    \"%c[client → panel] %c%s\",\n    \"color: green\",\n    \"color: green; font-weight: bold\",\n    fullMsg.msg,\n    fullMsg\n  );*/\n  window.postMessage(fullMsg, \"*\");\n}\n\nconst eventSource = makeEventSource<DevTools.FullPanelToClientMessage>();\n\n// Define it as a no-op in production environments or when run outside of a browser context\nif (process.env.NODE_ENV !== \"production\" && typeof window !== \"undefined\") {\n  window.addEventListener(\"message\", (event: MessageEvent<unknown>) => {\n    if (\n      event.source === window &&\n      (event.data as Record<string, unknown>)?.source ===\n        \"liveblocks-devtools-panel\"\n    ) {\n      // console.log(\n      //   \"%c[client ← panel] %c%s\",\n      //   \"color: purple\",\n      //   \"color: purple; font-weight: bold\",\n      //   (event.data as Record<string, unknown>).msg,\n      //   event.data\n      // );\n      eventSource.notify(event.data as DevTools.FullPanelToClientMessage);\n    } else {\n      // Message not for us\n    }\n  });\n}\n\nexport const onMessageFromPanel = eventSource.observable;\n","import { kInternal } from \"../internal\";\nimport type { Json, JsonObject } from \"../lib/Json\";\nimport type { BaseUserMeta } from \"../protocol/BaseUserMeta\";\nimport type { UpdateYDocClientMsg } from \"../protocol/ClientMsg\";\nimport type { YDocUpdateServerMsg } from \"../protocol/ServerMsg\";\nimport type { OpaqueRoom, RoomEventMessage } from \"../room\";\nimport { PKG_VERSION } from \"../version\";\nimport { activateBridge, onMessageFromPanel, sendToPanel } from \"./bridge\";\n\nconst VERSION = PKG_VERSION || \"dev\";\nlet _devtoolsSetupHasRun = false;\n\n/**\n * Sends a wake up message to the devtools panel, if any such panel exists, and\n * listens for the initial connect message, which would be the trigger to start\n * emitting updates.\n *\n * Must be called before linkDevTools() can be used.\n *\n * Will only run once, even when called multiple times.\n */\nexport function setupDevTools(getAllRooms: () => string[]): void {\n  // Define it as a no-op in production environments or when run outside of a browser context\n  if (process.env.NODE_ENV === \"production\" || typeof window === \"undefined\") {\n    return;\n  }\n\n  if (_devtoolsSetupHasRun) {\n    // This setup code should only happen the first time\n    return;\n  }\n\n  _devtoolsSetupHasRun = true;\n\n  onMessageFromPanel.subscribe((msg) => {\n    switch (msg.msg) {\n      // When a devtool panel sends an explicit \"connect\" message back to this\n      // live running client (in response to the \"wake-up-devtools\" message,\n      // or when the devtool panel is opened for the first time), it means that it's okay to\n      // start emitting messages.\n      // Before this explicit acknowledgement, any call to sendToPanel() will\n      // be a no-op.\n      case \"connect\": {\n        // Allows future sendToPanel() messages to go through\n        activateBridge(true);\n\n        // Emit an explicit \"room::available\" message for every known room at\n        // this point. These can be used by the devpanel to subscribe to such\n        // room's updates.\n        for (const roomId of getAllRooms()) {\n          sendToPanel({\n            msg: \"room::available\",\n            roomId,\n            clientVersion: VERSION,\n          });\n        }\n\n        break;\n      }\n\n      // TODO: Later on, we can support explicit disconnects, too\n      // case \"disconnect\": {\n      //   // Make sendToPanel() no-ops again\n      //   activateBridge(false);\n      //   break;\n      // }\n    }\n  });\n\n  // Send initial wake up message, in case the devtool panel is already open!\n  sendToPanel({ msg: \"wake-up-devtools\" }, { force: true });\n}\n\nconst unsubsByRoomId = new Map<string, (() => void)[]>();\n\nfunction stopSyncStream(roomId: string): void {\n  const unsubs = unsubsByRoomId.get(roomId) ?? [];\n  unsubsByRoomId.delete(roomId); // Pop it off\n\n  for (const unsub of unsubs) {\n    // Cancel all of the subscriptions to room updates that are synchronizing\n    // partial state to the devtools panel\n    unsub();\n  }\n}\n\n/**\n * Starts, or restarts, the stream of sync messages for the given room. A sync\n * stream consists of an initial \"full sync\" message, followed by many\n * \"partial\" messages that happen whenever part of the room changes.\n */\nfunction startSyncStream(room: OpaqueRoom): void {\n  stopSyncStream(room.id);\n\n  // Sync the room ID instantly, as soon as we know it\n  fullSync(room);\n\n  unsubsByRoomId.set(room.id, [\n    // When the connection status changes\n    room.events.status.subscribe(() => partialSyncConnection(room)),\n\n    // When storage initializes, send the update\n    room.events.storageDidLoad.subscribeOnce(() => partialSyncStorage(room)),\n\n    // Any time storage updates, send the new storage root\n    room.events.storageBatch.subscribe(() => partialSyncStorage(room)),\n\n    // Any time \"me\" or \"others\" updates, send the new values accordingly\n    room.events.self.subscribe(() => partialSyncMe(room)),\n    room.events.others.subscribe(() => partialSyncOthers(room)),\n\n    // Any time ydoc is updated, forward the update\n    room.events.ydoc.subscribe((update) => syncYdocUpdate(room, update)),\n\n    // Any time a custom room event is received, forward it\n    room.events.customEvent.subscribe((eventData) =>\n      forwardEvent(room, eventData)\n    ),\n  ]);\n}\n\nfunction syncYdocUpdate(\n  room: OpaqueRoom,\n  update: YDocUpdateServerMsg | UpdateYDocClientMsg\n) {\n  sendToPanel({\n    msg: \"room::sync::ydoc\",\n    roomId: room.id,\n    update,\n  });\n}\n\nconst loadedAt = Date.now();\nlet eventCounter = 0;\n\nfunction nextEventId() {\n  return `event-${loadedAt}-${eventCounter++}`;\n}\n\nfunction forwardEvent(\n  room: OpaqueRoom,\n  eventData: RoomEventMessage<JsonObject, BaseUserMeta, Json>\n) {\n  sendToPanel({\n    msg: \"room::events::custom-event\",\n    roomId: room.id,\n    event: {\n      type: \"CustomEvent\",\n      id: nextEventId(),\n      key: \"Event\",\n      connectionId: eventData.connectionId,\n      payload: eventData.event,\n    },\n  });\n}\n\nfunction partialSyncConnection(room: OpaqueRoom) {\n  sendToPanel({\n    msg: \"room::sync::partial\",\n    roomId: room.id,\n    status: room.getStatus(),\n  });\n}\n\nfunction partialSyncStorage(room: OpaqueRoom) {\n  const root = room.getStorageSnapshot();\n  if (root) {\n    sendToPanel({\n      msg: \"room::sync::partial\",\n      roomId: room.id,\n      storage: root.toTreeNode(\"root\").payload,\n    });\n  }\n}\n\nfunction partialSyncMe(room: OpaqueRoom) {\n  const me = room[kInternal].getSelf_forDevTools();\n  if (me) {\n    sendToPanel({\n      msg: \"room::sync::partial\",\n      roomId: room.id,\n      me,\n    });\n  }\n}\n\nfunction partialSyncOthers(room: OpaqueRoom) {\n  // Any time others updates, send the new storage root to the dev panel\n  const others = room[kInternal].getOthers_forDevTools();\n  if (others) {\n    sendToPanel({\n      msg: \"room::sync::partial\",\n      roomId: room.id,\n      others,\n    });\n  }\n}\n\nfunction fullSync(room: OpaqueRoom) {\n  const root = room.getStorageSnapshot();\n  const me = room[kInternal].getSelf_forDevTools();\n  const others = room[kInternal].getOthers_forDevTools();\n  // Because the room doesn't have access to the YJS doc, we must tell it to go get the full doc\n  // sending an empty vector will return the whole document and then devtools will be up to date\n  room.fetchYDoc(\"\");\n  sendToPanel({\n    msg: \"room::sync::full\",\n    roomId: room.id,\n    status: room.getStatus(),\n    storage: root?.toTreeNode(\"root\").payload ?? null,\n    me,\n    others,\n  });\n}\n\n// Currently registered \"channel\" listeners, waiting for \"room::subscribe\" or\n// \"room::unsubscribe\" messages coming from the devtools panel\nconst roomChannelListeners = new Map<string, () => void>();\n\nfunction stopRoomChannelListener(roomId: string) {\n  const listener = roomChannelListeners.get(roomId);\n  roomChannelListeners.delete(roomId);\n  if (listener) {\n    listener();\n  }\n}\n\n/**\n * Publicly announce to the devtool panel that a new room is available.\n */\nexport function linkDevTools(roomId: string, room: OpaqueRoom): void {\n  // Define it as a no-op in production environments or when run outside of a browser context\n  if (process.env.NODE_ENV === \"production\" || typeof window === \"undefined\") {\n    return;\n  }\n  sendToPanel({ msg: \"room::available\", roomId, clientVersion: VERSION });\n\n  // Before adding a new listener, stop all active listeners, so there is only\n  // ever going to be one listener per room \"channel\"\n  stopRoomChannelListener(roomId);\n  roomChannelListeners.set(\n    roomId,\n\n    // Returns the unsubscribe callback, that we store in the\n    // roomChannelListeners registry\n    onMessageFromPanel.subscribe((msg) => {\n      switch (msg.msg) {\n        // Sent by the devtool panel when it wants to receive the sync stream\n        // for a room\n        case \"room::subscribe\": {\n          // Only act on this message if it's intended for this room\n          if (msg.roomId === roomId) {\n            startSyncStream(room);\n          }\n          break;\n        }\n\n        case \"room::unsubscribe\": {\n          // Only act on this message if it's intended for this room\n          if (msg.roomId === roomId) {\n            stopSyncStream(roomId);\n          }\n          break;\n        }\n      }\n    })\n  );\n}\n\nexport function unlinkDevTools(roomId: string): void {\n  // Define it as a no-op in production environments or when run outside of a browser context\n  if (process.env.NODE_ENV === \"production\" || typeof window === \"undefined\") {\n    return;\n  }\n\n  // Immediately stop the sync stream of room updates to the dev panel\n  stopSyncStream(roomId);\n\n  stopRoomChannelListener(roomId);\n\n  // Inform dev panel that this room is no longer available\n  sendToPanel({\n    msg: \"room::unavailable\",\n    roomId,\n  });\n}\n","import * as console from \"./fancy-console\";\n\n// Keeps a set of messages in memory that it has warned about\n// already. There will be only one message in the console, no\n// matter how often it gets called.\nconst _emittedWarnings: Set<string> = new Set();\n\n/**\n * Emit a warning only once.\n *\n * Only has effect in dev mode. In production, this is a no-op.\n */\n// istanbul ignore next\nexport function warnOnce(message: string, key = message): void {\n  if (process.env.NODE_ENV !== \"production\") {\n    if (!_emittedWarnings.has(key)) {\n      _emittedWarnings.add(key);\n      console.warn(message);\n    }\n  }\n}\n\n/**\n * Emit a warning only once if a condition is met.\n *\n * Only has effect in dev mode. In production, this is a no-op.\n */\n// istanbul ignore next\nexport function warnOnceIf(\n  condition: boolean | (() => boolean),\n  message: string,\n  key = message\n): void {\n  if (typeof condition === \"function\" ? condition() : condition) {\n    warnOnce(message, key);\n  }\n}\n","import type { DAD } from \"../globals/augmentation\";\nimport * as console from \"../lib/fancy-console\";\nimport { create, entries, keys, values } from \"../lib/utils\";\n\n/**\n * Pre-defined notification channels support list.\n */\nexport type NotificationChannel = \"email\" | \"slack\" | \"teams\" | \"webPush\";\n\n/**\n * `K` represents custom notification kinds\n * defined in the augmentation `ActivitiesData` (e.g `liveblocks.config.ts`).\n * It means the type `NotificationKind` will be shaped like:\n * thread | textMention | $customKind1 | $customKind2 | ...\n */\nexport type NotificationKind<K extends keyof DAD = keyof DAD> =\n  | \"thread\"\n  | \"textMention\"\n  | K;\n\n/**\n * A notification channel settings is a set of notification kinds.\n * One setting can have multiple kinds (+ augmentation)\n */\nexport type NotificationChannelSettings = {\n  [K in NotificationKind]: boolean;\n};\n\n/**\n * @private\n *\n * Base definition of notification settings.\n * Plain means it's a simple object coming from the remote backend.\n *\n * It's the raw settings object where somme channels cannot exists\n * because there are no notification kinds enabled on the dashboard.\n * And this object isn't yet proxied by the creator factory `createNotificationSettings`.\n */\nexport type NotificationSettingsPlain = {\n  [C in NotificationChannel]?: NotificationChannelSettings;\n};\n\n/**\n * @internal\n *\n * Symbol to branch plain value of notification settings\n * inside the NotificationSettings object.\n */\nconst kPlain = Symbol(\"notification-settings-plain\");\n\n/**\n * @internal\n * Proxied `NotificationSettingsPlain` object.\n */\ntype ProxiedNotificationSettings = NotificationSettingsPlain;\n\n/**\n * Notification settings.\n * One channel for one set of settings.\n */\nexport type NotificationSettings = {\n  [C in NotificationChannel]: NotificationChannelSettings | null;\n};\n\n/**\n * It creates a deep partial specific for `NotificationSettings`\n * to offer a nice DX when updating the settings (e.g not being forced to define every keys)\n * and at the same the some preserver the augmentation for custom kinds (e.g `liveblocks.config.ts`).\n */\ntype DeepPartialWithAugmentation<T> = T extends object\n  ? {\n      [P in keyof T]?: T[P] extends { [K in NotificationKind]: boolean }\n        ? Partial<T[P]> & { [K in keyof DAD]?: boolean }\n        : DeepPartialWithAugmentation<T[P]>;\n    }\n  : T;\n\n/**\n * Partial notification settings with augmentation preserved gracefully.\n * It means you can update the settings without being forced to define every keys.\n * Useful when implementing update functions.\n */\nexport type PartialNotificationSettings =\n  DeepPartialWithAugmentation<NotificationSettingsPlain>;\n\n/**\n * @private\n *\n * Creates a `NotificationSettings` object with the given initial plain settings.\n * It defines a getter for each channel to access the settings and returns `null` with an error log\n * in case the required channel isn't enabled in the dashboard.\n *\n * You can see this function as `Proxy` like around `NotificationSettingsPlain` type.\n * We can't predict what will be enabled on the dashboard or not, so it's important\n * provide a good DX to developers by returning `null` completed by an error log\n * when they try to access a channel that isn't enabled in the dashboard.\n */\nexport function createNotificationSettings(\n  plain: NotificationSettingsPlain\n): NotificationSettings {\n  const channels: NotificationChannel[] = [\n    \"email\",\n    \"slack\",\n    \"teams\",\n    \"webPush\",\n  ];\n  const descriptors: PropertyDescriptorMap &\n    ThisType<NotificationSettings & { [kPlain]: ProxiedNotificationSettings }> =\n    {\n      [kPlain]: {\n        value: plain,\n        enumerable: false,\n      },\n    };\n\n  for (const channel of channels) {\n    descriptors[channel] = {\n      enumerable: true,\n      /**\n       * In the TypeScript standard library definitions, the built-in interface for a property descriptor\n       * does not include a specialized type for the “this” context in the getter or setter functions.\n       * As a result, both the ⁠get and ⁠set methods implicitly have ⁠this: any.\n       * The reason is that property descriptors in JavaScript are used across various objects with\n       * no enforced shape for ⁠this. And so the standard library definitions have to remain as broad as possible\n       * to support any valid JavaScript usage (e.g `Object.defineProperty`).\n       *\n       * So we can safely tells that this getter is typed as `this: NotificationSettings` because we're\n       * creating a well known shaped object → `NotificationSettings`.\n       */\n      get(\n        this: NotificationSettings & {\n          [kPlain]: ProxiedNotificationSettings;\n        }\n      ): NotificationChannelSettings | null {\n        const value = this[kPlain][channel];\n        if (typeof value === \"undefined\") {\n          console.error(\n            `In order to use the '${channel}' channel, please set up your project first. For more information: https://liveblocks.io/docs/errors/enable-a-notification-channel`\n          );\n          return null;\n        }\n        return value;\n      },\n    };\n  }\n\n  return create<NotificationSettings>(null, descriptors);\n}\n\n/**\n * @private\n *\n * Patch a `NotificationSettings` object by applying notification kind updates\n * coming from a `PartialNotificationSettings` object.\n */\nexport function patchNotificationSettings(\n  existing: NotificationSettings,\n  patch: PartialNotificationSettings\n): NotificationSettings {\n  // Create a copy of the settings object to mutate\n  const outcoming = createNotificationSettings({\n    ...(\n      existing as NotificationSettings & {\n        [kPlain]: ProxiedNotificationSettings;\n      }\n    )[kPlain],\n  });\n\n  for (const channel of keys(patch)) {\n    const updates = patch[channel];\n    if (updates !== undefined) {\n      const kindUpdates = Object.fromEntries(\n        entries(updates).filter(([, value]) => value !== undefined)\n      ) as NotificationChannelSettings; // Fine to type cast here because we've filtered out undefined values\n\n      (\n        outcoming as NotificationSettings & {\n          [kPlain]: ProxiedNotificationSettings;\n        }\n      )[kPlain][channel] = {\n        ...(\n          outcoming as NotificationSettings & {\n            [kPlain]: ProxiedNotificationSettings;\n          }\n        )[kPlain][channel],\n        ...kindUpdates,\n      };\n    }\n  }\n\n  return outcoming;\n}\n\n/**\n *\n * Utility to check if a notification channel settings\n * is enabled for every notification kinds.\n *\n * Usage:\n * ```ts\n * const isEmailChannelEnabled = isNotificationChannelEnabled(settings.email);\n * ```\n */\nexport function isNotificationChannelEnabled(\n  settings: NotificationChannelSettings | null\n): boolean {\n  return settings !== null\n    ? values(settings).every((enabled) => enabled === true)\n    : false;\n}\n","import type { BadgeLocation } from \"./types/Others\";\n\nconst OFFSET = \"12px\";\n\nconst injectBrandBadge = (\n  badgeLocation: BadgeLocation = \"bottom-right\"\n): void => {\n  // Only inject in browser environments\n  if (typeof document === \"undefined\") {\n    return;\n  }\n\n  // Check if badge already exists to avoid duplicates\n  if (document.getElementById(\"liveblocks-badge\")) {\n    return;\n  }\n\n  // Create and inject the badge HTML\n  const badgeDiv = document.createElement(\"div\");\n  badgeDiv.id = \"liveblocks-badge\";\n  badgeDiv.style.position = \"fixed\";\n  badgeDiv.style.opacity = \"0\";\n  badgeDiv.style.transition = \"opacity 300ms\";\n  badgeDiv.style.zIndex = \"9999\";\n\n  // Set position based on badgeLocation\n  switch (badgeLocation) {\n    case \"top-right\":\n      badgeDiv.style.top = OFFSET;\n      badgeDiv.style.right = OFFSET;\n      break;\n    case \"bottom-right\":\n      badgeDiv.style.bottom = OFFSET;\n      badgeDiv.style.right = OFFSET;\n      break;\n    case \"bottom-left\":\n      badgeDiv.style.bottom = OFFSET;\n      badgeDiv.style.left = OFFSET;\n      break;\n    case \"top-left\":\n      badgeDiv.style.top = OFFSET;\n      badgeDiv.style.left = OFFSET;\n      break;\n  }\n  badgeDiv.onmouseenter = () => {\n    const hideButton = document.getElementById(\"liveblocks-badge-hide-button\");\n    if (hideButton) {\n      hideButton.style.opacity = \"0.3\";\n    }\n  };\n  badgeDiv.onmouseleave = () => {\n    const hideButton = document.getElementById(\"liveblocks-badge-hide-button\");\n    if (hideButton) {\n      hideButton.style.opacity = \"0\";\n    }\n  };\n\n  const link = document.createElement(\"a\");\n  link.href = \"https://lblcks.io/badge\";\n  link.target = \"_blank\";\n  link.rel = \"noopener noreferrer\";\n  link.title = \"Liveblocks\";\n\n  const svg = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n  svg.setAttribute(\"width\", \"111\");\n  svg.setAttribute(\"height\", \"38\");\n  svg.setAttribute(\"viewBox\", \"0 0 111 38\");\n  svg.setAttribute(\"fill\", \"none\");\n\n  const rect1 = document.createElementNS(\"http://www.w3.org/2000/svg\", \"rect\");\n  rect1.setAttribute(\"x\", \"1\");\n  rect1.setAttribute(\"y\", \"1\");\n  rect1.setAttribute(\"width\", \"109\");\n  rect1.setAttribute(\"height\", \"36\");\n  rect1.setAttribute(\"rx\", \"8\");\n  rect1.setAttribute(\"fill\", \"white\");\n  svg.appendChild(rect1);\n\n  const rect2 = document.createElementNS(\"http://www.w3.org/2000/svg\", \"rect\");\n  rect2.setAttribute(\"x\", \"0.5\");\n  rect2.setAttribute(\"y\", \"0.5\");\n  rect2.setAttribute(\"width\", \"110\");\n  rect2.setAttribute(\"height\", \"37\");\n  rect2.setAttribute(\"rx\", \"8.5\");\n  rect2.setAttribute(\"stroke\", \"black\");\n  rect2.setAttribute(\"stroke-opacity\", \"0.1\");\n  svg.appendChild(rect2);\n\n  const path1 = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n  path1.setAttribute(\n    \"d\",\n    \"M39.8256 18.0832H38L38.0005 28.9009H39.8256V18.0832ZM43.213 21.1757H41.3879V28.9009H43.213V21.1757ZM43.213 18H41.3879V19.9688H43.213V18ZM45.8916 21.1757H43.9302L46.6915 28.9009H48.7283L51.4896 21.1757H49.5581L48.4039 24.8348C48.3739 24.93 48.2657 25.3024 48.0795 25.9511L47.7099 27.1959C47.4914 26.406 47.2626 25.6189 47.0237 24.8348L45.8916 21.1757ZM58.9659 23.59C58.8147 23.0721 58.5934 22.6317 58.3014 22.2694C57.9743 21.8628 57.5598 21.5482 57.0571 21.3268C56.5589 21.1004 56.0058 20.9877 55.3973 20.9877C54.2407 20.9877 53.3152 21.3495 52.6212 22.0735C52.275 22.4476 52.0103 22.8896 51.844 23.3715C51.6731 23.8691 51.5876 24.4199 51.5876 25.0233C51.5876 26.3157 51.9322 27.3142 52.6217 28.0184C53.3203 28.7323 54.2509 29.0894 55.4125 29.0894C56.4083 29.0894 57.2151 28.8658 57.8342 28.4181C58.453 27.9704 58.8628 27.3068 59.0638 26.4266L57.2834 26.2908C57.198 26.7685 57.0016 27.1257 56.6948 27.3618C56.3879 27.5933 55.9555 27.7093 55.3973 27.7093C54.1201 27.7093 53.4663 26.9899 53.4363 25.5514H59.1844L59.1922 25.295C59.1922 24.6763 59.1165 24.108 58.9659 23.59ZM53.8434 23.0471C54.1654 22.5943 54.6834 22.3679 55.3973 22.3679C55.7443 22.3679 56.0363 22.4155 56.2725 22.5111C56.509 22.6067 56.7128 22.7601 56.8837 22.9713C57.0167 23.1352 57.1189 23.3218 57.1855 23.5221C57.2605 23.731 57.3062 23.9493 57.3213 24.1708H53.451C53.4964 23.7231 53.6271 23.3484 53.8434 23.0471ZM66.2836 21.4779C65.7656 21.1406 65.1673 20.9724 64.4885 20.9724H64.4875C63.995 20.9724 63.5449 21.0727 63.1374 21.2742C62.7364 21.4696 62.3931 21.7659 62.1412 22.1341V18.0832H60.316V28.9009H62.1416V27.8373C62.373 28.2195 62.7008 28.5342 63.0921 28.7499C63.4996 28.9763 63.9497 29.0894 64.4422 29.0894C65.1266 29.0894 65.7324 28.9259 66.2614 28.5992C66.7891 28.2726 67.1989 27.8045 67.4905 27.1959C67.7871 26.5823 67.9359 25.8634 67.9359 25.0386C67.9359 24.2337 67.7895 23.5248 67.4984 22.9113C67.2115 22.2926 66.8066 21.8148 66.2836 21.4779ZM65.5064 27.0828C65.2148 27.5254 64.7172 27.7463 64.0125 27.7463C63.3786 27.7463 62.9013 27.5175 62.5797 27.0601C62.2576 26.6026 62.0968 25.9336 62.0968 25.0534C62.0968 24.2032 62.24 23.5397 62.5265 23.0619C62.8185 22.579 63.3088 22.3378 63.9978 22.3378C64.7019 22.3378 65.2023 22.5592 65.499 23.0013C65.7961 23.4389 65.944 24.1181 65.944 25.0386C65.944 25.9585 65.7985 26.6401 65.5064 27.0828ZM70.901 18.0832H69.0754V28.9009H70.901V18.0832ZM73.8582 28.6066C74.452 28.9286 75.1558 29.0894 75.9708 29.0894C76.7554 29.0894 77.4444 28.9208 78.0377 28.5844C78.6268 28.2569 79.1068 27.7637 79.4183 27.1659C79.745 26.5523 79.9086 25.843 79.9086 25.0386C79.9086 24.2642 79.7478 23.5697 79.4257 22.9565C79.117 22.3516 78.6404 21.8487 78.0529 21.508C77.4592 21.161 76.7652 20.9872 75.9708 20.9872C75.171 20.9872 74.4719 21.161 73.8735 21.508C73.2876 21.8472 72.811 22.3471 72.5002 22.9486C72.1837 23.5572 72.0252 24.254 72.0252 25.0386C72.0252 25.8735 72.181 26.5948 72.4929 27.2033C72.7962 27.798 73.2722 28.2871 73.8582 28.6066ZM77.4869 27.0906C77.18 27.5231 76.6746 27.7393 75.9708 27.7393C75.493 27.7393 75.1082 27.6437 74.8166 27.4524C74.5246 27.2565 74.3134 26.9621 74.1826 26.5699C74.0518 26.1725 73.9867 25.6619 73.9867 25.0381C73.9867 24.1029 74.1401 23.419 74.4469 22.9866C74.7588 22.5541 75.2667 22.3378 75.9708 22.3378C76.6699 22.3378 77.1727 22.5541 77.4795 22.9866C77.7914 23.419 77.9471 24.1029 77.9471 25.0386C77.9471 25.9738 77.7937 26.6576 77.4869 27.0906ZM82.3982 28.6066C82.9869 28.9286 83.6883 29.0894 84.5033 29.0894C85.1369 29.0894 85.7029 28.9791 86.2005 28.7577C86.6989 28.5364 87.1031 28.2272 87.4152 27.8299C87.7279 27.4249 87.9329 26.9471 88.0109 26.4414L86.2534 26.2607C86.1328 26.7431 85.9316 27.1031 85.6497 27.3392C85.3683 27.5757 84.9857 27.694 84.5033 27.694C84.0103 27.694 83.6232 27.5933 83.3413 27.3918C83.0598 27.1858 82.8635 26.8919 82.7531 26.5093C82.6422 26.1221 82.5872 25.6318 82.5872 25.0386C82.5872 24.455 82.6422 23.9722 82.7531 23.59C82.8635 23.2028 83.0571 22.9062 83.3339 22.6997C83.6157 22.4884 84.0053 22.3831 84.5033 22.3831C85.0362 22.3831 85.4312 22.5314 85.6877 22.8281C85.949 23.1196 86.1354 23.5193 86.2456 24.0276L87.9735 23.718C87.8078 22.8932 87.4326 22.232 86.8491 21.7344C86.2708 21.2363 85.489 20.9877 84.5033 20.9877C83.6985 20.9877 83.0021 21.1587 82.4134 21.5006C81.8322 21.8351 81.3625 22.3337 81.0633 22.9339C80.7514 23.5424 80.5952 24.2439 80.5952 25.0386C80.5952 25.8781 80.7486 26.6026 81.0554 27.2112C81.3673 27.8197 81.8151 28.285 82.3982 28.6066ZM90.8104 26.0343L91.6627 25.2192L93.9257 28.9009H96.0308L92.8999 24.0498L95.9328 21.1757H93.5634L90.8104 23.9976V18.0832H88.9845V28.9009H90.8104V26.0343ZM97.6304 28.8103C98.1436 28.9965 98.7142 29.0894 99.3428 29.0894C100.303 29.0894 101.095 28.8981 101.719 28.5165C102.348 28.1339 102.663 27.5101 102.663 26.6451C102.663 26.0818 102.516 25.6392 102.225 25.3176C101.933 24.9905 101.586 24.7566 101.184 24.6157C100.786 24.4702 100.245 24.3219 99.562 24.1707C99.1642 24.0853 98.8502 24.0049 98.6188 23.9295C98.3873 23.8538 98.201 23.7558 98.0604 23.6352C97.925 23.5141 97.8567 23.3584 97.8567 23.1676C97.8567 22.8858 97.9824 22.6723 98.2338 22.5263C98.4853 22.3803 98.7973 22.3073 99.1694 22.3073C99.6619 22.3073 100.047 22.4255 100.324 22.6621C100.605 22.8987 100.756 23.2531 100.776 23.7258L102.466 23.4467C102.385 22.5817 102.046 21.9556 101.447 21.568C100.854 21.1812 100.095 20.9872 99.1694 20.9872C98.6258 20.9872 98.1236 21.0699 97.6607 21.2362C97.2029 21.397 96.8335 21.6511 96.5517 21.9986C96.27 22.3451 96.1294 22.7827 96.1294 23.3109C96.1294 23.7988 96.25 24.1934 96.4911 24.4951C96.7368 24.8001 97.0527 25.0408 97.4118 25.1965C97.7838 25.3578 98.2512 25.5112 98.8147 25.6567L99.2828 25.7699C99.5949 25.844 99.9044 25.9295 100.211 26.0264C100.421 26.092 100.595 26.1826 100.731 26.2981C100.867 26.4136 100.935 26.5647 100.935 26.7509C100.935 27.0776 100.799 27.3294 100.527 27.505C100.261 27.6815 99.8708 27.7693 99.3583 27.7693C98.8347 27.7693 98.4176 27.6385 98.1055 27.377C97.7941 27.1154 97.6355 26.7384 97.6304 26.2454L95.9109 26.4413C95.9302 27.0351 96.094 27.5304 96.4009 27.9278C96.7129 28.3252 97.1223 28.619 97.6304 28.8103Z\"\n  );\n  path1.setAttribute(\"fill\", \"black\");\n  svg.appendChild(path1);\n\n  const path2 = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n  path2.setAttribute(\n    \"d\",\n    \"M37.6392 15V9.18182H39.7131C40.1657 9.18182 40.5407 9.2642 40.8381 9.42898C41.1354 9.59375 41.358 9.81913 41.5057 10.1051C41.6534 10.3892 41.7273 10.7093 41.7273 11.0653C41.7273 11.4233 41.6525 11.7453 41.5028 12.0312C41.3551 12.3153 41.1316 12.5407 40.8324 12.7074C40.535 12.8722 40.161 12.9545 39.7102 12.9545H38.2841V12.2102H39.6307C39.9167 12.2102 40.1487 12.161 40.3267 12.0625C40.5047 11.9621 40.6354 11.8258 40.7188 11.6534C40.8021 11.4811 40.8438 11.285 40.8438 11.0653C40.8438 10.8456 40.8021 10.6506 40.7188 10.4801C40.6354 10.3097 40.5038 10.1761 40.3239 10.0795C40.1458 9.98295 39.911 9.93466 39.6193 9.93466H38.517V15H37.6392ZM44.4716 15.0881C44.0625 15.0881 43.7055 14.9943 43.4006 14.8068C43.0956 14.6193 42.8589 14.357 42.6903 14.0199C42.5218 13.6828 42.4375 13.2888 42.4375 12.8381C42.4375 12.3854 42.5218 11.9896 42.6903 11.6506C42.8589 11.3116 43.0956 11.0483 43.4006 10.8608C43.7055 10.6733 44.0625 10.5795 44.4716 10.5795C44.8807 10.5795 45.2377 10.6733 45.5426 10.8608C45.8475 11.0483 46.0843 11.3116 46.2528 11.6506C46.4214 11.9896 46.5057 12.3854 46.5057 12.8381C46.5057 13.2888 46.4214 13.6828 46.2528 14.0199C46.0843 14.357 45.8475 14.6193 45.5426 14.8068C45.2377 14.9943 44.8807 15.0881 44.4716 15.0881ZM44.4744 14.375C44.7396 14.375 44.9593 14.3049 45.1335 14.1648C45.3078 14.0246 45.4366 13.8381 45.5199 13.6051C45.6051 13.3722 45.6477 13.1155 45.6477 12.8352C45.6477 12.5568 45.6051 12.3011 45.5199 12.0682C45.4366 11.8333 45.3078 11.6449 45.1335 11.5028C44.9593 11.3608 44.7396 11.2898 44.4744 11.2898C44.2074 11.2898 43.9858 11.3608 43.8097 11.5028C43.6354 11.6449 43.5057 11.8333 43.4205 12.0682C43.3371 12.3011 43.2955 12.5568 43.2955 12.8352C43.2955 13.1155 43.3371 13.3722 43.4205 13.6051C43.5057 13.8381 43.6354 14.0246 43.8097 14.1648C43.9858 14.3049 44.2074 14.375 44.4744 14.375ZM48.267 15L46.983 10.6364H47.8608L48.7159 13.8409H48.7585L49.6165 10.6364H50.4943L51.3466 13.8267H51.3892L52.2386 10.6364H53.1165L51.8352 15H50.9688L50.0824 11.8494H50.017L49.1307 15H48.267ZM55.6705 15.0881C55.2405 15.0881 54.8703 14.9962 54.5597 14.8125C54.2509 14.6269 54.0123 14.3665 53.8438 14.0312C53.6771 13.6941 53.5938 13.2992 53.5938 12.8466C53.5938 12.3996 53.6771 12.0057 53.8438 11.6648C54.0123 11.3239 54.2472 11.0578 54.5483 10.8665C54.8513 10.6752 55.2055 10.5795 55.6108 10.5795C55.857 10.5795 56.0956 10.6203 56.3267 10.7017C56.5578 10.7831 56.7652 10.911 56.9489 11.0852C57.1326 11.2595 57.2775 11.4858 57.3835 11.7642C57.4896 12.0407 57.5426 12.3769 57.5426 12.7727V13.0739H54.0739V12.4375H56.7102C56.7102 12.214 56.6648 12.0161 56.5739 11.8438C56.483 11.6695 56.3551 11.5322 56.1903 11.4318C56.0275 11.3314 55.8362 11.2812 55.6165 11.2812C55.3778 11.2812 55.1695 11.34 54.9915 11.4574C54.8153 11.5729 54.679 11.7244 54.5824 11.9119C54.4877 12.0975 54.4403 12.2992 54.4403 12.517V13.0142C54.4403 13.3059 54.4915 13.554 54.5938 13.7585C54.6979 13.9631 54.8428 14.1193 55.0284 14.2273C55.214 14.3333 55.4309 14.3864 55.679 14.3864C55.84 14.3864 55.9867 14.3636 56.1193 14.3182C56.2519 14.2708 56.3665 14.2008 56.4631 14.108C56.5597 14.0152 56.6335 13.9006 56.6847 13.7642L57.4886 13.9091C57.4242 14.1458 57.3087 14.3532 57.142 14.5312C56.9773 14.7074 56.7699 14.8447 56.5199 14.9432C56.2718 15.0398 55.9886 15.0881 55.6705 15.0881ZM58.4851 15V10.6364H59.3061V11.3295H59.3516C59.4311 11.0947 59.5713 10.91 59.772 10.7756C59.9747 10.6392 60.2038 10.571 60.4595 10.571C60.5125 10.571 60.575 10.5729 60.647 10.5767C60.7209 10.5805 60.7786 10.5852 60.8203 10.5909V11.4034C60.7862 11.3939 60.7256 11.3835 60.6385 11.3722C60.5514 11.3589 60.4643 11.3523 60.3771 11.3523C60.1764 11.3523 59.9974 11.3949 59.8402 11.4801C59.6849 11.5634 59.5618 11.6799 59.4709 11.8295C59.38 11.9773 59.3345 12.1458 59.3345 12.3352V15H58.4851ZM63.2798 15.0881C62.8499 15.0881 62.4796 14.9962 62.169 14.8125C61.8603 14.6269 61.6217 14.3665 61.4531 14.0312C61.2865 13.6941 61.2031 13.2992 61.2031 12.8466C61.2031 12.3996 61.2865 12.0057 61.4531 11.6648C61.6217 11.3239 61.8565 11.0578 62.1577 10.8665C62.4607 10.6752 62.8149 10.5795 63.2202 10.5795C63.4664 10.5795 63.705 10.6203 63.9361 10.7017C64.1671 10.7831 64.3745 10.911 64.5582 11.0852C64.742 11.2595 64.8868 11.4858 64.9929 11.7642C65.099 12.0407 65.152 12.3769 65.152 12.7727V13.0739H61.6832V12.4375H64.3196C64.3196 12.214 64.2741 12.0161 64.1832 11.8438C64.0923 11.6695 63.9645 11.5322 63.7997 11.4318C63.6368 11.3314 63.4455 11.2812 63.2259 11.2812C62.9872 11.2812 62.7789 11.34 62.6009 11.4574C62.4247 11.5729 62.2884 11.7244 62.1918 11.9119C62.0971 12.0975 62.0497 12.2992 62.0497 12.517V13.0142C62.0497 13.3059 62.1009 13.554 62.2031 13.7585C62.3073 13.9631 62.4522 14.1193 62.6378 14.2273C62.8234 14.3333 63.0402 14.3864 63.2884 14.3864C63.4493 14.3864 63.5961 14.3636 63.7287 14.3182C63.8613 14.2708 63.9759 14.2008 64.0724 14.108C64.169 14.0152 64.2429 13.9006 64.294 13.7642L65.098 13.9091C65.0336 14.1458 64.9181 14.3532 64.7514 14.5312C64.5866 14.7074 64.3793 14.8447 64.1293 14.9432C63.8812 15.0398 63.598 15.0881 63.2798 15.0881ZM67.728 15.0852C67.3757 15.0852 67.0613 14.9953 66.7848 14.8153C66.5102 14.6335 66.2943 14.375 66.1371 14.0398C65.9818 13.7027 65.9041 13.2983 65.9041 12.8267C65.9041 12.3551 65.9827 11.9517 66.1399 11.6165C66.299 11.2812 66.5168 11.0246 66.7933 10.8466C67.0698 10.6686 67.3833 10.5795 67.7337 10.5795C68.0045 10.5795 68.2223 10.625 68.3871 10.7159C68.5537 10.8049 68.6825 10.9091 68.7734 11.0284C68.8662 11.1477 68.9382 11.2528 68.9893 11.3438H69.0405V9.18182H69.8899V15H69.0604V14.321H68.9893C68.9382 14.4138 68.8643 14.5199 68.7678 14.6392C68.6731 14.7585 68.5424 14.8627 68.3757 14.9517C68.209 15.0407 67.9931 15.0852 67.728 15.0852ZM67.9155 14.3608C68.1598 14.3608 68.3662 14.2964 68.5348 14.1676C68.7053 14.0369 68.834 13.8561 68.9212 13.625C69.0102 13.3939 69.0547 13.125 69.0547 12.8182C69.0547 12.5152 69.0111 12.25 68.924 12.0227C68.8369 11.7955 68.709 11.6184 68.5405 11.4915C68.3719 11.3646 68.1636 11.3011 67.9155 11.3011C67.6598 11.3011 67.4467 11.3674 67.2763 11.5C67.1058 11.6326 66.977 11.8134 66.8899 12.0426C66.8047 12.2718 66.7621 12.5303 66.7621 12.8182C66.7621 13.1098 66.8056 13.3722 66.8928 13.6051C66.9799 13.8381 67.1087 14.0227 67.2791 14.1591C67.4515 14.2936 67.6636 14.3608 67.9155 14.3608ZM73.2876 15V9.18182H74.1371V11.3438H74.1882C74.2375 11.2528 74.3085 11.1477 74.4013 11.0284C74.4941 10.9091 74.6229 10.8049 74.7876 10.7159C74.9524 10.625 75.1702 10.5795 75.4411 10.5795C75.7933 10.5795 76.1077 10.6686 76.3842 10.8466C76.6607 11.0246 76.8776 11.2812 77.0348 11.6165C77.1939 11.9517 77.2734 12.3551 77.2734 12.8267C77.2734 13.2983 77.1948 13.7027 77.0376 14.0398C76.8804 14.375 76.6645 14.6335 76.3899 14.8153C76.1153 14.9953 75.8018 15.0852 75.4496 15.0852C75.1844 15.0852 74.9676 15.0407 74.799 14.9517C74.6323 14.8627 74.5017 14.7585 74.407 14.6392C74.3123 14.5199 74.2393 14.4138 74.1882 14.321H74.1172V15H73.2876ZM74.12 12.8182C74.12 13.125 74.1645 13.3939 74.2536 13.625C74.3426 13.8561 74.4714 14.0369 74.6399 14.1676C74.8085 14.2964 75.0149 14.3608 75.2592 14.3608C75.513 14.3608 75.7251 14.2936 75.8956 14.1591C76.0661 14.0227 76.1948 13.8381 76.282 13.6051C76.371 13.3722 76.4155 13.1098 76.4155 12.8182C76.4155 12.5303 76.3719 12.2718 76.2848 12.0426C76.1996 11.8134 76.0708 11.6326 75.8984 11.5C75.728 11.3674 75.5149 11.3011 75.2592 11.3011C75.013 11.3011 74.8047 11.3646 74.6342 11.4915C74.4657 11.6184 74.3378 11.7955 74.2507 12.0227C74.1636 12.25 74.12 12.5152 74.12 12.8182ZM78.6158 16.6364C78.4889 16.6364 78.3733 16.6259 78.2692 16.6051C78.165 16.5862 78.0874 16.5653 78.0362 16.5426L78.2408 15.8466C78.3961 15.8883 78.5343 15.9063 78.6555 15.9006C78.7768 15.8949 78.8838 15.8494 78.9766 15.7642C79.0713 15.679 79.1546 15.5398 79.2266 15.3466L79.3317 15.0568L77.7351 10.6364H78.6442L79.7493 14.0227H79.7947L80.8999 10.6364H81.8118L80.0135 15.5824C79.9302 15.8097 79.8241 16.0019 79.6953 16.1591C79.5665 16.3182 79.4131 16.4375 79.2351 16.517C79.0571 16.5966 78.8506 16.6364 78.6158 16.6364Z\"\n  );\n  path2.setAttribute(\"fill\", \"black\");\n  path2.setAttribute(\"fill-opacity\", \"0.5\");\n  svg.appendChild(path2);\n\n  const rect3 = document.createElementNS(\"http://www.w3.org/2000/svg\", \"rect\");\n  rect3.setAttribute(\"x\", \"7\");\n  rect3.setAttribute(\"y\", \"7\");\n  rect3.setAttribute(\"width\", \"24\");\n  rect3.setAttribute(\"height\", \"24\");\n  rect3.setAttribute(\"rx\", \"3\");\n  rect3.setAttribute(\"fill\", \"black\");\n  svg.appendChild(rect3);\n\n  const path3 = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n  path3.setAttribute(\"fill-rule\", \"evenodd\");\n  path3.setAttribute(\"clip-rule\", \"evenodd\");\n  path3.setAttribute(\n    \"d\",\n    \"M22.0455 15H12.2273L15.1364 17.9091V21.9091L22.0455 15Z\"\n  );\n  path3.setAttribute(\"fill\", \"white\");\n  svg.appendChild(path3);\n\n  const path4 = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n  path4.setAttribute(\"fill-rule\", \"evenodd\");\n  path4.setAttribute(\"clip-rule\", \"evenodd\");\n  path4.setAttribute(\n    \"d\",\n    \"M16.9546 22.9999H26.7728L23.8637 20.0908V16.0908L16.9546 22.9999Z\"\n  );\n  path4.setAttribute(\"fill\", \"white\");\n  svg.appendChild(path4);\n\n  link.appendChild(svg);\n  badgeDiv.appendChild(link);\n\n  const hideButton = document.createElement(\"button\");\n  hideButton.id = \"liveblocks-badge-hide-button\";\n  hideButton.style.position = \"absolute\";\n  hideButton.style.top = \"0\";\n  hideButton.style.right = \"0\";\n  hideButton.style.border = \"none\";\n  hideButton.style.padding = \"0\";\n  hideButton.style.margin = \"0\";\n  hideButton.style.background = \"none\";\n  hideButton.style.font = \"inherit\";\n  hideButton.style.cursor = \"pointer\";\n  hideButton.style.outline = \"none\";\n  hideButton.style.setProperty(\"-webkit-appearance\", \"none\");\n  hideButton.style.setProperty(\"-moz-appearance\", \"none\");\n  hideButton.style.setProperty(\"appearance\", \"none\");\n  hideButton.style.opacity = \"0\";\n  hideButton.onclick = () => {\n    const badge = document.getElementById(\"liveblocks-badge\");\n    if (badge) {\n      badge.style.display = \"none\";\n    }\n  };\n  hideButton.onmouseenter = () => {\n    hideButton.style.opacity = \"0.5\";\n  };\n  hideButton.onmouseleave = () => {\n    hideButton.style.opacity = \"0.3\";\n  };\n\n  const hideSvg = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n  hideSvg.setAttribute(\"width\", \"18\");\n  hideSvg.setAttribute(\"height\", \"18\");\n  hideSvg.setAttribute(\"viewBox\", \"0 0 18 18\");\n  hideSvg.setAttribute(\"fill\", \"none\");\n\n  const hidePath = document.createElementNS(\n    \"http://www.w3.org/2000/svg\",\n    \"path\"\n  );\n  hidePath.setAttribute(\"d\", \"M6 6L9 9M12 12L9 9M9 9L12 6M9 9L6 12\");\n  hidePath.setAttribute(\"stroke\", \"black\");\n  hideSvg.appendChild(hidePath);\n\n  hideButton.appendChild(hideSvg);\n  badgeDiv.appendChild(hideButton);\n\n  document.body.appendChild(badgeDiv);\n\n  // trigger twice so it goes from 0 to 1\n  requestAnimationFrame(() => {\n    requestAnimationFrame(() => {\n      badgeDiv.style.opacity = \"1\";\n    });\n  });\n};\n\nexport { injectBrandBadge };\n","/**\n * Positions, aka the Pos type, are efficient encodings of \"positions\" in\n * a list, using the following printable subset of the ASCII alphabet:\n *\n *    !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\n *   ^                                                                                             ^\n *   Lowest digit                                                                      Highest digit\n *\n * Each Pos is a sequence of characters from the above alphabet, conceptually\n * codifying a floating point number 0 < n < 1. For example, the string \"31007\"\n * would be used to represent the number 0.31007, except that this\n * representation uses base 96.\n *\n *   0 ≃ ' '  (lowest digit)\n *   1 ≃ '!'\n *   2 ≃ '\"'\n *   ...\n *   9 ≃ '~'  (highest digit)\n *\n * So think:\n *   '!'    ≃ 0.1\n *   '\"'    ≃ 0.2\n *   '!\"~'  ≃ 0.129\n *\n * Three rules:\n * - All \"characters\" in the string should be valid digits (from the above\n *   alphabet)\n * - The value 0.0 is not a valid Pos value\n * - A Pos cannot have trailing \"zeroes\"\n *\n * This representation has the following benefits:\n *\n * 1. It's always possible to get a number that lies before, after, or between\n *    two arbitrary Pos values.\n * 2. Pos values can be compared using normal string comparison.\n *\n * Some examples:\n * - '!'  < '\"'   (like how .1  < .2)\n * - '!'  < '~'   (like how .1  < .9)\n * - '!!' < '!~'  (like how .11 < .19)\n * - '~!' < '~~'  (like how .91 < .99)\n * - '~'  < '~!'  (like how .9  < .91)\n * - '!!' < '!O'  (like how .1  < .5)\n * - '!O' < '!~'  (like how .5  < .9)\n *\n */\nimport type { Brand } from \"./utils\";\n\n/**\n * A valid/verified \"position\" string. These values are used as \"parentKey\"s by\n * LiveList children, and define their relative ordering.\n */\nexport type Pos = Brand<string, \"Pos\">;\n\nconst MIN_CODE = 32; // ASCII code of the lowest alphabet char (e.g. ' ')\nconst MAX_CODE = 126; // ASCII code of the highest alphabet char (e.g. '~')\n\nconst NUM_DIGITS = MAX_CODE - MIN_CODE + 1; // 95\n\nconst ZERO: string = nthDigit(0); // \" \"\n\n/**\n * The \"first\" canonical position.\n * In an equivalent decimal number system, think of this as the value .1.\n */\nconst ONE: Pos = nthDigit(1); // \"!\"\n\nconst ZERO_NINE = (ZERO + nthDigit(-1)) as Pos;\n\n/**\n * Returns the Pos value for the nth digit in the alphabet.\n * Value must be between 0 and 94.\n *\n * Just used to generate some static data, and for usage in test cases.\n */\nfunction nthDigit(n: 0): string; // \"0\" is a legal _digit_, but not a legal Pos value\nfunction nthDigit(n: number): Pos;\nfunction nthDigit(n: number): Pos {\n  const code = MIN_CODE + (n < 0 ? NUM_DIGITS + n : n);\n  if (code < MIN_CODE || code > MAX_CODE) {\n    throw new Error(`Invalid n value: ${n}`);\n  }\n  return String.fromCharCode(code) as Pos;\n}\n\n/**\n * Given two positions, returns the position value that lies in the middle.\n * When given only a high bound, computes the canonical position \"before\" it.\n * When given only a low bound, computes the canonical position \"after\" it.\n * When given no bounds at all, returns the \"first\" canonical position.\n */\nfunction makePosition(x?: Pos, y?: Pos): Pos {\n  if (x !== undefined && y !== undefined) {\n    return between(x, y);\n  } else if (x !== undefined) {\n    return after(x);\n  } else if (y !== undefined) {\n    return before(y);\n  } else {\n    return ONE;\n  }\n}\n\n/**\n * Given any position value, computes the canonical position \"before\" it.\n *\n * The equivalent in a decimal number system would be:\n *   before(.1)     // .09\n *   before(.11)    // .1\n *   before(.111)   // .1\n *   before(.2)     // .1\n *   before(.23101) // .2\n *   before(.3)     // .2\n *   ...\n *   before(.8)     // .7\n *   before(.9)     // .8\n *   before(.91)    // .9\n *   before(.92)    // .9\n *   before(.93)    // .9\n *   ...\n *   before(.98)    // .9\n *   before(.99)    // .9\n *\n * Note:\n *   before(.01)    // .009\n *   before(.001)   // .0009\n *   before(.002)   // .001\n *   before(.00283) // .002\n *\n */\nfunction before(pos: Pos): Pos {\n  const lastIndex = pos.length - 1;\n  for (let i = 0; i <= lastIndex; i++) {\n    const code = pos.charCodeAt(i);\n\n    // Scan away all leading zeros, if there are any\n    if (code <= MIN_CODE) {\n      continue;\n    }\n\n    //\n    // Now, i points to the first non-zero digit\n    //\n    // Two options:\n    // 1. It's the last digit.\n    //    a. If it's a 1, it's on the edge. Replace with \"09\".\n    //    b. Otherwise, just lower it.\n    // 2. It's not the last digit, so we can just chop off the remainder.\n    //\n    if (i === lastIndex) {\n      if (code === MIN_CODE + 1) {\n        return (pos.substring(0, i) + ZERO_NINE) as Pos;\n      } else {\n        return (pos.substring(0, i) + String.fromCharCode(code - 1)) as Pos;\n      }\n    } else {\n      return pos.substring(0, i + 1) as Pos;\n    }\n  }\n\n  // If we end up here, it means the input consisted of only zeroes, which is\n  // invalid, so return the canonical first value as a best effort\n  return ONE;\n}\n\n/**\n * Given any position value, computes the canonical position \"after\" it.\n *\n * Uses \"viewport-based allocation\" (V=2+3) to bound position length growth\n * when repeatedly pushing items. Instead of always incrementing the last digit\n * (which leads to O(n/94) length growth), we treat positions as fixed-width\n * numbers within a \"viewport\" of V digits.\n *\n * - V=2: positions stay ≤2 chars for first ~8,900 pushes\n * - V=5: positions stay ≤5 chars for next ~848k pushes\n * - V=8, V=11, ...: each +3 adds capacity for ~848k more pushes\n *\n * This keeps position lengths dramatically smaller for typical usage while\n * remaining backward compatible with all existing position strings.\n *\n * Viewport growth: V=2 → V=5 → V=8 → V=11 → ...\n *\n * Examples (conceptually in decimal):\n *   after(.1)  // .11 (within V=2 viewport)\n *   after(.11) // .12\n *   after(.99) // .99001 (overflow V=2, extend to V=5)\n *\n */\nconst VIEWPORT_START = 2;\nconst VIEWPORT_STEP = 3;\n\nfunction after(pos: Pos): Pos {\n  // For positions with any chars outside valid range, just append ONE.\n  // This guarantees result > pos for any input string.\n  for (let i = 0; i < pos.length; i++) {\n    const code = pos.charCodeAt(i);\n    if (code < MIN_CODE || code > MAX_CODE) {\n      return (pos + ONE) as Pos;\n    }\n  }\n\n  // Strip trailing zeros for canonical form\n  while (pos.length > 1 && pos.charCodeAt(pos.length - 1) === MIN_CODE) {\n    pos = pos.slice(0, -1) as Pos;\n  }\n\n  // Handle empty/zero input\n  if (pos.length === 0 || pos === ZERO) {\n    return ONE;\n  }\n\n  // Determine viewport: V=2, then 5, 8, 11, ...\n  let viewport = VIEWPORT_START;\n  if (pos.length > VIEWPORT_START) {\n    viewport =\n      VIEWPORT_START +\n      Math.ceil((pos.length - VIEWPORT_START) / VIEWPORT_STEP) * VIEWPORT_STEP;\n  }\n\n  // Try to increment within current viewport\n  const result = incrementWithinViewport(pos, viewport);\n  if (result !== null) {\n    return result;\n  }\n\n  // Overflow: extend viewport and increment\n  viewport += VIEWPORT_STEP;\n  const extendedResult = incrementWithinViewport(pos, viewport);\n  if (extendedResult !== null) {\n    return extendedResult;\n  }\n\n  // Fallback (should rarely happen): just append\n  return (pos + ONE) as Pos;\n}\n\n/**\n * Increment a position string within a fixed viewport width.\n * Returns null if overflow occurs (all digits were at max).\n */\nfunction incrementWithinViewport(pos: Pos, viewport: number): Pos | null {\n  // Build array of digit values, padded to viewport width\n  const digits: number[] = [];\n  for (let i = 0; i < viewport; i++) {\n    if (i < pos.length) {\n      digits.push(pos.charCodeAt(i) - MIN_CODE);\n    } else {\n      digits.push(0); // Pad with zeros\n    }\n  }\n\n  // Increment from right to left with carry\n  let carry = 1;\n  for (let i = viewport - 1; i >= 0 && carry; i--) {\n    const sum = digits[i] + carry;\n    if (sum >= NUM_DIGITS) {\n      digits[i] = 0;\n      carry = 1;\n    } else {\n      digits[i] = sum;\n      carry = 0;\n    }\n  }\n\n  // If carry remains, we overflowed the viewport\n  if (carry) {\n    return null;\n  }\n\n  // Convert back to string, stripping trailing zeros\n  let result = \"\";\n  for (const d of digits) {\n    result += String.fromCharCode(d + MIN_CODE);\n  }\n\n  // Strip trailing zeros\n  while (\n    result.length > 1 &&\n    result.charCodeAt(result.length - 1) === MIN_CODE\n  ) {\n    result = result.slice(0, -1);\n  }\n\n  return result as Pos;\n}\n\n/**\n * Given two positions, returns the position value that lies in the middle.\n *\n * Think:\n *   between('!', '%')  // '#'    (like how between(.1, .5) would be .3)\n *   between('!', '\"')  // '!O'   (like how between(.1, .2) would be .15)\n *\n *   between(.1, .3)      // .2\n *   between(.1, .4)      // also .2\n *   between(.1, .5)      // .3\n *   between(.11, .21)    // .15\n *   between(.1,  .1003)  // .1001\n *   between(.11, .12)    // .115\n *   between(.09, .1)     // .095\n *   between(.19, .21)    // .195\n *\n */\nfunction between(lo: Pos, hi: Pos): Pos {\n  if (lo < hi) {\n    return _between(lo, hi);\n  } else if (lo > hi) {\n    return _between(hi, lo);\n  } else {\n    throw new Error(\"Cannot compute value between two equal positions\");\n  }\n}\n\n/**\n * Like between(), but guaranteed that lo < hi.\n */\nfunction _between(lo: Pos, hi: Pos | \"\"): Pos {\n  let index = 0;\n\n  const loLen = lo.length;\n  const hiLen = hi.length;\n  while (true) {\n    const loCode = index < loLen ? lo.charCodeAt(index) : MIN_CODE;\n    const hiCode = index < hiLen ? hi.charCodeAt(index) : MAX_CODE;\n\n    if (loCode === hiCode) {\n      index++;\n      continue;\n    }\n\n    // Difference of only 1 means we'll have to settle this in the next digit\n    if (hiCode - loCode === 1) {\n      const size = index + 1;\n      let prefix = lo.substring(0, size);\n      if (prefix.length < size) {\n        prefix += ZERO.repeat(size - prefix.length);\n      }\n      const suffix = lo.substring(size) as Pos;\n      const nines = \"\"; // Will get interpreted like .999999…\n      return (prefix + _between(suffix, nines)) as Pos;\n    } else {\n      // Difference of more than 1 means we take the \"middle\" between these digits\n      return (takeN(lo, index) +\n        String.fromCharCode((hiCode + loCode) >> 1)) as Pos;\n    }\n  }\n}\n\nfunction takeN(pos: string, n: number): string {\n  return n < pos.length\n    ? pos.substring(0, n)\n    : pos + ZERO.repeat(n - pos.length);\n}\n\nconst MIN_NON_ZERO_CODE = MIN_CODE + 1;\n\n/**\n * Checks whether a given string is a valid Pos value. There are three rules:\n *\n *   - The string must not be the empty string\n *   - The string must not have any trailing \"zeroes\" (trailing \" \")\n *   - All characters in the string must be from our alphabet\n *\n */\nfunction isPos(str: string): str is Pos {\n  // May not be empty string\n  if (str === \"\") {\n    return false;\n  }\n\n  // Last digit may not be a \"0\" (no trailing zeroes)\n  const lastIdx = str.length - 1;\n  const last = str.charCodeAt(lastIdx);\n  if (last < MIN_NON_ZERO_CODE || last > MAX_CODE) {\n    return false;\n  }\n\n  for (let i = 0; i < lastIdx; i++) {\n    const code = str.charCodeAt(i);\n    if (code < MIN_CODE || code > MAX_CODE) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction convertToPos(str: string): Pos {\n  const codes: number[] = [];\n\n  // All chars in the string must be in the min-max range\n  for (let i = 0; i < str.length; i++) {\n    const code = str.charCodeAt(i);\n\n    // Clamp to min-max range\n    codes.push(code < MIN_CODE ? MIN_CODE : code > MAX_CODE ? MAX_CODE : code);\n  }\n\n  // Strip all trailing zeros\n  while (codes.length > 0 && codes[codes.length - 1] === MIN_CODE) {\n    codes.length--;\n  }\n\n  return codes.length > 0\n    ? (String.fromCharCode(...codes) as Pos)\n    : // Edge case: the str was a 0-only string, which is invalid. Default back to .1\n      ONE;\n}\n\n/**\n * Checks that a str is a valid Pos, and converts it to the nearest valid one\n * if not.\n */\nfunction asPos(str: string): Pos {\n  // Calling convertToPos(str) would suffice here, but since this is a hot code\n  // path, we prefer to just check, which is a lot faster.\n  return isPos(str) ? str : convertToPos(str);\n}\n\nexport { asPos, makePosition };\n\n// For use in unit tests only\nexport {\n  after as __after,\n  before as __before,\n  between as __between,\n  isPos as __isPos,\n  nthDigit as __nthDigit,\n  NUM_DIGITS as __NUM_DIGITS,\n};\n","import type { Json, JsonObject } from \"../lib/Json\";\nimport type { DistributiveOmit } from \"../lib/utils\";\n\nexport type OpCode = (typeof OpCode)[keyof typeof OpCode];\nexport const OpCode = Object.freeze({\n  INIT: 0,\n  SET_PARENT_KEY: 1,\n  CREATE_LIST: 2,\n  UPDATE_OBJECT: 3,\n  CREATE_OBJECT: 4,\n  DELETE_CRDT: 5,\n  DELETE_OBJECT_KEY: 6,\n  CREATE_MAP: 7,\n  CREATE_REGISTER: 8,\n});\n\nexport namespace OpCode {\n  export type INIT = typeof OpCode.INIT;\n  export type SET_PARENT_KEY = typeof OpCode.SET_PARENT_KEY;\n  export type CREATE_LIST = typeof OpCode.CREATE_LIST;\n  export type UPDATE_OBJECT = typeof OpCode.UPDATE_OBJECT;\n  export type CREATE_OBJECT = typeof OpCode.CREATE_OBJECT;\n  export type DELETE_CRDT = typeof OpCode.DELETE_CRDT;\n  export type DELETE_OBJECT_KEY = typeof OpCode.DELETE_OBJECT_KEY;\n  export type CREATE_MAP = typeof OpCode.CREATE_MAP;\n  export type CREATE_REGISTER = typeof OpCode.CREATE_REGISTER;\n}\n\n/**\n * These operations are the payload for {@link UpdateStorageServerMsg} messages\n * only.\n */\nexport type Op =\n  | CreateOp\n  | UpdateObjectOp\n  | DeleteCrdtOp\n  | SetParentKeyOp // Only for lists!\n  | DeleteObjectKeyOp;\n\nexport type CreateOp =\n  | CreateObjectOp\n  | CreateRegisterOp\n  | CreateMapOp\n  | CreateListOp;\n\nexport type UpdateObjectOp = {\n  readonly opId?: string;\n  readonly id: string;\n  readonly type: OpCode.UPDATE_OBJECT;\n  readonly data: Partial<JsonObject>;\n};\n\nexport type CreateObjectOp = {\n  readonly opId?: string;\n  readonly id: string;\n  readonly intent?: \"set\";\n  readonly deletedId?: string;\n  readonly type: OpCode.CREATE_OBJECT;\n  readonly parentId: string;\n  readonly parentKey: string;\n  readonly data: JsonObject;\n};\n\nexport type CreateListOp = {\n  readonly opId?: string;\n  readonly id: string;\n  readonly intent?: \"set\";\n  readonly deletedId?: string;\n  readonly type: OpCode.CREATE_LIST;\n  readonly parentId: string;\n  readonly parentKey: string;\n};\n\nexport type CreateMapOp = {\n  readonly opId?: string;\n  readonly id: string;\n  readonly intent?: \"set\";\n  readonly deletedId?: string;\n  readonly type: OpCode.CREATE_MAP;\n  readonly parentId: string;\n  readonly parentKey: string;\n};\n\nexport type CreateRegisterOp = {\n  readonly opId?: string;\n  readonly id: string;\n  readonly intent?: \"set\";\n  readonly deletedId?: string;\n  readonly type: OpCode.CREATE_REGISTER;\n  readonly parentId: string;\n  readonly parentKey: string;\n  readonly data: Json;\n};\n\nexport type DeleteCrdtOp = {\n  readonly opId?: string;\n  readonly id: string;\n  readonly type: OpCode.DELETE_CRDT;\n};\n\n//\n// HACK:\n// Disguised as a \"DeleteCrdtOp\" for a nonexisting node \"ACK\", this Op that the\n// server may return to senders is effectively sent as a backward-compatible\n// way to trigger an acknowledgement for Ops that were seen by the server, but\n// deliberately ignored.\n//\nexport type IgnoredOp = {\n  readonly type: OpCode.DELETE_CRDT; // Not a typo!\n  readonly id: \"ACK\"; // (H)ACK\n  readonly opId: string;\n};\n\nexport function isIgnoredOp(op: ServerWireOp): op is IgnoredOp {\n  return op.type === OpCode.DELETE_CRDT && op.id === \"ACK\";\n}\n\nexport type SetParentKeyOp = {\n  readonly opId?: string;\n  readonly id: string;\n  readonly type: OpCode.SET_PARENT_KEY;\n  readonly parentKey: string;\n};\n\nexport type DeleteObjectKeyOp = {\n  readonly opId?: string;\n  readonly id: string;\n  readonly type: OpCode.DELETE_OBJECT_KEY;\n  readonly key: string;\n};\n\n//\n// ------------------------------------------------------------------------------\n// Wire types for Ops sent over the network\n// ------------------------------------------------------------------------------\n//\n\nexport type HasOpId = { opId: string };\n\n/**\n * Ops sent from client → server. Always includes an opId so the server can\n * acknowledge the receipt.\n */\nexport type ClientWireOp = Op & HasOpId;\nexport type ClientWireCreateOp = CreateOp & HasOpId;\n\n/**\n * ServerWireOp: Ops sent from server → client. Three variants:\n * 1. ClientWireOp — Full echo back of our own op, confirming it was applied\n * 2. IgnoredOp — Our op was seen but intentionally ignored (still counts as ack)\n * 3. Op without opId — Another client's op being forwarded to us\n */\nexport type ServerWireOp =\n  | ClientWireOp // \"Our\" Op echoed back in full to ACK (V7 response)\n  | IgnoredOp // \"Our\" Op was ignored by the server (not forwarded) in v7\n  | TheirOp; // \"Their\" Op (V7 forward)\n\ntype TheirOp = DistributiveOmit<Op, \"opId\"> & { opId?: undefined };\n","import { assertNever } from \"../lib/assert\";\nimport type { Pos } from \"../lib/position\";\nimport { asPos } from \"../lib/position\";\nimport type {\n  ClientWireCreateOp,\n  ClientWireOp,\n  CreateOp,\n  Op,\n} from \"../protocol/Op\";\nimport { OpCode } from \"../protocol/Op\";\nimport type { SerializedCrdt } from \"../protocol/StorageNode\";\nimport type * as DevTools from \"../types/DevToolsTreeNode\";\nimport type { Immutable } from \"../types/Immutable\";\nimport type { LiveNode, Lson } from \"./Lson\";\nimport type { StorageUpdate } from \"./StorageUpdates\";\n\nexport type ApplyResult =\n  | { reverse: Op[]; modified: StorageUpdate }\n  | { modified: false };\n\n/**\n * The managed pool is a namespace registry (i.e. a context) that \"owns\" all\n * the individual live nodes, ensuring each one has a unique ID, and holding on\n * to live nodes before and after they are inter-connected.\n */\nexport interface ManagedPool {\n  readonly roomId: string;\n  readonly nodes: ReadonlyMap<string, LiveNode>;\n  readonly generateId: () => string;\n  readonly generateOpId: () => string;\n\n  readonly getNode: (id: string) => LiveNode | undefined;\n  readonly addNode: (id: string, node: LiveNode) => void;\n  readonly deleteNode: (id: string) => void;\n\n  /**\n   * Dispatching has three responsibilities:\n   * - Sends serialized ops to the WebSocket servers\n   * - Add reverse operations to the undo/redo stack\n   * - Notify room subscribers with updates (in-client, no networking)\n   */\n  dispatch: (\n    ops: ClientWireOp[],\n    reverseOps: Op[],\n    storageUpdates: Map<string, StorageUpdate>\n  ) => void;\n\n  /**\n   * Ensures storage can be written to else throws an error.\n   * This is used to prevent writing to storage when the user does not have\n   * permission to do so.\n   * @throws {Error} if storage is not writable\n   * @returns {void}\n   */\n  assertStorageIsWritable: () => void;\n}\n\nexport type CreateManagedPoolOptions = {\n  /**\n   * Returns the current connection ID. This is used to generate unique\n   * prefixes for nodes created by this client. This number is allowed to\n   * change over time (for example, when the client reconnects).\n   */\n  getCurrentConnectionId(): number;\n\n  /**\n   * Will get invoked when any Live structure calls .dispatch() on the pool.\n   */\n  onDispatch?: (\n    ops: ClientWireOp[],\n    reverse: Op[],\n    storageUpdates: Map<string, StorageUpdate>\n  ) => void;\n\n  /**\n   * Will get invoked when any Live structure calls .assertStorageIsWritable()\n   * on the pool. Defaults to true when not provided. Return false if you want\n   * to prevent writes to the pool locally early, because you know they won't\n   * have an effect upstream.\n   */\n  isStorageWritable?: () => boolean;\n};\n\n/**\n * @private Private API, never use this API directly.\n */\nexport function createManagedPool(\n  roomId: string,\n  options: CreateManagedPoolOptions\n): ManagedPool {\n  const {\n    getCurrentConnectionId,\n    onDispatch,\n    isStorageWritable = () => true,\n  } = options;\n\n  let clock = 0;\n  let opClock = 0;\n  const nodes = new Map<string, LiveNode>();\n\n  return {\n    roomId,\n    nodes,\n\n    getNode: (id: string) => nodes.get(id),\n    addNode: (id: string, node: LiveNode) => void nodes.set(id, node),\n    deleteNode: (id: string) => void nodes.delete(id),\n\n    generateId: () => `${getCurrentConnectionId()}:${clock++}`,\n    generateOpId: () => `${getCurrentConnectionId()}:${opClock++}`,\n\n    dispatch(\n      ops: ClientWireOp[],\n      reverse: Op[],\n      storageUpdates: Map<string, StorageUpdate>\n    ) {\n      onDispatch?.(ops, reverse, storageUpdates);\n    },\n\n    assertStorageIsWritable: () => {\n      if (!isStorageWritable()) {\n        throw new Error(\n          \"Cannot write to storage with a read only user, please ensure the user has write permissions\"\n        );\n      }\n    },\n  };\n}\n\n/**\n * When applying an op to a CRDT, we need to know where it came from to apply\n * it correctly.\n */\nexport enum OpSource {\n  /**\n   * Optimistic update applied locally (from an undo, redo, or reconnect). Not\n   * yet acknowledged by the server. Will be sent to server and needs to be\n   * tracked for conflict resolution.\n   */\n  LOCAL,\n\n  /**\n   * Op received from server, originated from another client. Apply it, unless\n   * there's a pending local op for the same key (local ops take precedence\n   * until acknowledged).\n   *\n   * Note that a \"fix Op\" sent by the server in response to a local mutation\n   * that caused a conflict will also be classified as a THEIRS-like mutation.\n   * (As if another client resolved the conflict.)\n   */\n  THEIRS,\n\n  /**\n   * Op received from server, originated from THIS client. Server echoed it\n   * back to confirm.\n   */\n  OURS,\n}\n\n// TODO Temporary helper to help convert from AbstractCrdt -> LiveNode, only\n// needed for within this module. The reason is that AbstractCrdt is an\n// _abstract_ type, and in our LiveNode union we exhaustively include all\n// concrete types.\n// TODO Remove me later, if we inline the abstract base methods in the concrete\n// classes.\nfunction crdtAsLiveNode(\n  value: AbstractCrdt // eslint-disable-line no-restricted-syntax\n): LiveNode {\n  return value as LiveNode;\n}\n\ntype HasParent = {\n  readonly type: \"HasParent\";\n  readonly node: LiveNode;\n  readonly key: string;\n\n  // Typically the same as `key`, but checked to be a valid Pos value (needed\n  // when used as item in a LiveList)\n  readonly pos: Pos;\n};\n\ntype NoParent = {\n  readonly type: \"NoParent\";\n};\n\ntype Orphaned = {\n  readonly type: \"Orphaned\";\n  readonly oldKey: string;\n\n  // Typically the same as `key`, but checked to be a valid Pos value (needed\n  // when used as item in a LiveList)\n  readonly oldPos: Pos;\n};\n\nfunction HasParent(\n  node: LiveNode,\n  key: string,\n  pos: Pos = asPos(key)\n): HasParent {\n  return Object.freeze({ type: \"HasParent\", node, key, pos });\n}\n\nconst NoParent: NoParent = Object.freeze({ type: \"NoParent\" });\n\nfunction Orphaned(oldKey: string, oldPos: Pos = asPos(oldKey)): Orphaned {\n  return Object.freeze({ type: \"Orphaned\", oldKey, oldPos });\n}\n\n/**\n * Represents the possible states of the parent field pointers.\n */\ntype ParentInfo =\n  // Both the parent node and the parent key are set. This is a normal child.\n  | HasParent\n\n  // Neither are set. This is either the root node (if attached to a document),\n  // or it's a dangling node that hasn't been attached yet.\n  | NoParent\n\n  // -------------------------------------------------------------------------\n  // TODO Refactor this state away!\n  // -------------------------------------------------------------------------\n  // Tricky case! This state is used after the node is detached from its\n  // parent, but we still need to retain the parent key that it was originally\n  // attached under. For example we rely on this to derive the reverse Op to\n  // add. We should be able to get rid of this case by structuring the code\n  // differently!\n  | Orphaned;\n\nexport abstract class AbstractCrdt {\n  //                  ^^^^^^^^^^^^ TODO: Make this an interface\n  #pool?: ManagedPool;\n  #id?: string;\n\n  #parent: ParentInfo = NoParent;\n\n  /** @internal */\n  _getParentKeyOrThrow(): string {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        return this.parent.key;\n\n      case \"NoParent\":\n        throw new Error(\"Parent key is missing\");\n\n      case \"Orphaned\":\n        return this.parent.oldKey;\n\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n\n  /** @internal */\n  get _parentPos(): Pos {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        return this.parent.pos;\n\n      case \"NoParent\":\n        throw new Error(\"Parent key is missing\");\n\n      case \"Orphaned\":\n        return this.parent.oldPos;\n\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n\n  /** @internal */\n  protected get _pool(): ManagedPool | undefined {\n    return this.#pool;\n  }\n\n  get roomId(): string | null {\n    return this.#pool ? this.#pool.roomId : null;\n  }\n\n  /** @internal */\n  get _id(): string | undefined {\n    return this.#id;\n  }\n\n  /** @internal */\n  get parent(): ParentInfo {\n    return this.#parent;\n  }\n\n  /** @internal */\n  get _parentKey(): string | null {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        return this.parent.key;\n\n      case \"NoParent\":\n        return null;\n\n      case \"Orphaned\":\n        return this.parent.oldKey;\n\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n\n  /** @internal */\n  _apply(op: Op, _isLocal: boolean): ApplyResult {\n    switch (op.type) {\n      case OpCode.DELETE_CRDT: {\n        if (this.parent.type === \"HasParent\") {\n          return this.parent.node._detachChild(crdtAsLiveNode(this));\n        }\n\n        return { modified: false };\n      }\n    }\n\n    return { modified: false };\n  }\n\n  /** @internal */\n  _setParentLink(newParentNode: LiveNode, newParentKey: string): void {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        if (this.parent.node !== newParentNode) {\n          throw new Error(\"Cannot set parent: node already has a parent\");\n        } else {\n          // Ignore\n          this.#parent = HasParent(newParentNode, newParentKey);\n          return;\n        }\n\n      case \"Orphaned\":\n      case \"NoParent\": {\n        this.#parent = HasParent(newParentNode, newParentKey);\n        return;\n      }\n\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n\n  /** @internal */\n  _attach(id: string, pool: ManagedPool): void {\n    if (this.#id || this.#pool) {\n      throw new Error(\"Cannot attach node: already attached\");\n    }\n\n    pool.addNode(id, crdtAsLiveNode(this));\n\n    this.#id = id;\n    this.#pool = pool;\n  }\n\n  /** @internal */\n  abstract _attachChild(op: CreateOp, source: OpSource): ApplyResult;\n\n  /** @internal */\n  _detach(): void {\n    if (this.#pool && this.#id) {\n      this.#pool.deleteNode(this.#id);\n    }\n\n    switch (this.parent.type) {\n      case \"HasParent\": {\n        this.#parent = Orphaned(this.parent.key, this.parent.pos);\n        break;\n      }\n\n      case \"NoParent\": {\n        this.#parent = NoParent;\n        break;\n      }\n\n      case \"Orphaned\": {\n        // No change needed\n        break;\n      }\n\n      default:\n        assertNever(this.parent, \"Unknown state\");\n    }\n\n    this.#pool = undefined;\n  }\n\n  /** @internal */\n  abstract _detachChild(crdt: LiveNode): ApplyResult;\n\n  /**\n   * Serializes this CRDT and all its children into a list of creation ops\n   * without opIds. Used for creating reverse/undo operations, which get their\n   * opIds assigned later when the undo is actually applied.\n   *\n   * @internal\n   */\n  abstract _toOps(parentId: string, parentKey: string): CreateOp[];\n\n  /**\n   * Serializes this CRDT and all its children into a list of creation ops\n   * with opIds. Used for forward operations that will be sent over the wire\n   * immediately. Each op gets a unique opId for server acknowledgement.\n   *\n   * @internal\n   */\n  _toOpsWithOpId(\n    parentId: string,\n    parentKey: string,\n    pool: ManagedPool\n  ): ClientWireCreateOp[] {\n    return this._toOps(parentId, parentKey).map((op) => ({\n      opId: pool.generateOpId(),\n      ...op,\n    }));\n  }\n\n  /** @internal */\n  abstract _serialize(): SerializedCrdt;\n\n  /** This caches the result of the last .toImmutable() call for this Live node. */\n  #cachedImmutable?: Immutable;\n\n  #cachedTreeNodeKey?: string | number;\n  /** This caches the result of the last .toTreeNode() call for this Live node. */\n  #cachedTreeNode?: DevTools.LsonTreeNode;\n\n  /**\n   * @internal\n   *\n   * Clear the Immutable cache, so that the next call to `.toImmutable()` will\n   * recompute the equivalent Immutable value again.  Call this after every\n   * mutation to the Live node.\n   */\n  invalidate(): void {\n    if (\n      this.#cachedImmutable !== undefined ||\n      this.#cachedTreeNode !== undefined\n    ) {\n      this.#cachedImmutable = undefined;\n      this.#cachedTreeNode = undefined;\n\n      if (this.parent.type === \"HasParent\") {\n        this.parent.node.invalidate();\n      }\n    }\n  }\n\n  /** @internal */\n  abstract _toTreeNode(key: string): DevTools.LsonTreeNode;\n\n  /**\n   * @internal\n   *\n   * Return an snapshot of this Live tree for use in DevTools.\n   */\n  toTreeNode(key: string): DevTools.LsonTreeNode {\n    if (this.#cachedTreeNode === undefined || this.#cachedTreeNodeKey !== key) {\n      this.#cachedTreeNodeKey = key;\n      this.#cachedTreeNode = this._toTreeNode(key);\n    }\n\n    // Return cached version\n    return this.#cachedTreeNode;\n  }\n\n  /** @internal */\n  abstract _toImmutable(): Immutable;\n\n  /**\n   * Return an immutable snapshot of this Live node and its children.\n   */\n  toImmutable(): Immutable {\n    if (this.#cachedImmutable === undefined) {\n      this.#cachedImmutable = this._toImmutable();\n    }\n\n    // Return cached version\n    return this.#cachedImmutable;\n  }\n\n  /**\n   * Returns a deep clone of the current LiveStructure, suitable for insertion\n   * in the tree elsewhere.\n   */\n  abstract clone(): Lson;\n}\n","import type { Json, JsonObject } from \"../lib/Json\";\n\nexport type IdTuple<T> = [id: string, value: T];\n\nexport type CrdtType = (typeof CrdtType)[keyof typeof CrdtType];\nexport const CrdtType = Object.freeze({\n  OBJECT: 0,\n  LIST: 1,\n  MAP: 2,\n  REGISTER: 3,\n});\n\nexport namespace CrdtType {\n  export type OBJECT = typeof CrdtType.OBJECT;\n  export type LIST = typeof CrdtType.LIST;\n  export type MAP = typeof CrdtType.MAP;\n  export type REGISTER = typeof CrdtType.REGISTER;\n}\n\nexport type SerializedCrdt = SerializedRootObject | SerializedChild;\n\nexport type SerializedChild =\n  | SerializedObject\n  | SerializedList\n  | SerializedMap\n  | SerializedRegister;\n\nexport type SerializedRootObject = {\n  readonly type: CrdtType.OBJECT;\n  readonly data: JsonObject;\n\n  // Root objects don't have a parent relationship\n  readonly parentId?: never;\n  readonly parentKey?: never;\n};\n\nexport type SerializedObject = {\n  readonly type: CrdtType.OBJECT;\n  readonly parentId: string;\n  readonly parentKey: string;\n  readonly data: JsonObject;\n};\n\nexport type SerializedList = {\n  readonly type: CrdtType.LIST;\n  readonly parentId: string;\n  readonly parentKey: string;\n};\n\nexport type SerializedMap = {\n  readonly type: CrdtType.MAP;\n  readonly parentId: string;\n  readonly parentKey: string;\n};\n\nexport type SerializedRegister = {\n  readonly type: CrdtType.REGISTER;\n  readonly parentId: string;\n  readonly parentKey: string;\n  readonly data: Json;\n};\n\nexport type StorageNode = RootStorageNode | ChildStorageNode;\n\nexport type ChildStorageNode =\n  | ObjectStorageNode\n  | ListStorageNode\n  | MapStorageNode\n  | RegisterStorageNode;\n\nexport type RootStorageNode = [id: \"root\", value: SerializedRootObject];\nexport type ObjectStorageNode = [id: string, value: SerializedObject];\nexport type ListStorageNode = [id: string, value: SerializedList];\nexport type MapStorageNode = [id: string, value: SerializedMap];\nexport type RegisterStorageNode = [id: string, value: SerializedRegister];\n\nexport type NodeMap = Map<string, SerializedCrdt>;\nexport type NodeStream = Iterable<StorageNode>;\n\nexport function isRootStorageNode(node: StorageNode): node is RootStorageNode {\n  return node[0] === \"root\";\n}\n\nexport function isObjectStorageNode(\n  node: StorageNode\n): node is RootStorageNode | ObjectStorageNode {\n  return node[1].type === CrdtType.OBJECT;\n}\n\nexport function isListStorageNode(node: StorageNode): node is ListStorageNode {\n  return node[1].type === CrdtType.LIST;\n}\n\nexport function isMapStorageNode(node: StorageNode): node is MapStorageNode {\n  return node[1].type === CrdtType.MAP;\n}\n\nexport function isRegisterStorageNode(\n  node: StorageNode\n): node is RegisterStorageNode {\n  return node[1].type === CrdtType.REGISTER;\n}\n\nexport type CompactNode = CompactRootNode | CompactChildNode;\n\nexport type CompactChildNode =\n  | CompactObjectNode\n  | CompactListNode\n  | CompactMapNode\n  | CompactRegisterNode;\n\nexport type CompactRootNode = readonly [id: \"root\", data: JsonObject];\n\nexport type CompactObjectNode = readonly [\n  id: string,\n  type: CrdtType.OBJECT,\n  parentId: string,\n  parentKey: string,\n  data: JsonObject,\n];\n\nexport type CompactListNode = readonly [\n  id: string,\n  type: CrdtType.LIST,\n  parentId: string,\n  parentKey: string,\n];\n\nexport type CompactMapNode = readonly [\n  id: string,\n  type: CrdtType.MAP,\n  parentId: string,\n  parentKey: string,\n];\n\nexport type CompactRegisterNode = readonly [\n  id: string,\n  type: CrdtType.REGISTER,\n  parentId: string,\n  parentKey: string,\n  data: Json,\n];\n\nfunction isCompactRootNode(node: CompactNode): node is CompactRootNode {\n  return node[0] === \"root\";\n}\n\nexport function* compactNodesToNodeStream(\n  compactNodes: CompactNode[]\n): NodeStream {\n  for (const cnode of compactNodes) {\n    // Handle root nodes first - they have format [\"root\", data] where data is JsonObject\n    if (isCompactRootNode(cnode)) {\n      yield [cnode[0], { type: CrdtType.OBJECT, data: cnode[1] }];\n      continue;\n    }\n\n    switch (cnode[1]) {\n      case CrdtType.OBJECT:\n        // prettier-ignore\n        yield [cnode[0], { type: CrdtType.OBJECT, parentId: cnode[2], parentKey: cnode[3], data: cnode[4] }];\n        break;\n      case CrdtType.LIST:\n        // prettier-ignore\n        yield [cnode[0], { type: CrdtType.LIST, parentId: cnode[2], parentKey: cnode[3] }];\n        break;\n      case CrdtType.MAP:\n        // prettier-ignore\n        yield [cnode[0], { type: CrdtType.MAP, parentId: cnode[2], parentKey: cnode[3] }];\n        break;\n      case CrdtType.REGISTER:\n        // prettier-ignore\n        yield [cnode[0], {type: CrdtType.REGISTER, parentId: cnode[2], parentKey: cnode[3], data: cnode[4], }];\n        break;\n      default:\n      // Ignore\n    }\n  }\n}\n\nexport function* nodeStreamToCompactNodes(\n  nodes: NodeStream\n): Iterable<CompactNode> {\n  for (const node of nodes) {\n    if (isObjectStorageNode(node)) {\n      if (isRootStorageNode(node)) {\n        const id = node[0];\n        const crdt = node[1];\n        yield [id, crdt.data];\n      } else {\n        const id = node[0];\n        const crdt = node[1];\n        yield [id, CrdtType.OBJECT, crdt.parentId, crdt.parentKey, crdt.data];\n      }\n    } else if (isListStorageNode(node)) {\n      const id = node[0];\n      const crdt = node[1];\n      yield [id, CrdtType.LIST, crdt.parentId, crdt.parentKey];\n    } else if (isMapStorageNode(node)) {\n      const id = node[0];\n      const crdt = node[1];\n      yield [id, CrdtType.MAP, crdt.parentId, crdt.parentKey];\n    } else if (isRegisterStorageNode(node)) {\n      const id = node[0];\n      const crdt = node[1];\n      yield [id, CrdtType.REGISTER, crdt.parentId, crdt.parentKey, crdt.data];\n    } else {\n      // Ignore\n    }\n  }\n}\n","import type { LiveNode } from \"../crdts/Lson\";\nimport { nn } from \"../lib/assert\";\nimport type { Json } from \"../lib/Json\";\nimport { nanoid } from \"../lib/nanoid\";\nimport { deepClone } from \"../lib/utils\";\nimport type { CreateOp, CreateRegisterOp, Op } from \"../protocol/Op\";\nimport { OpCode } from \"../protocol/Op\";\nimport type {\n  RegisterStorageNode,\n  SerializedRegister,\n} from \"../protocol/StorageNode\";\nimport { CrdtType } from \"../protocol/StorageNode\";\nimport type * as DevTools from \"../types/DevToolsTreeNode\";\nimport type { Immutable } from \"../types/Immutable\";\nimport type { ParentToChildNodeMap } from \"../types/NodeMap\";\nimport type { ApplyResult, ManagedPool } from \"./AbstractCrdt\";\nimport { AbstractCrdt } from \"./AbstractCrdt\";\n\n/**\n * INTERNAL\n */\nexport class LiveRegister<TValue extends Json> extends AbstractCrdt {\n  #data: TValue;\n\n  constructor(data: TValue) {\n    super();\n    this.#data = data;\n  }\n\n  get data(): TValue {\n    return this.#data;\n  }\n\n  /** @internal */\n  static _deserialize(\n    [id, item]: RegisterStorageNode,\n    _parentToChildren: ParentToChildNodeMap,\n    pool: ManagedPool\n  ): LiveRegister<Json> {\n    const register = new LiveRegister(item.data);\n    register._attach(id, pool);\n    return register;\n  }\n\n  /** @internal */\n  _toOps(parentId: string, parentKey: string): CreateRegisterOp[] {\n    if (this._id === undefined) {\n      throw new Error(\n        \"Cannot serialize register if parentId or parentKey is undefined\"\n      );\n    }\n\n    return [\n      {\n        type: OpCode.CREATE_REGISTER,\n        id: this._id,\n        parentId,\n        parentKey,\n        data: this.data,\n      },\n    ];\n  }\n\n  /** @internal */\n  _serialize(): SerializedRegister {\n    if (this.parent.type !== \"HasParent\") {\n      throw new Error(\"Cannot serialize LiveRegister if parent is missing\");\n    }\n\n    return {\n      type: CrdtType.REGISTER,\n      parentId: nn(this.parent.node._id, \"Parent node expected to have ID\"),\n      parentKey: this.parent.key,\n      data: this.data,\n    };\n  }\n\n  /** @internal */\n  _attachChild(_op: CreateOp): ApplyResult {\n    throw new Error(\"Method not implemented.\");\n  }\n\n  /** @internal */\n  _detachChild(_crdt: LiveNode): ApplyResult {\n    throw new Error(\"Method not implemented.\");\n  }\n\n  /** @internal */\n  _apply(op: Op, isLocal: boolean): ApplyResult {\n    return super._apply(op, isLocal);\n  }\n\n  /** @internal */\n  _toTreeNode(key: string): DevTools.LsonTreeNode {\n    return {\n      type: \"Json\",\n      id: this._id ?? nanoid(),\n      key,\n      payload: this.#data,\n    };\n  }\n\n  /** @internal */\n  _toImmutable(): Immutable {\n    return this.#data;\n  }\n\n  clone(): TValue {\n    return deepClone(this.data);\n  }\n}\n","import { nn } from \"../lib/assert\";\nimport { nanoid } from \"../lib/nanoid\";\nimport type { Pos } from \"../lib/position\";\nimport { asPos, makePosition } from \"../lib/position\";\nimport { SortedList } from \"../lib/SortedList\";\nimport type { ClientWireOp, CreateListOp, CreateOp, Op } from \"../protocol/Op\";\nimport { OpCode } from \"../protocol/Op\";\nimport type { ListStorageNode, SerializedList } from \"../protocol/StorageNode\";\nimport { CrdtType } from \"../protocol/StorageNode\";\nimport type * as DevTools from \"../types/DevToolsTreeNode\";\nimport type { ParentToChildNodeMap } from \"../types/NodeMap\";\nimport type { ApplyResult, ManagedPool } from \"./AbstractCrdt\";\nimport { AbstractCrdt, OpSource } from \"./AbstractCrdt\";\nimport {\n  creationOpToLiveNode,\n  deserialize,\n  liveNodeToLson,\n  lsonToLiveNode,\n} from \"./liveblocks-helpers\";\nimport { LiveRegister } from \"./LiveRegister\";\nimport type { LiveNode, Lson } from \"./Lson\";\nimport type { ToImmutable } from \"./utils\";\n\nexport type LiveListUpdateDelta =\n  | { type: \"insert\"; index: number; item: Lson }\n  | { type: \"delete\"; index: number; deletedItem: Lson }\n  | { type: \"move\"; index: number; previousIndex: number; item: Lson }\n  | { type: \"set\"; index: number; item: Lson };\n\n/**\n * A LiveList notification that is sent in-client to any subscribers whenever\n * one or more of the items inside the LiveList instance have changed.\n */\nexport type LiveListUpdates<TItem extends Lson> = {\n  type: \"LiveList\";\n  node: LiveList<TItem>;\n  updates: LiveListUpdateDelta[];\n};\n\nfunction childNodeLt(a: LiveNode, b: LiveNode): boolean {\n  return a._parentPos < b._parentPos;\n}\n\n/**\n * The LiveList class represents an ordered collection of items that is synchronized across clients.\n */\nexport class LiveList<TItem extends Lson> extends AbstractCrdt {\n  #items: SortedList<LiveNode>;\n  #implicitlyDeletedItems: WeakSet<LiveNode>;\n  #unacknowledgedSets: Map<string, string>;\n\n  constructor(items: TItem[]) {\n    super();\n    this.#implicitlyDeletedItems = new WeakSet();\n    this.#unacknowledgedSets = new Map();\n\n    const nodes: LiveNode[] = [];\n    let lastPos: Pos | undefined;\n    for (const item of items) {\n      const pos = makePosition(lastPos);\n      const node = lsonToLiveNode(item);\n      node._setParentLink(this, pos);\n      nodes.push(node);\n      lastPos = pos;\n    }\n    this.#items = SortedList.fromAlreadySorted(nodes, childNodeLt);\n  }\n\n  /** @internal */\n  static _deserialize(\n    [id, _]: ListStorageNode,\n    parentToChildren: ParentToChildNodeMap,\n    pool: ManagedPool\n  ): LiveList<Lson> {\n    const list = new LiveList([]);\n    list._attach(id, pool);\n\n    const children = parentToChildren.get(id);\n    if (children === undefined) {\n      return list;\n    }\n\n    for (const node of children) {\n      const crdt = node[1];\n      const child = deserialize(node, parentToChildren, pool);\n\n      child._setParentLink(list, crdt.parentKey);\n      list.#insert(child);\n    }\n\n    return list;\n  }\n\n  /**\n   * @internal\n   * This function assumes that the resulting ops will be sent to the server if they have an 'opId'\n   * so we mutate _unacknowledgedSets to avoid potential flickering\n   * https://github.com/liveblocks/liveblocks/pull/1177\n   *\n   * This is quite unintuitive and should disappear as soon as\n   * we introduce an explicit LiveList.Set operation\n   */\n  _toOps(parentId: string, parentKey: string): CreateOp[] {\n    if (this._id === undefined) {\n      throw new Error(\"Cannot serialize item is not attached\");\n    }\n\n    const ops: CreateOp[] = [];\n    const op: CreateListOp = {\n      id: this._id,\n      type: OpCode.CREATE_LIST,\n      parentId,\n      parentKey,\n    };\n\n    ops.push(op);\n\n    for (const item of this.#items) {\n      const parentKey = item._getParentKeyOrThrow();\n      const childOps = HACK_addIntentAndDeletedIdToOperation(\n        item._toOps(this._id, parentKey),\n        undefined\n      );\n      for (const childOp of childOps) {\n        ops.push(childOp);\n      }\n    }\n\n    return ops;\n  }\n\n  /**\n   * Inserts a new child into the list in the correct location (binary search\n   * finds correct position efficiently). Returns the insertion index.\n   */\n  #insert(childNode: LiveNode): number {\n    const index = this.#items.add(childNode);\n    this.invalidate();\n    return index;\n  }\n\n  /**\n   * Updates an item's position and repositions it in the sorted list.\n   * Encapsulates the remove -> mutate -> add cycle needed when changing sort keys.\n   *\n   * IMPORTANT: Item must exist in this list. List count remains unchanged.\n   */\n  #updateItemPosition(item: LiveNode, newKey: string): void {\n    item._setParentLink(this, newKey);\n    this.#items.reposition(item);\n    this.invalidate();\n  }\n\n  /**\n   * Updates an item's position by index. Safer than #updateItemPosition when you have\n   * an index, as it ensures the item exists and is from this list.\n   */\n  #updateItemPositionAt(index: number, newKey: string): void {\n    const item = nn(this.#items.at(index));\n    this.#updateItemPosition(item, newKey);\n  }\n\n  /** @internal */\n  _indexOfPosition(position: string): number {\n    return this.#items.findIndex(\n      (item) => item._getParentKeyOrThrow() === position\n    );\n  }\n\n  /** @internal */\n  _attach(id: string, pool: ManagedPool): void {\n    super._attach(id, pool);\n\n    for (const item of this.#items) {\n      item._attach(pool.generateId(), pool);\n    }\n  }\n\n  /** @internal */\n  _detach(): void {\n    super._detach();\n\n    for (const item of this.#items) {\n      item._detach();\n    }\n  }\n\n  #applySetRemote(op: CreateOp): ApplyResult {\n    if (this._pool === undefined) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n\n    const { id, parentKey: key } = op;\n    const child = creationOpToLiveNode(op);\n    child._attach(id, this._pool);\n    child._setParentLink(this, key);\n\n    const deletedId = op.deletedId;\n\n    const indexOfItemWithSamePosition = this._indexOfPosition(key);\n\n    // If there is already an item at this position\n    if (indexOfItemWithSamePosition !== -1) {\n      const itemWithSamePosition = nn(\n        this.#items.removeAt(indexOfItemWithSamePosition)\n      );\n\n      // No conflict, the item that is being replaced is the same that was deleted on the sender\n      if (itemWithSamePosition._id === deletedId) {\n        itemWithSamePosition._detach();\n\n        // Replace the existing item with the newly created item\n        this.#items.add(child);\n\n        return {\n          modified: makeUpdate(this, [\n            setDelta(indexOfItemWithSamePosition, child),\n          ]),\n          reverse: [],\n        };\n      } else {\n        // Item at position to be replaced is different from server, so we\n        // remember it in case we need to restore it later.\n        // This scenario can happen if an other item has been put at this position\n        // while getting the acknowledgement of the set (move, insert or set)\n        this.#implicitlyDeletedItems.add(itemWithSamePosition);\n\n        // Replace the existing item with the newly created item without sorting the list\n        this.#items.remove(itemWithSamePosition);\n        this.#items.add(child);\n\n        const delta: LiveListUpdateDelta[] = [\n          setDelta(indexOfItemWithSamePosition, child),\n        ];\n\n        // Even if we implicitly delete the item at the set position\n        // We still need to delete the item that was orginaly deleted by the set\n        const deleteDelta = this.#detachItemAssociatedToSetOperation(\n          op.deletedId\n        );\n\n        if (deleteDelta) {\n          delta.push(deleteDelta);\n        }\n\n        return {\n          modified: makeUpdate(this, delta),\n          reverse: [],\n        };\n      }\n    } else {\n      // Item at position to be replaced doesn't exist\n      const updates: LiveListUpdateDelta[] = [];\n      const deleteDelta = this.#detachItemAssociatedToSetOperation(\n        op.deletedId\n      );\n      if (deleteDelta) {\n        updates.push(deleteDelta);\n      }\n\n      this.#insert(child);\n\n      updates.push(insertDelta(this._indexOfPosition(key), child));\n\n      return {\n        reverse: [],\n        modified: makeUpdate(this, updates),\n      };\n    }\n  }\n\n  #applySetAck(op: CreateOp): ApplyResult {\n    if (this._pool === undefined) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n\n    const delta: LiveListUpdateDelta[] = [];\n\n    // Deleted item can be re-inserted by remote undo/redo\n    const deletedDelta = this.#detachItemAssociatedToSetOperation(op.deletedId);\n    if (deletedDelta) {\n      delta.push(deletedDelta);\n    }\n\n    const unacknowledgedOpId = this.#unacknowledgedSets.get(op.parentKey);\n\n    if (unacknowledgedOpId !== undefined) {\n      if (unacknowledgedOpId !== op.opId) {\n        return delta.length === 0\n          ? { modified: false }\n          : { modified: makeUpdate(this, delta), reverse: [] };\n      } else {\n        this.#unacknowledgedSets.delete(op.parentKey);\n      }\n    }\n\n    const indexOfItemWithSamePosition = this._indexOfPosition(op.parentKey);\n\n    const existingItem = this.#items.find((item) => item._id === op.id);\n\n    // If item already exists...\n    if (existingItem !== undefined) {\n      // ...and if it's at the right position\n      if (existingItem._parentKey === op.parentKey) {\n        // ... do nothing\n        return {\n          modified: delta.length > 0 ? makeUpdate(this, delta) : false,\n          reverse: [],\n        };\n      }\n\n      // Item exists but not at the right position (local move after set)\n      if (indexOfItemWithSamePosition !== -1) {\n        const itemAtPosition = nn(\n          this.#items.removeAt(indexOfItemWithSamePosition)\n        );\n        this.#implicitlyDeletedItems.add(itemAtPosition);\n        delta.push(deleteDelta(indexOfItemWithSamePosition, itemAtPosition));\n      }\n\n      const prevIndex = this.#items.findIndex((item) => item === existingItem);\n      this.#updateItemPosition(existingItem, op.parentKey);\n      const newIndex = this.#items.findIndex((item) => item === existingItem);\n      if (newIndex !== prevIndex) {\n        delta.push(moveDelta(prevIndex, newIndex, existingItem));\n      }\n\n      return {\n        modified: delta.length > 0 ? makeUpdate(this, delta) : false,\n        reverse: [],\n      };\n    } else {\n      // Item associated to the set ack does not exist either deleted localy or via remote undo/redo\n      const orphan = this._pool.getNode(op.id);\n      if (orphan && this.#implicitlyDeletedItems.has(orphan)) {\n        // Reattach orphan at the new position\n        orphan._setParentLink(this, op.parentKey);\n        // And delete it from the orphan cache\n        this.#implicitlyDeletedItems.delete(orphan);\n\n        const recreatedItemIndex = this.#insert(orphan);\n        return {\n          modified: makeUpdate(this, [\n            // If there is an item at this position, update is a set, else it's an insert\n            indexOfItemWithSamePosition === -1\n              ? insertDelta(recreatedItemIndex, orphan)\n              : setDelta(recreatedItemIndex, orphan),\n            ...delta,\n          ]),\n          reverse: [],\n        };\n      } else {\n        if (indexOfItemWithSamePosition !== -1) {\n          nn(this.#items.removeAt(indexOfItemWithSamePosition));\n        }\n\n        const { newItem, newIndex } = this.#createAttachItemAndSort(\n          op,\n          op.parentKey\n        );\n\n        return {\n          modified: makeUpdate(this, [\n            // If there is an item at this position, update is a set, else it's an insert\n            indexOfItemWithSamePosition === -1\n              ? insertDelta(newIndex, newItem)\n              : setDelta(newIndex, newItem),\n            ...delta,\n          ]),\n          reverse: [],\n        };\n      }\n    }\n  }\n\n  /**\n   * Returns the update delta of the deletion or null\n   */\n  #detachItemAssociatedToSetOperation(\n    deletedId?: string\n  ): LiveListUpdateDelta | null {\n    if (deletedId === undefined || this._pool === undefined) {\n      return null;\n    }\n\n    const deletedItem = this._pool.getNode(deletedId);\n    if (deletedItem === undefined) {\n      return null;\n    }\n\n    const result = this._detachChild(deletedItem);\n    if (result.modified === false) {\n      return null;\n    }\n\n    return result.modified.updates[0];\n  }\n\n  #applyRemoteInsert(op: CreateOp): ApplyResult {\n    if (this._pool === undefined) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n\n    const key = asPos(op.parentKey);\n\n    const existingItemIndex = this._indexOfPosition(key);\n\n    if (existingItemIndex !== -1) {\n      // If change is remote => assign a temporary position to existing child until we get the fix from the backend\n      this.#shiftItemPosition(existingItemIndex, key);\n    }\n\n    const { newItem, newIndex } = this.#createAttachItemAndSort(op, key);\n\n    // TODO: add move update?\n    return {\n      modified: makeUpdate(this, [insertDelta(newIndex, newItem)]),\n      reverse: [],\n    };\n  }\n\n  #applyInsertAck(op: CreateOp): ApplyResult {\n    const existingItem = this.#items.find((item) => item._id === op.id);\n    const key = asPos(op.parentKey);\n\n    const itemIndexAtPosition = this._indexOfPosition(key);\n\n    if (existingItem) {\n      if (existingItem._parentKey === key) {\n        // Normal case, no modification\n        return {\n          modified: false,\n        };\n      } else {\n        const oldPositionIndex = this.#items.findIndex(\n          (item) => item === existingItem\n        );\n        if (itemIndexAtPosition !== -1) {\n          this.#shiftItemPosition(itemIndexAtPosition, key);\n        }\n\n        this.#updateItemPosition(existingItem, key);\n\n        const newIndex = this._indexOfPosition(key);\n\n        if (newIndex === oldPositionIndex) {\n          return { modified: false };\n        }\n\n        return {\n          modified: makeUpdate(this, [\n            moveDelta(oldPositionIndex, newIndex, existingItem),\n          ]),\n          reverse: [],\n        };\n      }\n    } else {\n      const orphan = nn(this._pool).getNode(op.id);\n      if (orphan && this.#implicitlyDeletedItems.has(orphan)) {\n        // Implicit delete after set\n        orphan._setParentLink(this, key);\n        this.#implicitlyDeletedItems.delete(orphan);\n\n        this.#insert(orphan);\n\n        const newIndex = this._indexOfPosition(key);\n\n        return {\n          modified: makeUpdate(this, [insertDelta(newIndex, orphan)]),\n          reverse: [],\n        };\n      } else {\n        if (itemIndexAtPosition !== -1) {\n          this.#shiftItemPosition(itemIndexAtPosition, key);\n        }\n\n        const { newItem, newIndex } = this.#createAttachItemAndSort(op, key);\n\n        return {\n          modified: makeUpdate(this, [insertDelta(newIndex, newItem)]),\n          reverse: [],\n        };\n      }\n    }\n  }\n\n  #applyInsertUndoRedo(op: CreateOp): ApplyResult {\n    const { id, parentKey: key } = op;\n    const child = creationOpToLiveNode(op);\n\n    if (this._pool?.getNode(id) !== undefined) {\n      return { modified: false };\n    }\n\n    child._attach(id, nn(this._pool));\n    child._setParentLink(this, key);\n\n    const existingItemIndex = this._indexOfPosition(key);\n\n    let newKey = key;\n\n    if (existingItemIndex !== -1) {\n      const before = this.#items.at(existingItemIndex)?._parentPos;\n      const after = this.#items.at(existingItemIndex + 1)?._parentPos;\n\n      newKey = makePosition(before, after);\n      child._setParentLink(this, newKey);\n    }\n\n    this.#insert(child);\n\n    const newIndex = this._indexOfPosition(newKey);\n\n    return {\n      modified: makeUpdate(this, [insertDelta(newIndex, child)]),\n      reverse: [{ type: OpCode.DELETE_CRDT, id }],\n    };\n  }\n\n  #applySetUndoRedo(op: CreateOp): ApplyResult {\n    const { id, parentKey: key } = op;\n    const child = creationOpToLiveNode(op);\n\n    if (this._pool?.getNode(id) !== undefined) {\n      return { modified: false };\n    }\n\n    this.#unacknowledgedSets.set(key, nn(op.opId));\n\n    const indexOfItemWithSameKey = this._indexOfPosition(key);\n\n    child._attach(id, nn(this._pool));\n    child._setParentLink(this, key);\n\n    const newKey = key;\n\n    // If there is already an item at this position\n    if (indexOfItemWithSameKey !== -1) {\n      // TODO: Should we add this item to implictly deleted item?\n      const existingItem = this.#items.at(indexOfItemWithSameKey)!; // eslint-disable-line no-restricted-syntax\n      existingItem._detach();\n\n      this.#items.remove(existingItem);\n      this.#items.add(child);\n\n      const reverse = HACK_addIntentAndDeletedIdToOperation(\n        existingItem._toOps(nn(this._id), key),\n        op.id\n      );\n\n      const delta = [setDelta(indexOfItemWithSameKey, child)];\n      const deletedDelta = this.#detachItemAssociatedToSetOperation(\n        op.deletedId\n      );\n      if (deletedDelta) {\n        delta.push(deletedDelta);\n      }\n\n      return {\n        modified: makeUpdate(this, delta),\n        reverse,\n      };\n    } else {\n      this.#insert(child);\n\n      // TODO: Use delta\n      this.#detachItemAssociatedToSetOperation(op.deletedId);\n\n      const newIndex = this._indexOfPosition(newKey);\n\n      return {\n        reverse: [{ type: OpCode.DELETE_CRDT, id }],\n        modified: makeUpdate(this, [insertDelta(newIndex, child)]),\n      };\n    }\n  }\n\n  /** @internal */\n  _attachChild(op: CreateOp, source: OpSource): ApplyResult {\n    if (this._pool === undefined) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n\n    let result: ApplyResult;\n\n    if (op.intent === \"set\") {\n      if (source === OpSource.THEIRS) {\n        result = this.#applySetRemote(op);\n      } else if (source === OpSource.OURS) {\n        result = this.#applySetAck(op);\n      } else {\n        result = this.#applySetUndoRedo(op);\n      }\n    } else {\n      if (source === OpSource.THEIRS) {\n        result = this.#applyRemoteInsert(op);\n      } else if (source === OpSource.OURS) {\n        result = this.#applyInsertAck(op);\n      } else {\n        result = this.#applyInsertUndoRedo(op);\n      }\n    }\n\n    if (result.modified !== false) {\n      this.invalidate();\n    }\n\n    return result;\n  }\n\n  /** @internal */\n  _detachChild(\n    child: LiveNode\n  ): { reverse: Op[]; modified: LiveListUpdates<TItem> } | { modified: false } {\n    if (child) {\n      const parentKey = nn(child._parentKey);\n      const reverse = child._toOps(nn(this._id), parentKey);\n\n      const indexToDelete = this.#items.findIndex((item) => item === child);\n\n      if (indexToDelete === -1) {\n        return {\n          modified: false,\n        };\n      }\n\n      const previousNode = this.#items.at(indexToDelete)!; // eslint-disable-line no-restricted-syntax\n      this.#items.remove(child);\n      this.invalidate();\n\n      child._detach();\n\n      return {\n        modified: makeUpdate(this, [deleteDelta(indexToDelete, previousNode)]),\n        reverse,\n      };\n    }\n\n    return { modified: false };\n  }\n\n  #applySetChildKeyRemote(newKey: Pos, child: LiveNode): ApplyResult {\n    if (this.#implicitlyDeletedItems.has(child)) {\n      this.#implicitlyDeletedItems.delete(child);\n\n      child._setParentLink(this, newKey);\n      const newIndex = this.#insert(child);\n\n      // TODO: Shift existing item?\n      return {\n        modified: makeUpdate(this, [insertDelta(newIndex, child)]),\n        reverse: [],\n      };\n    }\n\n    const previousKey = child._parentKey;\n\n    if (newKey === previousKey) {\n      return {\n        modified: false,\n      };\n    }\n\n    // TODO: should we look at orphan\n    const existingItemIndex = this._indexOfPosition(newKey);\n\n    // Normal case\n    if (existingItemIndex === -1) {\n      const previousIndex = this.#items.findIndex((item) => item === child);\n      this.#updateItemPosition(child, newKey);\n      const newIndex = this.#items.findIndex((item) => item === child);\n\n      if (newIndex === previousIndex) {\n        return {\n          modified: false,\n        };\n      }\n\n      return {\n        modified: makeUpdate(this, [moveDelta(previousIndex, newIndex, child)]),\n        reverse: [],\n      };\n    } else {\n      this.#updateItemPositionAt(\n        existingItemIndex,\n        makePosition(newKey, this.#items.at(existingItemIndex + 1)?._parentPos)\n      );\n\n      const previousIndex = this.#items.findIndex((item) => item === child);\n      this.#updateItemPosition(child, newKey);\n      const newIndex = this.#items.findIndex((item) => item === child);\n\n      if (newIndex === previousIndex) {\n        return {\n          modified: false,\n        };\n      }\n\n      return {\n        modified: makeUpdate(this, [moveDelta(previousIndex, newIndex, child)]),\n        reverse: [],\n      };\n    }\n  }\n\n  #applySetChildKeyAck(newKey: Pos, child: LiveNode): ApplyResult {\n    const previousKey = nn(child._parentKey);\n\n    if (this.#implicitlyDeletedItems.has(child)) {\n      const existingItemIndex = this._indexOfPosition(newKey);\n\n      this.#implicitlyDeletedItems.delete(child);\n\n      if (existingItemIndex !== -1) {\n        const existingItem = this.#items.at(existingItemIndex)!; // eslint-disable-line no-restricted-syntax\n        existingItem._setParentLink(\n          this,\n          makePosition(\n            newKey,\n            this.#items.at(existingItemIndex + 1)?._parentPos\n          )\n        );\n        this.#items.reposition(existingItem);\n      }\n\n      child._setParentLink(this, newKey);\n      const newIndex = this.#insert(child);\n      return {\n        modified: makeUpdate(this, [insertDelta(newIndex, child)]),\n        reverse: [],\n      };\n    } else {\n      if (newKey === previousKey) {\n        return {\n          modified: false,\n        };\n      }\n\n      // At this point, it means that the item has been moved before receiving the ack\n      // so we replace it at the right position\n\n      const previousIndex = this.#items.findIndex((item) => item === child);\n\n      const existingItemIndex = this._indexOfPosition(newKey);\n\n      if (existingItemIndex !== -1) {\n        this.#updateItemPositionAt(\n          existingItemIndex,\n          makePosition(\n            newKey,\n            this.#items.at(existingItemIndex + 1)?._parentPos\n          )\n        );\n      }\n\n      this.#updateItemPosition(child, newKey);\n\n      const newIndex = this.#items.findIndex((item) => item === child);\n\n      if (previousIndex === newIndex) {\n        // parentKey changed but final position in the list didn't\n        return {\n          modified: false,\n        };\n      } else {\n        return {\n          modified: makeUpdate(this, [\n            moveDelta(previousIndex, newIndex, child),\n          ]),\n          reverse: [],\n        };\n      }\n    }\n  }\n\n  #applySetChildKeyUndoRedo(newKey: Pos, child: LiveNode): ApplyResult {\n    const previousKey = nn(child._parentKey);\n\n    const previousIndex = this.#items.findIndex((item) => item === child);\n    const existingItemIndex = this._indexOfPosition(newKey);\n\n    // If position is occupied, find a free position for item being moved\n    let actualNewKey = newKey;\n    if (existingItemIndex !== -1) {\n      // Find a free position near the desired position\n      actualNewKey = makePosition(\n        newKey,\n        this.#items.at(existingItemIndex + 1)?._parentPos\n      );\n    }\n\n    this.#updateItemPosition(child, actualNewKey);\n\n    const newIndex = this.#items.findIndex((item) => item === child);\n\n    if (previousIndex === newIndex) {\n      return {\n        modified: false,\n      };\n    }\n\n    return {\n      modified: makeUpdate(this, [moveDelta(previousIndex, newIndex, child)]),\n      reverse: [\n        {\n          type: OpCode.SET_PARENT_KEY,\n          id: nn(child._id),\n          parentKey: previousKey,\n        },\n      ],\n    };\n  }\n\n  /** @internal */\n  _setChildKey(newKey: Pos, child: LiveNode, source: OpSource): ApplyResult {\n    if (source === OpSource.THEIRS) {\n      return this.#applySetChildKeyRemote(newKey, child);\n    } else if (source === OpSource.OURS) {\n      return this.#applySetChildKeyAck(newKey, child);\n    } else {\n      return this.#applySetChildKeyUndoRedo(newKey, child);\n    }\n  }\n\n  /** @internal */\n  _apply(op: Op, isLocal: boolean): ApplyResult {\n    return super._apply(op, isLocal);\n  }\n\n  /** @internal */\n  _serialize(): SerializedList {\n    if (this.parent.type !== \"HasParent\") {\n      throw new Error(\"Cannot serialize LiveList if parent is missing\");\n    }\n\n    return {\n      type: CrdtType.LIST,\n      parentId: nn(this.parent.node._id, \"Parent node expected to have ID\"),\n      parentKey: this.parent.key,\n    };\n  }\n\n  /**\n   * Returns the number of elements.\n   */\n  get length(): number {\n    return this.#items.length;\n  }\n\n  /**\n   * Adds one element to the end of the LiveList.\n   * @param element The element to add to the end of the LiveList.\n   */\n  push(element: TItem): void {\n    this._pool?.assertStorageIsWritable();\n    return this.insert(element, this.length);\n  }\n\n  /**\n   * Inserts one element at a specified index.\n   * @param element The element to insert.\n   * @param index The index at which you want to insert the element.\n   */\n  insert(element: TItem, index: number): void {\n    this._pool?.assertStorageIsWritable();\n    if (index < 0 || index > this.#items.length) {\n      throw new Error(\n        `Cannot insert list item at index \"\u001d${index}\". index should be between 0 and ${this.#items.length}`\n      );\n    }\n\n    const before = this.#items.at(index - 1)?._parentPos;\n    const after = this.#items.at(index)?._parentPos;\n\n    const position = makePosition(before, after);\n\n    const value = lsonToLiveNode(element);\n    value._setParentLink(this, position);\n\n    this.#insert(value);\n\n    if (this._pool && this._id) {\n      const id = this._pool.generateId();\n      value._attach(id, this._pool);\n\n      this._pool.dispatch(\n        value._toOpsWithOpId(this._id, position, this._pool),\n        [{ type: OpCode.DELETE_CRDT, id }],\n        new Map<string, LiveListUpdates<TItem>>([\n          [this._id, makeUpdate(this, [insertDelta(index, value)])],\n        ])\n      );\n    }\n  }\n\n  /**\n   * Move one element from one index to another.\n   * @param index The index of the element to move\n   * @param targetIndex The index where the element should be after moving.\n   */\n  move(index: number, targetIndex: number): void {\n    this._pool?.assertStorageIsWritable();\n    if (targetIndex < 0) {\n      throw new Error(\"targetIndex cannot be less than 0\");\n    }\n\n    if (targetIndex >= this.#items.length) {\n      throw new Error(\n        \"targetIndex cannot be greater or equal than the list length\"\n      );\n    }\n\n    if (index < 0) {\n      throw new Error(\"index cannot be less than 0\");\n    }\n\n    if (index >= this.#items.length) {\n      throw new Error(\"index cannot be greater or equal than the list length\");\n    }\n\n    let beforePosition = null;\n    let afterPosition = null;\n\n    if (index < targetIndex) {\n      afterPosition =\n        targetIndex === this.#items.length - 1\n          ? undefined\n          : this.#items.at(targetIndex + 1)?._parentPos;\n      beforePosition = this.#items.at(targetIndex)!._parentPos; // eslint-disable-line no-restricted-syntax\n    } else {\n      afterPosition = this.#items.at(targetIndex)!._parentPos; // eslint-disable-line no-restricted-syntax\n      beforePosition =\n        targetIndex === 0\n          ? undefined\n          : this.#items.at(targetIndex - 1)?._parentPos;\n    }\n\n    const position = makePosition(beforePosition, afterPosition);\n\n    const item = this.#items.at(index)!; // eslint-disable-line no-restricted-syntax\n    const previousPosition = item._getParentKeyOrThrow();\n    this.#updateItemPositionAt(index, position);\n\n    if (this._pool && this._id) {\n      const storageUpdates = new Map<string, LiveListUpdates<TItem>>([\n        [this._id, makeUpdate(this, [moveDelta(index, targetIndex, item)])],\n      ]);\n\n      this._pool.dispatch(\n        [\n          {\n            type: OpCode.SET_PARENT_KEY,\n            id: nn(item._id),\n            opId: this._pool.generateOpId(),\n            parentKey: position,\n          },\n        ],\n        [\n          {\n            type: OpCode.SET_PARENT_KEY,\n            id: nn(item._id),\n            parentKey: previousPosition,\n          },\n        ],\n        storageUpdates\n      );\n    }\n  }\n\n  /**\n   * Deletes an element at the specified index\n   * @param index The index of the element to delete\n   */\n  delete(index: number): void {\n    this._pool?.assertStorageIsWritable();\n    if (index < 0 || index >= this.#items.length) {\n      throw new Error(\n        `Cannot delete list item at index \"${index}\". index should be between 0 and ${\n          this.#items.length - 1\n        }`\n      );\n    }\n\n    const item = this.#items.at(index)!; // eslint-disable-line no-restricted-syntax\n    item._detach();\n    this.#items.remove(item);\n    this.invalidate();\n\n    if (this._pool) {\n      const childRecordId = item._id;\n      if (childRecordId) {\n        const storageUpdates = new Map<string, LiveListUpdates<TItem>>();\n        storageUpdates.set(\n          nn(this._id),\n          makeUpdate(this, [deleteDelta(index, item)])\n        );\n\n        this._pool.dispatch(\n          [\n            {\n              id: childRecordId,\n              opId: this._pool.generateOpId(),\n              type: OpCode.DELETE_CRDT,\n            },\n          ],\n          item._toOps(nn(this._id), item._getParentKeyOrThrow()),\n          storageUpdates\n        );\n      }\n    }\n  }\n\n  clear(): void {\n    this._pool?.assertStorageIsWritable();\n    if (this._pool) {\n      const ops: ClientWireOp[] = [];\n      const reverseOps: Op[] = [];\n\n      const updateDelta: LiveListUpdateDelta[] = [];\n\n      for (const item of this.#items) {\n        item._detach();\n        const childId = item._id;\n        if (childId) {\n          ops.push({\n            type: OpCode.DELETE_CRDT,\n            id: childId,\n            opId: this._pool.generateOpId(),\n          });\n          reverseOps.push(\n            ...item._toOps(nn(this._id), item._getParentKeyOrThrow())\n          );\n\n          // Index is always 0 because updates are applied one after another\n          // when applied on an immutable state\n          updateDelta.push(deleteDelta(0, item));\n        }\n      }\n\n      this.#items.clear();\n      this.invalidate();\n\n      const storageUpdates = new Map<string, LiveListUpdates<TItem>>();\n      storageUpdates.set(nn(this._id), makeUpdate(this, updateDelta));\n\n      this._pool.dispatch(ops, reverseOps, storageUpdates);\n    } else {\n      for (const item of this.#items) {\n        item._detach();\n      }\n      this.#items.clear();\n      this.invalidate();\n    }\n  }\n\n  set(index: number, item: TItem): void {\n    this._pool?.assertStorageIsWritable();\n    if (index < 0 || index >= this.#items.length) {\n      throw new Error(\n        `Cannot set list item at index \"\u001d${index}\". index should be between 0 and ${\n          this.#items.length - 1\n        }`\n      );\n    }\n\n    const existingItem = this.#items.at(index)!; // eslint-disable-line no-restricted-syntax\n    const position = existingItem._getParentKeyOrThrow();\n\n    const existingId = existingItem._id;\n    existingItem._detach();\n\n    const value = lsonToLiveNode(item);\n    value._setParentLink(this, position);\n    this.#items.remove(existingItem);\n    this.#items.add(value);\n    this.invalidate();\n\n    if (this._pool && this._id) {\n      const id = this._pool.generateId();\n      value._attach(id, this._pool);\n\n      const storageUpdates = new Map<string, LiveListUpdates<TItem>>();\n      storageUpdates.set(this._id, makeUpdate(this, [setDelta(index, value)]));\n\n      const ops = HACK_addIntentAndDeletedIdToOperation(\n        value._toOpsWithOpId(this._id, position, this._pool),\n        existingId\n      );\n      this.#unacknowledgedSets.set(position, nn(ops[0].opId));\n      const reverseOps = HACK_addIntentAndDeletedIdToOperation(\n        existingItem._toOps(this._id, position),\n        id\n      );\n\n      this._pool.dispatch(ops, reverseOps, storageUpdates);\n    }\n  }\n\n  /**\n   * Returns an Array of all the elements in the LiveList.\n   */\n  toArray(): TItem[] {\n    return Array.from(this.#items, (entry) => liveNodeToLson(entry) as TItem);\n    //                                                                ^^^^^^^^\n    //                                                                FIXME! This isn't safe.\n  }\n\n  /**\n   * Tests whether all elements pass the test implemented by the provided function.\n   * @param predicate Function to test for each element, taking two arguments (the element and its index).\n   * @returns true if the predicate function returns a truthy value for every element. Otherwise, false.\n   */\n  every(predicate: (value: TItem, index: number) => unknown): boolean {\n    return this.toArray().every(predicate);\n  }\n\n  /**\n   * Creates an array with all elements that pass the test implemented by the provided function.\n   * @param predicate Function to test each element of the LiveList. Return a value that coerces to true to keep the element, or to false otherwise.\n   * @returns An array with the elements that pass the test.\n   */\n  filter(predicate: (value: TItem, index: number) => unknown): TItem[] {\n    return this.toArray().filter(predicate);\n  }\n\n  /**\n   * Returns the first element that satisfies the provided testing function.\n   * @param predicate Function to execute on each value.\n   * @returns The value of the first element in the LiveList that satisfies the provided testing function. Otherwise, undefined is returned.\n   */\n  find(predicate: (value: TItem, index: number) => unknown): TItem | undefined {\n    return this.toArray().find(predicate);\n  }\n\n  /**\n   * Returns the index of the first element in the LiveList that satisfies the provided testing function.\n   * @param predicate Function to execute on each value until the function returns true, indicating that the satisfying element was found.\n   * @returns The index of the first element in the LiveList that passes the test. Otherwise, -1.\n   */\n  findIndex(predicate: (value: TItem, index: number) => unknown): number {\n    return this.toArray().findIndex(predicate);\n  }\n\n  /**\n   * Executes a provided function once for each element.\n   * @param callbackfn Function to execute on each element.\n   */\n  forEach(callbackfn: (value: TItem, index: number) => void): void {\n    return this.toArray().forEach(callbackfn);\n  }\n\n  /**\n   * Get the element at the specified index.\n   * @param index The index on the element to get.\n   * @returns The element at the specified index or undefined.\n   */\n  get(index: number): TItem | undefined {\n    if (index < 0 || index >= this.#items.length) {\n      return undefined;\n    }\n\n    const item = this.#items.at(index);\n    return item ? (liveNodeToLson(item) as TItem | undefined) : undefined;\n    //                                     ^^^^^^^^^^^^^^^^^\n    //                                     FIXME! This isn't safe.\n  }\n\n  /**\n   * Returns the first index at which a given element can be found in the LiveList, or -1 if it is not present.\n   * @param searchElement Element to locate.\n   * @param fromIndex The index to start the search at.\n   * @returns The first index of the element in the LiveList; -1 if not found.\n   */\n  indexOf(searchElement: TItem, fromIndex?: number): number {\n    return this.toArray().indexOf(searchElement, fromIndex);\n  }\n\n  /**\n   * Returns the last index at which a given element can be found in the LiveList, or -1 if it is not present. The LiveLsit is searched backwards, starting at fromIndex.\n   * @param searchElement Element to locate.\n   * @param fromIndex The index at which to start searching backwards.\n   * @returns\n   */\n  lastIndexOf(searchElement: TItem, fromIndex?: number): number {\n    return this.toArray().lastIndexOf(searchElement, fromIndex);\n  }\n\n  /**\n   * Creates an array populated with the results of calling a provided function on every element.\n   * @param callback Function that is called for every element.\n   * @returns An array with each element being the result of the callback function.\n   */\n  map<U>(callback: (value: TItem, index: number) => U): U[] {\n    const result: U[] = [];\n    let i = 0;\n    for (const entry of this.#items) {\n      result.push(\n        callback(\n          liveNodeToLson(entry) as TItem,\n          //                    ^^^^^^^^\n          //                    FIXME! This isn't safe.\n          i\n        )\n      );\n      i++;\n    }\n    return result;\n  }\n\n  /**\n   * Tests whether at least one element in the LiveList passes the test implemented by the provided function.\n   * @param predicate Function to test for each element.\n   * @returns true if the callback function returns a truthy value for at least one element. Otherwise, false.\n   */\n  some(predicate: (value: TItem, index: number) => unknown): boolean {\n    return this.toArray().some(predicate);\n  }\n\n  [Symbol.iterator](): IterableIterator<TItem> {\n    return new LiveListIterator(this.#items);\n  }\n\n  #createAttachItemAndSort(\n    op: CreateOp,\n    key: string\n  ): {\n    newItem: LiveNode;\n    newIndex: number;\n  } {\n    const newItem = creationOpToLiveNode(op);\n\n    newItem._attach(op.id, nn(this._pool));\n    newItem._setParentLink(this, key);\n\n    this.#insert(newItem);\n\n    const newIndex = this._indexOfPosition(key);\n\n    return { newItem, newIndex };\n  }\n\n  #shiftItemPosition(index: number, key: Pos) {\n    const shiftedPosition = makePosition(\n      key,\n      this.#items.length > index + 1\n        ? this.#items.at(index + 1)?._parentPos\n        : undefined\n    );\n\n    this.#updateItemPositionAt(index, shiftedPosition);\n  }\n\n  /** @internal */\n  _toTreeNode(key: string): DevTools.LsonTreeNode {\n    const payload: DevTools.LsonTreeNode[] = [];\n    let index = 0;\n    for (const item of this.#items) {\n      payload.push(item.toTreeNode(index.toString()));\n      index++;\n    }\n    return {\n      type: \"LiveList\",\n      id: this._id ?? nanoid(),\n      key,\n      payload,\n    };\n  }\n\n  toImmutable(): readonly ToImmutable<TItem>[] {\n    // Don't implement actual toJson logic in here. Implement it in ._toImmutable()\n    // instead. This helper merely exists to help TypeScript infer better\n    // return types.\n    return super.toImmutable() as readonly ToImmutable<TItem>[];\n  }\n\n  /** @internal */\n  _toImmutable(): readonly ToImmutable<TItem>[] {\n    const result = Array.from(this.#items, (node) => node.toImmutable());\n    return (\n      process.env.NODE_ENV === \"production\" ? result : Object.freeze(result)\n    ) as readonly ToImmutable<TItem>[];\n  }\n\n  clone(): LiveList<TItem> {\n    return new LiveList(\n      Array.from(this.#items, (item) => item.clone() as TItem)\n    );\n  }\n}\n\nclass LiveListIterator<T extends Lson> implements IterableIterator<T> {\n  #innerIterator: IterableIterator<LiveNode>;\n\n  constructor(items: SortedList<LiveNode>) {\n    this.#innerIterator = items[Symbol.iterator]();\n  }\n\n  [Symbol.iterator](): IterableIterator<T> {\n    return this;\n  }\n\n  next(): IteratorResult<T> {\n    const result = this.#innerIterator.next();\n\n    if (result.done) {\n      return {\n        done: true,\n        value: undefined,\n      };\n    }\n\n    const value = liveNodeToLson(result.value) as T;\n    //                                         ^^^^\n    //                                         FIXME! This isn't safe.\n    return { value };\n  }\n}\n\nfunction makeUpdate<TItem extends Lson>(\n  liveList: LiveList<TItem>,\n  deltaUpdates: LiveListUpdateDelta[]\n): LiveListUpdates<TItem> {\n  return {\n    node: liveList,\n    type: \"LiveList\",\n    updates: deltaUpdates,\n  };\n}\n\nfunction setDelta(index: number, item: LiveNode): LiveListUpdateDelta {\n  return {\n    index,\n    type: \"set\",\n    item: item instanceof LiveRegister ? item.data : item,\n  };\n}\n\nfunction deleteDelta(\n  index: number,\n  deletedNode: LiveNode\n): LiveListUpdateDelta {\n  return {\n    type: \"delete\",\n    index,\n    deletedItem:\n      deletedNode instanceof LiveRegister ? deletedNode.data : deletedNode,\n  };\n}\n\nfunction insertDelta(index: number, item: LiveNode): LiveListUpdateDelta {\n  return {\n    index,\n    type: \"insert\",\n    item: item instanceof LiveRegister ? item.data : item,\n  };\n}\n\nfunction moveDelta(\n  previousIndex: number,\n  index: number,\n  item: LiveNode\n): LiveListUpdateDelta {\n  return {\n    type: \"move\",\n    index,\n    item: item instanceof LiveRegister ? item.data : item,\n    previousIndex,\n  };\n}\n\n/**\n * This function is only temporary.\n * As soon as we refactor the operations structure,\n * serializing a LiveStructure should not know anything about intent\n */\nfunction HACK_addIntentAndDeletedIdToOperation<T extends CreateOp>(\n  ops: T[],\n  deletedId: string | undefined\n): T[] {\n  return ops.map((op, index) => {\n    if (index === 0) {\n      // NOTE: Only patch the first Op here\n      const firstOp = op;\n      return {\n        ...firstOp,\n        intent: \"set\",\n        deletedId,\n      };\n    } else {\n      return op;\n    }\n  });\n}\n","import { nn } from \"../lib/assert\";\nimport { freeze } from \"../lib/freeze\";\nimport { nanoid } from \"../lib/nanoid\";\nimport type { CreateMapOp, CreateOp, Op } from \"../protocol/Op\";\nimport { OpCode } from \"../protocol/Op\";\nimport type { MapStorageNode, SerializedMap } from \"../protocol/StorageNode\";\nimport { CrdtType } from \"../protocol/StorageNode\";\nimport type * as DevTools from \"../types/DevToolsTreeNode\";\nimport type { ParentToChildNodeMap } from \"../types/NodeMap\";\nimport type { ApplyResult, ManagedPool } from \"./AbstractCrdt\";\nimport { AbstractCrdt, OpSource } from \"./AbstractCrdt\";\nimport {\n  creationOpToLiveNode,\n  deserialize,\n  isLiveNode,\n  liveNodeToLson,\n  lsonToLiveNode,\n} from \"./liveblocks-helpers\";\nimport type { LiveNode, Lson } from \"./Lson\";\nimport type { UpdateDelta } from \"./UpdateDelta\";\nimport type { ToImmutable } from \"./utils\";\n\n/**\n * A LiveMap notification that is sent in-client to any subscribers whenever\n * one or more of the values inside the LiveMap instance have changed.\n */\nexport type LiveMapUpdates<TKey extends string, TValue extends Lson> = {\n  type: \"LiveMap\";\n  node: LiveMap<TKey, TValue>;\n  updates: { [key: string]: UpdateDelta };\n  //               ^^^^^^\n  //               FIXME: `string` is not specific enough here. See if we can\n  //               improve this type to match TKey!\n};\n\n/**\n * The LiveMap class is similar to a JavaScript Map that is synchronized on all clients.\n * Keys should be a string, and values should be serializable to JSON.\n * If multiple clients update the same property simultaneously, the last modification received by the Liveblocks servers is the winner.\n */\nexport class LiveMap<\n  TKey extends string,\n  TValue extends Lson,\n> extends AbstractCrdt {\n  #map: Map<TKey, LiveNode>;\n  #unacknowledgedSet: Map<TKey, string>;\n\n  constructor(entries?: readonly (readonly [TKey, TValue])[] | undefined) {\n    super();\n    this.#unacknowledgedSet = new Map<TKey, string>();\n\n    if (entries) {\n      const mappedEntries: [TKey, LiveNode][] = [];\n      for (const [key, value] of entries) {\n        const node = lsonToLiveNode(value);\n        node._setParentLink(this, key);\n        mappedEntries.push([key, node]);\n      }\n      this.#map = new Map(mappedEntries);\n    } else {\n      this.#map = new Map();\n    }\n  }\n\n  /** @internal */\n  _toOps(parentId: string, parentKey: string): CreateOp[] {\n    if (this._id === undefined) {\n      throw new Error(\"Cannot serialize item is not attached\");\n    }\n\n    const ops: CreateOp[] = [];\n    const op: CreateMapOp = {\n      id: this._id,\n      type: OpCode.CREATE_MAP,\n      parentId,\n      parentKey,\n    };\n\n    ops.push(op);\n\n    for (const [key, value] of this.#map) {\n      for (const childOp of value._toOps(this._id, key)) {\n        ops.push(childOp);\n      }\n    }\n\n    return ops;\n  }\n\n  /** @internal */\n  static _deserialize(\n    [id, _item]: MapStorageNode,\n    parentToChildren: ParentToChildNodeMap,\n    pool: ManagedPool\n  ): LiveMap<string, Lson> {\n    const map = new LiveMap();\n    map._attach(id, pool);\n\n    const children = parentToChildren.get(id);\n    if (children === undefined) {\n      return map;\n    }\n\n    for (const node of children) {\n      const crdt = node[1];\n      const child = deserialize(node, parentToChildren, pool);\n      child._setParentLink(map, crdt.parentKey);\n      map.#map.set(crdt.parentKey, child);\n      map.invalidate();\n    }\n\n    return map;\n  }\n\n  /** @internal */\n  _attach(id: string, pool: ManagedPool): void {\n    super._attach(id, pool);\n\n    for (const [_key, value] of this.#map) {\n      if (isLiveNode(value)) {\n        value._attach(pool.generateId(), pool);\n      }\n    }\n  }\n\n  /** @internal */\n  _attachChild(op: CreateOp, source: OpSource): ApplyResult {\n    if (this._pool === undefined) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n\n    const { id, parentKey, opId } = op;\n\n    const key = parentKey as TKey;\n    //                    ^^^^^^^ TODO: Fix me!\n\n    const child = creationOpToLiveNode(op);\n\n    if (this._pool.getNode(id) !== undefined) {\n      return { modified: false };\n    }\n\n    if (source === OpSource.OURS) {\n      const lastUpdateOpId = this.#unacknowledgedSet.get(key);\n      if (lastUpdateOpId === opId) {\n        // Acknowlegment from local operation\n        this.#unacknowledgedSet.delete(key);\n        return { modified: false };\n      } else if (lastUpdateOpId !== undefined) {\n        // Another local set has overriden the value, so we do nothing\n        return { modified: false };\n      }\n    } else if (source === OpSource.THEIRS) {\n      // If a remote operation set an item,\n      // delete the unacknowledgedSet associated to the key\n      // to make sure any future ack can override it\n      this.#unacknowledgedSet.delete(key);\n    }\n\n    const previousValue = this.#map.get(key);\n    let reverse: Op[];\n    if (previousValue) {\n      const thisId = nn(this._id);\n      reverse = previousValue._toOps(thisId, key);\n      previousValue._detach();\n    } else {\n      reverse = [{ type: OpCode.DELETE_CRDT, id }];\n    }\n\n    child._setParentLink(this, key);\n    child._attach(id, this._pool);\n    this.#map.set(key, child);\n    this.invalidate();\n\n    return {\n      modified: {\n        node: this,\n        type: \"LiveMap\",\n        updates: { [key]: { type: \"update\" } },\n      },\n      reverse,\n    };\n  }\n\n  /** @internal */\n  _detach(): void {\n    super._detach();\n\n    for (const item of this.#map.values()) {\n      item._detach();\n    }\n  }\n\n  /** @internal */\n  _detachChild(child: LiveNode): ApplyResult {\n    const id = nn(this._id);\n    const parentKey = nn(child._parentKey);\n    const reverse = child._toOps(id, parentKey);\n\n    for (const [key, value] of this.#map) {\n      if (value === child) {\n        this.#map.delete(key);\n        this.invalidate();\n      }\n    }\n\n    child._detach();\n\n    const storageUpdate: LiveMapUpdates<TKey, TValue> = {\n      node: this,\n      type: \"LiveMap\",\n      updates: {\n        [parentKey]: {\n          type: \"delete\",\n          deletedItem: liveNodeToLson(child),\n        },\n      },\n    };\n\n    return { modified: storageUpdate, reverse };\n  }\n\n  /** @internal */\n  _serialize(): SerializedMap {\n    if (this.parent.type !== \"HasParent\") {\n      throw new Error(\"Cannot serialize LiveMap if parent is missing\");\n    }\n\n    return {\n      type: CrdtType.MAP,\n      parentId: nn(this.parent.node._id, \"Parent node expected to have ID\"),\n      parentKey: this.parent.key,\n    };\n  }\n\n  /**\n   * Returns a specified element from the LiveMap.\n   * @param key The key of the element to return.\n   * @returns The element associated with the specified key, or undefined if the key can't be found in the LiveMap.\n   */\n  get(key: TKey): TValue | undefined {\n    const value = this.#map.get(key);\n    if (value === undefined) {\n      return undefined;\n    }\n    return liveNodeToLson(value) as TValue | undefined;\n    //                           ^^^^^^^^^^^^^^^^^^^^^\n    //                           FIXME! This isn't safe.\n  }\n\n  /**\n   * Adds or updates an element with a specified key and a value.\n   * @param key The key of the element to add. Should be a string.\n   * @param value The value of the element to add. Should be serializable to JSON.\n   */\n  set(key: TKey, value: TValue): void {\n    this._pool?.assertStorageIsWritable();\n    const oldValue = this.#map.get(key);\n\n    if (oldValue) {\n      oldValue._detach();\n    }\n\n    const item = lsonToLiveNode(value);\n    item._setParentLink(this, key);\n\n    this.#map.set(key, item);\n    this.invalidate();\n\n    if (this._pool && this._id) {\n      const id = this._pool.generateId();\n      item._attach(id, this._pool);\n\n      const storageUpdates = new Map<string, LiveMapUpdates<TKey, TValue>>();\n      storageUpdates.set(this._id, {\n        node: this,\n        type: \"LiveMap\",\n        updates: { [key]: { type: \"update\" } },\n      });\n\n      const ops = item._toOpsWithOpId(this._id, key, this._pool);\n\n      this.#unacknowledgedSet.set(key, nn(ops[0].opId));\n\n      this._pool.dispatch(\n        ops,\n        oldValue\n          ? oldValue._toOps(this._id, key)\n          : [{ type: OpCode.DELETE_CRDT, id }],\n        storageUpdates\n      );\n    }\n  }\n\n  /**\n   * Returns the number of elements in the LiveMap.\n   */\n  get size(): number {\n    return this.#map.size;\n  }\n\n  /**\n   * Returns a boolean indicating whether an element with the specified key exists or not.\n   * @param key The key of the element to test for presence.\n   */\n  has(key: TKey): boolean {\n    return this.#map.has(key);\n  }\n\n  /**\n   * Removes the specified element by key.\n   * @param key The key of the element to remove.\n   * @returns true if an element existed and has been removed, or false if the element does not exist.\n   */\n  delete(key: TKey): boolean {\n    this._pool?.assertStorageIsWritable();\n    const item = this.#map.get(key);\n\n    if (item === undefined) {\n      return false;\n    }\n\n    item._detach();\n    this.#map.delete(key);\n    this.invalidate();\n\n    if (this._pool && item._id) {\n      const thisId = nn(this._id);\n      const storageUpdates = new Map<string, LiveMapUpdates<TKey, TValue>>();\n      storageUpdates.set(thisId, {\n        node: this,\n        type: \"LiveMap\",\n        updates: {\n          [key]: {\n            type: \"delete\",\n            deletedItem: liveNodeToLson(item),\n          },\n        },\n      });\n      this._pool.dispatch(\n        [\n          {\n            type: OpCode.DELETE_CRDT,\n            id: item._id,\n            opId: this._pool.generateOpId(),\n          },\n        ],\n        item._toOps(thisId, key),\n        storageUpdates\n      );\n    }\n\n    return true;\n  }\n\n  /**\n   * Returns a new Iterator object that contains the [key, value] pairs for each element.\n   */\n  entries(): IterableIterator<[TKey, TValue]> {\n    const innerIterator = this.#map.entries();\n\n    return {\n      [Symbol.iterator]() {\n        return this;\n      },\n      next() {\n        const iteratorValue = innerIterator.next();\n\n        if (iteratorValue.done) {\n          return {\n            done: true,\n            value: undefined,\n          };\n        }\n\n        const entry = iteratorValue.value;\n\n        const key = entry[0];\n        const value = liveNodeToLson(iteratorValue.value[1]) as TValue;\n        //                                                   ^^^^^^^^^\n        //                                                   FIXME! This isn't safe.\n        return {\n          value: [key, value],\n        };\n      },\n    };\n  }\n\n  /**\n   * Same function object as the initial value of the entries method.\n   */\n  [Symbol.iterator](): IterableIterator<[TKey, TValue]> {\n    return this.entries();\n  }\n\n  /**\n   * Returns a new Iterator object that contains the keys for each element.\n   */\n  keys(): IterableIterator<TKey> {\n    return this.#map.keys();\n  }\n\n  /**\n   * Returns a new Iterator object that contains the values for each element.\n   */\n  values(): IterableIterator<TValue> {\n    const innerIterator = this.#map.values();\n\n    return {\n      [Symbol.iterator]() {\n        return this;\n      },\n      next() {\n        const iteratorValue = innerIterator.next();\n\n        if (iteratorValue.done) {\n          return {\n            done: true,\n            value: undefined,\n          };\n        }\n\n        const value = liveNodeToLson(iteratorValue.value) as TValue;\n        //                                                ^^^^^^^^^\n        //                                                FIXME! This isn't safe.\n\n        return { value };\n      },\n    };\n  }\n\n  /**\n   * Executes a provided function once per each key/value pair in the Map object, in insertion order.\n   * @param callback Function to execute for each entry in the map.\n   */\n  forEach(\n    callback: (value: TValue, key: TKey, map: LiveMap<TKey, TValue>) => void\n  ): void {\n    for (const entry of this) {\n      callback(entry[1], entry[0], this);\n    }\n  }\n\n  /** @internal */\n  _toTreeNode(key: string): DevTools.LsonTreeNode {\n    return {\n      type: \"LiveMap\",\n      id: this._id ?? nanoid(),\n      key,\n      payload: Array.from(this.#map.entries()).map(([key, val]) =>\n        val.toTreeNode(key)\n      ),\n    };\n  }\n\n  toImmutable(): ReadonlyMap<TKey, ToImmutable<TValue>> {\n    // Don't implement actual toImmutable logic in here. Implement it in\n    // ._toImmutable() instead. This helper merely exists to help TypeScript\n    // infer better return types.\n    return super.toImmutable() as ReadonlyMap<TKey, ToImmutable<TValue>>;\n  }\n\n  /** @internal */\n  _toImmutable(): ReadonlyMap<TKey, ToImmutable<TValue>> {\n    const result: Map<TKey, ToImmutable<TValue>> = new Map();\n    for (const [key, value] of this.#map) {\n      result.set(key, value.toImmutable() as ToImmutable<TValue>);\n    }\n    return freeze(result);\n  }\n\n  clone(): LiveMap<TKey, TValue> {\n    return new LiveMap(\n      Array.from(this.#map).map(([key, node]) => [key, node.clone() as TValue])\n    );\n  }\n}\n","import type { LiveNode, Lson, LsonObject } from \"../crdts/Lson\";\nimport { nn } from \"../lib/assert\";\nimport type { Json, JsonObject } from \"../lib/Json\";\nimport { nanoid } from \"../lib/nanoid\";\nimport type { RemoveUndefinedValues } from \"../lib/utils\";\nimport { compactObject, deepClone } from \"../lib/utils\";\nimport type {\n  ClientWireOp,\n  CreateObjectOp,\n  CreateOp,\n  DeleteObjectKeyOp,\n  Op,\n  UpdateObjectOp,\n} from \"../protocol/Op\";\nimport { OpCode } from \"../protocol/Op\";\nimport type {\n  NodeStream,\n  ObjectStorageNode,\n  RootStorageNode,\n  SerializedObject,\n  SerializedRootObject,\n} from \"../protocol/StorageNode\";\nimport { CrdtType, isRootStorageNode } from \"../protocol/StorageNode\";\nimport type * as DevTools from \"../types/DevToolsTreeNode\";\nimport type { ParentToChildNodeMap } from \"../types/NodeMap\";\nimport type { ApplyResult, ManagedPool } from \"./AbstractCrdt\";\nimport { AbstractCrdt, OpSource } from \"./AbstractCrdt\";\nimport {\n  creationOpToLson,\n  deserializeToLson,\n  isLiveNode,\n  isLiveStructure,\n} from \"./liveblocks-helpers\";\nimport type { UpdateDelta } from \"./UpdateDelta\";\nimport type { ToImmutable } from \"./utils\";\n\nexport type LiveObjectUpdateDelta<O extends { [key: string]: unknown }> = {\n  [K in keyof O]?: UpdateDelta | undefined;\n};\n\n// One key platform limit is that a LiveObject cannot exceed 128 kB when\n// totalling the size of the keys and values.\n// See https://liveblocks.io/docs/platform/limits#Liveblocks-Storage-limits\nconst MAX_LIVE_OBJECT_SIZE = 128 * 1024;\n\n/**\n * A LiveObject notification that is sent in-client to any subscribers whenever\n * one or more of the entries inside the LiveObject instance have changed.\n */\nexport type LiveObjectUpdates<TData extends LsonObject> = {\n  type: \"LiveObject\";\n  node: LiveObject<TData>;\n  updates: LiveObjectUpdateDelta<TData>;\n};\n\n/**\n * The LiveObject class is similar to a JavaScript object that is synchronized on all clients.\n * Keys should be a string, and values should be serializable to JSON.\n * If multiple clients update the same property simultaneously, the last modification received by the Liveblocks servers is the winner.\n */\nexport class LiveObject<O extends LsonObject> extends AbstractCrdt {\n  #map: Map<string, Lson>;\n\n  /**\n   * Tracks unacknowledged local changes per property to preserve optimistic\n   * updates. Maps property keys to their pending operation IDs.\n   *\n   * INVARIANT: Only locally-generated opIds are ever stored here. Remote opIds\n   * are only compared against (to detect ACKs), never stored.\n   *\n   * When a local change is made, the opId is stored here. When a remote op\n   * arrives for the same key:\n   * - If no entry exists → apply remote op\n   * - If opId matches → it's an ACK, clear the entry\n   * - If opId differs → ignore remote op to preserve optimistic update\n   */\n  #unackedOpsByKey: Map<string, string>;\n\n  /**\n   * Enable or disable detection of too large LiveObjects.\n   * When enabled, throws an error if LiveObject static data exceeds 128KB, which\n   * is the maximum value the server will be able to accept.\n   * By default, this behavior is disabled to avoid the runtime performance\n   * overhead on every LiveObject.set() or LiveObject.update() call.\n   *\n   * @experimental\n   */\n  public static detectLargeObjects = false;\n\n  static #buildRootAndParentToChildren(\n    nodes: NodeStream\n  ): [root: SerializedRootObject, nodeMap: ParentToChildNodeMap] {\n    const parentToChildren: ParentToChildNodeMap = new Map();\n    let root: SerializedRootObject | null = null;\n\n    for (const node of nodes) {\n      if (isRootStorageNode(node)) {\n        root = node[1];\n      } else {\n        const crdt = node[1];\n        const children = parentToChildren.get(crdt.parentId);\n        if (children !== undefined) {\n          children.push(node);\n        } else {\n          parentToChildren.set(crdt.parentId, [node]);\n        }\n      }\n    }\n\n    if (root === null) {\n      throw new Error(\"Root can't be null\");\n    }\n\n    return [root, parentToChildren];\n  }\n\n  /** @private Do not use this API directly */\n  static _fromItems<O extends LsonObject>(\n    nodes: NodeStream,\n    pool: ManagedPool\n  ): LiveObject<O> {\n    const [root, parentToChildren] =\n      LiveObject.#buildRootAndParentToChildren(nodes);\n    return LiveObject._deserialize(\n      [\"root\", root],\n      parentToChildren,\n      pool\n    ) as LiveObject<O>;\n  }\n\n  constructor(obj: O = {} as O) {\n    super();\n\n    this.#unackedOpsByKey = new Map();\n\n    const o: RemoveUndefinedValues<LsonObject> = compactObject(obj);\n    for (const key of Object.keys(o)) {\n      const value = o[key];\n      if (isLiveNode(value)) {\n        value._setParentLink(this, key);\n      }\n    }\n\n    this.#map = new Map(Object.entries(o));\n  }\n\n  /** @internal */\n  _toOps(parentId: string, parentKey: string): CreateOp[] {\n    if (this._id === undefined) {\n      throw new Error(\"Cannot serialize item is not attached\");\n    }\n\n    const ops: CreateOp[] = [];\n    const op: CreateObjectOp = {\n      type: OpCode.CREATE_OBJECT,\n      id: this._id,\n      parentId,\n      parentKey,\n      data: {},\n    };\n\n    ops.push(op);\n\n    for (const [key, value] of this.#map) {\n      if (isLiveNode(value)) {\n        for (const childOp of value._toOps(this._id, key)) {\n          ops.push(childOp);\n        }\n      } else {\n        op.data[key] = value;\n      }\n    }\n\n    return ops;\n  }\n\n  /** @internal */\n  static _deserialize(\n    [id, item]: RootStorageNode | ObjectStorageNode,\n    parentToChildren: ParentToChildNodeMap,\n    pool: ManagedPool\n  ): LiveObject<LsonObject> {\n    const liveObj = new LiveObject(item.data);\n    liveObj._attach(id, pool);\n    return this._deserializeChildren(liveObj, parentToChildren, pool);\n  }\n\n  /** @internal */\n  static _deserializeChildren(\n    liveObj: LiveObject<JsonObject>,\n    parentToChildren: ParentToChildNodeMap,\n    pool: ManagedPool\n  ): LiveObject<LsonObject> {\n    const children = parentToChildren.get(nn(liveObj._id));\n    if (children === undefined) {\n      return liveObj;\n    }\n\n    for (const node of children) {\n      const child = deserializeToLson(node, parentToChildren, pool);\n      const crdt = node[1];\n      if (isLiveStructure(child)) {\n        child._setParentLink(liveObj, crdt.parentKey);\n      }\n      liveObj.#map.set(crdt.parentKey, child);\n      liveObj.invalidate();\n    }\n\n    return liveObj;\n  }\n\n  /** @internal */\n  _attach(id: string, pool: ManagedPool): void {\n    super._attach(id, pool);\n\n    for (const [_key, value] of this.#map) {\n      if (isLiveNode(value)) {\n        value._attach(pool.generateId(), pool);\n      }\n    }\n  }\n\n  /** @internal */\n  _attachChild(op: CreateOp, source: OpSource): ApplyResult {\n    if (this._pool === undefined) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n\n    const { id, opId, parentKey: key } = op;\n    const child = creationOpToLson(op);\n\n    if (this._pool.getNode(id) !== undefined) {\n      if (this.#unackedOpsByKey.get(key) === opId) {\n        // Acknowlegment from local operation\n        this.#unackedOpsByKey.delete(key);\n      }\n\n      return { modified: false };\n    }\n\n    if (source === OpSource.LOCAL) {\n      // Track locally-generated opId to preserve optimistic update\n      this.#unackedOpsByKey.set(key, nn(opId));\n    } else if (this.#unackedOpsByKey.get(key) === undefined) {\n      // Remote operation with no local change => apply operation\n    } else if (this.#unackedOpsByKey.get(key) === opId) {\n      // Acknowlegment from local operation\n      this.#unackedOpsByKey.delete(key);\n      return { modified: false };\n    } else {\n      // Conflict, ignore remote operation\n      return { modified: false };\n    }\n\n    const thisId = nn(this._id);\n    const previousValue = this.#map.get(key);\n    let reverse: Op[];\n    if (isLiveNode(previousValue)) {\n      reverse = previousValue._toOps(thisId, key);\n      previousValue._detach();\n    } else if (previousValue === undefined) {\n      reverse = [{ type: OpCode.DELETE_OBJECT_KEY, id: thisId, key }];\n    } else {\n      reverse = [\n        {\n          type: OpCode.UPDATE_OBJECT,\n          id: thisId,\n          data: { [key]: previousValue },\n        },\n      ];\n    }\n\n    this.#map.set(key, child);\n    this.invalidate();\n\n    if (isLiveStructure(child)) {\n      child._setParentLink(this, key);\n      child._attach(id, this._pool);\n    }\n\n    return {\n      reverse,\n      modified: {\n        node: this,\n        type: \"LiveObject\",\n        updates: { [key]: { type: \"update\" } },\n      },\n    };\n  }\n\n  /** @internal */\n  _detachChild(child: LiveNode): ApplyResult {\n    if (child) {\n      const id = nn(this._id);\n      const parentKey = nn(child._parentKey);\n      const reverse = child._toOps(id, parentKey);\n\n      for (const [key, value] of this.#map) {\n        if (value === child) {\n          this.#map.delete(key);\n          this.invalidate();\n        }\n      }\n\n      child._detach();\n\n      const storageUpdate: LiveObjectUpdates<O> = {\n        node: this,\n        type: \"LiveObject\",\n        updates: {\n          [parentKey]: { type: \"delete\" },\n        } as { [K in keyof O]: UpdateDelta },\n      };\n\n      return { modified: storageUpdate, reverse };\n    }\n\n    return { modified: false };\n  }\n\n  /** @internal */\n  _detach(): void {\n    super._detach();\n\n    for (const value of this.#map.values()) {\n      if (isLiveNode(value)) {\n        value._detach();\n      }\n    }\n  }\n\n  /** @internal */\n  _apply(op: Op, isLocal: boolean): ApplyResult {\n    if (op.type === OpCode.UPDATE_OBJECT) {\n      return this.#applyUpdate(op, isLocal);\n    } else if (op.type === OpCode.DELETE_OBJECT_KEY) {\n      return this.#applyDeleteObjectKey(op, isLocal);\n    }\n\n    return super._apply(op, isLocal);\n  }\n\n  /** @internal */\n  _serialize(): SerializedObject | SerializedRootObject {\n    const data: JsonObject = {};\n\n    // Add only the static Json data fields into the objects\n    for (const [key, value] of this.#map) {\n      if (!isLiveNode(value)) {\n        data[key] = value;\n      }\n    }\n\n    if (this.parent.type === \"HasParent\" && this.parent.node._id) {\n      return {\n        type: CrdtType.OBJECT,\n        parentId: this.parent.node._id,\n        parentKey: this.parent.key,\n        data,\n      };\n    } else {\n      // Root object has no parent ID/key\n      return {\n        type: CrdtType.OBJECT,\n        data,\n      };\n    }\n  }\n\n  #applyUpdate(op: UpdateObjectOp, isLocal: boolean): ApplyResult {\n    let isModified = false;\n    const id = nn(this._id);\n    const reverse: Op[] = [];\n    const reverseUpdate: UpdateObjectOp = {\n      type: OpCode.UPDATE_OBJECT,\n      id,\n      data: {},\n    };\n\n    for (const key in op.data as Partial<O>) {\n      const oldValue = this.#map.get(key);\n      if (isLiveNode(oldValue)) {\n        for (const childOp of oldValue._toOps(id, key)) {\n          reverse.push(childOp);\n        }\n        oldValue._detach();\n      } else if (oldValue !== undefined) {\n        reverseUpdate.data[key] = oldValue;\n      } else if (oldValue === undefined) {\n        reverse.push({ type: OpCode.DELETE_OBJECT_KEY, id, key });\n      }\n    }\n\n    const updateDelta: LiveObjectUpdateDelta<O> = {};\n    for (const key in op.data as Partial<O>) {\n      const value = op.data[key];\n      if (value === undefined) {\n        continue;\n      }\n\n      if (isLocal) {\n        // Track locally-generated opId to preserve optimistic update\n        this.#unackedOpsByKey.set(key, nn(op.opId));\n      } else if (this.#unackedOpsByKey.get(key) === undefined) {\n        // Not modified localy so we apply update\n        isModified = true;\n      } else if (this.#unackedOpsByKey.get(key) === op.opId) {\n        // Acknowlegment from local operation\n        this.#unackedOpsByKey.delete(key);\n        continue;\n      } else {\n        // Conflict, ignore remote operation\n        continue;\n      }\n\n      const oldValue = this.#map.get(key);\n\n      if (isLiveNode(oldValue)) {\n        oldValue._detach();\n      }\n\n      isModified = true;\n      updateDelta[key] = { type: \"update\" };\n      this.#map.set(key, value);\n      this.invalidate();\n    }\n\n    if (Object.keys(reverseUpdate.data).length !== 0) {\n      reverse.unshift(reverseUpdate);\n    }\n\n    return isModified\n      ? {\n          modified: {\n            node: this,\n            type: \"LiveObject\",\n            updates: updateDelta,\n          },\n          reverse,\n        }\n      : { modified: false };\n  }\n\n  #applyDeleteObjectKey(op: DeleteObjectKeyOp, isLocal: boolean): ApplyResult {\n    const key = op.key;\n\n    // If property does not exist, exit without notifying\n    const oldValue = this.#map.get(key);\n    if (oldValue === undefined) {\n      return { modified: false };\n    }\n\n    // If a local operation exists on the same key and we receive a remote\n    // one prevent flickering by not applying delete op.\n    if (!isLocal && this.#unackedOpsByKey.get(key) !== undefined) {\n      return { modified: false };\n    }\n\n    const id = nn(this._id);\n    let reverse: Op[] = [];\n    if (isLiveNode(oldValue)) {\n      reverse = oldValue._toOps(id, op.key);\n      oldValue._detach();\n    } else if (oldValue !== undefined) {\n      reverse = [\n        {\n          type: OpCode.UPDATE_OBJECT,\n          id,\n          data: { [key]: oldValue },\n        },\n      ];\n    }\n\n    this.#map.delete(key);\n    this.invalidate();\n    return {\n      modified: {\n        node: this,\n        type: \"LiveObject\",\n        updates: {\n          [op.key]: { type: \"delete\", deletedItem: oldValue satisfies Lson },\n        },\n      },\n      reverse,\n    };\n  }\n\n  /**\n   * Transform the LiveObject into a javascript object\n   */\n  toObject(): O {\n    return Object.fromEntries(this.#map) as O;\n  }\n\n  /**\n   * Adds or updates a property with a specified key and a value.\n   * @param key The key of the property to add\n   * @param value The value of the property to add\n   */\n  set<TKey extends keyof O>(key: TKey, value: O[TKey]): void {\n    // TODO: Find out why typescript complains\n    this._pool?.assertStorageIsWritable();\n    this.update({ [key]: value } as unknown as Partial<O>);\n  }\n\n  /**\n   * Returns a specified property from the LiveObject.\n   * @param key The key of the property to get\n   */\n  get<TKey extends keyof O>(key: TKey): O[TKey] {\n    return this.#map.get(key as string) as O[TKey];\n  }\n\n  /**\n   * Deletes a key from the LiveObject\n   * @param key The key of the property to delete\n   */\n  delete(key: keyof O): void {\n    this._pool?.assertStorageIsWritable();\n    const keyAsString = key as string;\n\n    const oldValue = this.#map.get(keyAsString);\n    if (oldValue === undefined) {\n      return;\n    }\n\n    if (this._pool === undefined || this._id === undefined) {\n      if (isLiveNode(oldValue)) {\n        oldValue._detach();\n      }\n      this.#map.delete(keyAsString);\n      this.invalidate();\n      return;\n    }\n\n    let reverse: Op[];\n\n    if (isLiveNode(oldValue)) {\n      oldValue._detach();\n      reverse = oldValue._toOps(this._id, keyAsString);\n    } else {\n      reverse = [\n        {\n          type: OpCode.UPDATE_OBJECT,\n          data: { [keyAsString]: oldValue },\n          id: this._id,\n        },\n      ];\n    }\n\n    this.#map.delete(keyAsString);\n    this.invalidate();\n\n    const storageUpdates = new Map<string, LiveObjectUpdates<O>>();\n    storageUpdates.set(this._id, {\n      node: this,\n      type: \"LiveObject\",\n      updates: {\n        [key]: { type: \"delete\", deletedItem: oldValue } satisfies UpdateDelta,\n      } as {\n        [K in keyof O]: UpdateDelta;\n      },\n    });\n\n    this._pool.dispatch(\n      [\n        {\n          type: OpCode.DELETE_OBJECT_KEY,\n          key: keyAsString,\n          id: this._id,\n          opId: this._pool.generateOpId(),\n        },\n      ],\n      reverse,\n      storageUpdates\n    );\n  }\n\n  /**\n   * Adds or updates multiple properties at once with an object.\n   * @param patch The object used to overrides properties\n   */\n  update(patch: Partial<O>): void {\n    this._pool?.assertStorageIsWritable();\n\n    // If detectLargeObjects is enabled, perform a runtime size check now so we\n    // can immediately throw as soon as the max object size is exceeded.\n    if (LiveObject.detectLargeObjects) {\n      const data: Record<string, Json> = {};\n      for (const [key, value] of this.#map) {\n        if (!isLiveNode(value)) {\n          data[key] = value;\n        }\n      }\n      for (const key of Object.keys(patch)) {\n        const value = patch[key];\n        if (value === undefined) continue;\n        if (!isLiveNode(value)) {\n          data[key] = value;\n        }\n      }\n\n      // Fast upper-bound check: multiply JSON string length by 4 (worst-case UTF-8)\n      // This is much faster than TextEncoder and gives us an upper bound\n      const jsonString = JSON.stringify(data);\n      const upperBoundSize = jsonString.length * 4;\n\n      // Only do the precise calculation if the fast check suggests we might be close\n      if (upperBoundSize > MAX_LIVE_OBJECT_SIZE) {\n        const preciseSize = new TextEncoder().encode(jsonString).length;\n        if (preciseSize > MAX_LIVE_OBJECT_SIZE) {\n          throw new Error(\n            `LiveObject size exceeded limit: ${preciseSize} bytes > ${MAX_LIVE_OBJECT_SIZE} bytes. See https://liveblocks.io/docs/platform/limits#Liveblocks-Storage-limits`\n          );\n        }\n      }\n    }\n\n    if (this._pool === undefined || this._id === undefined) {\n      for (const key in patch) {\n        const newValue = patch[key];\n        if (newValue === undefined) {\n          continue;\n        }\n\n        const oldValue = this.#map.get(key);\n        if (isLiveNode(oldValue)) {\n          oldValue._detach();\n        }\n\n        if (isLiveNode(newValue)) {\n          newValue._setParentLink(this, key);\n        }\n\n        this.#map.set(key, newValue);\n        this.invalidate();\n      }\n\n      return;\n    }\n\n    const ops: ClientWireOp[] = [];\n    const reverseOps: Op[] = [];\n\n    const opId = this._pool.generateOpId();\n    const updatedProps: JsonObject = {};\n\n    const reverseUpdateOp: UpdateObjectOp = {\n      id: this._id,\n      type: OpCode.UPDATE_OBJECT,\n      data: {},\n    };\n\n    const updateDelta: LiveObjectUpdateDelta<O> = {};\n\n    for (const key in patch) {\n      const newValue: Lson | undefined = patch[key];\n      if (newValue === undefined) {\n        continue;\n      }\n\n      const oldValue = this.#map.get(key);\n\n      if (isLiveNode(oldValue)) {\n        for (const childOp of oldValue._toOps(this._id, key)) {\n          reverseOps.push(childOp);\n        }\n        oldValue._detach();\n      } else if (oldValue === undefined) {\n        reverseOps.push({ type: OpCode.DELETE_OBJECT_KEY, id: this._id, key });\n      } else {\n        reverseUpdateOp.data[key] = oldValue;\n      }\n\n      if (isLiveNode(newValue)) {\n        newValue._setParentLink(this, key);\n        newValue._attach(this._pool.generateId(), this._pool);\n        const newAttachChildOps = newValue._toOpsWithOpId(\n          this._id,\n          key,\n          this._pool\n        );\n\n        const createCrdtOp = newAttachChildOps.find(\n          (op: Op & { parentId?: string }) => op.parentId === this._id\n        );\n        if (createCrdtOp) {\n          // Track locally-generated opId to preserve optimistic update\n          this.#unackedOpsByKey.set(key, nn(createCrdtOp.opId));\n        }\n\n        for (const childOp of newAttachChildOps) {\n          ops.push(childOp);\n        }\n      } else {\n        updatedProps[key] = newValue;\n        // Track locally-generated opId to preserve optimistic update\n        this.#unackedOpsByKey.set(key, opId);\n      }\n\n      this.#map.set(key, newValue);\n      this.invalidate();\n      updateDelta[key] = { type: \"update\" };\n    }\n\n    if (Object.keys(reverseUpdateOp.data).length !== 0) {\n      reverseOps.unshift(reverseUpdateOp);\n    }\n\n    if (Object.keys(updatedProps).length !== 0) {\n      ops.unshift({\n        opId,\n        id: this._id,\n        type: OpCode.UPDATE_OBJECT,\n        data: updatedProps,\n      });\n    }\n\n    const storageUpdates = new Map<string, LiveObjectUpdates<O>>();\n    storageUpdates.set(this._id, {\n      node: this,\n      type: \"LiveObject\",\n      updates: updateDelta,\n    });\n    this._pool.dispatch(ops, reverseOps, storageUpdates);\n  }\n\n  toImmutable(): ToImmutable<O> {\n    // Don't implement actual toImmutable logic in here. Implement it in\n    // ._toImmutable() instead. This helper merely exists to help TypeScript\n    // infer better return types.\n    return super.toImmutable() as ToImmutable<O>;\n  }\n\n  /** @internal */\n  toTreeNode(key: string): DevTools.LiveTreeNode<\"LiveObject\"> {\n    // Don't implement actual toTreeNode logic in here. Implement it in\n    // ._toTreeNode() instead. This helper merely exists to help TypeScript\n    // infer better return types.\n    return super.toTreeNode(key) as DevTools.LiveTreeNode<\"LiveObject\">;\n  }\n\n  /** @internal */\n  _toTreeNode(key: string): DevTools.LsonTreeNode {\n    const nodeId = this._id ?? nanoid();\n    return {\n      type: \"LiveObject\",\n      id: nodeId,\n      key,\n      payload: Array.from(this.#map.entries()).map(([key, value]) =>\n        isLiveNode(value)\n          ? value.toTreeNode(key)\n          : { type: \"Json\", id: `${nodeId}:${key}`, key, payload: value }\n      ),\n    };\n  }\n\n  /** @internal */\n  _toImmutable(): ToImmutable<O> {\n    const result: { [key: string]: unknown } = {};\n    for (const [key, val] of this.#map) {\n      result[key] = isLiveStructure(val) ? val.toImmutable() : val;\n    }\n    return (\n      process.env.NODE_ENV === \"production\" ? result : Object.freeze(result)\n    ) as ToImmutable<O>;\n  }\n\n  clone(): LiveObject<O> {\n    return new LiveObject(\n      Object.fromEntries(\n        Array.from(this.#map).map(([key, value]) => [\n          key,\n          isLiveStructure(value) ? value.clone() : deepClone(value),\n        ])\n      ) as O\n    );\n  }\n}\n","import { assertNever, nn } from \"../lib/assert\";\nimport { isPlainObject } from \"../lib/guards\";\nimport type { Json } from \"../lib/Json\";\nimport { stringifyOrLog as stringify } from \"../lib/stringify\";\nimport { deepClone, entries } from \"../lib/utils\";\nimport type { CreateOp, Op } from \"../protocol/Op\";\nimport { OpCode } from \"../protocol/Op\";\nimport type { NodeMap, StorageNode } from \"../protocol/StorageNode\";\nimport {\n  CrdtType,\n  isListStorageNode,\n  isMapStorageNode,\n  isObjectStorageNode,\n  isRegisterStorageNode,\n} from \"../protocol/StorageNode\";\nimport type { ParentToChildNodeMap } from \"../types/NodeMap\";\nimport type { ManagedPool } from \"./AbstractCrdt\";\nimport { LiveList, type LiveListUpdates } from \"./LiveList\";\nimport { LiveMap, type LiveMapUpdates } from \"./LiveMap\";\nimport { LiveObject, type LiveObjectUpdates } from \"./LiveObject\";\nimport { LiveRegister } from \"./LiveRegister\";\nimport type { LiveNode, LiveStructure, Lson, LsonObject } from \"./Lson\";\nimport type { StorageUpdate } from \"./StorageUpdates\";\n\nexport function creationOpToLiveNode(op: CreateOp): LiveNode {\n  return lsonToLiveNode(creationOpToLson(op));\n}\n\nexport function creationOpToLson(op: CreateOp): Lson {\n  switch (op.type) {\n    case OpCode.CREATE_REGISTER:\n      return op.data;\n    case OpCode.CREATE_OBJECT:\n      return new LiveObject(op.data);\n    case OpCode.CREATE_MAP:\n      return new LiveMap();\n    case OpCode.CREATE_LIST:\n      return new LiveList([]);\n    default:\n      return assertNever(op, \"Unknown creation Op\");\n  }\n}\n\nexport function isSameNodeOrChildOf(node: LiveNode, parent: LiveNode): boolean {\n  if (node === parent) {\n    return true;\n  }\n  if (node.parent.type === \"HasParent\") {\n    return isSameNodeOrChildOf(node.parent.node, parent);\n  }\n  return false;\n}\n\nexport function deserialize(\n  node: StorageNode,\n  parentToChildren: ParentToChildNodeMap,\n  pool: ManagedPool\n): LiveNode {\n  if (isObjectStorageNode(node)) {\n    return LiveObject._deserialize(node, parentToChildren, pool);\n  } else if (isListStorageNode(node)) {\n    return LiveList._deserialize(node, parentToChildren, pool);\n  } else if (isMapStorageNode(node)) {\n    return LiveMap._deserialize(node, parentToChildren, pool);\n  } else if (isRegisterStorageNode(node)) {\n    return LiveRegister._deserialize(node, parentToChildren, pool);\n  } else {\n    throw new Error(\"Unexpected CRDT type\");\n  }\n}\n\nexport function deserializeToLson(\n  node: StorageNode,\n  parentToChildren: ParentToChildNodeMap,\n  pool: ManagedPool\n): Lson {\n  if (isObjectStorageNode(node)) {\n    return LiveObject._deserialize(node, parentToChildren, pool);\n  } else if (isListStorageNode(node)) {\n    return LiveList._deserialize(node, parentToChildren, pool);\n  } else if (isMapStorageNode(node)) {\n    return LiveMap._deserialize(node, parentToChildren, pool);\n  } else if (isRegisterStorageNode(node)) {\n    return node[1].data;\n  } else {\n    throw new Error(\"Unexpected CRDT type\");\n  }\n}\n\nexport function isLiveStructure(value: unknown): value is LiveStructure {\n  return isLiveList(value) || isLiveMap(value) || isLiveObject(value);\n}\n\nexport function isLiveNode(value: unknown): value is LiveNode {\n  return isLiveStructure(value) || isLiveRegister(value);\n}\n\nexport function isLiveList(value: unknown): value is LiveList<Lson> {\n  return value instanceof LiveList;\n}\n\nexport function isLiveMap(value: unknown): value is LiveMap<string, Lson> {\n  return value instanceof LiveMap;\n}\n\nexport function isLiveObject(value: unknown): value is LiveObject<LsonObject> {\n  return value instanceof LiveObject;\n}\n\nexport function isLiveRegister(value: unknown): value is LiveRegister<Json> {\n  return value instanceof LiveRegister;\n}\n\nexport function cloneLson<L extends Lson | undefined>(value: L): L {\n  return value === undefined\n    ? (undefined as L)\n    : isLiveStructure(value)\n      ? (value.clone() as L)\n      : (deepClone(value) as L);\n}\n\nexport function liveNodeToLson(obj: LiveNode): Lson {\n  if (obj instanceof LiveRegister) {\n    return obj.data;\n  } else if (\n    obj instanceof LiveList ||\n    obj instanceof LiveMap ||\n    obj instanceof LiveObject\n  ) {\n    return obj;\n  } else {\n    return assertNever(obj, \"Unknown AbstractCrdt\");\n  }\n}\n\nexport function lsonToLiveNode(value: Lson): LiveNode {\n  if (\n    value instanceof LiveObject ||\n    value instanceof LiveMap ||\n    value instanceof LiveList\n  ) {\n    return value;\n  } else {\n    return new LiveRegister(value);\n  }\n}\n\n/**\n * Computes the operations needed to transform one NodeMap into another.\n *\n * Used when the client receives a fresh storage snapshot from the server\n * (e.g. after reconnecting). The local state may have diverged, so we diff\n * the two trees and apply the resulting ops to bring local state in sync\n * with the server's authoritative version.\n *\n * Returns ops for:\n * - DELETE_CRDT: nodes in current but not in new\n * - CREATE_*: nodes in new but not in current\n * - UPDATE_OBJECT: objects whose data changed\n * - SET_PARENT_KEY: nodes whose position changed\n *\n * Example:\n * - Current: { \"root\": { a: 1 },  \"node1\": { b: 2 } }\n * - New:     { \"root\": { a: 99 }, \"node2\": { c: 3 } }\n *\n * Returns:\n *  - DELETE_CRDT for \"node1\" (removed)\n *  - UPDATE_OBJECT for \"root\" (data changed: a: 1 → 99)\n *  - CREATE_OBJECT for \"node2\" (added)\n */\nexport function getTreesDiffOperations(\n  currentItems: NodeMap,\n  newItems: NodeMap\n): Op[] {\n  const ops: Op[] = [];\n\n  currentItems.forEach((_, id) => {\n    if (!newItems.get(id)) {\n      // Delete crdt\n      ops.push({ type: OpCode.DELETE_CRDT, id });\n    }\n  });\n\n  newItems.forEach((crdt, id) => {\n    const currentCrdt = currentItems.get(id);\n    if (currentCrdt) {\n      if (crdt.type === CrdtType.OBJECT) {\n        if (\n          currentCrdt.type !== CrdtType.OBJECT ||\n          stringify(crdt.data) !== stringify(currentCrdt.data)\n        ) {\n          ops.push({\n            type: OpCode.UPDATE_OBJECT,\n            id,\n            data: crdt.data,\n          });\n        }\n      }\n      if (crdt.parentKey !== currentCrdt.parentKey) {\n        ops.push({\n          type: OpCode.SET_PARENT_KEY,\n          id,\n          parentKey: nn(crdt.parentKey, \"Parent key must not be missing\"),\n        });\n      }\n    } else {\n      // new Crdt\n      switch (crdt.type) {\n        case CrdtType.REGISTER:\n          ops.push({\n            type: OpCode.CREATE_REGISTER,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey,\n            data: crdt.data,\n          });\n          break;\n        case CrdtType.LIST:\n          ops.push({\n            type: OpCode.CREATE_LIST,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey,\n          });\n          break;\n        case CrdtType.OBJECT:\n          if (crdt.parentId === undefined || crdt.parentKey === undefined) {\n            throw new Error(\n              \"Internal error. Cannot serialize storage root into an operation\"\n            );\n          }\n          ops.push({\n            type: OpCode.CREATE_OBJECT,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey,\n            data: crdt.data,\n          });\n          break;\n        case CrdtType.MAP:\n          ops.push({\n            type: OpCode.CREATE_MAP,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey,\n          });\n          break;\n      }\n    }\n  });\n\n  return ops;\n}\n\nfunction mergeObjectStorageUpdates<A extends LsonObject, B extends LsonObject>(\n  first: LiveObjectUpdates<A>,\n  second: LiveObjectUpdates<B>\n): LiveObjectUpdates<B> {\n  const updates = first.updates as (typeof second)[\"updates\"];\n  for (const [key, value] of entries(second.updates)) {\n    updates[key] = value;\n  }\n  return {\n    ...second,\n    updates,\n  };\n}\n\nfunction mergeMapStorageUpdates<K2 extends string, V2 extends Lson>(\n  first: LiveMapUpdates<string, Lson>,\n  second: LiveMapUpdates<K2, V2>\n): LiveMapUpdates<K2, V2> {\n  const updates = first.updates;\n  for (const [key, value] of entries(second.updates)) {\n    updates[key] = value;\n  }\n  return {\n    ...second,\n    updates,\n  };\n}\n\nfunction mergeListStorageUpdates<T extends Lson>(\n  first: LiveListUpdates<Lson>,\n  second: LiveListUpdates<T>\n): LiveListUpdates<T> {\n  const updates = first.updates;\n  return {\n    ...second,\n    updates: updates.concat(second.updates),\n  };\n}\n\nexport function mergeStorageUpdates(\n  first: StorageUpdate | undefined,\n  second: StorageUpdate\n): StorageUpdate {\n  if (first === undefined) {\n    return second;\n  }\n\n  if (first.type === \"LiveObject\" && second.type === \"LiveObject\") {\n    return mergeObjectStorageUpdates(first, second);\n  } else if (first.type === \"LiveMap\" && second.type === \"LiveMap\") {\n    return mergeMapStorageUpdates(first, second);\n  } else if (first.type === \"LiveList\" && second.type === \"LiveList\") {\n    return mergeListStorageUpdates(first, second);\n  } else {\n    /* Mismatching merge types. Throw an error here? */\n  }\n\n  return second;\n}\n\nfunction isPlain(\n  value: unknown\n): value is\n  | undefined\n  | null\n  | string\n  | boolean\n  | number\n  | unknown[]\n  | { [key: string]: unknown } {\n  const type = typeof value;\n  return (\n    value === undefined ||\n    value === null ||\n    type === \"string\" ||\n    type === \"boolean\" ||\n    type === \"number\" ||\n    Array.isArray(value) ||\n    isPlainObject(value)\n  );\n}\n\nexport function findNonSerializableValue(\n  value: unknown,\n  path: string = \"\"\n): { path: string; value: unknown } | false {\n  if (!isPlain) {\n    return {\n      path: path || \"root\",\n      value,\n    };\n  }\n\n  if (typeof value !== \"object\" || value === null) {\n    return false;\n  }\n\n  for (const [key, nestedValue] of Object.entries(value)) {\n    const nestedPath = path ? path + \".\" + key : key;\n\n    if (!isPlain(nestedValue)) {\n      return {\n        path: nestedPath,\n        value: nestedValue,\n      };\n    }\n\n    if (typeof nestedValue === \"object\") {\n      const nonSerializableNestedValue = findNonSerializableValue(\n        nestedValue,\n        nestedPath\n      );\n\n      if (nonSerializableNestedValue) {\n        return nonSerializableNestedValue;\n      }\n    }\n  }\n\n  return false;\n}\n","import { raise } from \"./utils\";\n\n/**\n * A Deque (= Double Ended Queue) is like a stack, but where elements can be\n * efficiently pushed or popped from either side.\n *\n * The following calls are equivalent with arrays (but insertions are O(n)\n * instead of O(n^2)):\n *\n * - deque.push(1)              ⇔  array.push(1)\n * - deque.push([1, 2, 3])      ⇔  array.push(1, 2, 3)\n * - deque.push(many)           ⇔  array.push(...many)\n * - deque.pop()                ⇔  array.pop()\n *\n * - deque.pushLeft(1)          ⇔  array.unshift(1)\n * - deque.pushLeft([1, 2, 3])  ⇔  array.unshift(1, 2, 3)\n * - deque.pushLeft(many)       ⇔  array.unshift(...many)\n * - deque.popLeft()            ⇔  array.shift()\n *\n */\nexport class Deque<T> {\n  readonly #data: Record<number, T>;\n  #front: number;\n  #back: number;\n  #size: number;\n\n  constructor() {\n    this.#data = {};\n    this.#front = 0; // Inclusive\n    this.#back = 1; // Exclusive\n    this.#size = 0;\n  }\n\n  get length(): number {\n    return this.#size;\n  }\n\n  *[Symbol.iterator](): IterableIterator<T> {\n    const size = this.#size;\n    const front = this.#front;\n    for (let i = 0; i < size; i++) {\n      yield this.#data[front + i];\n    }\n  }\n\n  push(value: T | readonly T[]): void {\n    const values: readonly T[] = Array.isArray(value)\n      ? value\n      : ([value] as readonly T[]);\n    if (this.#back > Number.MAX_SAFE_INTEGER - values.length - 1)\n      raise(\"Deque full\");\n    for (const value of values) {\n      this.#data[this.#back++ - 1] = value;\n    }\n    this.#size += values.length;\n  }\n\n  pop(): T | undefined {\n    if (this.#size < 1) return undefined;\n\n    this.#back--;\n    const value = this.#data[this.#back - 1];\n    delete this.#data[this.#back - 1];\n    this.#size--;\n    return value;\n  }\n\n  pushLeft(value: T | readonly T[]): void {\n    const values: readonly T[] = Array.isArray(value)\n      ? value\n      : ([value] as readonly T[]);\n    if (this.#front < Number.MIN_SAFE_INTEGER + values.length)\n      raise(\"Deque full\");\n    for (let i = values.length - 1; i >= 0; i--) {\n      this.#data[--this.#front] = values[i];\n    }\n    this.#size += values.length;\n  }\n\n  popLeft(): T | undefined {\n    if (this.#size < 1) return undefined;\n\n    const value = this.#data[this.#front];\n    delete this.#data[this.#front];\n    this.#front++;\n    this.#size--;\n    return value;\n  }\n}\n","/**\n * Represents an indefinitely deep arbitrary JSON data structure. There are\n * four types that make up the Json family:\n *\n * - Json         any legal JSON value\n * - JsonScalar   any legal JSON leaf value (no lists or objects)\n * - JsonArray    a JSON value whose outer type is an array\n * - JsonObject   a JSON value whose outer type is an object\n *\n */\nexport type Json = JsonScalar | JsonArray | JsonObject;\nexport type JsonScalar = string | number | boolean | null;\nexport type JsonArray = Json[];\n/**\n * Any valid JSON object.\n */\nexport type JsonObject = { [key: string]: Json | undefined };\n\nexport function isJsonScalar(data: Json): data is JsonScalar {\n  return (\n    data === null ||\n    typeof data === \"string\" ||\n    typeof data === \"number\" ||\n    typeof data === \"boolean\"\n  );\n}\n\nexport function isJsonArray(data: Json): data is JsonArray {\n  return Array.isArray(data);\n}\n\nexport function isJsonObject(data: Json): data is JsonObject {\n  return !isJsonScalar(data) && !isJsonArray(data);\n}\n","interface StopWatch {\n  start: () => void;\n  lap: (now?: number) => void;\n  stop: () => { total: number; laps: number[] };\n}\n\nexport function makeStopWatch(): StopWatch {\n  let startTime = 0;\n  let lastLapTime = 0;\n  let laps: number[];\n\n  function start() {\n    laps = [];\n    startTime = performance.now();\n    lastLapTime = startTime;\n  }\n\n  function lap(now = performance.now()) {\n    laps.push(now - lastLapTime);\n    lastLapTime = now;\n  }\n\n  function stop(): { total: number; laps: number[] } {\n    const endTime = performance.now();\n    lap(endTime);\n    const total = endTime - startTime;\n    return { total, laps };\n  }\n\n  return { start, lap, stop };\n}\n","import type { Json, JsonObject } from \"../lib/Json\";\nimport type { ClientWireOp } from \"./Op\";\n\nexport type ClientMsgCode = (typeof ClientMsgCode)[keyof typeof ClientMsgCode];\nexport const ClientMsgCode = Object.freeze({\n  // For Presence\n  UPDATE_PRESENCE: 100,\n  BROADCAST_EVENT: 103,\n\n  // For Storage\n  FETCH_STORAGE: 200,\n  UPDATE_STORAGE: 201,\n\n  // For Yjs support\n  FETCH_YDOC: 300,\n  UPDATE_YDOC: 301,\n});\n\nexport namespace ClientMsgCode {\n  export type UPDATE_PRESENCE = typeof ClientMsgCode.UPDATE_PRESENCE;\n  export type BROADCAST_EVENT = typeof ClientMsgCode.BROADCAST_EVENT;\n  export type FETCH_STORAGE = typeof ClientMsgCode.FETCH_STORAGE;\n  export type UPDATE_STORAGE = typeof ClientMsgCode.UPDATE_STORAGE;\n  export type FETCH_YDOC = typeof ClientMsgCode.FETCH_YDOC;\n  export type UPDATE_YDOC = typeof ClientMsgCode.UPDATE_YDOC;\n}\n\n/**\n * Messages that can be sent from the client to the server.\n */\nexport type ClientMsg<P extends JsonObject, E extends Json> =\n  // For Presence\n  | BroadcastEventClientMsg<E>\n  | UpdatePresenceClientMsg<P>\n\n  // For Storage\n  | UpdateStorageClientMsg\n  | FetchStorageClientMsg\n\n  // For Yjs support\n  | FetchYDocClientMsg\n  | UpdateYDocClientMsg;\n\nexport type BroadcastEventClientMsg<E extends Json> = {\n  type: ClientMsgCode.BROADCAST_EVENT;\n  event: E;\n};\n\nexport type UpdatePresenceClientMsg<P extends JsonObject> =\n  //\n  // Full Presence™ message\n  //\n  | {\n      readonly type: ClientMsgCode.UPDATE_PRESENCE;\n      /**\n       * Set this to any number to signify that this is a Full Presence™\n       * update, not a patch.\n       *\n       * The numeric value itself no longer has specific meaning. Historically,\n       * this field was intended so that clients could ignore these broadcasted\n       * full presence messages, but it turned out that getting a full presence\n       * \"keyframe\" from time to time was useful.\n       *\n       * So nowadays, the presence (pun intended) of this `targetActor` field\n       * is a backward-compatible way of expressing that the `data` contains\n       * all presence fields, and isn't a partial \"patch\".\n       */\n      readonly targetActor: number;\n      readonly data: P;\n    }\n\n  //\n  // Partial Presence™ message\n  //\n  | {\n      readonly type: ClientMsgCode.UPDATE_PRESENCE;\n      /**\n       * Absence of the `targetActor` field signifies that this is a Partial\n       * Presence™ \"patch\".\n       */\n      readonly targetActor?: undefined;\n      readonly data: Partial<P>;\n    };\n\nexport type UpdateStorageClientMsg = {\n  readonly type: ClientMsgCode.UPDATE_STORAGE;\n  readonly ops: ClientWireOp[];\n};\n\nexport type FetchStorageClientMsg = {\n  readonly type: ClientMsgCode.FETCH_STORAGE;\n};\n\nexport type FetchYDocClientMsg = {\n  readonly type: ClientMsgCode.FETCH_YDOC;\n  readonly vector: string; // base64 encoded stateVector a from yjs doc\n  readonly guid?: string; // an optional guid to identify a subdoc\n  readonly v2?: boolean; // if it's a v2 update\n};\n\nexport type UpdateYDocClientMsg = {\n  readonly type: ClientMsgCode.UPDATE_YDOC;\n  readonly update: string; // base64 encoded update from a yjs doc\n  readonly guid?: string; // an optional guid to identify a subdoc\n  readonly v2?: boolean; // if it's a v2 update\n};\n","import { freeze } from \"../lib/freeze\";\nimport type { JsonObject } from \"../lib/Json\";\nimport { DerivedSignal, merge, MutableSignal } from \"../lib/signals\";\nimport { compact, compactObject } from \"../lib/utils\";\nimport { canComment, canWriteStorage } from \"../protocol/AuthToken\";\nimport type { BaseUserMeta } from \"../protocol/BaseUserMeta\";\nimport type { User } from \"../types/User\";\n\ntype Connection<U extends BaseUserMeta> = {\n  readonly connectionId: number;\n  readonly scopes: string[];\n  readonly id: U[\"id\"];\n  readonly info: U[\"info\"];\n};\n\nfunction makeUser<P extends JsonObject, U extends BaseUserMeta>(\n  conn: Connection<U>,\n  presence: P\n): User<P, U> {\n  const { connectionId, id, info } = conn;\n  const canWrite = canWriteStorage(conn.scopes);\n  return freeze(\n    compactObject({\n      connectionId,\n      id,\n      info,\n      canWrite,\n      canComment: canComment(conn.scopes),\n      isReadOnly: !canWrite, // Deprecated, kept for backward-compatibility\n      presence,\n    })\n  );\n}\n\nexport class ManagedOthers<P extends JsonObject, U extends BaseUserMeta> {\n  // Track mutable state internally, but signal to the outside when the\n  // observable derived state changes only\n  readonly #internal: MutableSignal<{\n    connections: Map</* connectionId */ number, Connection<U>>;\n    presences: Map</* connectionId */ number, P>;\n  }>;\n  readonly #userCache: Map</* connectionId */ number, User<P, U>>;\n\n  // The \"clean\" signal that is exposed to the outside world\n  public readonly signal: DerivedSignal<readonly User<P, U>[]>;\n\n  constructor() {\n    this.#internal = new MutableSignal({\n      connections: new Map</* connectionId */ number, Connection<U>>(),\n      presences: new Map</* connectionId */ number, P>(),\n    });\n\n    this.signal = DerivedSignal.from(\n      this.#internal,\n      (_ignore): readonly User<P, U>[] =>\n        compact(\n          Array.from(this.#internal.get().presences.keys()).map(\n            (connectionId) => this.getUser(Number(connectionId))\n          )\n        )\n    );\n\n    // Others\n    this.#userCache = new Map();\n  }\n\n  // Shorthand for .signal.get()\n  get(): readonly User<P, U>[] {\n    return this.signal.get();\n  }\n\n  public connectionIds(): IterableIterator<number> {\n    return this.#internal.get().connections.keys();\n  }\n\n  clearOthers(): void {\n    this.#internal.mutate((state) => {\n      state.connections.clear();\n      state.presences.clear();\n      this.#userCache.clear();\n    });\n  }\n\n  #_getUser(connectionId: number): User<P, U> | undefined {\n    const state = this.#internal.get();\n    const conn = state.connections.get(connectionId);\n    const presence = state.presences.get(connectionId);\n    if (conn !== undefined && presence !== undefined) {\n      return makeUser(conn, presence);\n    }\n    return undefined;\n  }\n\n  getUser(connectionId: number): User<P, U> | undefined {\n    const cachedUser = this.#userCache.get(connectionId);\n    if (cachedUser) {\n      return cachedUser;\n    }\n\n    const computedUser = this.#_getUser(connectionId);\n    if (computedUser) {\n      this.#userCache.set(connectionId, computedUser);\n      return computedUser;\n    }\n\n    return undefined;\n  }\n\n  #invalidateUser(connectionId: number): void {\n    this.#userCache.delete(connectionId);\n  }\n\n  /**\n   * Records a known connection. This records the connection ID and the\n   * associated metadata.\n   */\n  setConnection(\n    connectionId: number,\n    metaUserId: U[\"id\"],\n    metaUserInfo: U[\"info\"],\n    scopes: string[]\n  ): void {\n    this.#internal.mutate((state) => {\n      state.connections.set(\n        connectionId,\n        freeze({\n          connectionId,\n          id: metaUserId,\n          info: metaUserInfo,\n          scopes,\n        })\n      );\n      if (!state.presences.has(connectionId)) {\n        return false;\n      }\n      return this.#invalidateUser(connectionId);\n    });\n  }\n\n  /**\n   * Removes a known connectionId. Removes both the connection's metadata and\n   * the presence information.\n   */\n  removeConnection(connectionId: number): void {\n    this.#internal.mutate((state) => {\n      state.connections.delete(connectionId);\n      state.presences.delete(connectionId);\n      this.#invalidateUser(connectionId);\n    });\n  }\n\n  /**\n   * Stores a new user from a full presence update. If the user already exists,\n   * its known presence data is overwritten.\n   */\n  setOther(connectionId: number, presence: P): void {\n    this.#internal.mutate((state) => {\n      state.presences.set(connectionId, freeze(compactObject(presence)));\n      if (!state.connections.has(connectionId)) {\n        return false;\n      }\n      return this.#invalidateUser(connectionId);\n    });\n  }\n\n  /**\n   * Patches the presence data for an existing \"other\". If we don't know the\n   * initial presence data for this user yet, discard this patch and await the\n   * full .setOther() call first.\n   */\n  patchOther(connectionId: number, patch: Partial<P>): void {\n    this.#internal.mutate((state) => {\n      const oldPresence = state.presences.get(connectionId);\n      if (oldPresence === undefined) {\n        return false;\n      }\n\n      const newPresence = merge(oldPresence, patch);\n      if (oldPresence === newPresence) {\n        return false;\n      }\n\n      state.presences.set(connectionId, freeze(newPresence));\n      return this.#invalidateUser(connectionId);\n    });\n  }\n}\n","import { assertNever } from \"../lib/assert\";\nimport type { Relax } from \"../lib/Relax\";\nimport type { BaseMetadata, CommentBody } from \"../protocol/Comments\";\nimport type { Patchable } from \"./Patchable\";\n\n// All possible error originating from using Presence, Storage, or Yjs\n\ntype AiConnectionErrorContext = {\n  type: \"AI_CONNECTION_ERROR\";\n  code: -1 | 4001 | (number & {}); // eslint-disable-line @typescript-eslint/ban-types\n};\n\ntype RoomConnectionErrorContext = {\n  type: \"ROOM_CONNECTION_ERROR\";\n  code: -1 | 4001 | 4005 | 4006 | (number & {}); // eslint-disable-line @typescript-eslint/ban-types\n  roomId: string;\n};\n\ntype LargeMessageErrorContext = {\n  type: \"LARGE_MESSAGE_ERROR\";\n};\n\n// All possible errors originating from using Comments or Notifications\ntype CommentsOrNotificationsErrorContext =\n  | {\n      type: \"CREATE_THREAD_ERROR\";\n      roomId: string;\n      threadId: string;\n      commentId: string;\n      body: CommentBody;\n      metadata: BaseMetadata;\n      commentMetadata: BaseMetadata;\n    }\n  | {\n      type: \"DELETE_THREAD_ERROR\";\n      roomId: string;\n      threadId: string;\n    }\n  | {\n      type: \"EDIT_THREAD_METADATA_ERROR\";\n      roomId: string;\n      threadId: string;\n      metadata: Patchable<BaseMetadata>;\n    }\n  | {\n      type: \"EDIT_COMMENT_METADATA_ERROR\";\n      roomId: string;\n      threadId: string;\n      commentId: string;\n      metadata: Patchable<BaseMetadata>;\n    }\n  | {\n      type:\n        | \"MARK_THREAD_AS_RESOLVED_ERROR\"\n        | \"MARK_THREAD_AS_UNRESOLVED_ERROR\"\n        | \"SUBSCRIBE_TO_THREAD_ERROR\"\n        | \"UNSUBSCRIBE_FROM_THREAD_ERROR\";\n      roomId: string;\n      threadId: string;\n    }\n  | {\n      type: \"CREATE_COMMENT_ERROR\" | \"EDIT_COMMENT_ERROR\";\n      roomId: string;\n      threadId: string;\n      commentId: string;\n      body: CommentBody;\n      metadata: BaseMetadata;\n    }\n  | {\n      type: \"DELETE_COMMENT_ERROR\";\n      roomId: string;\n      threadId: string;\n      commentId: string;\n    }\n  | {\n      type: \"ADD_REACTION_ERROR\" | \"REMOVE_REACTION_ERROR\";\n      roomId: string;\n      threadId: string;\n      commentId: string;\n      emoji: string;\n    }\n  | {\n      type: \"MARK_INBOX_NOTIFICATION_AS_READ_ERROR\";\n      inboxNotificationId: string;\n      roomId?: string;\n    }\n  | {\n      type: \"DELETE_INBOX_NOTIFICATION_ERROR\";\n      inboxNotificationId: string;\n    }\n  | {\n      type:\n        | \"MARK_ALL_INBOX_NOTIFICATIONS_AS_READ_ERROR\"\n        | \"DELETE_ALL_INBOX_NOTIFICATIONS_ERROR\";\n    }\n  | {\n      type: \"UPDATE_ROOM_SUBSCRIPTION_SETTINGS_ERROR\";\n      roomId: string;\n    }\n  | {\n      type: \"UPDATE_NOTIFICATION_SETTINGS_ERROR\";\n    };\n\nexport type LiveblocksErrorContext = Relax<\n  | RoomConnectionErrorContext // from Presence, Storage, or Yjs\n  | CommentsOrNotificationsErrorContext // from Comments or Notifications or UserNotificationSettings\n  | AiConnectionErrorContext // from AI\n  | LargeMessageErrorContext // whena  message is too large\n>;\n\nexport class LiveblocksError extends Error {\n  public readonly context: LiveblocksErrorContext;\n\n  constructor(message: string, context: LiveblocksErrorContext, cause?: Error) {\n    super(message, { cause });\n    this.context = context;\n    this.name = \"LiveblocksError\";\n  }\n\n  /** Convenience accessor for error.context.roomId (if available) */\n  get roomId(): LiveblocksErrorContext[\"roomId\"] {\n    return this.context.roomId;\n  }\n\n  /** @internal Use `context.code` instead, to enable type narrowing */\n  get code(): LiveblocksErrorContext[\"code\"] {\n    return this.context.code;\n  }\n\n  /**\n   * Creates a LiveblocksError from a generic error, by attaching Liveblocks\n   * contextual information like room ID, thread ID, etc.\n   */\n  static from(context: LiveblocksErrorContext, cause?: Error): LiveblocksError {\n    return new LiveblocksError(\n      defaultMessageFromContext(context),\n      context,\n      cause\n    );\n  }\n}\n\n/**\n * Return a default, human-friendly error message for each possible error.\n */\nfunction defaultMessageFromContext(context: LiveblocksErrorContext): string {\n  // prettier-ignore\n  switch (context.type) {\n      case \"ROOM_CONNECTION_ERROR\": {\n        switch (context.code) {\n          case 4001: return \"Not allowed to connect to the room\";\n          case 4005: return \"Room is already full\";\n          case 4006: return \"Kicked out of the room, because the room ID changed\";\n          default:   return \"Could not connect to the room\";\n        }\n      }\n\n    case \"AI_CONNECTION_ERROR\": {\n      switch (context.code) {\n        case 4001: return \"Not allowed to connect to ai\";\n        default:   return \"Could not connect to the room\";\n      }\n    }\n\n    case \"CREATE_THREAD_ERROR\": return \"Could not create new thread\";\n    case \"DELETE_THREAD_ERROR\": return \"Could not delete thread\";\n    case \"EDIT_THREAD_METADATA_ERROR\": return \"Could not edit thread metadata\";\n    case \"EDIT_COMMENT_METADATA_ERROR\": return \"Could not edit comment metadata\";\n    case \"MARK_THREAD_AS_RESOLVED_ERROR\": return \"Could not mark thread as resolved\";\n    case \"MARK_THREAD_AS_UNRESOLVED_ERROR\": return \"Could not mark thread as unresolved\";\n    case \"SUBSCRIBE_TO_THREAD_ERROR\": return \"Could not subscribe to thread\";\n    case \"UNSUBSCRIBE_FROM_THREAD_ERROR\": return \"Could not unsubscribe from thread\";\n    case \"CREATE_COMMENT_ERROR\": return \"Could not create new comment\";\n    case \"EDIT_COMMENT_ERROR\": return \"Could not edit comment\";\n    case \"DELETE_COMMENT_ERROR\": return \"Could not delete comment\";\n    case \"ADD_REACTION_ERROR\": return \"Could not add reaction\";\n    case \"REMOVE_REACTION_ERROR\": return \"Could not remove reaction\";\n    case \"MARK_INBOX_NOTIFICATION_AS_READ_ERROR\": return \"Could not mark inbox notification as read\";\n    case \"DELETE_INBOX_NOTIFICATION_ERROR\": return \"Could not delete inbox notification\";\n    case \"MARK_ALL_INBOX_NOTIFICATIONS_AS_READ_ERROR\": return \"Could not mark all inbox notifications as read\";\n    case \"DELETE_ALL_INBOX_NOTIFICATIONS_ERROR\": return \"Could not delete all inbox notifications\";\n    case \"UPDATE_ROOM_SUBSCRIPTION_SETTINGS_ERROR\": return \"Could not update room subscription settings\";\n    case \"UPDATE_NOTIFICATION_SETTINGS_ERROR\": return \"Could not update notification settings\";\n    case \"LARGE_MESSAGE_ERROR\": return \"Could not send large message\";\n\n    default:\n      return assertNever(context, \"Unhandled case\");\n  }\n}\n","import { getBearerTokenFromAuthValue, type RoomHttpApi } from \"./api-client\";\nimport type { AuthManager, AuthValue } from \"./auth-manager\";\nimport { injectBrandBadge } from \"./brand\";\nimport type { InternalSyncStatus } from \"./client\";\nimport type { Delegates, LostConnectionEvent, Status } from \"./connection\";\nimport { ManagedSocket, StopRetrying } from \"./connection\";\nimport type { ApplyResult, ManagedPool } from \"./crdts/AbstractCrdt\";\nimport { createManagedPool, OpSource } from \"./crdts/AbstractCrdt\";\nimport {\n  cloneLson,\n  getTreesDiffOperations,\n  isLiveList,\n  isLiveNode,\n  isSameNodeOrChildOf,\n  mergeStorageUpdates,\n} from \"./crdts/liveblocks-helpers\";\nimport { LiveObject } from \"./crdts/LiveObject\";\nimport type { LiveStructure, LsonObject } from \"./crdts/Lson\";\nimport type { StorageCallback, StorageUpdate } from \"./crdts/StorageUpdates\";\nimport type { DCM, DE, DP, DS, DTM, DU } from \"./globals/augmentation\";\nimport { kInternal } from \"./internal\";\nimport { assertNever, nn } from \"./lib/assert\";\nimport type { BatchStore } from \"./lib/batch\";\nimport { Promise_withResolvers } from \"./lib/controlledPromise\";\nimport { createCommentAttachmentId } from \"./lib/createIds\";\nimport { Deque } from \"./lib/Deque\";\nimport type { Callback, EventSource, Observable } from \"./lib/EventSource\";\nimport { makeEventSource } from \"./lib/EventSource\";\nimport * as console from \"./lib/fancy-console\";\nimport type { Json, JsonObject } from \"./lib/Json\";\nimport { isJsonArray, isJsonObject } from \"./lib/Json\";\nimport { asPos } from \"./lib/position\";\nimport { DerivedSignal, PatchableSignal, Signal } from \"./lib/signals\";\nimport { makeStopWatch } from \"./lib/stopwatch\";\nimport { stringifyOrLog as stringify } from \"./lib/stringify\";\nimport {\n  compact,\n  deepClone,\n  memoizeOnSuccess,\n  partition,\n  tryParseJson,\n} from \"./lib/utils\";\nimport type {\n  ContextualPromptContext,\n  ContextualPromptResponse,\n} from \"./protocol/Ai\";\nimport type { Permission } from \"./protocol/AuthToken\";\nimport { canComment, canWriteStorage } from \"./protocol/AuthToken\";\nimport type { BaseUserMeta, IUserInfo } from \"./protocol/BaseUserMeta\";\nimport type { ClientMsg, UpdateYDocClientMsg } from \"./protocol/ClientMsg\";\nimport { ClientMsgCode } from \"./protocol/ClientMsg\";\nimport type {\n  BaseMetadata,\n  CommentAttachment,\n  CommentBody,\n  CommentData,\n  CommentLocalAttachment,\n  CommentUserReaction,\n  QueryMetadata,\n  ThreadData,\n  ThreadDeleteInfo,\n} from \"./protocol/Comments\";\nimport type {\n  InboxNotificationData,\n  InboxNotificationDeleteInfo,\n} from \"./protocol/InboxNotifications\";\nimport type { MentionData } from \"./protocol/MentionData\";\nimport type { ClientWireOp, Op, ServerWireOp } from \"./protocol/Op\";\nimport { isIgnoredOp, OpCode } from \"./protocol/Op\";\nimport type { RoomSubscriptionSettings } from \"./protocol/RoomSubscriptionSettings\";\nimport type {\n  CommentsEventServerMsg,\n  RoomStateServerMsg,\n  ServerMsg,\n  UpdatePresenceServerMsg,\n  UserJoinServerMsg,\n  UserLeftServerMsg,\n  YDocUpdateServerMsg,\n} from \"./protocol/ServerMsg\";\nimport { ServerMsgCode } from \"./protocol/ServerMsg\";\nimport type {\n  NodeMap,\n  NodeStream,\n  SerializedCrdt,\n} from \"./protocol/StorageNode\";\nimport { compactNodesToNodeStream } from \"./protocol/StorageNode\";\nimport type {\n  SubscriptionData,\n  SubscriptionDeleteInfo,\n} from \"./protocol/Subscriptions\";\nimport type { HistoryVersion } from \"./protocol/VersionHistory\";\nimport { ManagedOthers } from \"./refs/ManagedOthers\";\nimport type * as DevTools from \"./types/DevToolsTreeNode\";\nimport type {\n  IWebSocket,\n  IWebSocketCloseEvent,\n  IWebSocketInstance,\n  IWebSocketMessageEvent,\n} from \"./types/IWebSocket\";\nimport { LiveblocksError } from \"./types/LiveblocksError\";\nimport type {\n  BadgeLocation,\n  InternalOthersEvent,\n  OthersEvent,\n  TextEditorType,\n} from \"./types/Others\";\nimport type { Patchable } from \"./types/Patchable\";\nimport type { User } from \"./types/User\";\nimport { PKG_VERSION } from \"./version\";\n\nexport type TimeoutID = ReturnType<typeof setTimeout>;\n\n//\n// NOTE:\n// This type looks an awful lot like InternalOthersEvent, but don't change this\n// type definition or DRY this up!\n// The type LegacyOthersEvent is used in the signature of some public APIs, and\n// as such should remain backward compatible.\n//\ntype LegacyOthersEvent<P extends JsonObject, U extends BaseUserMeta> =\n  | { type: \"leave\"; user: User<P, U> }\n  | { type: \"enter\"; user: User<P, U> }\n  | {\n      type: \"update\";\n      user: User<P, U>;\n      updates: Partial<P>;\n    }\n  | { type: \"reset\" };\n\ntype LegacyOthersEventCallback<P extends JsonObject, U extends BaseUserMeta> = (\n  others: readonly User<P, U>[],\n  event: LegacyOthersEvent<P, U>\n) => void;\n\nexport type RoomEventMessage<\n  P extends JsonObject,\n  U extends BaseUserMeta,\n  E extends Json,\n> = {\n  /**\n   * The connection ID of the client that sent the event.\n   * If this message was broadcast from the server (via the REST API), then\n   * this value will be -1.\n   */\n  connectionId: number;\n  /**\n   * The User (from the others list) that sent the event.\n   * If this message was broadcast from the server (via the REST API), then\n   * this value will be null.\n   */\n  user: User<P, U> | null;\n  event: E;\n};\n\nexport type SyncStatus =\n  /* Liveblocks is in the process of writing changes */\n  | \"synchronizing\"\n  /* Liveblocks has persisted all pending changes */\n  | \"synchronized\";\n\nexport type StorageStatus =\n  /* The storage is not loaded and has not been requested. */\n  | \"not-loaded\"\n  /* The storage is loading from Liveblocks servers */\n  | \"loading\"\n  /* Some storage modifications has not been acknowledged yet by the server */\n  | \"synchronizing\"\n  /* The storage is sync with Liveblocks servers */\n  | \"synchronized\";\n\ntype RoomEventCallbackMap<\n  P extends JsonObject,\n  U extends BaseUserMeta,\n  E extends Json,\n> = {\n  status: Callback<Status>; // New/recommended API\n  \"lost-connection\": Callback<LostConnectionEvent>;\n  event: Callback<RoomEventMessage<P, U, E>>;\n  \"my-presence\": Callback<P>;\n  //\n  // NOTE: LegacyOthersEventCallback is the only one not taking a Callback<T>\n  // shape, since this API historically has taken _two_ callback arguments\n  // instead of just one.\n  others: LegacyOthersEventCallback<P, U>;\n  error: Callback<Error>;\n  history: Callback<HistoryEvent>;\n  \"storage-status\": Callback<StorageStatus>;\n  comments: Callback<CommentsEventServerMsg>;\n};\n\nexport interface History {\n  /**\n   * Undoes the last operation executed by the current client.\n   * It does not impact operations made by other clients.\n   *\n   * @example\n   * room.updatePresence({ selectedId: \"xx\" }, { addToHistory: true });\n   * room.updatePresence({ selectedId: \"yy\" }, { addToHistory: true });\n   * room.history.undo();\n   * // room.getPresence() equals { selectedId: \"xx\" }\n   */\n  undo: () => void;\n\n  /**\n   * Redoes the last operation executed by the current client.\n   * It does not impact operations made by other clients.\n   *\n   * @example\n   * room.updatePresence({ selectedId: \"xx\" }, { addToHistory: true });\n   * room.updatePresence({ selectedId: \"yy\" }, { addToHistory: true });\n   * room.history.undo();\n   * // room.getPresence() equals { selectedId: \"xx\" }\n   * room.history.redo();\n   * // room.getPresence() equals { selectedId: \"yy\" }\n   */\n  redo: () => void;\n\n  /**\n   * Returns whether there are any operations to undo.\n   *\n   * @example\n   * room.updatePresence({ selectedId: \"xx\" }, { addToHistory: true });\n   * // room.history.canUndo() is true\n   * room.history.undo();\n   * // room.history.canUndo() is false\n   */\n  canUndo: () => boolean;\n\n  /**\n   * Returns whether there are any operations to redo.\n   *\n   * @example\n   * room.updatePresence({ selectedId: \"xx\" }, { addToHistory: true });\n   * room.history.undo();\n   * // room.history.canRedo() is true\n   * room.history.redo();\n   * // room.history.canRedo() is false\n   */\n  canRedo: () => boolean;\n\n  /**\n   * Clears the undo and redo stacks. This operation cannot be undone ;)\n   */\n  clear: () => void;\n\n  /**\n   * All future modifications made on the Room will be merged together to create a single history item until resume is called.\n   *\n   * @example\n   * room.updatePresence({ cursor: { x: 0, y: 0 } }, { addToHistory: true });\n   * room.history.pause();\n   * room.updatePresence({ cursor: { x: 1, y: 1 } }, { addToHistory: true });\n   * room.updatePresence({ cursor: { x: 2, y: 2 } }, { addToHistory: true });\n   * room.history.resume();\n   * room.history.undo();\n   * // room.getPresence() equals { cursor: { x: 0, y: 0 } }\n   */\n  pause: () => void;\n\n  /**\n   * Resumes history. Modifications made on the Room are not merged into a single history item anymore.\n   *\n   * @example\n   * room.updatePresence({ cursor: { x: 0, y: 0 } }, { addToHistory: true });\n   * room.history.pause();\n   * room.updatePresence({ cursor: { x: 1, y: 1 } }, { addToHistory: true });\n   * room.updatePresence({ cursor: { x: 2, y: 2 } }, { addToHistory: true });\n   * room.history.resume();\n   * room.history.undo();\n   * // room.getPresence() equals { cursor: { x: 0, y: 0 } }\n   */\n  resume: () => void;\n}\n\nexport type HistoryEvent = {\n  canUndo: boolean;\n  canRedo: boolean;\n};\n\nexport type RoomEventName = Extract<\n  keyof RoomEventCallbackMap<never, never, never>,\n  string\n>;\n\nexport type RoomEventCallbackFor<\n  K extends RoomEventName,\n  P extends JsonObject,\n  U extends BaseUserMeta,\n  E extends Json,\n> = RoomEventCallbackMap<P, U, E>[K];\n\nexport type RoomEventCallback = RoomEventCallbackFor<\n  RoomEventName,\n  JsonObject,\n  BaseUserMeta,\n  Json\n>;\n\nexport type BroadcastOptions = {\n  /**\n   * Whether or not event is queued if the connection is currently closed.\n   *\n   * ❗ We are not sure if we want to support this option in the future so it might be deprecated to be replaced by something else\n   */\n  shouldQueueEventIfNotReady: boolean;\n};\n\ntype SubscribeFn<\n  P extends JsonObject,\n  _TStorage extends LsonObject,\n  U extends BaseUserMeta,\n  E extends Json,\n> = {\n  /**\n   * Subscribes to changes made on any Live structure. Returns an unsubscribe function.\n   *\n   * @internal This legacy API works, but was never documented publicly.\n   */\n  (callback: StorageCallback): () => void;\n\n  /**\n   * Subscribe to the current user presence updates.\n   *\n   * @param listener the callback that is called every time the current user presence is updated with {@link Room.updatePresence}.\n   *\n   * @returns Unsubscribe function.\n   *\n   * @example\n   * room.subscribe(\"my-presence\", (presence) => {\n   *   // Do something\n   * });\n   */\n  (type: \"my-presence\", listener: Callback<P>): () => void;\n\n  /**\n   * Subscribe to the other users updates.\n   *\n   * @param listener the callback that is called when a user enters or leaves the room or when a user update its presence.\n   *\n   * @returns Unsubscribe function.\n   *\n   * @example\n   * room.subscribe(\"others\", (others) => {\n   *   // Do something\n   * });\n   *\n   */\n  (type: \"others\", listener: LegacyOthersEventCallback<P, U>): () => void;\n\n  /**\n   * Subscribe to events broadcasted by {@link Room.broadcastEvent}\n   *\n   * @param listener the callback that is called when a user calls {@link Room.broadcastEvent}\n   *\n   * @returns Unsubscribe function.\n   *\n   * @example\n   * room.subscribe(\"event\", ({ event, connectionId }) => {\n   *   // Do something\n   * });\n   *\n   */\n  (type: \"event\", listener: Callback<RoomEventMessage<P, U, E>>): () => void;\n\n  /**\n   * Subscribe to errors thrown in the room.\n   *\n   * @returns Unsubscribe function.\n   *\n   */\n  (type: \"error\", listener: Callback<LiveblocksError>): () => void;\n\n  /**\n   * Subscribe to connection status updates. The callback will be called any\n   * time the status changes.\n   *\n   * @returns Unsubscribe function.\n   *\n   */\n  (type: \"status\", listener: Callback<Status>): () => void;\n\n  /**\n   * Subscribe to the exceptional event where reconnecting to the Liveblocks\n   * servers is taking longer than usual. This typically is a sign of a client\n   * that has lost internet connectivity.\n   *\n   * This isn't problematic (because the Liveblocks client is still trying to\n   * reconnect), but it's typically a good idea to inform users about it if\n   * the connection takes too long to recover.\n   */\n  (\n    type: \"lost-connection\",\n    listener: Callback<LostConnectionEvent>\n  ): () => void;\n\n  /**\n   * Subscribes to changes made on a Live structure. Returns an unsubscribe function.\n   *\n   * @param callback The callback this called when the Live structure changes.\n   *\n   * @returns Unsubscribe function.\n   *\n   * @example\n   * const liveMap = new LiveMap();  // Could also be LiveList or LiveObject\n   * const unsubscribe = room.subscribe(liveMap, (liveMap) => { });\n   * unsubscribe();\n   */\n  <L extends LiveStructure>(\n    liveStructure: L,\n    callback: (node: L) => void\n  ): () => void;\n\n  /**\n   * Subscribes to changes made on a Live structure and all the nested data\n   * structures. Returns an unsubscribe function. In a future version, we\n   * will also expose what exactly changed in the Live structure.\n   *\n   * @param callback The callback this called when the Live structure, or any\n   * of its nested values, changes.\n   *\n   * @returns Unsubscribe function.\n   *\n   * @example\n   * const liveMap = new LiveMap();  // Could also be LiveList or LiveObject\n   * const unsubscribe = room.subscribe(liveMap, (updates) => { }, { isDeep: true });\n   * unsubscribe();\n   */\n  <L extends LiveStructure>(\n    liveStructure: L,\n    callback: StorageCallback,\n    options: { isDeep: true }\n  ): () => void;\n\n  /**\n   * Subscribe to the current user's history changes.\n   *\n   * @returns Unsubscribe function.\n   *\n   * @example\n   * room.subscribe(\"history\", ({ canUndo, canRedo }) => {\n   *   // Do something\n   * });\n   */\n  (type: \"history\", listener: Callback<HistoryEvent>): () => void;\n\n  /**\n   * Subscribe to storage status changes.\n   *\n   * @returns Unsubscribe function.\n   *\n   * @example\n   * room.subscribe(\"storage-status\", (status) => {\n   *   switch(status) {\n   *      case \"not-loaded\":\n   *        break;\n   *      case \"loading\":\n   *        break;\n   *      case \"synchronizing\":\n   *        break;\n   *      case \"synchronized\":\n   *        break;\n   *      default:\n   *        break;\n   *   }\n   * });\n   */\n  (type: \"storage-status\", listener: Callback<StorageStatus>): () => void;\n\n  (type: \"comments\", listener: Callback<CommentsEventServerMsg>): () => void;\n};\n\nexport type GetThreadsOptions<TM extends BaseMetadata> = {\n  cursor?: string;\n  query?: {\n    resolved?: boolean;\n    subscribed?: boolean;\n    metadata?: Partial<QueryMetadata<TM>>;\n  };\n};\n\nexport type GetThreadsSinceOptions = {\n  since: Date;\n  signal?: AbortSignal;\n};\n\nexport type UploadAttachmentOptions = {\n  signal?: AbortSignal;\n};\n\ntype ListTextVersionsSinceOptions = {\n  since: Date;\n  signal?: AbortSignal;\n};\n\ntype GetSubscriptionSettingsOptions = {\n  signal?: AbortSignal;\n};\n\n/**\n * @private Widest-possible Room type, matching _any_ Room instance. Note that\n * this type is different from `Room`-without-type-arguments. That represents\n * a Room instance using globally augmented types only, which is narrower.\n */\nexport type OpaqueRoom = Room<\n  JsonObject,\n  LsonObject,\n  BaseUserMeta,\n  Json,\n  BaseMetadata\n>;\n\nexport type Room<\n  P extends JsonObject = DP,\n  S extends LsonObject = DS,\n  U extends BaseUserMeta = DU,\n  E extends Json = DE,\n  TM extends BaseMetadata = DTM,\n  CM extends BaseMetadata = DCM,\n> = {\n  /**\n   * @private\n   *\n   * Private methods and variables used in the core internals, but as a user\n   * of Liveblocks, NEVER USE ANY OF THESE DIRECTLY, because bad things\n   * will probably happen if you do.\n   */\n  readonly [kInternal]: PrivateRoomApi;\n\n  /**\n   * The id of the room.\n   */\n  readonly id: string;\n\n  /**\n   * Return the current connection status for this room. Can be used to display\n   * a status badge for your Liveblocks connection.\n   */\n  getStatus(): Status;\n  readonly subscribe: SubscribeFn<P, S, U, E>;\n\n  /**\n   * Room's history contains functions that let you undo and redo operation made on by the current client on the presence and storage.\n   */\n  readonly history: History;\n\n  /**\n   * Gets the current user.\n   * Returns null if not it is not yet connected to the room.\n   *\n   * @example\n   * const user = room.getSelf();\n   */\n  getSelf(): User<P, U> | null;\n\n  /**\n   * Gets the presence of the current user.\n   *\n   * @example\n   * const presence = room.getPresence();\n   */\n  getPresence(): P;\n\n  /**\n   * Gets all the other users in the room.\n   *\n   * @example\n   * const others = room.getOthers();\n   */\n  getOthers(): readonly User<P, U>[];\n\n  /**\n   * Updates the presence of the current user. Only pass the properties you want to update. No need to send the full presence.\n   * @param patch A partial object that contains the properties you want to update.\n   * @param options Optional object to configure the behavior of updatePresence.\n   *\n   * @example\n   * room.updatePresence({ x: 0 });\n   * room.updatePresence({ y: 0 });\n   *\n   * const presence = room.getPresence();\n   * // presence is equivalent to { x: 0, y: 0 }\n   */\n  updatePresence(\n    patch: Partial<P>,\n    options?: {\n      /**\n       * Whether or not the presence should have an impact on the undo/redo history.\n       */\n      addToHistory: boolean;\n    }\n  ): void;\n\n  /**\n   * Sends Yjs document updates to Liveblocks server.\n   *\n   * @param {string} data the doc update to send to the server, base64 encoded uint8array\n   */\n  updateYDoc(data: string, guid?: string, isV2?: boolean): void;\n\n  /**\n   * Sends a request for the current document from liveblocks server\n   */\n  fetchYDoc(stateVector: string, guid?: string, isV2?: boolean): void;\n\n  /**\n   * Broadcasts an event to other users in the room. Event broadcasted to the room can be listened with {@link Room.subscribe}(\"event\").\n   * @param {any} event the event to broadcast. Should be serializable to JSON\n   *\n   * @example\n   * // On client A\n   * room.broadcastEvent({ type: \"EMOJI\", emoji: \"🔥\" });\n   *\n   * // On client B\n   * room.subscribe(\"event\", ({ event }) => {\n   *   if(event.type === \"EMOJI\") {\n   *     // Do something\n   *   }\n   * });\n   */\n  broadcastEvent(event: E, options?: BroadcastOptions): void;\n\n  /**\n   * Get the room's storage asynchronously.\n   * The storage's root is a {@link LiveObject}.\n   *\n   * @example\n   * const { root } = await room.getStorage();\n   */\n  getStorage(): Promise<{\n    root: LiveObject<S>;\n  }>;\n\n  /**\n   * Get the room's storage synchronously.\n   * The storage's root is a {@link LiveObject}.\n   *\n   * @example\n   * const root = room.getStorageSnapshot();\n   */\n  getStorageSnapshot(): LiveObject<S> | null;\n\n  /**\n   * All possible room events, subscribable from a single place.\n   *\n   * @private These event sources are private for now, but will become public\n   * once they're stable.\n   */\n  readonly events: {\n    readonly status: Observable<Status>;\n    readonly lostConnection: Observable<LostConnectionEvent>;\n\n    readonly customEvent: Observable<RoomEventMessage<P, U, E>>; // prettier-ignore\n    readonly self: Observable<User<P, U>>;\n    readonly myPresence: Observable<P>;\n    readonly others: Observable<OthersEvent<P, U>>;\n    readonly storageBatch: Observable<StorageUpdate[]>;\n    readonly history: Observable<HistoryEvent>;\n\n    /**\n     * Subscribe to the storage loaded event. Will fire any time a full Storage\n     * copy is downloaded. (This happens after the initial connect, and on\n     * every reconnect.)\n     */\n    readonly storageDidLoad: Observable<void>;\n\n    readonly storageStatus: Observable<StorageStatus>;\n    readonly ydoc: Observable<YDocUpdateServerMsg | UpdateYDocClientMsg>;\n    readonly comments: Observable<CommentsEventServerMsg>;\n\n    /**\n     * Called right before the room is destroyed. The event cannot be used to\n     * prevent the room from being destroyed, only to be informed that this is\n     * imminent.\n     */\n    readonly roomWillDestroy: Observable<void>;\n  };\n\n  /**\n   * Batches modifications made during the given function.\n   * All the modifications are sent to other clients in a single message.\n   * All the subscribers are called only after the batch is over.\n   * All the modifications are merged in a single history item (undo/redo).\n   *\n   * @example\n   * const { root } = await room.getStorage();\n   * room.batch(() => {\n   *   root.set(\"x\", 0);\n   *   room.updatePresence({ cursor: { x: 100, y: 100 }});\n   * });\n   */\n  batch<T>(fn: () => T): T;\n\n  /**\n   * Get the storage status.\n   *\n   * - `not-loaded`: Initial state when entering the room.\n   * - `loading`: Once the storage has been requested via room.getStorage().\n   * - `synchronizing`: When some local updates have not been acknowledged by Liveblocks servers.\n   * - `synchronized`: Storage is in sync with Liveblocks servers.\n   */\n  getStorageStatus(): StorageStatus;\n\n  isPresenceReady(): boolean;\n  isStorageReady(): boolean;\n\n  /**\n   * Returns a Promise that resolves as soon as Presence is available, which\n   * happens shortly after the WebSocket connection has been established. Once\n   * this happens, `self` and `others` are known and available to use. After\n   * awaiting this promise, `.isPresenceReady()` will be guaranteed to be true.\n   * Even when calling this function multiple times, it's guaranteed to return\n   * the same Promise instance.\n   */\n  waitUntilPresenceReady(): Promise<void>;\n\n  /**\n   * Returns a Promise that resolves as soon as Storage has been loaded and\n   * available. After awaiting this promise, `.isStorageReady()` will be\n   * guaranteed to be true. Even when calling this function multiple times,\n   * it's guaranteed to return the same Promise instance.\n   */\n  waitUntilStorageReady(): Promise<void>;\n\n  /**\n   * Start an attempt to connect the room (aka \"enter\" it). Calling\n   * `.connect()` only has an effect if the room is still in its idle initial\n   * state, or the room was explicitly disconnected, or reconnection attempts\n   * were stopped (for example, because the user isn't authorized to enter the\n   * room). Will be a no-op otherwise.\n   */\n  connect(): void;\n\n  /**\n   * Disconnect the room's connection to the Liveblocks server, if any. Puts\n   * the room back into an idle state. It will not do anything until either\n   * `.connect()` or `.reconnect()` is called.\n   *\n   * Only use this API if you wish to connect the room again at a later time.\n   * If you want to disconnect the room because you no longer need it, call\n   * `.destroy()` instead.\n   */\n  disconnect(): void;\n\n  /**\n   * @internal (for now)\n   *\n   * Disconnect the room's connection to the Liveblocks server, if any. Runs\n   * cleanup functions. The room instance can no longer be used to (re)connect.\n   */\n  destroy(): void;\n\n  /**\n   * Reconnect the room to the Liveblocks server by re-establishing a fresh\n   * connection. If the room is not connected yet, initiate it.\n   */\n  reconnect(): void;\n\n  /**\n   * Returns the threads within the current room and their associated inbox notifications.\n   * It also returns the request date that can be used for subsequent polling.\n   *\n   * @example\n   * const {\n   *   threads,\n   *   inboxNotifications,\n   *   subscriptions,\n   *   requestedAt\n   * } = await room.getThreads({ query: { resolved: false }});\n   */\n  getThreads(options?: GetThreadsOptions<TM>): Promise<{\n    threads: ThreadData<TM, CM>[];\n    inboxNotifications: InboxNotificationData[];\n    subscriptions: SubscriptionData[];\n    requestedAt: Date;\n    nextCursor: string | null;\n    permissionHints: Record<string, Permission[]>;\n  }>;\n\n  /**\n   * Returns the updated and deleted threads and their associated inbox notifications and subscriptions since the requested date.\n   *\n   * @example\n   * const result = await room.getThreads();\n   * // ... //\n   * await room.getThreadsSince({ since: result.requestedAt });\n   */\n  getThreadsSince(options: GetThreadsSinceOptions): Promise<{\n    threads: {\n      updated: ThreadData<TM, CM>[];\n      deleted: ThreadDeleteInfo[];\n    };\n    inboxNotifications: {\n      updated: InboxNotificationData[];\n      deleted: InboxNotificationDeleteInfo[];\n    };\n    subscriptions: {\n      updated: SubscriptionData[];\n      deleted: SubscriptionDeleteInfo[];\n    };\n    requestedAt: Date;\n    permissionHints: Record<string, Permission[]>;\n  }>;\n\n  /**\n   * Returns a thread and the associated inbox notification and subscription if it exists.\n   *\n   * @example\n   * const { thread, inboxNotification, subscription } = await room.getThread(\"th_xxx\");\n   */\n  getThread(threadId: string): Promise<{\n    thread?: ThreadData<TM, CM>;\n    inboxNotification?: InboxNotificationData;\n    subscription?: SubscriptionData;\n  }>;\n\n  /**\n   * Creates a thread.\n   *\n   * @example\n   * const thread = await room.createThread({\n   *   body: {\n   *     version: 1,\n   *     content: [{ type: \"paragraph\", children: [{ text: \"Hello\" }] }],\n   *   },\n   * })\n   */\n  createThread(options: {\n    threadId?: string;\n    commentId?: string;\n    metadata: TM | undefined;\n    body: CommentBody;\n    commentMetadata?: CM;\n    attachmentIds?: string[];\n  }): Promise<ThreadData<TM, CM>>;\n\n  /**\n   * Deletes a thread.\n   *\n   * @example\n   * await room.deleteThread(\"th_xxx\");\n   */\n  deleteThread(threadId: string): Promise<void>;\n\n  /**\n   * Edits a thread's metadata.\n   * To delete an existing metadata property, set its value to `null`.\n   *\n   * @example\n   * await room.editThreadMetadata({ threadId: \"th_xxx\", metadata: { x: 100, y: 100 } })\n   */\n  editThreadMetadata(options: {\n    metadata: Patchable<TM>;\n    threadId: string;\n  }): Promise<TM>;\n\n  /**\n   * Edits a comment's metadata.\n   * To delete an existing metadata property, set its value to `null`.\n   *\n   * @example\n   * await room.editCommentMetadata({ threadId: \"th_xxx\", commentId: \"cm_xxx\", metadata: { tag: \"important\", externalId: 1234 } })\n   */\n  editCommentMetadata(options: {\n    threadId: string;\n    commentId: string;\n    metadata: Patchable<CM>;\n  }): Promise<CM>;\n\n  /**\n   * Marks a thread as resolved.\n   *\n   * @example\n   * await room.markThreadAsResolved(\"th_xxx\");\n   */\n  markThreadAsResolved(threadId: string): Promise<void>;\n\n  /**\n   * Marks a thread as unresolved.\n   *\n   * @example\n   * await room.markThreadAsUnresolved(\"th_xxx\");\n   */\n  markThreadAsUnresolved(threadId: string): Promise<void>;\n\n  /**\n   * Subscribes the user to a thread.\n   *\n   * @example\n   * await room.subscribeToThread(\"th_xxx\");\n   */\n  subscribeToThread(threadId: string): Promise<SubscriptionData>;\n\n  /**\n   * Unsubscribes the user from a thread.\n   *\n   * @example\n   * await room.unsubscribeFromThread(\"th_xxx\");\n   */\n  unsubscribeFromThread(threadId: string): Promise<void>;\n\n  /**\n   * Creates a comment.\n   *\n   * @example\n   * await room.createComment({\n   *   threadId: \"th_xxx\",\n   *   body: {\n   *     version: 1,\n   *     content: [{ type: \"paragraph\", children: [{ text: \"Hello\" }] }],\n   *   },\n   * });\n   */\n  createComment(options: {\n    threadId: string;\n    commentId?: string;\n    body: CommentBody;\n    metadata?: CM;\n    attachmentIds?: string[];\n  }): Promise<CommentData<CM>>;\n\n  /**\n   * Edits a comment.\n   *\n   * @example\n   * await room.editComment({\n   *   threadId: \"th_xxx\",\n   *   commentId: \"cm_xxx\"\n   *   body: {\n   *     version: 1,\n   *     content: [{ type: \"paragraph\", children: [{ text: \"Hello\" }] }],\n   *   },\n   * });\n   */\n  editComment(options: {\n    threadId: string;\n    commentId: string;\n    body: CommentBody;\n    metadata?: Patchable<CM>;\n    attachmentIds?: string[];\n  }): Promise<CommentData<CM>>;\n\n  /**\n   * Deletes a comment.\n   * If it is the last non-deleted comment, the thread also gets deleted.\n   *\n   * @example\n   * await room.deleteComment({\n   *   threadId: \"th_xxx\",\n   *   commentId: \"cm_xxx\"\n   * });\n   */\n  deleteComment(options: {\n    threadId: string;\n    commentId: string;\n  }): Promise<void>;\n\n  /**\n   * Adds a reaction from a comment for the current user.\n   *\n   * @example\n   * await room.addReaction({ threadId: \"th_xxx\", commentId: \"cm_xxx\", emoji: \"👍\" })\n   */\n  addReaction(options: {\n    threadId: string;\n    commentId: string;\n    emoji: string;\n  }): Promise<CommentUserReaction>;\n\n  /**\n   * Removes a reaction from a comment.\n   *\n   * @example\n   * await room.removeReaction({ threadId: \"th_xxx\", commentId: \"cm_xxx\", emoji: \"👍\" })\n   */\n  removeReaction(options: {\n    threadId: string;\n    commentId: string;\n    emoji: string;\n  }): Promise<void>;\n\n  /**\n   * Creates a local attachment from a file.\n   *\n   * @example\n   * room.prepareAttachment(file);\n   */\n  prepareAttachment(file: File): CommentLocalAttachment;\n\n  /**\n   * Uploads a local attachment.\n   *\n   * @example\n   * const attachment = room.prepareAttachment(file);\n   * await room.uploadAttachment(attachment);\n   */\n  uploadAttachment(\n    attachment: CommentLocalAttachment,\n    options?: UploadAttachmentOptions\n  ): Promise<CommentAttachment>;\n\n  /**\n   * Returns a presigned URL for an attachment by its ID.\n   *\n   * @example\n   * await room.getAttachmentUrl(\"at_xxx\");\n   */\n  getAttachmentUrl(attachmentId: string): Promise<string>;\n\n  /**\n   * Gets the user's subscription settings for the current room.\n   *\n   * @example\n   * const settings = await room.getSubscriptionSettings();\n   */\n  getSubscriptionSettings(\n    options?: GetSubscriptionSettingsOptions\n  ): Promise<RoomSubscriptionSettings>;\n\n  /**\n   * Updates the user's subscription settings for the current room.\n   *\n   * @example\n   * await room.updateSubscriptionSettings({ threads: \"replies_and_mentions\" });\n   */\n  updateSubscriptionSettings(\n    settings: Partial<RoomSubscriptionSettings>\n  ): Promise<RoomSubscriptionSettings>;\n\n  /**\n   * @private\n   *\n   * Internal use only. Signature might change in the future.\n   */\n  markInboxNotificationAsRead(notificationId: string): Promise<void>;\n};\n\nexport type YjsSyncStatus = \"loading\" | \"synchronizing\" | \"synchronized\";\n\n/**\n * Interface that @liveblocks/yjs must respect.\n * This interface type is declare in @liveblocks/core, so we don't have to\n * depend on `yjs`. It's only used to determine the API contract between\n * @liveblocks/core and @liveblocks/yjs.\n */\nexport interface IYjsProvider {\n  synced: boolean;\n  getStatus: () => YjsSyncStatus;\n  on(event: \"sync\", listener: (synced: boolean) => void): void;\n  on(event: \"status\", listener: (status: YjsSyncStatus) => void): void;\n  off(event: \"sync\", listener: (synced: boolean) => void): void;\n  off(event: \"status\", listener: (status: YjsSyncStatus) => void): void;\n}\n\n/**\n * A \"Sync Source\" can be a Storage document, a Yjs document, Comments,\n * Notifications, etc.\n * The Client keeps a registry of all active sync sources, and will use it to\n * determine the global \"sync status\" for Liveblocks.\n */\nexport interface SyncSource {\n  setSyncStatus(status: InternalSyncStatus): void;\n  destroy(): void;\n}\n\n/**\n * @private\n *\n * Private methods to directly control the underlying state machine for this\n * room. Used in the core internals and for unit testing, but as a user of\n * Liveblocks, NEVER USE ANY OF THESE METHODS DIRECTLY, because bad things\n * will probably happen if you do.\n */\nexport type PrivateRoomApi = {\n  // For introspection in unit tests only\n  presenceBuffer: Json | undefined;\n  undoStack: readonly (readonly Readonly<Stackframe<JsonObject>>[])[];\n  nodeCount: number;\n\n  // Get/set the associated Yjs provider on this room\n  getYjsProvider(): IYjsProvider | undefined;\n  setYjsProvider(provider: IYjsProvider | undefined): void;\n  yjsProviderDidChange: Observable<void>;\n\n  // For DevTools support (Liveblocks browser extension)\n  getSelf_forDevTools(): DevTools.UserTreeNode | null;\n  getOthers_forDevTools(): readonly DevTools.UserTreeNode[];\n\n  // For reporting editor metadata\n  reportTextEditor(editor: TextEditorType, rootKey: string): Promise<void>;\n\n  createTextMention(mentionId: string, mention: MentionData): Promise<void>;\n  deleteTextMention(mentionId: string): Promise<void>;\n  listTextVersions(): Promise<{\n    versions: HistoryVersion[];\n    requestedAt: Date;\n  }>;\n  listTextVersionsSince(options: ListTextVersionsSinceOptions): Promise<{\n    versions: HistoryVersion[];\n    requestedAt: Date;\n  }>;\n\n  getTextVersion(versionId: string): Promise<Response>;\n  createTextVersion(): Promise<void>;\n\n  executeContextualPrompt(options: {\n    prompt: string;\n    context: ContextualPromptContext;\n    previous?: {\n      prompt: string;\n      response: ContextualPromptResponse;\n    };\n    signal: AbortSignal;\n  }): Promise<string>;\n\n  // NOTE: These are only used in our e2e test app!\n  simulate: {\n    explicitClose(event: IWebSocketCloseEvent): void;\n    rawSend(data: string): void;\n  };\n\n  attachmentUrlsStore: BatchStore<string, string>;\n};\n\nfunction makeIdFactory(connectionId: number): IdFactory {\n  let count = 0;\n  return () => `${connectionId}:${count++}`;\n}\n\ntype Stackframe<P extends JsonObject> = Op | PresenceStackframe<P>;\n\ntype PresenceStackframe<P extends JsonObject> = {\n  readonly type: \"presence\";\n  readonly data: P;\n};\n\ntype IdFactory = () => string;\n\nexport type StaticSessionInfo = {\n  readonly userId?: string;\n  readonly userInfo?: IUserInfo;\n};\n\nexport type DynamicSessionInfo = {\n  readonly actor: number;\n  readonly nonce: string;\n  readonly scopes: string[];\n  readonly meta: JsonObject;\n};\n\ntype RoomState<\n  P extends JsonObject,\n  S extends LsonObject,\n  U extends BaseUserMeta,\n  E extends Json,\n> = {\n  /**\n   * All pending changes that yet need to be synced.\n   */\n  buffer: {\n    flushTimerID: TimeoutID | undefined;\n\n    // When the last flush happened. Together with config.throttleDelay, this\n    // will control whether the next flush will be sent out immediately, or if\n    // a flush will get scheduled for a few milliseconds into the future.\n    readonly lastFlushedAt: number;\n\n    // Queued-up \"my presence\" updates to be flushed at the earliest convenience\n    presenceUpdates:\n      | { type: \"partial\"; data: Partial<P> }\n      | { type: \"full\"; data: P }\n      | null;\n    messages: ClientMsg<P, E>[];\n    storageOperations: ClientWireOp[];\n  };\n\n  //\n  // The \"self\" User takes assembly of three sources-of-truth:\n  // - The JWT token provides the userId and userInfo metadata (static)\n  // - The server, in its initial ROOM_STATE message, will provide the actor ID\n  //   and the scopes (dynamic)\n  // - The presence is provided by the client's initialPresence configuration (presence)\n  //\n  readonly staticSessionInfoSig: Signal<StaticSessionInfo | null>;\n  readonly dynamicSessionInfoSig: Signal<DynamicSessionInfo | null>;\n  readonly myPresence: PatchableSignal<P>;\n  readonly others: ManagedOthers<P, U>;\n\n  idFactory: IdFactory | null;\n  initialStorage: S;\n\n  yjsProvider: IYjsProvider | undefined;\n  readonly yjsProviderDidChange: EventSource<void>;\n\n  pool: ManagedPool;\n  root: LiveObject<S> | undefined;\n\n  readonly undoStack: Stackframe<P>[][];\n  readonly redoStack: Stackframe<P>[][];\n\n  /**\n   * When history is paused, all operations will get queued up here. When\n   * history is resumed, these operations get \"committed\" to the undo stack.\n   */\n  pausedHistory: null | Deque<Stackframe<P>>;\n\n  /**\n   * Place to collect all mutations during a batch. Ops will be sent over the\n   * wire after the batch is ended.\n   */\n  activeBatch: {\n    ops: ClientWireOp[];\n    reverseOps: Deque<Stackframe<P>>;\n    updates: {\n      others: [];\n      presence: boolean;\n      storageUpdates: Map<string, StorageUpdate>;\n    };\n  } | null;\n\n  // A registry of yet-unacknowledged Ops. These Ops have already been\n  // submitted to the server, but have not yet been acknowledged.\n  readonly unacknowledgedOps: Map<string, ClientWireOp>;\n};\n\nexport type Polyfills = {\n  atob?: (data: string) => string;\n  fetch?: typeof fetch;\n  WebSocket?: IWebSocket;\n};\n\n/**\n * Makes all tuple positions optional.\n * Example, turns:\n *   [foo: string; bar: number]\n * into:\n *   [foo?: string; bar?: number]\n */\ntype OptionalTuple<T extends any[]> = { [K in keyof T]?: T[K] };\n\n/**\n * Returns Partial<T> if all fields on C are optional, T otherwise.\n */\nexport type PartialUnless<C, T> =\n  Record<string, never> extends C\n    ? Partial<T>\n    : // Extra test. We'll want to treat \"never\" as if the empty object is\n      // assignable to it, because otherwise it will not\n      [C] extends [never]\n      ? Partial<T>\n      : T;\n\n/**\n * Returns OptionalTupleUnless<T> if all fields on C are optional, T otherwise.\n */\nexport type OptionalTupleUnless<C, T extends any[]> =\n  Record<string, never> extends C\n    ? OptionalTuple<T>\n    : // Extra test. We'll want to treat \"never\" as if the empty object is\n      // assignable to it, because otherwise it will not\n      [C] extends [never]\n      ? OptionalTuple<T>\n      : T;\n\nexport type RoomDelegates = Omit<Delegates<AuthValue>, \"canZombie\">;\n\n/** @internal */\nexport type RoomConfig<TM extends BaseMetadata, CM extends BaseMetadata> = {\n  delegates: RoomDelegates;\n\n  roomId: string;\n  throttleDelay: number;\n  lostConnectionTimeout: number;\n  backgroundKeepAliveTimeout?: number;\n\n  /**\n   * @deprecated For new rooms, use `engine: 2` instead. Rooms on the v2\n   * Storage engine have native support for streaming. This flag will be\n   * removed in a future version, but will continue to work for existing engine\n   * v1 rooms for now.\n   */\n  unstable_streamData?: boolean;\n\n  polyfills?: Polyfills;\n\n  roomHttpClient: RoomHttpApi<TM, CM>;\n\n  baseUrl: string;\n  enableDebugLogging?: boolean;\n\n  badgeLocation?: BadgeLocation;\n\n  // We would not have to pass this complicated factory/callback functions to\n  // the createRoom() function if we would simply pass the Client instance to\n  // the Room instance, so it can directly call this back on the Client.\n  createSyncSource: () => SyncSource;\n  errorEventSource: EventSource<LiveblocksError>;\n};\n\nfunction userToTreeNode(\n  key: string,\n  user: User<JsonObject, BaseUserMeta>\n): DevTools.UserTreeNode {\n  return {\n    type: \"User\",\n    id: `${user.connectionId}`,\n    key,\n    payload: {\n      connectionId: user.connectionId,\n      id: user.id,\n      info: user.info,\n      presence: user.presence,\n      isReadOnly: !user.canWrite,\n    },\n  };\n}\n\n/**\n * Returns a ref to access if, and if so, how long the current tab is in the\n * background and an unsubscribe function.\n *\n * The `inBackgroundSince` value will either be a JS timestamp indicating the\n * moment the tab was put into the background, or `null` in case the tab isn't\n * currently in the background. In non-DOM environments, this will always\n * return `null`.\n */\nfunction installBackgroundTabSpy(): [\n  inBackgroundSince: { readonly current: number | null },\n  unsub: () => void,\n] {\n  const doc = typeof document !== \"undefined\" ? document : undefined;\n  const inBackgroundSince: { current: number | null } = { current: null };\n\n  function onVisibilityChange() {\n    if (doc?.visibilityState === \"hidden\") {\n      inBackgroundSince.current = inBackgroundSince.current ?? Date.now();\n    } else {\n      inBackgroundSince.current = null;\n    }\n  }\n\n  doc?.addEventListener(\"visibilitychange\", onVisibilityChange);\n  const unsub = () => {\n    doc?.removeEventListener(\"visibilitychange\", onVisibilityChange);\n  };\n\n  return [inBackgroundSince, unsub];\n}\n\nfunction makeNodeMapBuffer() {\n  let map: NodeMap = new Map();\n  return {\n    /** Append a \"page\" of nodes to the current NodeMap buffer. */\n    append(chunk: NodeStream) {\n      for (const [id, node] of chunk) {\n        map.set(id, node);\n      }\n    },\n    /** Return the contents of the current NodeMap buffer, and create a fresh new one. */\n    take(): NodeMap {\n      const result = map;\n      map = new Map();\n      return result;\n    },\n  };\n}\n\n/**\n * @internal\n * Initializes a new Room, and returns its public API.\n */\nexport function createRoom<\n  P extends JsonObject,\n  S extends LsonObject,\n  U extends BaseUserMeta,\n  E extends Json,\n  TM extends BaseMetadata,\n  CM extends BaseMetadata,\n>(\n  options: { initialPresence: P; initialStorage: S },\n  config: RoomConfig<TM, CM>\n): Room<P, S, U, E, TM, CM> {\n  const roomId = config.roomId;\n  const initialPresence = options.initialPresence; // ?? {};\n  const initialStorage = options.initialStorage; // ?? {};\n\n  const httpClient = config.roomHttpClient;\n\n  const [inBackgroundSince, uninstallBgTabSpy] = installBackgroundTabSpy();\n\n  // Create a delegate pair for (a specific) Live Room socket connection(s)\n  const delegates = {\n    ...config.delegates,\n\n    // A connection is allowed to go into \"zombie state\" only if all of the\n    // following conditions apply:\n    //\n    // - The `backgroundKeepAliveTimeout` client option is configured\n    // - The browser window has been in the background for at least\n    //   `backgroundKeepAliveTimeout` milliseconds\n    // - There are no pending changes\n    //\n    canZombie() {\n      return (\n        config.backgroundKeepAliveTimeout !== undefined &&\n        inBackgroundSince.current !== null &&\n        Date.now() >\n          inBackgroundSince.current + config.backgroundKeepAliveTimeout &&\n        getStorageStatus() !== \"synchronizing\"\n      );\n    },\n  };\n\n  const managedSocket: ManagedSocket<AuthValue> = new ManagedSocket(\n    delegates,\n    config.enableDebugLogging\n  );\n\n  // The room's internal stateful context\n  const context: RoomState<P, S, U, E> = {\n    buffer: {\n      flushTimerID: undefined,\n      lastFlushedAt: 0,\n      presenceUpdates:\n        // Queue up the initial presence message as a Full Presence™ update\n        {\n          type: \"full\",\n          data: initialPresence,\n        },\n      messages: [],\n      storageOperations: [],\n    },\n\n    staticSessionInfoSig: new Signal<StaticSessionInfo | null>(null),\n    dynamicSessionInfoSig: new Signal<DynamicSessionInfo | null>(null),\n    myPresence: new PatchableSignal(initialPresence),\n    others: new ManagedOthers<P, U>(),\n\n    initialStorage,\n    idFactory: null,\n\n    // The Yjs provider associated to this room\n    yjsProvider: undefined,\n    yjsProviderDidChange: makeEventSource(),\n\n    // Storage\n    pool: createManagedPool(roomId, {\n      getCurrentConnectionId,\n      onDispatch,\n      isStorageWritable,\n    }),\n    root: undefined,\n\n    undoStack: [],\n    redoStack: [],\n    pausedHistory: null,\n\n    activeBatch: null,\n    unacknowledgedOps: new Map<string, ClientWireOp>(),\n  };\n\n  // Accumulates nodes as initial storage arrives in chunks via\n  // STORAGE_CHUNK messages. Once the final chunk arrives (with\n  // done: true), the complete map is passed to processInitialStorage().\n  const nodeMapBuffer = makeNodeMapBuffer();\n\n  // Tracks timing of storage fetch for debug logging\n  const stopwatch = config.enableDebugLogging ? makeStopWatch() : undefined;\n\n  let lastTokenKey: string | undefined;\n  function onStatusDidChange(newStatus: Status) {\n    const authValue = managedSocket.authValue;\n    if (authValue !== null) {\n      const tokenKey = getBearerTokenFromAuthValue(authValue);\n\n      if (tokenKey !== lastTokenKey) {\n        lastTokenKey = tokenKey;\n\n        if (authValue.type === \"secret\") {\n          const token = authValue.token.parsed;\n          context.staticSessionInfoSig.set({\n            userId: token.uid,\n            userInfo: token.ui,\n          });\n        } else {\n          context.staticSessionInfoSig.set({\n            userId: undefined,\n            userInfo: undefined,\n          });\n        }\n      }\n    }\n\n    // Forward to the outside world\n    eventHub.status.notify(newStatus);\n    notifySelfChanged();\n  }\n\n  let _connectionLossTimerId: TimeoutID | undefined;\n  let _hasLostConnection = false;\n\n  function handleConnectionLossEvent(newStatus: Status) {\n    if (newStatus === \"reconnecting\") {\n      _connectionLossTimerId = setTimeout(() => {\n        eventHub.lostConnection.notify(\"lost\");\n        _hasLostConnection = true;\n\n        // Clear the others\n        context.others.clearOthers();\n        notify({ others: [{ type: \"reset\" }] });\n      }, config.lostConnectionTimeout);\n    } else {\n      clearTimeout(_connectionLossTimerId);\n\n      if (_hasLostConnection) {\n        if (newStatus === \"disconnected\") {\n          eventHub.lostConnection.notify(\"failed\");\n        } else {\n          // Typically the case when going back to \"connected\", but really take\n          // *any* other state change as a recovery sign\n          eventHub.lostConnection.notify(\"restored\");\n        }\n\n        _hasLostConnection = false;\n      }\n    }\n  }\n\n  function onDidConnect() {\n    // Re-broadcast the full user presence as soon as we (re)connect\n    context.buffer.presenceUpdates = {\n      type: \"full\",\n      data:\n        // Because context.me.current is a readonly object, we'll have to\n        // make a copy here. Otherwise, type errors happen later when\n        // \"patching\" my presence.\n        { ...context.myPresence.get() },\n    };\n\n    // NOTE: There was a flush here before, but I don't think it's really\n    // needed anymore. We're now combining this flush with the one below, to\n    // combine them in a single batch.\n    // tryFlushing();\n\n    // If a storage fetch has ever been initiated, we assume the client is\n    // interested in storage, so we will refresh it after a reconnection.\n    if (_getStorage$ !== null) {\n      refreshStorage({ flush: false });\n    }\n    flushNowOrSoon();\n  }\n\n  function onDidDisconnect() {\n    clearTimeout(context.buffer.flushTimerID);\n  }\n\n  // Register events handlers for events coming from the socket\n  // We never have to unsubscribe, because the Room and the Connection Manager\n  // will have the same life-time.\n  managedSocket.events.onMessage.subscribe(handleServerMessage);\n  managedSocket.events.statusDidChange.subscribe(onStatusDidChange);\n  managedSocket.events.statusDidChange.subscribe(handleConnectionLossEvent);\n  managedSocket.events.didConnect.subscribe(onDidConnect);\n  managedSocket.events.didDisconnect.subscribe(onDidDisconnect);\n  managedSocket.events.onConnectionError.subscribe(({ message, code }) => {\n    const type = \"ROOM_CONNECTION_ERROR\";\n    const err = new LiveblocksError(message, { type, code, roomId });\n    const didNotify = config.errorEventSource.notify(err);\n    if (!didNotify) {\n      if (process.env.NODE_ENV !== \"production\") {\n        console.error(\n          `Connection to websocket server closed. Reason: ${message} (code: ${code}).`\n        );\n      }\n    }\n  });\n\n  function onDispatch(\n    ops: ClientWireOp[],\n    reverse: Op[],\n    storageUpdates: Map<string, StorageUpdate>\n  ): void {\n    if (context.activeBatch) {\n      for (const op of ops) {\n        context.activeBatch.ops.push(op);\n      }\n      for (const [key, value] of storageUpdates) {\n        context.activeBatch.updates.storageUpdates.set(\n          key,\n          mergeStorageUpdates(\n            context.activeBatch.updates.storageUpdates.get(key),\n            value\n          )\n        );\n      }\n      context.activeBatch.reverseOps.pushLeft(reverse);\n    } else {\n      addToUndoStack(reverse);\n      context.redoStack.length = 0;\n      dispatchOps(ops);\n      notify({ storageUpdates });\n    }\n  }\n\n  function isStorageWritable(): boolean {\n    const scopes = context.dynamicSessionInfoSig.get()?.scopes;\n    // If we aren't connected yet, assume we can write\n    return scopes !== undefined ? canWriteStorage(scopes) : true;\n  }\n\n  const eventHub = {\n    status: makeEventSource<Status>(), // New/recommended API\n    lostConnection: makeEventSource<LostConnectionEvent>(),\n\n    customEvent: makeEventSource<RoomEventMessage<P, U, E>>(),\n    self: makeEventSource<User<P, U>>(),\n    myPresence: makeEventSource<P>(),\n    others: makeEventSource<OthersEvent<P, U>>(),\n    storageBatch: makeEventSource<StorageUpdate[]>(),\n    history: makeEventSource<HistoryEvent>(),\n    storageDidLoad: makeEventSource<void>(),\n    storageStatus: makeEventSource<StorageStatus>(),\n    ydoc: makeEventSource<YDocUpdateServerMsg | UpdateYDocClientMsg>(),\n\n    comments: makeEventSource<CommentsEventServerMsg>(),\n    roomWillDestroy: makeEventSource<void>(),\n  };\n\n  async function createTextMention(mentionId: string, mention: MentionData) {\n    return httpClient.createTextMention({ roomId, mentionId, mention });\n  }\n\n  async function deleteTextMention(mentionId: string) {\n    return httpClient.deleteTextMention({ roomId, mentionId });\n  }\n\n  async function reportTextEditor(type: TextEditorType, rootKey: string) {\n    await httpClient.reportTextEditor({ roomId, type, rootKey });\n  }\n\n  async function listTextVersions() {\n    return httpClient.listTextVersions({ roomId });\n  }\n\n  async function listTextVersionsSince(options: ListTextVersionsSinceOptions) {\n    return httpClient.listTextVersionsSince({\n      roomId,\n      since: options.since,\n      signal: options.signal,\n    });\n  }\n\n  async function getTextVersion(versionId: string) {\n    return httpClient.getTextVersion({ roomId, versionId });\n  }\n\n  async function createTextVersion() {\n    return httpClient.createTextVersion({ roomId });\n  }\n\n  async function executeContextualPrompt(options: {\n    prompt: string;\n    context: ContextualPromptContext;\n    previous?: {\n      prompt: string;\n      response: ContextualPromptResponse;\n    };\n    signal: AbortSignal;\n  }) {\n    return httpClient.executeContextualPrompt({\n      roomId,\n      ...options,\n    });\n  }\n\n  function sendMessages(messages: ClientMsg<P, E>[]) {\n    managedSocket.send(stringify(messages));\n  }\n\n  const self = DerivedSignal.from(\n    context.staticSessionInfoSig,\n    context.dynamicSessionInfoSig,\n    context.myPresence,\n    (staticSession, dynamicSession, myPresence): User<P, U> | null => {\n      if (staticSession === null || dynamicSession === null) {\n        return null;\n      } else {\n        const canWrite = canWriteStorage(dynamicSession.scopes);\n        return {\n          connectionId: dynamicSession.actor,\n          id: staticSession.userId,\n          info: staticSession.userInfo,\n          presence: myPresence,\n          canWrite,\n          canComment: canComment(dynamicSession.scopes),\n        };\n      }\n    }\n  );\n\n  let _lastSelf: Readonly<User<P, U>> | undefined;\n  function notifySelfChanged() {\n    const currSelf = self.get();\n    if (currSelf !== null && currSelf !== _lastSelf) {\n      eventHub.self.notify(currSelf);\n      _lastSelf = currSelf;\n    }\n  }\n\n  // For use in DevTools\n  const selfAsTreeNode = DerivedSignal.from(self, (me) =>\n    me !== null ? userToTreeNode(\"Me\", me) : null\n  );\n\n  function createOrUpdateRootFromMessage(nodes: NodeMap) {\n    if (nodes.size === 0) {\n      throw new Error(\"Internal error: cannot load storage without items\");\n    }\n\n    if (context.root !== undefined) {\n      const currentItems: NodeMap = new Map();\n      for (const [id, crdt] of context.pool.nodes) {\n        currentItems.set(id, crdt._serialize());\n      }\n\n      // Get operations that represent the diff between 2 states.\n      const ops = getTreesDiffOperations(currentItems, nodes);\n\n      const result = applyRemoteOps(ops);\n      notify(result.updates);\n    } else {\n      context.root = LiveObject._fromItems<S>(\n        nodes as NodeStream,\n        context.pool\n      );\n    }\n\n    const canWrite = self.get()?.canWrite ?? true;\n\n    // Populate missing top-level keys using `initialStorage`\n    const stackSizeBefore = context.undoStack.length;\n    for (const key in context.initialStorage) {\n      if (context.root.get(key) === undefined) {\n        if (canWrite) {\n          context.root.set(key, cloneLson(context.initialStorage[key]));\n        } else {\n          console.warn(\n            `Attempted to populate missing storage key '${key}', but current user has no write access`\n          );\n        }\n      }\n    }\n\n    // Initial storage is populated using normal \"set\" operations in the loop\n    // above, those updates can end up in the undo stack, so let's prune it.\n    context.undoStack.length = stackSizeBefore;\n  }\n\n  function _addToRealUndoStack(frames: Stackframe<P>[]) {\n    // If undo stack is too large, we remove the older item\n    if (context.undoStack.length >= 50) {\n      context.undoStack.shift();\n    }\n\n    context.undoStack.push(frames);\n    onHistoryChange();\n  }\n\n  function addToUndoStack(frames: Stackframe<P>[]) {\n    if (context.pausedHistory !== null) {\n      context.pausedHistory.pushLeft(frames);\n    } else {\n      _addToRealUndoStack(frames);\n    }\n  }\n\n  type NotifyUpdates = {\n    storageUpdates?: Map<string, StorageUpdate>;\n    presence?: boolean;\n    others?: InternalOthersEvent<P, U>[];\n  };\n\n  function notify(updates: NotifyUpdates) {\n    const storageUpdates = updates.storageUpdates;\n    const othersUpdates = updates.others;\n\n    if (othersUpdates !== undefined && othersUpdates.length > 0) {\n      const others = context.others.get();\n      for (const event of othersUpdates) {\n        eventHub.others.notify({ ...event, others });\n      }\n    }\n\n    if (updates.presence ?? false) {\n      notifySelfChanged();\n      eventHub.myPresence.notify(context.myPresence.get());\n    }\n\n    if (storageUpdates !== undefined && storageUpdates.size > 0) {\n      const updates = Array.from(storageUpdates.values());\n      eventHub.storageBatch.notify(updates);\n    }\n    notifyStorageStatus();\n  }\n\n  function getCurrentConnectionId() {\n    const info = context.dynamicSessionInfoSig.get();\n    if (info) {\n      return info.actor;\n    }\n\n    throw new Error(\n      \"Internal. Tried to get connection id but connection was never open\"\n    );\n  }\n\n  function applyLocalOps(frames: readonly Stackframe<P>[]): {\n    opsToEmit: ClientWireOp[]; // Ops to send over the wire afterwards\n    reverse: Stackframe<P>[]; // Reverse ops to add to the undo stack aftwards\n    // Updates to notify about afterwards\n    updates: {\n      storageUpdates: Map<string, StorageUpdate>;\n      presence: boolean;\n    };\n  } {\n    const [pframes, ops] = partition(\n      frames,\n      (f): f is PresenceStackframe<P> => f.type === \"presence\"\n    );\n\n    // Ensure all local ops have opIds assigned before applying them\n    const opsWithOpIds = ops.map((op: Op) =>\n      op.opId === undefined\n        ? { ...op, opId: context.pool.generateOpId() }\n        : (op as ClientWireOp)\n    );\n\n    const { reverse, updates } = applyOps(\n      pframes,\n      opsWithOpIds,\n      /* isLocal */ true\n    );\n    return { opsToEmit: opsWithOpIds, reverse, updates };\n  }\n\n  function applyRemoteOps(ops: readonly ServerWireOp[]): {\n    // Updates to notify about afterwards\n    updates: {\n      storageUpdates: Map<string, StorageUpdate>;\n      presence: boolean;\n    };\n  } {\n    return applyOps([], ops, /* isLocal */ false);\n  }\n\n  function applyOps(\n    pframes: readonly PresenceStackframe<P>[],\n    ops: readonly Op[],\n    isLocal: boolean\n  ): {\n    reverse: Stackframe<P>[];\n    updates: {\n      storageUpdates: Map<string, StorageUpdate>;\n      presence: boolean;\n    };\n  } {\n    const output = {\n      reverse: new Deque<Stackframe<P>>(),\n      storageUpdates: new Map<string, StorageUpdate>(),\n      presence: false,\n    };\n\n    for (const pf of pframes) {\n      const reverse = {\n        type: \"presence\" as const,\n        data: {} as P,\n      };\n\n      for (const key in pf.data) {\n        reverse.data[key] = context.myPresence.get()[key];\n      }\n\n      context.myPresence.patch(pf.data);\n\n      if (context.buffer.presenceUpdates === null) {\n        context.buffer.presenceUpdates = { type: \"partial\", data: pf.data };\n      } else {\n        // Merge the new fields with whatever is already queued up (doesn't\n        // matter whether its a partial or full update)\n        for (const key in pf.data) {\n          context.buffer.presenceUpdates.data[key] = pf.data[key];\n        }\n      }\n\n      output.reverse.pushLeft(reverse);\n      output.presence = true;\n    }\n\n    const createdNodeIds = new Set<string>();\n    for (const op of ops) {\n      let source: OpSource;\n\n      if (isLocal) {\n        source = OpSource.LOCAL;\n      } else if (op.opId !== undefined) {\n        context.unacknowledgedOps.delete(op.opId);\n        source = OpSource.OURS;\n      } else {\n        // Remotely generated Ops (and fix Ops as a special case of that)\n        // don't have opId anymore.\n        source = OpSource.THEIRS;\n      }\n\n      const applyOpResult = applyOp(op, source);\n      if (applyOpResult.modified) {\n        const nodeId = applyOpResult.modified.node._id;\n\n        // If the modified node was created in the same batch, we don't want\n        // to notify storage updates for it (children of newly created nodes\n        // shouldn't trigger separate updates).\n        if (!(nodeId && createdNodeIds.has(nodeId))) {\n          output.storageUpdates.set(\n            nn(applyOpResult.modified.node._id),\n            mergeStorageUpdates(\n              output.storageUpdates.get(nn(applyOpResult.modified.node._id)),\n              applyOpResult.modified\n            )\n          );\n          output.reverse.pushLeft(applyOpResult.reverse);\n        }\n\n        if (\n          op.type === OpCode.CREATE_LIST ||\n          op.type === OpCode.CREATE_MAP ||\n          op.type === OpCode.CREATE_OBJECT\n        ) {\n          createdNodeIds.add(op.id);\n        }\n      }\n    }\n\n    return {\n      reverse: Array.from(output.reverse),\n      updates: {\n        storageUpdates: output.storageUpdates,\n        presence: output.presence,\n      },\n    };\n  }\n\n  function applyOp(op: Op, source: OpSource): ApplyResult {\n    // Explicit case to handle ignored Ops\n    if (isIgnoredOp(op)) {\n      return { modified: false };\n    }\n\n    switch (op.type) {\n      case OpCode.DELETE_OBJECT_KEY:\n      case OpCode.UPDATE_OBJECT:\n      case OpCode.DELETE_CRDT: {\n        const node = context.pool.nodes.get(op.id);\n        if (node === undefined) {\n          return { modified: false };\n        }\n\n        return node._apply(op, source === OpSource.LOCAL);\n      }\n\n      case OpCode.SET_PARENT_KEY: {\n        const node = context.pool.nodes.get(op.id);\n        if (node === undefined) {\n          return { modified: false };\n        }\n\n        if (node.parent.type === \"HasParent\" && isLiveList(node.parent.node)) {\n          return node.parent.node._setChildKey(\n            asPos(op.parentKey),\n            node,\n            source\n          );\n        }\n        return { modified: false };\n      }\n      case OpCode.CREATE_OBJECT:\n      case OpCode.CREATE_LIST:\n      case OpCode.CREATE_MAP:\n      case OpCode.CREATE_REGISTER: {\n        if (op.parentId === undefined) {\n          return { modified: false };\n        }\n\n        const parentNode = context.pool.nodes.get(op.parentId);\n        if (parentNode === undefined) {\n          return { modified: false };\n        }\n\n        return parentNode._attachChild(op, source);\n      }\n    }\n  }\n\n  function updatePresence(\n    patch: Partial<P>,\n    options?: { addToHistory: boolean }\n  ) {\n    const oldValues = {} as P;\n\n    if (context.buffer.presenceUpdates === null) {\n      // try {\n      context.buffer.presenceUpdates = {\n        type: \"partial\",\n        data: {},\n      };\n      // } catch (err) {\n      //   window.console.log({ context, patch, err });\n      //   throw err;\n      // }\n    }\n\n    for (const key in patch) {\n      type K = typeof key;\n      const overrideValue: P[K] | undefined = patch[key];\n      if (overrideValue === undefined) {\n        continue;\n      }\n      context.buffer.presenceUpdates.data[key] = overrideValue;\n      oldValues[key] = context.myPresence.get()[key];\n    }\n\n    context.myPresence.patch(patch);\n\n    if (context.activeBatch) {\n      if (options?.addToHistory) {\n        context.activeBatch.reverseOps.pushLeft({\n          type: \"presence\",\n          data: oldValues,\n        });\n      }\n      context.activeBatch.updates.presence = true;\n    } else {\n      flushNowOrSoon();\n      if (options?.addToHistory) {\n        addToUndoStack([{ type: \"presence\", data: oldValues }]);\n      }\n      notify({ presence: true });\n    }\n  }\n\n  function onUpdatePresenceMessage(\n    message: UpdatePresenceServerMsg<P>\n  ): InternalOthersEvent<P, U> | undefined {\n    if (message.targetActor !== undefined) {\n      // The incoming message is a full presence update. We are obliged to\n      // handle it if `targetActor` matches our own connection ID, but we can\n      // use the opportunity to effectively reset the known presence as\n      // a \"keyframe\" update, while we have free access to it.\n      const oldUser = context.others.getUser(message.actor);\n      context.others.setOther(message.actor, message.data);\n\n      const newUser = context.others.getUser(message.actor);\n      if (oldUser === undefined && newUser !== undefined) {\n        // The user just became \"visible\" due to this update, so fire the\n        // \"enter\" event\n        return { type: \"enter\", user: newUser };\n      }\n    } else {\n      // The incoming message is a partial presence update\n      context.others.patchOther(message.actor, message.data), message;\n    }\n\n    const user = context.others.getUser(message.actor);\n    if (user) {\n      return {\n        type: \"update\",\n        updates: message.data,\n        user,\n      };\n    } else {\n      return undefined;\n    }\n  }\n\n  function onUserLeftMessage(\n    message: UserLeftServerMsg\n  ): InternalOthersEvent<P, U> | null {\n    const user = context.others.getUser(message.actor);\n    if (user) {\n      context.others.removeConnection(message.actor);\n      return { type: \"leave\", user };\n    }\n    return null;\n  }\n\n  function onRoomStateMessage(\n    message: RoomStateServerMsg<U>\n  ): InternalOthersEvent<P, U> {\n    // The server will inform the client about its assigned actor ID and scopes\n    context.dynamicSessionInfoSig.set({\n      actor: message.actor,\n      nonce: message.nonce,\n      scopes: message.scopes,\n      meta: message.meta,\n    });\n    context.idFactory = makeIdFactory(message.actor);\n    notifySelfChanged();\n\n    // Inject brand badge if meta.showBrand is true\n    if (message.meta.showBrand === true) {\n      injectBrandBadge(config.badgeLocation ?? \"bottom-right\");\n    }\n\n    for (const connectionId of context.others.connectionIds()) {\n      const user = message.users[connectionId];\n      if (user === undefined) {\n        context.others.removeConnection(connectionId);\n      }\n    }\n\n    for (const key in message.users) {\n      const user = message.users[key];\n      const connectionId = Number(key);\n      context.others.setConnection(\n        connectionId,\n        user.id,\n        user.info,\n        user.scopes\n      );\n    }\n\n    // NOTE: We could be notifying the \"others\" event here, but the reality is\n    // that ROOM_STATE is often the first message to be received from the\n    // server, and it won't contain all the information needed to update the\n    // other views yet. Instead, we'll let the others' presences trickle in,\n    // and notify each time that happens.\n    return { type: \"reset\" };\n  }\n\n  function canUndo() { return context.undoStack.length > 0; } // prettier-ignore\n  function canRedo() { return context.redoStack.length > 0; } // prettier-ignore\n  function onHistoryChange() {\n    eventHub.history.notify({ canUndo: canUndo(), canRedo: canRedo() });\n  }\n\n  function onUserJoinedMessage(\n    message: UserJoinServerMsg<U>\n  ): InternalOthersEvent<P, U> | undefined {\n    context.others.setConnection(\n      message.actor,\n      message.id,\n      message.info,\n      message.scopes\n    );\n    // Send current presence to new user\n    // TODO: Consider storing it on the backend\n    context.buffer.messages.push({\n      type: ClientMsgCode.UPDATE_PRESENCE,\n      data: context.myPresence.get(),\n      targetActor: message.actor,\n    });\n    flushNowOrSoon();\n\n    // We recorded the connection, but we won't make the new user visible\n    // unless we also know their initial presence data at this point.\n    const user = context.others.getUser(message.actor);\n    return user ? { type: \"enter\", user } : undefined;\n  }\n\n  function parseServerMessage(data: Json): ServerMsg<P, U, E> | null {\n    if (!isJsonObject(data)) {\n      return null;\n    }\n    return data as ServerMsg<P, U, E>;\n  }\n\n  function parseServerMessages(text: string): ServerMsg<P, U, E>[] | null {\n    const data: Json | undefined = tryParseJson(text);\n    if (data === undefined) {\n      return null;\n    } else if (isJsonArray(data)) {\n      return compact(data.map((item) => parseServerMessage(item)));\n    } else {\n      return compact([parseServerMessage(data)]);\n    }\n  }\n\n  function applyAndSendOfflineOps(unackedOps: Map<string, ClientWireOp>) {\n    if (unackedOps.size === 0) {\n      return;\n    }\n\n    const messages: ClientMsg<P, E>[] = [];\n    const inOps = Array.from(unackedOps.values());\n    const result = applyLocalOps(inOps);\n    messages.push({\n      type: ClientMsgCode.UPDATE_STORAGE,\n      ops: result.opsToEmit,\n    });\n\n    notify(result.updates);\n    sendMessages(messages);\n  }\n\n  /**\n   * Handles a message received on the WebSocket. Will never be a \"pong\". The\n   * \"pong\" is handled at the connection manager level.\n   */\n  function handleServerMessage(event: IWebSocketMessageEvent) {\n    if (typeof event.data !== \"string\") {\n      // istanbul ignore next: Unknown incoming message\n      return;\n    }\n\n    const messages = parseServerMessages(event.data);\n    if (messages === null || messages.length === 0) {\n      // istanbul ignore next: Unknown incoming message\n      return;\n    }\n\n    const updates = {\n      storageUpdates: new Map<string, StorageUpdate>(),\n      others: [] as InternalOthersEvent<P, U>[],\n    };\n\n    for (const message of messages) {\n      switch (message.type) {\n        case ServerMsgCode.USER_JOINED: {\n          const userJoinedUpdate = onUserJoinedMessage(message);\n          if (userJoinedUpdate) {\n            updates.others.push(userJoinedUpdate);\n          }\n          break;\n        }\n\n        case ServerMsgCode.UPDATE_PRESENCE: {\n          const othersPresenceUpdate = onUpdatePresenceMessage(message);\n          if (othersPresenceUpdate) {\n            updates.others.push(othersPresenceUpdate);\n          }\n          break;\n        }\n\n        case ServerMsgCode.BROADCASTED_EVENT: {\n          const others = context.others.get();\n          eventHub.customEvent.notify({\n            connectionId: message.actor,\n            user:\n              message.actor < 0\n                ? null\n                : (others.find((u) => u.connectionId === message.actor) ??\n                  null),\n            event: message.event,\n          });\n          break;\n        }\n\n        case ServerMsgCode.USER_LEFT: {\n          const event = onUserLeftMessage(message);\n          if (event) {\n            updates.others.push(event);\n          }\n          break;\n        }\n\n        case ServerMsgCode.UPDATE_YDOC: {\n          eventHub.ydoc.notify(message);\n          break;\n        }\n\n        case ServerMsgCode.ROOM_STATE: {\n          updates.others.push(onRoomStateMessage(message));\n          break;\n        }\n\n        case ServerMsgCode.STORAGE_CHUNK:\n          stopwatch?.lap();\n          nodeMapBuffer.append(compactNodesToNodeStream(message.nodes));\n          break;\n\n        case ServerMsgCode.STORAGE_STREAM_END: {\n          const timing = stopwatch?.stop();\n          if (timing) {\n            const ms = (v: number) => `${v.toFixed(1)}ms`;\n            const rest = timing.laps.slice(1);\n            console.warn(\n              `Storage chunk arrival: ${[\n                `total=${ms(timing.total)}`,\n                `first=${ms(timing.laps[0])}`,\n                `rest.n=${rest.length}`,\n                `rest.avg=${ms(rest.reduce((a, b) => a + b, 0) / rest.length)}`,\n                `rest.max=${ms(rest.reduce((a, b) => Math.max(a, b), 0))}`,\n              ].join(\", \")}`\n            );\n          }\n          processInitialStorage(nodeMapBuffer.take());\n          break;\n        }\n\n        case ServerMsgCode.UPDATE_STORAGE: {\n          const applyResult = applyRemoteOps(message.ops);\n          for (const [key, value] of applyResult.updates.storageUpdates) {\n            updates.storageUpdates.set(\n              key,\n              mergeStorageUpdates(updates.storageUpdates.get(key), value)\n            );\n          }\n          break;\n        }\n\n        // Receiving a RejectedOps message in the client means that the server is no\n        // longer in sync with the client. Trying to synchronize the client again by\n        // rolling back particular Ops may be hard/impossible. It's fine to not try and\n        // accept the out-of-sync reality and throw an error.\n        case ServerMsgCode.REJECT_STORAGE_OP: {\n          console.errorWithTitle(\n            \"Storage mutation rejection error\",\n            message.reason\n          );\n\n          if (process.env.NODE_ENV !== \"production\") {\n            throw new Error(\n              `Storage mutations rejected by server: ${message.reason}`\n            );\n          }\n\n          break;\n        }\n\n        case ServerMsgCode.THREAD_CREATED:\n        case ServerMsgCode.THREAD_DELETED:\n        case ServerMsgCode.THREAD_METADATA_UPDATED:\n        case ServerMsgCode.THREAD_UPDATED:\n        case ServerMsgCode.COMMENT_REACTION_ADDED:\n        case ServerMsgCode.COMMENT_REACTION_REMOVED:\n        case ServerMsgCode.COMMENT_CREATED:\n        case ServerMsgCode.COMMENT_EDITED:\n        case ServerMsgCode.COMMENT_DELETED:\n        case ServerMsgCode.COMMENT_METADATA_UPDATED: {\n          eventHub.comments.notify(message);\n          break;\n        }\n\n        case ServerMsgCode.STORAGE_STATE_V7: // No longer used in V8\n        default:\n          // Ignore unknown server messages\n          break;\n      }\n    }\n\n    notify(updates);\n  }\n\n  function flushNowOrSoon() {\n    const storageOps = context.buffer.storageOperations;\n    if (storageOps.length > 0) {\n      for (const op of storageOps) {\n        context.unacknowledgedOps.set(op.opId, op);\n      }\n      notifyStorageStatus();\n    }\n\n    if (managedSocket.getStatus() !== \"connected\") {\n      context.buffer.storageOperations = [];\n      return;\n    }\n\n    const now = Date.now();\n    const elapsedMillis = now - context.buffer.lastFlushedAt;\n\n    if (elapsedMillis >= config.throttleDelay) {\n      // Flush the buffer right now\n      const messagesToFlush = serializeBuffer();\n      if (messagesToFlush.length === 0) {\n        return;\n      }\n\n      sendMessages(messagesToFlush);\n      context.buffer = {\n        flushTimerID: undefined,\n        lastFlushedAt: now,\n        messages: [],\n        storageOperations: [],\n        presenceUpdates: null,\n      };\n    } else {\n      // Or schedule the flush a few millis into the future\n      clearTimeout(context.buffer.flushTimerID);\n      context.buffer.flushTimerID = setTimeout(\n        flushNowOrSoon,\n        config.throttleDelay - elapsedMillis\n      );\n    }\n  }\n\n  /**\n   * Returns a list of ClientMsgs to flush to the network, computed from all\n   * pending changes in the buffer. Has no side effects.\n   */\n  function serializeBuffer() {\n    const messages: ClientMsg<P, E>[] = [];\n    if (context.buffer.presenceUpdates) {\n      messages.push(\n        context.buffer.presenceUpdates.type === \"full\"\n          ? {\n              type: ClientMsgCode.UPDATE_PRESENCE,\n              // Populating the `targetActor` field turns this message into\n              // a Full Presence™ update message (not a patch), which will get\n              // interpreted by other clients as such.\n              targetActor: -1,\n              data: context.buffer.presenceUpdates.data,\n            }\n          : {\n              type: ClientMsgCode.UPDATE_PRESENCE,\n              data: context.buffer.presenceUpdates.data,\n            }\n      );\n    }\n    for (const event of context.buffer.messages) {\n      messages.push(event);\n    }\n    if (context.buffer.storageOperations.length > 0) {\n      messages.push({\n        type: ClientMsgCode.UPDATE_STORAGE,\n        ops: context.buffer.storageOperations,\n      });\n    }\n    return messages;\n  }\n\n  function updateYDoc(update: string, guid?: string, isV2?: boolean) {\n    const clientMsg: UpdateYDocClientMsg = {\n      type: ClientMsgCode.UPDATE_YDOC,\n      update,\n      guid,\n      v2: isV2,\n    };\n    context.buffer.messages.push(clientMsg);\n    eventHub.ydoc.notify(clientMsg);\n    flushNowOrSoon();\n  }\n\n  function broadcastEvent(\n    event: E,\n    options: BroadcastOptions = {\n      shouldQueueEventIfNotReady: false,\n    }\n  ) {\n    if (\n      managedSocket.getStatus() !== \"connected\" &&\n      !options.shouldQueueEventIfNotReady\n    ) {\n      return;\n    }\n\n    context.buffer.messages.push({\n      type: ClientMsgCode.BROADCAST_EVENT,\n      event,\n    });\n    flushNowOrSoon();\n  }\n\n  /**\n   * Schedule Ops to be sent to the server (now or soon). All ops should be\n   * \"wire-ready\" (have an opId), once dispatched there is no going back.\n   */\n  function dispatchOps(ops: ClientWireOp[]) {\n    const { storageOperations } = context.buffer;\n    for (const op of ops) {\n      storageOperations.push(op);\n    }\n    flushNowOrSoon();\n  }\n\n  let _getStorage$: Promise<void> | null = null;\n  let _resolveStoragePromise: (() => void) | null = null;\n\n  function processInitialStorage(nodes: NodeMap) {\n    const unacknowledgedOps = new Map(context.unacknowledgedOps);\n    createOrUpdateRootFromMessage(nodes);\n    applyAndSendOfflineOps(unacknowledgedOps);\n    _resolveStoragePromise?.();\n    notifyStorageStatus();\n    eventHub.storageDidLoad.notify();\n  }\n\n  async function streamStorage() {\n    // TODO: Handle potential race conditions where the room get disconnected while the request is pending\n    if (!managedSocket.authValue) return;\n    const nodes = new Map<string, SerializedCrdt>(\n      await httpClient.streamStorage({ roomId })\n    );\n    processInitialStorage(nodes);\n  }\n\n  function refreshStorage(options: { flush: boolean }) {\n    const messages = context.buffer.messages;\n    if (config.unstable_streamData) {\n      // instead of sending a fetch message over WS, stream over HTTP\n      void streamStorage();\n    } else if (\n      !messages.some((msg) => msg.type === ClientMsgCode.FETCH_STORAGE)\n    ) {\n      // Only add the fetch message to the outgoing message queue if it isn't\n      // already there\n      messages.push({ type: ClientMsgCode.FETCH_STORAGE });\n      nodeMapBuffer.take(); // Reset any partial state from previous fetch\n      stopwatch?.start();\n    }\n\n    if (options.flush) {\n      flushNowOrSoon();\n    }\n  }\n\n  function startLoadingStorage(): Promise<void> {\n    if (_getStorage$ === null) {\n      refreshStorage({ flush: true });\n      _getStorage$ = new Promise((resolve) => {\n        _resolveStoragePromise = resolve;\n      });\n      notifyStorageStatus();\n    }\n    return _getStorage$;\n  }\n\n  /**\n   * Closely related to .getStorage(), but synchronously. Will be `null`\n   * initially. When requested for the first time, will kick off the loading of\n   * Storage if it hasn't happened yet.\n   *\n   * Once Storage is loaded, will return a stable reference to the storage\n   * root.\n   */\n  function getStorageSnapshot(): LiveObject<S> | null {\n    const root = context.root;\n    if (root !== undefined) {\n      // Done loading\n      return root;\n    } else {\n      // Not done loading, kick off the loading (will not do anything if already kicked off)\n      void startLoadingStorage();\n      return null;\n    }\n  }\n\n  async function getStorage(): Promise<{\n    root: LiveObject<S>;\n  }> {\n    if (context.root !== undefined) {\n      // Store has already loaded, so we can resolve it directly\n      return Promise.resolve({\n        root: context.root,\n      });\n    }\n\n    await startLoadingStorage();\n    return {\n      root: nn(context.root) as LiveObject<S>,\n    };\n  }\n\n  function fetchYDoc(vector: string, guid?: string, isV2?: boolean): void {\n    // don't allow multiple fetches in the same buffer with the same vector\n    // dev tools may also call with a different vector (if its opened later), and that's okay\n    // because the updates will be ignored by the provider\n    if (\n      !context.buffer.messages.find((m) => {\n        return (\n          m.type === ClientMsgCode.FETCH_YDOC &&\n          m.vector === vector &&\n          m.guid === guid &&\n          m.v2 === isV2\n        );\n      })\n    ) {\n      context.buffer.messages.push({\n        type: ClientMsgCode.FETCH_YDOC,\n        vector,\n        guid,\n        v2: isV2,\n      });\n    }\n\n    flushNowOrSoon();\n  }\n\n  function undo() {\n    if (context.activeBatch) {\n      throw new Error(\"undo is not allowed during a batch\");\n    }\n    const frames = context.undoStack.pop();\n    if (frames === undefined) {\n      return;\n    }\n\n    context.pausedHistory = null;\n    const result = applyLocalOps(frames);\n\n    notify(result.updates);\n    context.redoStack.push(result.reverse);\n    onHistoryChange();\n\n    for (const op of result.opsToEmit) {\n      context.buffer.storageOperations.push(op);\n    }\n    flushNowOrSoon();\n  }\n\n  function redo() {\n    if (context.activeBatch) {\n      throw new Error(\"redo is not allowed during a batch\");\n    }\n\n    const frames = context.redoStack.pop();\n    if (frames === undefined) {\n      return;\n    }\n\n    context.pausedHistory = null;\n    const result = applyLocalOps(frames);\n\n    notify(result.updates);\n    context.undoStack.push(result.reverse);\n    onHistoryChange();\n\n    for (const op of result.opsToEmit) {\n      context.buffer.storageOperations.push(op);\n    }\n    flushNowOrSoon();\n  }\n\n  function clear() {\n    context.undoStack.length = 0;\n    context.redoStack.length = 0;\n  }\n\n  function batch<T>(callback: () => T): T {\n    if (context.activeBatch) {\n      // If there already is an active batch, we don't have to handle this in\n      // any special way. That outer active batch will handle the batch. This\n      // nested call can be a no-op.\n      return callback();\n    }\n\n    let returnValue: T = undefined as unknown as T;\n\n    context.activeBatch = {\n      ops: [],\n      updates: {\n        storageUpdates: new Map(),\n        presence: false,\n        others: [],\n      },\n      reverseOps: new Deque(),\n    };\n    try {\n      returnValue = callback();\n    } finally {\n      // \"Pop\" the current batch of the state, closing the active batch, but\n      // handling it separately here\n      const currentBatch = context.activeBatch;\n      context.activeBatch = null;\n\n      if (currentBatch.reverseOps.length > 0) {\n        addToUndoStack(Array.from(currentBatch.reverseOps));\n      }\n\n      if (currentBatch.ops.length > 0) {\n        // Only clear the redo stack if something has changed during a batch\n        // Clear the redo stack because batch is always called from a local operation\n        context.redoStack.length = 0;\n      }\n\n      if (currentBatch.ops.length > 0) {\n        dispatchOps(currentBatch.ops);\n      }\n\n      notify(currentBatch.updates);\n      flushNowOrSoon();\n    }\n\n    return returnValue;\n  }\n\n  function pauseHistory() {\n    if (context.pausedHistory === null) {\n      context.pausedHistory = new Deque();\n    }\n  }\n\n  function resumeHistory() {\n    const frames = context.pausedHistory;\n    context.pausedHistory = null;\n    if (frames !== null && frames.length > 0) {\n      _addToRealUndoStack(Array.from(frames));\n    }\n  }\n\n  // Register a global source of pending changes for Storage™, so that the\n  // useSyncStatus() hook will be able to report this to end users\n  const syncSourceForStorage = config.createSyncSource();\n\n  function getStorageStatus(): StorageStatus {\n    if (context.root === undefined) {\n      return _getStorage$ === null ? \"not-loaded\" : \"loading\";\n    } else {\n      return context.unacknowledgedOps.size === 0\n        ? \"synchronized\"\n        : \"synchronizing\";\n    }\n  }\n\n  /**\n   * Storage status is a computed value based other internal states so we need to keep a reference to the previous computed value to avoid triggering events when it does not change\n   * This is far from ideal because we need to call this function whenever we update our internal states.\n   *\n   * TODO: Encapsulate our internal state differently to make sure this event is triggered whenever necessary.\n   * Currently okay because we only have 4 callers and shielded by tests.\n   */\n  let _lastStorageStatus = getStorageStatus();\n  function notifyStorageStatus() {\n    const storageStatus = getStorageStatus();\n    if (_lastStorageStatus !== storageStatus) {\n      _lastStorageStatus = storageStatus;\n      eventHub.storageStatus.notify(storageStatus);\n    }\n    syncSourceForStorage.setSyncStatus(\n      storageStatus === \"synchronizing\" ? \"synchronizing\" : \"synchronized\"\n    );\n  }\n\n  function isPresenceReady() {\n    return self.get() !== null;\n  }\n\n  async function waitUntilPresenceReady(): Promise<void> {\n    while (!isPresenceReady()) {\n      const { promise, resolve } = Promise_withResolvers();\n\n      const unsub1 = events.self.subscribeOnce(resolve);\n      const unsub2 = events.status.subscribeOnce(resolve);\n      // Return whenever one of these returns, whichever is first\n      await promise;\n      unsub1();\n      unsub2();\n    }\n  }\n\n  function isStorageReady() {\n    return getStorageSnapshot() !== null;\n  }\n\n  async function waitUntilStorageReady(): Promise<void> {\n    while (!isStorageReady()) {\n      // Trigger a load of Storage and wait until it finished\n      await getStorage();\n    }\n  }\n\n  // Derived cached state for use in DevTools\n  const others_forDevTools = DerivedSignal.from(\n    context.others.signal,\n    (others) =>\n      others.map((other, index) => userToTreeNode(`Other ${index}`, other))\n  );\n\n  const events = {\n    status: eventHub.status.observable,\n    lostConnection: eventHub.lostConnection.observable,\n\n    customEvent: eventHub.customEvent.observable,\n    others: eventHub.others.observable,\n    self: eventHub.self.observable,\n    myPresence: eventHub.myPresence.observable,\n    storageBatch: eventHub.storageBatch.observable,\n    history: eventHub.history.observable,\n    storageDidLoad: eventHub.storageDidLoad.observable,\n    storageStatus: eventHub.storageStatus.observable,\n    ydoc: eventHub.ydoc.observable,\n\n    comments: eventHub.comments.observable,\n    roomWillDestroy: eventHub.roomWillDestroy.observable,\n  };\n\n  async function getThreadsSince(options: GetThreadsSinceOptions) {\n    return httpClient.getThreadsSince({\n      roomId,\n      since: options.since,\n      signal: options.signal,\n    });\n  }\n\n  async function getThreads(options?: GetThreadsOptions<TM>) {\n    return httpClient.getThreads({\n      roomId,\n      query: options?.query,\n      cursor: options?.cursor,\n    });\n  }\n\n  async function getThread(threadId: string) {\n    return httpClient.getThread({ roomId, threadId });\n  }\n\n  // TODO 4.0: Update API to be similar to `@liveblocks/node`'s `createThread` method.\n  // Instead of a flat list of options (`commentId`, `metadata`, `body`, `commentMetadata`, etc.),\n  // we could move to using a nested `comment` object to differentiate between thread and comment properties.\n  //\n  // {\n  //   roomId: string;\n  //   threadId?: string;\n  //   metadata: TM | undefined;\n  //   comment: {\n  //     id?: string;\n  //     metadata: CM | undefined;\n  //     body: CommentBody;\n  //     attachmentIds?: string[];\n  //   };\n  // }\n  async function createThread(options: {\n    roomId: string;\n    threadId?: string;\n    commentId?: string;\n    metadata: TM | undefined;\n    commentMetadata: CM | undefined;\n    body: CommentBody;\n    attachmentIds?: string[];\n  }) {\n    return httpClient.createThread({\n      roomId,\n      threadId: options.threadId,\n      commentId: options.commentId,\n      metadata: options.metadata,\n      body: options.body,\n      commentMetadata: options.commentMetadata,\n      attachmentIds: options.attachmentIds,\n    });\n  }\n\n  async function deleteThread(threadId: string) {\n    return httpClient.deleteThread({ roomId, threadId });\n  }\n\n  async function editThreadMetadata({\n    metadata,\n    threadId,\n  }: {\n    roomId: string;\n    metadata: Patchable<TM>;\n    threadId: string;\n  }) {\n    return httpClient.editThreadMetadata({ roomId, threadId, metadata });\n  }\n\n  async function editCommentMetadata({\n    threadId,\n    commentId,\n    metadata,\n  }: {\n    roomId: string;\n    threadId: string;\n    commentId: string;\n    metadata: Patchable<CM>;\n  }) {\n    return httpClient.editCommentMetadata({\n      roomId,\n      threadId,\n      commentId,\n      metadata,\n    });\n  }\n\n  async function markThreadAsResolved(threadId: string) {\n    return httpClient.markThreadAsResolved({ roomId, threadId });\n  }\n\n  async function markThreadAsUnresolved(threadId: string) {\n    return httpClient.markThreadAsUnresolved({\n      roomId,\n      threadId,\n    });\n  }\n\n  async function subscribeToThread(threadId: string) {\n    return httpClient.subscribeToThread({ roomId, threadId });\n  }\n\n  async function unsubscribeFromThread(threadId: string) {\n    return httpClient.unsubscribeFromThread({ roomId, threadId });\n  }\n\n  async function createComment(options: {\n    threadId: string;\n    commentId?: string;\n    body: CommentBody;\n    metadata?: CM;\n    attachmentIds?: string[];\n  }) {\n    return httpClient.createComment({\n      roomId,\n      threadId: options.threadId,\n      commentId: options.commentId,\n      body: options.body,\n      metadata: options.metadata,\n      attachmentIds: options.attachmentIds,\n    });\n  }\n\n  async function editComment(options: {\n    threadId: string;\n    commentId: string;\n    body: CommentBody;\n    metadata?: Patchable<CM>;\n    attachmentIds?: string[];\n  }) {\n    return httpClient.editComment({\n      roomId,\n      threadId: options.threadId,\n      commentId: options.commentId,\n      body: options.body,\n      metadata: options.metadata,\n      attachmentIds: options.attachmentIds,\n    });\n  }\n\n  async function deleteComment({\n    threadId,\n    commentId,\n  }: {\n    roomId: string;\n    threadId: string;\n    commentId: string;\n  }) {\n    return httpClient.deleteComment({ roomId, threadId, commentId });\n  }\n\n  async function addReaction({\n    threadId,\n    commentId,\n    emoji,\n  }: {\n    threadId: string;\n    commentId: string;\n    emoji: string;\n  }) {\n    return httpClient.addReaction({ roomId, threadId, commentId, emoji });\n  }\n\n  async function removeReaction({\n    threadId,\n    commentId,\n    emoji,\n  }: {\n    threadId: string;\n    commentId: string;\n    emoji: string;\n  }) {\n    return await httpClient.removeReaction({\n      roomId,\n      threadId,\n      commentId,\n      emoji,\n    });\n  }\n\n  function prepareAttachment(file: File): CommentLocalAttachment {\n    return {\n      type: \"localAttachment\",\n      status: \"idle\",\n      id: createCommentAttachmentId(),\n      name: file.name,\n      size: file.size,\n      mimeType: file.type,\n      file,\n    };\n  }\n\n  async function uploadAttachment(\n    attachment: CommentLocalAttachment,\n    options: UploadAttachmentOptions = {}\n  ): Promise<CommentAttachment> {\n    return httpClient.uploadAttachment({\n      roomId,\n      attachment,\n      signal: options.signal,\n    });\n  }\n\n  function getAttachmentUrl(attachmentId: string) {\n    return httpClient.getAttachmentUrl({ roomId, attachmentId });\n  }\n\n  function getSubscriptionSettings(\n    options?: GetSubscriptionSettingsOptions\n  ): Promise<RoomSubscriptionSettings> {\n    return httpClient.getSubscriptionSettings({\n      roomId,\n      signal: options?.signal,\n    });\n  }\n\n  function updateSubscriptionSettings(\n    settings: Partial<RoomSubscriptionSettings>\n  ): Promise<RoomSubscriptionSettings> {\n    return httpClient.updateSubscriptionSettings({ roomId, settings });\n  }\n\n  async function markInboxNotificationAsRead(inboxNotificationId: string) {\n    await httpClient.markRoomInboxNotificationAsRead({\n      roomId,\n      inboxNotificationId,\n    });\n  }\n\n  // Register a global source of pending changes for Storage™, so that the\n  // useSyncStatus() hook will be able to report this to end users\n  const syncSourceForYjs = config.createSyncSource();\n\n  function yjsStatusDidChange(status: YjsSyncStatus) {\n    return syncSourceForYjs.setSyncStatus(\n      status === \"synchronizing\" || status === \"loading\"\n        ? \"synchronizing\"\n        : \"synchronized\"\n    );\n  }\n\n  return Object.defineProperty(\n    {\n      [kInternal]: {\n        get presenceBuffer() { return deepClone(context.buffer.presenceUpdates?.data ?? null) }, // prettier-ignore\n        get undoStack() { return deepClone(context.undoStack) }, // prettier-ignore\n        get nodeCount() { return context.pool.nodes.size }, // prettier-ignore\n\n        getYjsProvider() {\n          return context.yjsProvider;\n        },\n\n        setYjsProvider(newProvider: IYjsProvider | undefined) {\n          // Deregister status change listener for the old Yjs provider\n          // Register status change listener for the new Yjs provider\n          context.yjsProvider?.off(\"status\", yjsStatusDidChange);\n          context.yjsProvider = newProvider;\n          newProvider?.on(\"status\", yjsStatusDidChange);\n          context.yjsProviderDidChange.notify();\n        },\n\n        yjsProviderDidChange: context.yjsProviderDidChange.observable,\n\n        // send metadata when using a text editor\n        reportTextEditor,\n        // create a text mention when using a text editor\n        createTextMention,\n        // delete a text mention when using a text editor\n        deleteTextMention,\n        // list versions of the document\n        listTextVersions,\n        // List versions of the document since the specified date\n        listTextVersionsSince,\n        // get a specific version\n        getTextVersion,\n        // create a version\n        createTextVersion,\n        // execute a contextual prompt\n        executeContextualPrompt,\n\n        // Support for the Liveblocks browser extension\n        getSelf_forDevTools: () => selfAsTreeNode.get(),\n        getOthers_forDevTools: (): readonly DevTools.UserTreeNode[] =>\n          others_forDevTools.get(),\n\n        // prettier-ignore\n        simulate: {\n          // These exist only for our E2E testing app\n          explicitClose: (event) => managedSocket._privateSendMachineEvent({ type: \"EXPLICIT_SOCKET_CLOSE\", event }),\n          rawSend: (data) => managedSocket.send(data),\n        },\n\n        attachmentUrlsStore: httpClient.getOrCreateAttachmentUrlsStore(roomId),\n      },\n\n      id: roomId,\n      subscribe: makeClassicSubscribeFn(\n        roomId,\n        events,\n        config.errorEventSource\n      ),\n\n      connect: () => managedSocket.connect(),\n      reconnect: () => managedSocket.reconnect(),\n      disconnect: () => managedSocket.disconnect(),\n      destroy: () => {\n        // remove the roomWillDestroy event from the event hub\n        const { roomWillDestroy, ...eventsExceptDestroy } = eventHub;\n        // Unregister all registered callbacks\n        for (const source of Object.values(eventsExceptDestroy)) {\n          source.dispose();\n        }\n        eventHub.roomWillDestroy.notify();\n        context.yjsProvider?.off(\"status\", yjsStatusDidChange);\n        syncSourceForStorage.destroy();\n        syncSourceForYjs.destroy();\n        uninstallBgTabSpy();\n        managedSocket.destroy();\n\n        // cleanup will destroy listener\n        roomWillDestroy.dispose();\n      },\n\n      // Presence\n      updatePresence,\n      updateYDoc,\n      broadcastEvent,\n\n      // Storage\n      batch,\n      history: {\n        undo,\n        redo,\n        canUndo,\n        canRedo,\n        clear,\n        pause: pauseHistory,\n        resume: resumeHistory,\n      },\n\n      fetchYDoc,\n      getStorage,\n      getStorageSnapshot,\n      getStorageStatus,\n\n      isPresenceReady,\n      isStorageReady,\n      waitUntilPresenceReady: memoizeOnSuccess(waitUntilPresenceReady),\n      waitUntilStorageReady: memoizeOnSuccess(waitUntilStorageReady),\n\n      events,\n\n      // Core\n      getStatus: () => managedSocket.getStatus(),\n      getSelf: () => self.get(),\n\n      // Presence\n      getPresence: () => context.myPresence.get(),\n      getOthers: () => context.others.get(),\n\n      // Comments\n      getThreads,\n      getThreadsSince,\n      getThread,\n      createThread,\n      deleteThread,\n      editThreadMetadata,\n      markThreadAsResolved,\n      markThreadAsUnresolved,\n      subscribeToThread,\n      unsubscribeFromThread,\n      createComment,\n      editComment,\n      editCommentMetadata,\n      deleteComment,\n      addReaction,\n      removeReaction,\n      prepareAttachment,\n      uploadAttachment,\n      getAttachmentUrl,\n\n      // Notifications\n      getNotificationSettings: getSubscriptionSettings,\n      getSubscriptionSettings,\n      updateNotificationSettings: updateSubscriptionSettings,\n      updateSubscriptionSettings,\n      markInboxNotificationAsRead,\n    },\n\n    // Explictly make the internal field non-enumerable, to avoid aggressive\n    // freezing when used with Immer\n    kInternal,\n    { enumerable: false }\n  );\n}\n\n/**\n * @internal\n * This recreates the classic single `.subscribe()` method for the Room API, as\n * documented here https://liveblocks.io/docs/api-reference/liveblocks-client#Room.subscribe(storageItem)\n */\nfunction makeClassicSubscribeFn<\n  P extends JsonObject,\n  S extends LsonObject,\n  U extends BaseUserMeta,\n  E extends Json,\n  TM extends BaseMetadata,\n  CM extends BaseMetadata,\n>(\n  roomId: string,\n  events: Room<P, S, U, E, TM, CM>[\"events\"],\n  errorEvents: EventSource<LiveblocksError>\n): SubscribeFn<P, S, U, E> {\n  // Set up the \"subscribe\" wrapper API\n  function subscribeToLiveStructureDeeply<L extends LiveStructure>(\n    node: L,\n    callback: (updates: StorageUpdate[]) => void\n  ): () => void {\n    return events.storageBatch.subscribe((updates) => {\n      const relatedUpdates = updates.filter((update) =>\n        isSameNodeOrChildOf(update.node, node)\n      );\n      if (relatedUpdates.length > 0) {\n        callback(relatedUpdates);\n      }\n    });\n  }\n\n  function subscribeToLiveStructureShallowly<L extends LiveStructure>(\n    node: L,\n    callback: (node: L) => void\n  ): () => void {\n    return events.storageBatch.subscribe((updates) => {\n      for (const update of updates) {\n        if (update.node._id === node._id) {\n          callback(update.node as L);\n        }\n      }\n    });\n  }\n\n  // Generic storage callbacks\n  function subscribe(callback: StorageCallback): () => void; // prettier-ignore\n  // Storage callbacks filtered by Live structure\n  function subscribe<L extends LiveStructure>(liveStructure: L, callback: (node: L) => void): () => void; // prettier-ignore\n  function subscribe(node: LiveStructure, callback: StorageCallback, options: { isDeep: true }): () => void; // prettier-ignore\n  // Room event callbacks\n  function subscribe<K extends RoomEventName>(type: K, listener: RoomEventCallbackFor<K, P, U, E>): () => void; // prettier-ignore\n\n  function subscribe<L extends LiveStructure, K extends RoomEventName>(\n    first: StorageCallback | L | K,\n    second?: ((node: L) => void) | StorageCallback | RoomEventCallback,\n    options?: { isDeep: boolean }\n  ): () => void {\n    if (typeof first === \"string\" && isRoomEventName(first)) {\n      if (typeof second !== \"function\") {\n        throw new Error(\"Second argument must be a callback function\");\n      }\n      const callback = second;\n      switch (first) {\n        case \"event\":\n          return events.customEvent.subscribe(\n            callback as Callback<RoomEventMessage<P, U, E>>\n          );\n\n        case \"my-presence\":\n          return events.myPresence.subscribe(callback as Callback<P>);\n\n        case \"others\": {\n          // NOTE: Others have a different callback structure, where the API\n          // exposed on the outside takes _two_ callback arguments!\n          const cb = callback as LegacyOthersEventCallback<P, U>;\n          return events.others.subscribe((event) => {\n            const { others, ...internalEvent } = event;\n            return cb(others, internalEvent);\n          });\n        }\n\n        case \"error\": {\n          return errorEvents.subscribe((err) => {\n            if (err.roomId === roomId) {\n              return (callback as Callback<Error>)(err);\n            }\n          });\n        }\n\n        case \"status\":\n          return events.status.subscribe(callback as Callback<Status>);\n\n        case \"lost-connection\":\n          return events.lostConnection.subscribe(\n            callback as Callback<LostConnectionEvent>\n          );\n\n        case \"history\":\n          return events.history.subscribe(callback as Callback<HistoryEvent>);\n\n        case \"storage-status\":\n          return events.storageStatus.subscribe(\n            callback as Callback<StorageStatus>\n          );\n\n        case \"comments\":\n          return events.comments.subscribe(\n            callback as Callback<CommentsEventServerMsg>\n          );\n\n        // istanbul ignore next\n        default:\n          return assertNever(\n            first,\n            `\"${String(first)}\" is not a valid event name`\n          );\n      }\n    }\n\n    if (second === undefined || typeof first === \"function\") {\n      if (typeof first === \"function\") {\n        const storageCallback = first;\n        return events.storageBatch.subscribe(storageCallback);\n      } else {\n        // istanbul ignore next\n        throw new Error(\"Please specify a listener callback\");\n      }\n    }\n\n    if (isLiveNode(first)) {\n      const node = first;\n      if (options?.isDeep) {\n        const storageCallback = second as StorageCallback;\n        return subscribeToLiveStructureDeeply(node, storageCallback);\n      } else {\n        const nodeCallback = second as (node: L) => void;\n        return subscribeToLiveStructureShallowly(node, nodeCallback);\n      }\n    }\n\n    throw new Error(\n      `${String(first)} is not a value that can be subscribed to.`\n    );\n  }\n\n  return subscribe;\n}\n\nfunction isRoomEventName(value: string) {\n  return (\n    value === \"my-presence\" ||\n    value === \"others\" ||\n    value === \"event\" ||\n    value === \"error\" ||\n    value === \"history\" ||\n    value === \"status\" ||\n    value === \"storage-status\" ||\n    value === \"lost-connection\" ||\n    value === \"connection\" ||\n    value === \"comments\"\n  );\n}\n\nexport function makeAuthDelegateForRoom(\n  roomId: string,\n  authManager: AuthManager\n): () => Promise<AuthValue> {\n  return async () => {\n    return authManager.getAuthValue({ requestedScope: \"room:read\", roomId });\n  };\n}\n\nexport function makeCreateSocketDelegateForRoom(\n  roomId: string,\n  baseUrl: string,\n  WebSocketPolyfill?: IWebSocket,\n  engine?: 1 | 2\n) {\n  return (authValue: AuthValue): IWebSocketInstance => {\n    const ws: IWebSocket | undefined =\n      WebSocketPolyfill ??\n      (typeof WebSocket === \"undefined\" ? undefined : WebSocket);\n\n    if (ws === undefined) {\n      throw new StopRetrying(\n        \"To use Liveblocks client in a non-DOM environment, you need to provide a WebSocket polyfill.\"\n      );\n    }\n\n    const url = new URL(baseUrl);\n    url.protocol = url.protocol === \"http:\" ? \"ws\" : \"wss\";\n    url.pathname = \"/v8\";\n    url.searchParams.set(\"roomId\", roomId);\n    if (authValue.type === \"secret\") {\n      url.searchParams.set(\"tok\", authValue.token.raw);\n    } else if (authValue.type === \"public\") {\n      url.searchParams.set(\"pubkey\", authValue.publicApiKey);\n    } else {\n      return assertNever(authValue, \"Unhandled case\");\n    }\n    url.searchParams.set(\"version\", PKG_VERSION || \"dev\");\n    if (engine !== undefined) {\n      url.searchParams.set(\"e\", String(engine));\n    }\n    return new ws(url.toString());\n  };\n}\n","import { type Ai, createAi, makeCreateSocketDelegateForAi } from \"./ai\";\nimport type { LiveblocksHttpApi } from \"./api-client\";\nimport { createApiClient } from \"./api-client\";\nimport { createAuthManager } from \"./auth-manager\";\nimport { isIdle, StopRetrying } from \"./connection\";\nimport { DEFAULT_BASE_URL } from \"./constants\";\nimport type { LsonObject } from \"./crdts/Lson\";\nimport { linkDevTools, setupDevTools, unlinkDevTools } from \"./devtools\";\nimport type {\n  DCM,\n  DE,\n  DGI,\n  DP,\n  DRI,\n  DS,\n  DTM,\n  DU,\n} from \"./globals/augmentation\";\nimport { kInternal } from \"./internal\";\nimport type { BatchStore } from \"./lib/batch\";\nimport { Batch, createBatchStore } from \"./lib/batch\";\nimport type { Observable } from \"./lib/EventSource\";\nimport { makeEventSource } from \"./lib/EventSource\";\nimport * as console from \"./lib/fancy-console\";\nimport type { Json, JsonObject } from \"./lib/Json\";\nimport type { NoInfr } from \"./lib/NoInfer\";\nimport type { Relax } from \"./lib/Relax\";\nimport type { Resolve } from \"./lib/Resolve\";\nimport { Signal } from \"./lib/signals\";\nimport { warnOnceIf } from \"./lib/warnings\";\nimport type { CustomAuthenticationResult } from \"./protocol/Authentication\";\nimport type { BaseUserMeta } from \"./protocol/BaseUserMeta\";\nimport type {\n  BaseMetadata,\n  ThreadData,\n  ThreadDeleteInfo,\n} from \"./protocol/Comments\";\nimport type {\n  InboxNotificationData,\n  InboxNotificationDeleteInfo,\n} from \"./protocol/InboxNotifications\";\nimport type { MentionData } from \"./protocol/MentionData\";\nimport type {\n  NotificationSettings,\n  PartialNotificationSettings,\n} from \"./protocol/NotificationSettings\";\nimport { createNotificationSettings } from \"./protocol/NotificationSettings\";\nimport type {\n  SubscriptionData,\n  SubscriptionDeleteInfo,\n} from \"./protocol/Subscriptions\";\nimport type {\n  OpaqueRoom,\n  OptionalTupleUnless,\n  PartialUnless,\n  Polyfills,\n  Room,\n  RoomDelegates,\n  SyncSource,\n} from \"./room\";\nimport {\n  createRoom,\n  makeAuthDelegateForRoom,\n  makeCreateSocketDelegateForRoom,\n} from \"./room\";\nimport type { Awaitable } from \"./types/Awaitable\";\nimport type { LiveblocksErrorContext } from \"./types/LiveblocksError\";\nimport { LiveblocksError } from \"./types/LiveblocksError\";\nimport type { BadgeLocation } from \"./types/Others\";\n\nconst MIN_THROTTLE = 16;\nconst MAX_THROTTLE = 1_000;\nconst DEFAULT_THROTTLE = 100;\n\nconst MIN_BACKGROUND_KEEP_ALIVE_TIMEOUT = 15_000;\nconst MIN_LOST_CONNECTION_TIMEOUT = 200;\nconst RECOMMENDED_MIN_LOST_CONNECTION_TIMEOUT = 1_000;\nconst MAX_LOST_CONNECTION_TIMEOUT = 30_000;\nconst DEFAULT_LOST_CONNECTION_TIMEOUT = 5_000;\n\nconst RESOLVE_USERS_BATCH_DELAY = 50;\nconst RESOLVE_ROOMS_INFO_BATCH_DELAY = 50;\nconst RESOLVE_GROUPS_INFO_BATCH_DELAY = 50;\n\nexport type ResolveMentionSuggestionsArgs = {\n  /**\n   * The ID of the current room.\n   */\n  roomId: string;\n\n  /**\n   * The text to search for.\n   */\n  text: string;\n};\n\nexport type ResolveUsersArgs = {\n  /**\n   * The IDs of the users to resolve.\n   */\n  userIds: string[];\n};\n\nexport type ResolveRoomsInfoArgs = {\n  /**\n   * The IDs of the rooms to resolve.\n   */\n  roomIds: string[];\n};\n\nexport type ResolveGroupsInfoArgs = {\n  /**\n   * The IDs of the groups to resolve.\n   */\n  groupIds: string[];\n};\n\nexport type EnterOptions<P extends JsonObject = DP, S extends LsonObject = DS> =\n  // prettier-ignore\n  Resolve<\n  {\n    /**\n     * Whether or not the room automatically connects to Liveblock servers.\n     * Default is true.\n     *\n     * Usually set to false when the client is used from the server to not call\n     * the authentication endpoint or connect via WebSocket.\n     */\n    autoConnect?: boolean;\n\n    /**\n     * Preferred storage engine version to use when creating the room. Only\n     * takes effect if the room doesn't exist yet. Version 2 can support larger\n     * documents, is more performant, and will become the default in the future.\n     */\n    engine?: 1 | 2;\n  }\n\n  // Initial presence is only mandatory if the custom type requires it to be\n  & PartialUnless<\n    P,\n    {\n      /**\n       * The initial Presence to use and announce when you enter the Room. The\n       * Presence is available on all users in the Room (me & others).\n       */\n      initialPresence: P | ((roomId: string) => P);\n    }\n  >\n  \n  // Initial storage is only mandatory if the custom type requires it to be\n  & PartialUnless<\n    S,\n    {\n      /**\n       * The initial Storage to use when entering a new Room.\n       */\n      initialStorage: S | ((roomId: string) => S);\n    }\n  >\n>;\n\nexport type SyncStatus =\n  /* Liveblocks is in the process of writing changes */\n  | \"synchronizing\"\n  /* Liveblocks has persisted all pending changes */\n  | \"synchronized\";\n\n/**\n * \"synchronizing\"     - Liveblocks is in the process of writing changes\n * \"synchronized\"      - Liveblocks has persisted all pending changes\n * \"has-local-changes\" - There is local pending state inputted by the user, but\n *                       we're not yet \"synchronizing\" it until a user\n *                       interaction, like the draft text in a comment box.\n */\nexport type InternalSyncStatus = SyncStatus | \"has-local-changes\";\n\n/**\n * @private\n *\n * Private methods and variables used in the core internals, but as a user\n * of Liveblocks, NEVER USE ANY OF THESE DIRECTLY, because bad things\n * will probably happen if you do.\n */\nexport type PrivateClientApi<\n  U extends BaseUserMeta,\n  TM extends BaseMetadata,\n  CM extends BaseMetadata,\n> = {\n  readonly currentUserId: Signal<string | undefined>;\n  readonly mentionSuggestionsCache: Map<string, MentionData[]>;\n  readonly resolveMentionSuggestions: ClientOptions<U>[\"resolveMentionSuggestions\"];\n  readonly usersStore: BatchStore<U[\"info\"] | undefined, string>;\n  readonly roomsInfoStore: BatchStore<DRI | undefined, string>;\n  readonly groupsInfoStore: BatchStore<DGI | undefined, string>;\n  readonly getRoomIds: () => string[];\n  readonly httpClient: LiveblocksHttpApi<TM, CM>;\n  // Type-level helper\n  as<TM2 extends BaseMetadata, CM2 extends BaseMetadata>(): Client<U, TM2, CM2>;\n  // Tracking pending changes globally\n  createSyncSource(): SyncSource;\n  emitError(context: LiveblocksErrorContext, cause?: Error): void;\n  ai: Ai;\n};\n\nexport type NotificationsApi<\n  TM extends BaseMetadata,\n  CM extends BaseMetadata,\n> = {\n  /**\n   * Gets a page (or the initial page) for user inbox notifications and their\n   * associated threads and thread subscriptions.\n   *\n   * This function should NOT be used for delta updates, only for pagination\n   * (including the first page fetch). For delta updates (done during the\n   * periodic polling), use the `getInboxNotificationsSince` function.\n   *\n   * @example\n   * const {\n   *   inboxNotifications,\n   *   threads,\n   *   subscriptions,\n   *   nextCursor,\n   * } = await client.getInboxNotifications();\n   * const data = await client.getInboxNotifications();  // Fetch initial page (of 20 inbox notifications)\n   * const data = await client.getInboxNotifications({ cursor: nextCursor });  // Fetch next page (= next 20 inbox notifications)\n   */\n  getInboxNotifications(options?: {\n    cursor?: string;\n    query?: { roomId?: string; kind?: string };\n  }): Promise<{\n    inboxNotifications: InboxNotificationData[];\n    threads: ThreadData<TM, CM>[];\n    subscriptions: SubscriptionData[];\n    nextCursor: string | null;\n    requestedAt: Date;\n  }>;\n\n  /**\n   * Fetches a \"delta update\" since the last time we updated.\n   *\n   * This function should NOT be used for pagination, for that, see the\n   * `getInboxNotifications` function.\n   *\n   * @example\n   * const {\n   *   inboxNotifications: {\n   *     updated,\n   *     deleted,\n   *   },\n   *   threads: {\n   *     updated,\n   *     deleted,\n   *   },\n   *   subscriptions: {\n   *     updated,\n   *     deleted,\n   *   },\n   *   requestedAt,\n   * } = await client.getInboxNotificationsSince({ since: result.requestedAt }});\n   */\n  getInboxNotificationsSince(options: {\n    since: Date;\n    query?: { roomId?: string; kind?: string };\n    signal?: AbortSignal;\n  }): Promise<{\n    inboxNotifications: {\n      updated: InboxNotificationData[];\n      deleted: InboxNotificationDeleteInfo[];\n    };\n    threads: {\n      updated: ThreadData<TM, CM>[];\n      deleted: ThreadDeleteInfo[];\n    };\n    subscriptions: {\n      updated: SubscriptionData[];\n      deleted: SubscriptionDeleteInfo[];\n    };\n    requestedAt: Date;\n  }>;\n\n  /**\n   * Gets the number of unread inbox notifications for the current user.\n   *\n   * @example\n   * const count = await client.getUnreadInboxNotificationsCount();\n   */\n  getUnreadInboxNotificationsCount(options?: {\n    query?: {\n      roomId?: string;\n      kind?: string;\n    };\n    signal?: AbortSignal;\n  }): Promise<number>;\n\n  /**\n   * Marks all inbox notifications as read.\n   *\n   * @example\n   * await client.markAllInboxNotificationsAsRead();\n   */\n  markAllInboxNotificationsAsRead(): Promise<void>;\n\n  /**\n   * Marks an inbox notification as read.\n   *\n   * @example\n   * await client.markInboxNotificationAsRead(\"in_xxx\");\n   */\n  markInboxNotificationAsRead(inboxNotificationId: string): Promise<void>;\n\n  /**\n   * Deletes all inbox notifications for the current user.\n   *\n   * @example\n   * await client.deleteAllInboxNotifications();\n   */\n  deleteAllInboxNotifications(): Promise<void>;\n\n  /**\n   * Deletes an inbox notification for the current user.\n   *\n   * @example\n   * await client.deleteInboxNotification(\"in_xxx\");\n   */\n  deleteInboxNotification(inboxNotificationId: string): Promise<void>;\n\n  /**\n   * Gets notifications settings for a user for a project.\n   *\n   * @example\n   * const notificationSettings = await client.getNotificationSettings();\n   */\n  getNotificationSettings(options?: {\n    signal?: AbortSignal;\n  }): Promise<NotificationSettings>;\n\n  /**\n   * Update notifications settings for a user for a project.\n   *\n   * @example\n   * await client.updateNotificationSettings({\n   *  email: {\n   *    thread: true,\n   *    textMention: false,\n   *    $customKind1: true,\n   *  }\n   * })\n   */\n  updateNotificationSettings(\n    settings: PartialNotificationSettings\n  ): Promise<NotificationSettings>;\n};\n\n/**\n * @private Widest-possible Client type, matching _any_ Client instance. Note\n * that this type is different from `Client`-without-type-arguments. That\n * represents a Client instance using globally augmented types only, which is\n * narrower.\n */\nexport type OpaqueClient = Client<BaseUserMeta>;\n\nexport type Client<\n  U extends BaseUserMeta = DU,\n  TM extends BaseMetadata = DTM,\n  CM extends BaseMetadata = DCM,\n> = {\n  /**\n   * Gets a room. Returns null if {@link Client.enter} has not been called previously.\n   *\n   * @param roomId The id of the room\n   */\n  getRoom<\n    P extends JsonObject = DP,\n    S extends LsonObject = DS,\n    E extends Json = DE,\n    TM2 extends BaseMetadata = TM,\n    CM2 extends BaseMetadata = CM,\n  >(\n    roomId: string\n  ): Room<P, S, U, E, TM2, CM2> | null;\n\n  /**\n   * Enter a room.\n   * @param roomId The id of the room\n   * @param options Optional. You can provide initializers for the Presence or Storage when entering the Room.\n   * @returns The room and a leave function. Call the returned leave() function when you no longer need the room.\n   */\n  enterRoom<\n    P extends JsonObject = DP,\n    S extends LsonObject = DS,\n    E extends Json = DE,\n    TM2 extends BaseMetadata = TM,\n    CM2 extends BaseMetadata = CM,\n  >(\n    roomId: string,\n    ...args: OptionalTupleUnless<\n      P & S,\n      [options: EnterOptions<NoInfr<P>, NoInfr<S>>]\n    >\n  ): {\n    room: Room<P, S, U, E, TM2, CM2>;\n    leave: () => void;\n  };\n\n  /**\n   * Purges all cached auth tokens and reconnects all rooms that are still\n   * connected, if any.\n   *\n   * Call this whenever you log out a user in your application.\n   */\n  logout(): void;\n\n  /**\n   * Advanced APIs related to the resolvers.\n   */\n  resolvers: {\n    /**\n     * Invalidate some or all users that were previously cached by `resolveUsers`.\n     *\n     * @example\n     * // Invalidate all users\n     * client.resolvers.invalidateUsers();\n     *\n     * @example\n     * // Invalidate specific users\n     * client.resolvers.invalidateUsers([\"user-1\", \"user-2\"]);\n     */\n    invalidateUsers(userIds?: string[]): void;\n\n    /**\n     * Invalidate some or all rooms info that were previously cached by `resolveRoomsInfo`.\n     *\n     * @example\n     * // Invalidate all rooms\n     * client.resolvers.invalidateRoomsInfo();\n     *\n     * @example\n     * // Invalidate specific rooms\n     * client.resolvers.invalidateRoomsInfo([\"room-1\", \"room-2\"]);\n     */\n    invalidateRoomsInfo(roomIds?: string[]): void;\n\n    /**\n     * Invalidate some or all groups info that were previously cached by `resolveGroupsInfo`.\n     *\n     * @example\n     * // Invalidate all groups\n     * client.resolvers.invalidateGroupsInfo();\n     *\n     * @example\n     * // Invalidate specific groups\n     * client.resolvers.invalidateGroupsInfo([\"group-1\", \"group-2\"]);\n     */\n    invalidateGroupsInfo(groupIds?: string[]): void;\n\n    /**\n     * Invalidate all mention suggestions cached by `resolveMentionSuggestions`.\n     *\n     * @example\n     * // Invalidate all mention suggestions\n     * client.resolvers.invalidateMentionSuggestions();\n     */\n    invalidateMentionSuggestions(): void;\n  };\n\n  /**\n   * @private\n   *\n   * Private methods and variables used in the core internals, but as a user\n   * of Liveblocks, NEVER USE ANY OF THESE DIRECTLY, because bad things\n   * will probably happen if you do.\n   */\n  // TODO Make this a getter, so we can provide M\n  readonly [kInternal]: PrivateClientApi<U, TM, CM>;\n\n  /**\n   * Returns the current global sync status of the Liveblocks client. If any\n   * part of Liveblocks has any local pending changes that haven't been\n   * confirmed by or persisted by the server yet, this will be \"synchronizing\",\n   * otherwise \"synchronized\".\n   *\n   * This is a combined status for all of the below parts of Liveblocks:\n   * - Storage (realtime APIs)\n   * - Text Editors\n   * - Comments\n   * - Notifications\n   *\n   * @example\n   * const status = client.getSyncStatus();  // \"synchronizing\" | \"synchronized\"\n   */\n  getSyncStatus(): SyncStatus;\n\n  /**\n   * All possible client events, subscribable from a single place.\n   */\n  readonly events: {\n    readonly error: Observable<LiveblocksError>;\n    readonly syncStatus: Observable<void>;\n  };\n} & NotificationsApi<TM, CM>;\n\nexport type AuthEndpoint =\n  | string\n  | ((room?: string) => Promise<CustomAuthenticationResult>);\n\n/**\n * The authentication endpoint that is called to ensure that the current user has access to a room.\n * Can be an url or a callback if you need to add additional headers.\n */\nexport type ClientOptions<U extends BaseUserMeta = DU> = {\n  throttle?: number; // in milliseconds\n  lostConnectionTimeout?: number; // in milliseconds\n  backgroundKeepAliveTimeout?: number; // in milliseconds\n  polyfills?: Polyfills;\n  /**\n   * @deprecated For new rooms, use `engine: 2` instead. Rooms on the v2\n   * Storage engine have native support for streaming. This flag will be\n   * removed in a future version, but will continue to work for existing engine\n   * v1 rooms for now.\n   */\n  unstable_streamData?: boolean;\n  /**\n   * A function that returns a list of mention suggestions matching a string.\n   */\n  resolveMentionSuggestions?: (\n    args: ResolveMentionSuggestionsArgs\n  ) => Awaitable<string[] | MentionData[]>;\n\n  /**\n   * A function that returns user info from user IDs.\n   * You should return a list of user objects of the same size, in the same order.\n   */\n  resolveUsers?: (\n    args: ResolveUsersArgs\n  ) => Awaitable<(U[\"info\"] | undefined)[] | undefined>;\n\n  /**\n   * A function that returns room info from room IDs.\n   * You should return a list of room info objects of the same size, in the same order.\n   */\n  resolveRoomsInfo?: (\n    args: ResolveRoomsInfoArgs\n  ) => Awaitable<(DRI | undefined)[] | undefined>;\n\n  /**\n   * A function that returns group info from group IDs.\n   * You should return a list of group info objects of the same size, in the same order.\n   */\n  resolveGroupsInfo?: (\n    args: ResolveGroupsInfoArgs\n  ) => Awaitable<(DGI | undefined)[] | undefined>;\n\n  /**\n   * Prevent the current browser tab from being closed if there are any locally\n   * pending Liveblocks changes that haven't been submitted to or confirmed by\n   * the server yet.\n   */\n  preventUnsavedChanges?: boolean;\n\n  /**\n   * The location where the brand badge should be displayed when using a free plan.\n   * Default is \"bottom-right\".\n   */\n  badgeLocation?: BadgeLocation;\n\n  /** Point the client to an alternative Liveblocks server. */\n  baseUrl?: string;\n\n  /** @internal */\n  mockedDelegates?: RoomDelegates;\n\n  /** @internal */\n  enableDebugLogging?: boolean;\n\n  /** @internal */\n  __DANGEROUSLY_disableThrottling?: true; // for unit testing purposes only, never use this in production\n} & Relax<{ publicApiKey: string } | { authEndpoint: AuthEndpoint }>;\n\nfunction getBaseUrl(baseUrl?: string | undefined): string {\n  if (\n    typeof baseUrl === \"string\" &&\n    baseUrl.startsWith(\"http\") // Must be http or https URL\n  ) {\n    return baseUrl;\n  } else {\n    return DEFAULT_BASE_URL;\n  }\n}\n\n/**\n * Create a client that will be responsible to communicate with liveblocks servers.\n *\n * @example\n * const client = createClient({\n *   authEndpoint: \"/api/auth\"\n * });\n *\n * // It's also possible to use a function to call your authentication endpoint.\n * // Useful to add additional headers or use an API wrapper (like Firebase functions)\n * const client = createClient({\n *   authEndpoint: async (room?) => {\n *     const response = await fetch(\"/api/auth\", {\n *       method: \"POST\",\n *       headers: {\n *          Authentication: \"token\",\n *          \"Content-Type\": \"application/json\"\n *       },\n *       body: JSON.stringify({ room })\n *     });\n *\n *     return await response.json(); // should be: { token: \"...\" }\n *   }\n * });\n */\nexport function createClient<U extends BaseUserMeta = DU>(\n  options: ClientOptions<U>\n): Client<U> {\n  const clientOptions = options;\n  const throttleDelay =\n    process.env.NODE_ENV !== \"production\" &&\n    clientOptions.__DANGEROUSLY_disableThrottling\n      ? 0\n      : getThrottle(clientOptions.throttle ?? DEFAULT_THROTTLE);\n  const lostConnectionTimeout = getLostConnectionTimeout(\n    clientOptions.lostConnectionTimeout ?? DEFAULT_LOST_CONNECTION_TIMEOUT\n  );\n  const backgroundKeepAliveTimeout = getBackgroundKeepAliveTimeout(\n    clientOptions.backgroundKeepAliveTimeout\n  );\n  const baseUrl = getBaseUrl(clientOptions.baseUrl);\n\n  const currentUserId = new Signal<string | undefined>(undefined);\n\n  const authManager = createAuthManager(options, (token) => {\n    currentUserId.set(() => token.uid);\n  });\n\n  const fetchPolyfill =\n    clientOptions.polyfills?.fetch ||\n    /* istanbul ignore next */ globalThis.fetch?.bind(globalThis);\n\n  const httpClient = createApiClient({\n    baseUrl,\n    fetchPolyfill,\n    currentUserId,\n    authManager,\n  });\n\n  type RoomDetails = {\n    room: OpaqueRoom;\n    unsubs: Set<() => void>;\n  };\n\n  const roomsById = new Map<string, RoomDetails>();\n\n  const ai = createAi({\n    userId: currentUserId.get(),\n    lostConnectionTimeout,\n    backgroundKeepAliveTimeout: getBackgroundKeepAliveTimeout(\n      clientOptions.backgroundKeepAliveTimeout\n    ),\n    polyfills: clientOptions.polyfills,\n    delegates: {\n      createSocket: makeCreateSocketDelegateForAi(\n        baseUrl,\n        clientOptions.polyfills?.WebSocket\n      ),\n      authenticate: async () => {\n        const resp = await authManager.getAuthValue({\n          requestedScope: \"room:read\",\n        });\n        if (resp.type === \"public\") {\n          throw new StopRetrying(\n            \"Cannot use AI Copilots with a public API key\"\n          );\n        }\n        return resp;\n      },\n      canZombie: () => false,\n    },\n  });\n\n  function teardownRoom(room: OpaqueRoom) {\n    unlinkDevTools(room.id);\n    roomsById.delete(room.id);\n    room.destroy();\n  }\n\n  function leaseRoom<\n    P extends JsonObject,\n    S extends LsonObject,\n    U extends BaseUserMeta,\n    E extends Json,\n    TM extends BaseMetadata,\n    CM extends BaseMetadata,\n  >(\n    details: RoomDetails\n  ): {\n    room: Room<P, S, U, E, TM, CM>;\n    leave: () => void;\n  } {\n    // Create a new self-destructing leave function\n    const leave = () => {\n      const self = leave; // A reference to the currently executing function itself\n\n      if (!details.unsubs.delete(self)) {\n        console.warn(\n          \"This leave function was already called. Calling it more than once has no effect.\"\n        );\n      } else {\n        // Was this the last room lease? If so, tear down the room\n        if (details.unsubs.size === 0) {\n          teardownRoom(details.room);\n        }\n      }\n    };\n\n    details.unsubs.add(leave);\n    return {\n      room: details.room as Room<P, S, U, E, TM, CM>,\n      leave,\n    };\n  }\n\n  function enterRoom<\n    P extends JsonObject,\n    S extends LsonObject,\n    U extends BaseUserMeta,\n    E extends Json,\n    TM extends BaseMetadata,\n    CM extends BaseMetadata,\n  >(\n    roomId: string,\n    ...args: OptionalTupleUnless<\n      P & S,\n      [options: EnterOptions<NoInfr<P>, NoInfr<S>>]\n    >\n  ): {\n    room: Room<P, S, U, E, TM, CM>;\n    leave: () => void;\n  } {\n    const existing = roomsById.get(roomId);\n    if (existing !== undefined) {\n      return leaseRoom(existing);\n    }\n\n    const options = args[0] ?? ({} as EnterOptions<P, S>);\n    const initialPresence =\n      (typeof options.initialPresence === \"function\"\n        ? options.initialPresence(roomId)\n        : options.initialPresence) ?? ({} as P);\n\n    const initialStorage =\n      (typeof options.initialStorage === \"function\"\n        ? options.initialStorage(roomId)\n        : options.initialStorage) ?? ({} as S);\n\n    const newRoom = createRoom<P, S, U, E, TM, CM>(\n      { initialPresence, initialStorage },\n      {\n        roomId,\n        throttleDelay,\n        lostConnectionTimeout,\n        backgroundKeepAliveTimeout,\n        polyfills: clientOptions.polyfills,\n        delegates: clientOptions.mockedDelegates ?? {\n          createSocket: makeCreateSocketDelegateForRoom(\n            roomId,\n            baseUrl,\n            clientOptions.polyfills?.WebSocket,\n            options.engine\n          ),\n          authenticate: makeAuthDelegateForRoom(roomId, authManager),\n        },\n        enableDebugLogging: clientOptions.enableDebugLogging,\n        baseUrl,\n        errorEventSource: liveblocksErrorSource,\n        unstable_streamData: !!clientOptions.unstable_streamData,\n        roomHttpClient: httpClient as LiveblocksHttpApi<TM, CM>,\n        createSyncSource,\n        badgeLocation: clientOptions.badgeLocation ?? \"bottom-right\",\n      }\n    );\n\n    const newRoomDetails: RoomDetails = {\n      room: newRoom,\n      unsubs: new Set(),\n    };\n    roomsById.set(roomId, newRoomDetails);\n\n    setupDevTools(() => Array.from(roomsById.keys()));\n    linkDevTools(roomId, newRoom);\n\n    const shouldConnect = options.autoConnect ?? true;\n    if (shouldConnect) {\n      // we need to check here because nextjs would fail earlier with Node < 16\n      if (typeof atob === \"undefined\") {\n        if (clientOptions.polyfills?.atob === undefined) {\n          throw new Error(\n            \"You need to polyfill atob to use the client in your environment. Please follow the instructions at https://liveblocks.io/docs/errors/liveblocks-client/atob-polyfill\"\n          );\n        }\n        // At this point, atob does not exist so we are either on React Native or on Node < 16, hence global is available.\n        global.atob = clientOptions.polyfills.atob;\n      }\n\n      newRoom.connect();\n    }\n\n    return leaseRoom(newRoomDetails);\n  }\n\n  function getRoom<\n    P extends JsonObject,\n    S extends LsonObject,\n    U extends BaseUserMeta,\n    E extends Json,\n    TM extends BaseMetadata,\n    CM extends BaseMetadata,\n  >(roomId: string): Room<P, S, U, E, TM, CM> | null {\n    const room = roomsById.get(roomId)?.room;\n    return room ? (room as Room<P, S, U, E, TM, CM>) : null;\n  }\n\n  function logout() {\n    authManager.reset();\n\n    // Reset the current user id store when the client is logged out\n    currentUserId.set(() => undefined);\n\n    // Reconnect all rooms that aren't idle, if any. This ensures that those\n    // rooms will get reauthorized now that the auth cache is reset. If that\n    // fails, they might disconnect.\n    for (const { room } of roomsById.values()) {\n      if (!isIdle(room.getStatus())) {\n        room.reconnect();\n      }\n    }\n  }\n\n  const resolveUsers = clientOptions.resolveUsers;\n  const batchedResolveUsers = new Batch(\n    async (batchedUserIds: string[]) => {\n      const userIds = batchedUserIds.flat();\n      const users = await resolveUsers?.({ userIds });\n\n      warnOnceIf(\n        !resolveUsers,\n        \"Set the resolveUsers option in createClient to specify user info.\"\n      );\n\n      return users ?? userIds.map(() => undefined);\n    },\n    { delay: RESOLVE_USERS_BATCH_DELAY }\n  );\n  const usersStore = createBatchStore(batchedResolveUsers);\n\n  function invalidateResolvedUsers(userIds?: string[]) {\n    usersStore.invalidate(userIds);\n  }\n\n  const resolveRoomsInfo = clientOptions.resolveRoomsInfo;\n  const batchedResolveRoomsInfo = new Batch(\n    async (batchedRoomIds: string[]) => {\n      const roomIds = batchedRoomIds.flat();\n      const roomsInfo = await resolveRoomsInfo?.({ roomIds });\n\n      warnOnceIf(\n        !resolveRoomsInfo,\n        \"Set the resolveRoomsInfo option in createClient to specify room info.\"\n      );\n\n      return roomsInfo ?? roomIds.map(() => undefined);\n    },\n    { delay: RESOLVE_ROOMS_INFO_BATCH_DELAY }\n  );\n  const roomsInfoStore = createBatchStore(batchedResolveRoomsInfo);\n\n  function invalidateResolvedRoomsInfo(roomIds?: string[]) {\n    roomsInfoStore.invalidate(roomIds);\n  }\n\n  const resolveGroupsInfo = clientOptions.resolveGroupsInfo;\n  const batchedResolveGroupsInfo = new Batch(\n    async (batchedGroupIds: string[]) => {\n      const groupIds = batchedGroupIds.flat();\n      const groupsInfo = await resolveGroupsInfo?.({ groupIds });\n\n      warnOnceIf(\n        !resolveGroupsInfo,\n        \"Set the resolveGroupsInfo option in createClient to specify group info.\"\n      );\n\n      return groupsInfo ?? groupIds.map(() => undefined);\n    },\n    { delay: RESOLVE_GROUPS_INFO_BATCH_DELAY }\n  );\n  const groupsInfoStore = createBatchStore(batchedResolveGroupsInfo);\n\n  function invalidateResolvedGroupsInfo(groupIds?: string[]) {\n    groupsInfoStore.invalidate(groupIds);\n  }\n\n  const mentionSuggestionsCache = new Map<string, MentionData[]>();\n\n  function invalidateResolvedMentionSuggestions() {\n    mentionSuggestionsCache.clear();\n  }\n\n  // ----------------------------------------------------------------\n\n  const syncStatusSources: Signal<InternalSyncStatus>[] = [];\n  const syncStatusSignal = new Signal<InternalSyncStatus>(\"synchronized\");\n\n  const liveblocksErrorSource = makeEventSource<LiveblocksError>();\n\n  function getSyncStatus(): SyncStatus {\n    const status = syncStatusSignal.get();\n    return status === \"synchronizing\" ? status : \"synchronized\";\n  }\n\n  function recompute() {\n    syncStatusSignal.set(\n      syncStatusSources.some((src) => src.get() === \"synchronizing\")\n        ? \"synchronizing\"\n        : syncStatusSources.some((src) => src.get() === \"has-local-changes\")\n          ? \"has-local-changes\"\n          : \"synchronized\"\n    );\n  }\n\n  function createSyncSource(): SyncSource {\n    const source = new Signal<InternalSyncStatus>(\"synchronized\");\n    syncStatusSources.push(source);\n\n    const unsub = source.subscribe(() => recompute());\n\n    function setSyncStatus(status: InternalSyncStatus) {\n      source.set(status);\n    }\n\n    function destroy() {\n      unsub();\n      const index = syncStatusSources.findIndex((item) => item === source);\n      if (index > -1) {\n        const [ref] = syncStatusSources.splice(index, 1);\n        const wasStillPending = ref.get() !== \"synchronized\";\n        if (wasStillPending) {\n          // We only have to recompute if it was still pending. Otherwise it\n          // could not have an effect on the global state anyway.\n          recompute();\n        }\n      }\n    }\n\n    return { setSyncStatus, destroy };\n  }\n\n  // ----------------------------------------------------------------\n\n  // Set up event handler that will prevent the browser tab from being closed\n  // if there are locally pending changes to any part of Liveblocks (Storage,\n  // text editors, Threads, Notifications, etc)\n  {\n    const maybePreventClose = (e: BeforeUnloadEvent) => {\n      if (\n        clientOptions.preventUnsavedChanges &&\n        syncStatusSignal.get() !== \"synchronized\"\n      ) {\n        e.preventDefault();\n      }\n    };\n\n    // A Liveblocks client is currently never destroyed.\n    // TODO Call win.removeEventListener(\"beforeunload\", maybePreventClose)\n    // once we have a client.destroy() method\n    const win = typeof window !== \"undefined\" ? window : undefined;\n    win?.addEventListener(\"beforeunload\", maybePreventClose);\n  }\n\n  async function getNotificationSettings(options?: {\n    signal?: AbortSignal;\n  }): Promise<NotificationSettings> {\n    const plainSettings = await httpClient.getNotificationSettings(options);\n    const settings = createNotificationSettings(plainSettings);\n\n    return settings;\n  }\n\n  async function updateNotificationSettings(\n    settings: PartialNotificationSettings\n  ): Promise<NotificationSettings> {\n    const plainSettings = await httpClient.updateNotificationSettings(settings);\n    const settingsObject = createNotificationSettings(plainSettings);\n\n    return settingsObject;\n  }\n\n  const client: Client<U> = Object.defineProperty(\n    {\n      enterRoom,\n      getRoom,\n\n      logout,\n\n      // Public inbox notifications API\n      getInboxNotifications: httpClient.getInboxNotifications,\n      getInboxNotificationsSince: httpClient.getInboxNotificationsSince,\n      getUnreadInboxNotificationsCount:\n        httpClient.getUnreadInboxNotificationsCount,\n      markAllInboxNotificationsAsRead:\n        httpClient.markAllInboxNotificationsAsRead,\n      markInboxNotificationAsRead: httpClient.markInboxNotificationAsRead,\n      deleteAllInboxNotifications: httpClient.deleteAllInboxNotifications,\n      deleteInboxNotification: httpClient.deleteInboxNotification,\n\n      // Public notification settings API\n      getNotificationSettings,\n      updateNotificationSettings,\n\n      // Advanced resolvers APIs\n      resolvers: {\n        invalidateUsers: invalidateResolvedUsers,\n        invalidateRoomsInfo: invalidateResolvedRoomsInfo,\n        invalidateGroupsInfo: invalidateResolvedGroupsInfo,\n        invalidateMentionSuggestions: invalidateResolvedMentionSuggestions,\n      },\n\n      getSyncStatus,\n      events: {\n        error: liveblocksErrorSource,\n        syncStatus: syncStatusSignal,\n      },\n\n      // Internal\n      [kInternal]: {\n        currentUserId,\n        mentionSuggestionsCache,\n        ai,\n        resolveMentionSuggestions: clientOptions.resolveMentionSuggestions,\n        usersStore,\n        roomsInfoStore,\n        groupsInfoStore,\n        getRoomIds() {\n          return Array.from(roomsById.keys());\n        },\n        httpClient,\n        // Type-level helper only, it's effectively only an identity-function at runtime\n        as: <TM2 extends BaseMetadata, CM2 extends BaseMetadata>() =>\n          client as Client<U, TM2, CM2>,\n        createSyncSource,\n        emitError: (context: LiveblocksErrorContext, cause?: Error) => {\n          const error = LiveblocksError.from(context, cause);\n          const didNotify = liveblocksErrorSource.notify(error);\n          if (!didNotify) {\n            console.error(error.message);\n          }\n        },\n      },\n    },\n    kInternal,\n    {\n      enumerable: false,\n    }\n  );\n\n  return client;\n}\n\n/**\n * @private Private API, don't use this directly.\n */\nexport function checkBounds(\n  option: string,\n  value: unknown,\n  min: number,\n  max?: number,\n  recommendedMin?: number\n): number {\n  if (\n    typeof value !== \"number\" ||\n    value < min ||\n    (max !== undefined && value > max)\n  ) {\n    throw new Error(\n      max !== undefined\n        ? `${option} should be between ${recommendedMin ?? min} and ${max}.`\n        : `${option} should be at least ${recommendedMin ?? min}.`\n    );\n  }\n  return value;\n}\n\nfunction getBackgroundKeepAliveTimeout(\n  value: number | undefined\n): number | undefined {\n  if (value === undefined) return undefined;\n  return checkBounds(\n    \"backgroundKeepAliveTimeout\",\n    value,\n    MIN_BACKGROUND_KEEP_ALIVE_TIMEOUT\n  );\n}\n\nfunction getThrottle(value: number): number {\n  return checkBounds(\"throttle\", value, MIN_THROTTLE, MAX_THROTTLE);\n}\n\nfunction getLostConnectionTimeout(value: number): number {\n  return checkBounds(\n    \"lostConnectionTimeout\",\n    value,\n    MIN_LOST_CONNECTION_TIMEOUT,\n    MAX_LOST_CONNECTION_TIMEOUT,\n    RECOMMENDED_MIN_LOST_CONNECTION_TIMEOUT\n  );\n}\n","import type { ResolveGroupsInfoArgs, ResolveUsersArgs } from \"../client\";\nimport type { DGI, DU } from \"../globals/augmentation\";\nimport { nn } from \"../lib/assert\";\nimport { sanitizeUrl } from \"../lib/url\";\nimport type { BaseUserMeta } from \"../protocol/BaseUserMeta\";\nimport type {\n  CommentBody,\n  CommentBodyBlockElement,\n  CommentBodyElement,\n  CommentBodyInlineElement,\n  CommentBodyLink,\n  CommentBodyMention,\n  CommentBodyParagraph,\n  CommentBodyText,\n} from \"../protocol/Comments\";\nimport type { Awaitable } from \"../types/Awaitable\";\n\ntype CommentBodyBlockElementName = Exclude<\n  CommentBodyBlockElement,\n  CommentBodyText\n>[\"type\"];\n\ntype CommentBodyInlineElementName =\n  | Exclude<CommentBodyInlineElement, CommentBodyText>[\"type\"]\n  | \"text\";\n\ntype CommentBodyElementName =\n  | CommentBodyBlockElementName\n  | CommentBodyInlineElementName;\n\ntype CommentBodyBlockElements = {\n  paragraph: CommentBodyParagraph;\n};\n\ntype CommentBodyInlineElements = {\n  text: CommentBodyText;\n  link: CommentBodyLink;\n  mention: CommentBodyMention;\n};\n\ntype CommentBodyElements = CommentBodyBlockElements & CommentBodyInlineElements;\n\ntype CommentBodyVisitor<T extends CommentBodyElement = CommentBodyElement> = (\n  element: T\n) => void;\n\nexport type CommentBodyParagraphElementArgs = {\n  /**\n   * The paragraph element.\n   */\n  element: CommentBodyParagraph;\n\n  /**\n   * The text content of the paragraph.\n   */\n  children: string;\n};\n\nexport type CommentBodyTextElementArgs = {\n  /**\n   * The text element.\n   */\n  element: CommentBodyText;\n};\n\nexport type CommentBodyLinkElementArgs = {\n  /**\n   * The link element.\n   */\n  element: CommentBodyLink;\n\n  /**\n   * The absolute URL of the link.\n   */\n  href: string;\n};\n\nexport type CommentBodyMentionElementArgs<U extends BaseUserMeta = DU> = {\n  /**\n   * The mention element.\n   */\n  element: CommentBodyMention;\n\n  /**\n   * The mention's user info, if the mention is a user mention and the `resolveUsers` option was provided.\n   */\n  user?: U[\"info\"];\n\n  /**\n   * The mention's group info, if the mention is a group mention and the `resolveGroupsInfo` option was provided.\n   */\n  group?: DGI;\n};\n\nexport type StringifyCommentBodyElements<U extends BaseUserMeta = DU> = {\n  /**\n   * The element used to display paragraphs.\n   */\n  paragraph: (args: CommentBodyParagraphElementArgs, index: number) => string;\n\n  /**\n   * The element used to display text elements.\n   */\n  text: (args: CommentBodyTextElementArgs, index: number) => string;\n\n  /**\n   * The element used to display links.\n   */\n  link: (args: CommentBodyLinkElementArgs, index: number) => string;\n\n  /**\n   * The element used to display mentions.\n   */\n  mention: (args: CommentBodyMentionElementArgs<U>, index: number) => string;\n};\n\nexport type StringifyCommentBodyOptions<U extends BaseUserMeta = DU> = {\n  /**\n   * Which format to convert the comment to.\n   */\n  format?: \"plain\" | \"html\" | \"markdown\";\n\n  /**\n   * The elements used to customize the resulting string. Each element has\n   * priority over the defaults inherited from the `format` option.\n   */\n  elements?: Partial<StringifyCommentBodyElements<U>>;\n\n  /**\n   * The separator used between paragraphs.\n   */\n  separator?: string;\n\n  /**\n   * A function that returns user info from user IDs.\n   * You should return a list of user objects of the same size, in the same order.\n   */\n  resolveUsers?: (\n    args: ResolveUsersArgs\n  ) => Awaitable<(U[\"info\"] | undefined)[] | undefined>;\n\n  /**\n   * A function that returns group info from group IDs.\n   * You should return a list of group info objects of the same size, in the same order.\n   */\n  resolveGroupsInfo?: (\n    args: ResolveGroupsInfoArgs\n  ) => Awaitable<(DGI | undefined)[] | undefined>;\n};\n\nexport function isCommentBodyParagraph(\n  element: CommentBodyElement\n): element is CommentBodyParagraph {\n  return \"type\" in element && element.type === \"paragraph\";\n}\n\nexport function isCommentBodyText(\n  element: CommentBodyElement\n): element is CommentBodyText {\n  return (\n    !(\"type\" in element) &&\n    \"text\" in element &&\n    typeof element.text === \"string\"\n  );\n}\n\nexport function isCommentBodyMention(\n  element: CommentBodyElement\n): element is CommentBodyMention {\n  return \"type\" in element && element.type === \"mention\";\n}\n\nexport function isCommentBodyLink(\n  element: CommentBodyElement\n): element is CommentBodyLink {\n  return \"type\" in element && element.type === \"link\";\n}\n\nconst commentBodyElementsGuards = {\n  paragraph: isCommentBodyParagraph,\n  text: isCommentBodyText,\n  link: isCommentBodyLink,\n  mention: isCommentBodyMention,\n};\n\nconst commentBodyElementsTypes: Record<\n  CommentBodyElementName,\n  \"block\" | \"inline\"\n> = {\n  paragraph: \"block\",\n  text: \"inline\",\n  link: \"inline\",\n  mention: \"inline\",\n};\n\nfunction traverseCommentBody(\n  body: CommentBody,\n  visitor: CommentBodyVisitor\n): void;\nfunction traverseCommentBody<T extends CommentBodyElementName>(\n  body: CommentBody,\n  element: T,\n  visitor: CommentBodyVisitor<CommentBodyElements[T]>\n): void;\nfunction traverseCommentBody(\n  body: CommentBody,\n  elementOrVisitor: CommentBodyElementName | CommentBodyVisitor,\n  possiblyVisitor?: CommentBodyVisitor\n): void {\n  if (!body || !body?.content) {\n    return;\n  }\n\n  const element =\n    typeof elementOrVisitor === \"string\" ? elementOrVisitor : undefined;\n  const type = element ? commentBodyElementsTypes[element] : \"all\";\n  const guard = element ? commentBodyElementsGuards[element] : () => true;\n  const visitor =\n    typeof elementOrVisitor === \"function\" ? elementOrVisitor : possiblyVisitor;\n\n  for (const block of body.content) {\n    if (type === \"all\" || type === \"block\") {\n      if (guard(block)) {\n        visitor?.(block);\n      }\n    }\n\n    if (type === \"all\" || type === \"inline\") {\n      for (const inline of block.children) {\n        if (guard(inline)) {\n          visitor?.(inline);\n        }\n      }\n    }\n  }\n}\n\n/**\n * Get an array of all mentions in a `CommentBody`.\n *\n * Narrow results with an optional predicate, e.g.\n * `(mention) => mention.kind === \"user\"` to only get user mentions.\n */\nexport function getMentionsFromCommentBody(\n  body: CommentBody,\n  predicate?: (mention: CommentBodyMention) => boolean\n): CommentBodyMention[] {\n  const mentionIds = new Set<string>();\n  const mentions: CommentBodyMention[] = [];\n\n  traverseCommentBody(body, \"mention\", (mention) => {\n    if (\n      // If this mention isn't already in the list\n      !mentionIds.has(mention.id) &&\n      // And the provided predicate is true\n      (predicate ? predicate(mention) : true)\n    ) {\n      mentionIds.add(mention.id);\n      mentions.push(mention);\n    }\n  });\n\n  return mentions;\n}\n\nexport async function resolveMentionsInCommentBody<U extends BaseUserMeta>(\n  body: CommentBody,\n  resolveUsers?: (\n    args: ResolveUsersArgs\n  ) => Awaitable<(U[\"info\"] | undefined)[] | undefined>,\n  resolveGroupsInfo?: (\n    args: ResolveGroupsInfoArgs\n  ) => Awaitable<(DGI | undefined)[] | undefined>\n): Promise<{\n  users: Map<string, U[\"info\"]>;\n  groups: Map<string, DGI>;\n}> {\n  const resolvedUsers = new Map<string, U[\"info\"]>();\n  const resolvedGroupsInfo = new Map<string, DGI>();\n\n  if (!resolveUsers && !resolveGroupsInfo) {\n    return {\n      users: resolvedUsers,\n      groups: resolvedGroupsInfo,\n    };\n  }\n\n  const mentions = getMentionsFromCommentBody(body);\n  const userIds = mentions\n    .filter((mention) => mention.kind === \"user\")\n    .map((mention) => mention.id);\n  const groupIds = mentions\n    .filter((mention) => mention.kind === \"group\")\n    .map((mention) => mention.id);\n\n  const [users, groups] = await Promise.all([\n    resolveUsers && userIds.length > 0 ? resolveUsers({ userIds }) : undefined,\n    resolveGroupsInfo && groupIds.length > 0\n      ? resolveGroupsInfo({ groupIds })\n      : undefined,\n  ]);\n\n  if (users) {\n    for (const [index, userId] of userIds.entries()) {\n      const user = users[index];\n      if (user) {\n        resolvedUsers.set(userId, user);\n      }\n    }\n  }\n\n  if (groups) {\n    for (const [index, groupId] of groupIds.entries()) {\n      const group = groups[index];\n      if (group) {\n        resolvedGroupsInfo.set(groupId, group);\n      }\n    }\n  }\n\n  return {\n    users: resolvedUsers,\n    groups: resolvedGroupsInfo,\n  };\n}\n\nconst htmlEscapables = {\n  \"&\": \"&amp;\",\n  \"<\": \"&lt;\",\n  \">\": \"&gt;\",\n  '\"': \"&quot;\",\n  \"'\": \"&#39;\",\n};\n\nconst htmlEscapablesRegex = new RegExp(\n  Object.keys(htmlEscapables)\n    .map((entity) => `\\\\${entity}`)\n    .join(\"|\"),\n  \"g\"\n);\n\nexport function htmlSafe(value: string): HtmlSafeString {\n  return new HtmlSafeString([String(value)], []);\n}\n\nfunction joinHtml(strings: (string | HtmlSafeString)[]) {\n  if (strings.length <= 0) {\n    return new HtmlSafeString([\"\"], []);\n  }\n\n  return new HtmlSafeString(\n    [\"\", ...(Array(strings.length - 1).fill(\"\") as string[]), \"\"],\n    strings\n  );\n}\n\nfunction escapeHtml(\n  value: string | string[] | HtmlSafeString | HtmlSafeString[]\n) {\n  if (value instanceof HtmlSafeString) {\n    return value.toString();\n  }\n\n  if (Array.isArray(value)) {\n    return joinHtml(value).toString();\n  }\n\n  return String(value).replace(\n    htmlEscapablesRegex,\n    (character) => htmlEscapables[character as keyof typeof htmlEscapables]\n  );\n}\n\n// Adapted from https://github.com/Janpot/escape-html-template-tag\nexport class HtmlSafeString {\n  #strings: readonly string[];\n  #values: readonly (string | string[] | HtmlSafeString | HtmlSafeString[])[];\n\n  constructor(\n    strings: readonly string[],\n    values: readonly (string | string[] | HtmlSafeString | HtmlSafeString[])[]\n  ) {\n    this.#strings = strings;\n    this.#values = values;\n  }\n\n  toString(): string {\n    return this.#strings.reduce((result, str, i) => {\n      return result + escapeHtml(nn(this.#values[i - 1])) + str;\n    });\n  }\n}\n\n/**\n * Build an HTML string from a template literal where the values are escaped.\n * Nested calls are supported and won't be escaped.\n */\nexport function html(\n  strings: TemplateStringsArray,\n  ...values: (string | string[] | HtmlSafeString | HtmlSafeString[])[]\n): string {\n  return new HtmlSafeString(strings, values) as unknown as string;\n}\n\nconst markdownEscapables = {\n  _: \"\\\\_\",\n  \"*\": \"\\\\*\",\n  \"#\": \"\\\\#\",\n  \"`\": \"\\\\`\",\n  \"~\": \"\\\\~\",\n  \"!\": \"\\\\!\",\n  \"|\": \"\\\\|\",\n  \"(\": \"\\\\(\",\n  \")\": \"\\\\)\",\n  \"{\": \"\\\\{\",\n  \"}\": \"\\\\}\",\n  \"[\": \"\\\\[\",\n  \"]\": \"\\\\]\",\n};\n\nconst markdownEscapablesRegex = new RegExp(\n  Object.keys(markdownEscapables)\n    .map((entity) => `\\\\${entity}`)\n    .join(\"|\"),\n  \"g\"\n);\n\nfunction joinMarkdown(strings: (string | MarkdownSafeString)[]) {\n  if (strings.length <= 0) {\n    return new MarkdownSafeString([\"\"], []);\n  }\n\n  return new MarkdownSafeString(\n    [\"\", ...(Array(strings.length - 1).fill(\"\") as string[]), \"\"],\n    strings\n  );\n}\n\nfunction escapeMarkdown(\n  value: string | string[] | MarkdownSafeString | MarkdownSafeString[]\n) {\n  if (value instanceof MarkdownSafeString) {\n    return value.toString();\n  }\n\n  if (Array.isArray(value)) {\n    return joinMarkdown(value).toString();\n  }\n\n  return String(value).replace(\n    markdownEscapablesRegex,\n    (character) =>\n      markdownEscapables[character as keyof typeof markdownEscapables]\n  );\n}\n\n// Adapted from https://github.com/Janpot/escape-html-template-tag\nexport class MarkdownSafeString {\n  #strings: readonly string[];\n  #values: readonly (\n    | string\n    | string[]\n    | MarkdownSafeString\n    | MarkdownSafeString[]\n  )[];\n\n  constructor(\n    strings: readonly string[],\n    values: readonly (\n      | string\n      | string[]\n      | MarkdownSafeString\n      | MarkdownSafeString[]\n    )[]\n  ) {\n    this.#strings = strings;\n    this.#values = values;\n  }\n\n  toString(): string {\n    return this.#strings.reduce((result, str, i) => {\n      return result + escapeMarkdown(nn(this.#values[i - 1])) + str;\n    });\n  }\n}\n\n/**\n * Build a Markdown string from a template literal where the values are escaped.\n * Nested calls are supported and won't be escaped.\n */\nfunction markdown(\n  strings: TemplateStringsArray,\n  ...values: (string | string[] | MarkdownSafeString | MarkdownSafeString[])[]\n) {\n  return new MarkdownSafeString(strings, values) as unknown as string;\n}\n\nconst stringifyCommentBodyPlainElements: StringifyCommentBodyElements<BaseUserMeta> =\n  {\n    paragraph: ({ children }) => children,\n    text: ({ element }) => element.text,\n    link: ({ element }) => element.text ?? element.url,\n    mention: ({ element, user, group }) => {\n      return `@${user?.name ?? group?.name ?? element.id}`;\n    },\n  };\n\nconst stringifyCommentBodyHtmlElements: StringifyCommentBodyElements<BaseUserMeta> =\n  {\n    paragraph: ({ children }) => {\n      // prettier-ignore\n      return children ? html`<p>${htmlSafe(children)}</p>` : children;\n    },\n    text: ({ element }) => {\n      // <code><s><em><strong>text</strong></s></em></code>\n      let children = element.text;\n\n      if (!children) {\n        return html`${children}`;\n      }\n\n      if (element.bold) {\n        // prettier-ignore\n        children = html`<strong>${children}</strong>`;\n      }\n\n      if (element.italic) {\n        // prettier-ignore\n        children = html`<em>${children}</em>`;\n      }\n\n      if (element.strikethrough) {\n        // prettier-ignore\n        children = html`<s>${children}</s>`;\n      }\n\n      if (element.code) {\n        // prettier-ignore\n        children = html`<code>${children}</code>`;\n      }\n\n      return html`${children}`;\n    },\n    link: ({ element, href }) => {\n      // prettier-ignore\n      return html`<a href=\"${href}\" target=\"_blank\" rel=\"noopener noreferrer\">${element.text ? html`${element.text}` : element.url}</a>`;\n    },\n    mention: ({ element, user, group }) => {\n      // prettier-ignore\n      return html`<span data-mention>@${user?.name ? html`${user?.name}` : group?.name ? html`${group?.name}` : element.id}</span>`;\n    },\n  };\n\nconst stringifyCommentBodyMarkdownElements: StringifyCommentBodyElements<BaseUserMeta> =\n  {\n    paragraph: ({ children }) => {\n      return children;\n    },\n    text: ({ element }) => {\n      // <code><s><em><strong>text</strong></s></em></code>\n      let children = element.text;\n\n      if (!children) {\n        return children;\n      }\n\n      if (element.bold) {\n        // prettier-ignore\n        children = markdown`**${children}**`;\n      }\n\n      if (element.italic) {\n        // prettier-ignore\n        children = markdown`_${children}_`;\n      }\n\n      if (element.strikethrough) {\n        // prettier-ignore\n        children = markdown`~~${children}~~`;\n      }\n\n      if (element.code) {\n        // prettier-ignore\n        children = markdown`\\`${children}\\``;\n      }\n\n      return children;\n    },\n    link: ({ element, href }) => {\n      // prettier-ignore\n      return markdown`[${element.text ?? element.url}](${href})`;\n    },\n    mention: ({ element, user, group }) => {\n      // prettier-ignore\n      return markdown`@${user?.name ?? group?.name ?? element.id}`;\n    },\n  };\n\n/**\n * Convert a `CommentBody` into either a plain string,\n * Markdown, HTML, or a custom format.\n */\nexport async function stringifyCommentBody(\n  body: CommentBody,\n  options?: StringifyCommentBodyOptions<BaseUserMeta>\n): Promise<string> {\n  const format = options?.format ?? \"plain\";\n  const separator =\n    options?.separator ?? (format === \"markdown\" ? \"\\n\\n\" : \"\\n\");\n  const elements = {\n    ...(format === \"html\"\n      ? stringifyCommentBodyHtmlElements\n      : format === \"markdown\"\n        ? stringifyCommentBodyMarkdownElements\n        : stringifyCommentBodyPlainElements),\n    ...options?.elements,\n  };\n  const { users: resolvedUsers, groups: resolvedGroupsInfo } =\n    await resolveMentionsInCommentBody(\n      body,\n      options?.resolveUsers,\n      options?.resolveGroupsInfo\n    );\n\n  const blocks = body.content.flatMap((block, blockIndex) => {\n    switch (block.type) {\n      case \"paragraph\": {\n        const inlines = block.children.flatMap((inline, inlineIndex) => {\n          if (isCommentBodyMention(inline)) {\n            return inline.id\n              ? [\n                  elements.mention(\n                    {\n                      element: inline,\n                      user:\n                        inline.kind === \"user\"\n                          ? resolvedUsers.get(inline.id)\n                          : undefined,\n                      group:\n                        inline.kind === \"group\"\n                          ? resolvedGroupsInfo.get(inline.id)\n                          : undefined,\n                    },\n                    inlineIndex\n                  ),\n                ]\n              : [];\n          }\n\n          if (isCommentBodyLink(inline)) {\n            const href = sanitizeUrl(inline.url);\n\n            // If the URL is invalid, its text/URL are used as plain text.\n            if (href === null) {\n              return [\n                elements.text(\n                  {\n                    element: { text: inline.text ?? inline.url },\n                  },\n                  inlineIndex\n                ),\n              ];\n            }\n\n            return [\n              elements.link(\n                {\n                  element: inline,\n                  href,\n                },\n                inlineIndex\n              ),\n            ];\n          }\n\n          if (isCommentBodyText(inline)) {\n            return [elements.text({ element: inline }, inlineIndex)];\n          }\n\n          return [];\n        });\n\n        return [\n          elements.paragraph(\n            { element: block, children: inlines.join(\"\") },\n            blockIndex\n          ),\n        ];\n      }\n\n      default:\n        return [];\n    }\n  });\n\n  return blocks.join(separator);\n}\n","import type { Json } from \"../lib/Json\";\nimport type { PlainLson } from \"../types/PlainLson\";\nimport { LiveList } from \"./LiveList\";\nimport { LiveMap } from \"./LiveMap\";\nimport { LiveObject } from \"./LiveObject\";\nimport type { Lson, LsonObject } from \"./Lson\";\n\n/**\n * Helper type to convert any valid Lson type to the equivalent Json type.\n *\n * Examples:\n *\n *   ToImmutable<42>                         // 42\n *   ToImmutable<'hi'>                       // 'hi'\n *   ToImmutable<number>                     // number\n *   ToImmutable<string>                     // string\n *   ToImmutable<string | LiveList<number>>  // string | readonly number[]\n *   ToImmutable<LiveMap<string, LiveList<number>>>\n *                                           // ReadonlyMap<string, readonly number[]>\n *   ToImmutable<LiveObject<{ a: number, b: LiveList<string>, c?: number }>>\n *                                           // { readonly a: null, readonly b: readonly string[], readonly c?: number }\n *\n */\n// prettier-ignore\nexport type ToImmutable<L extends Lson | LsonObject> =\n  // A LiveList serializes to an equivalent JSON array\n  L extends LiveList<infer I> ? readonly ToImmutable<I>[] :\n\n  // A LiveObject serializes to an equivalent JSON object\n  L extends LiveObject<infer O> ? ToImmutable<O> :\n\n  // A LiveMap serializes to a JSON object with string-V pairs\n  L extends LiveMap<infer K, infer V> ? ReadonlyMap<K, ToImmutable<V>> :\n\n  // Any LsonObject recursively becomes a JsonObject\n  L extends LsonObject ?\n    { readonly [K in keyof L]: ToImmutable<Exclude<L[K], undefined>>\n                                 | (undefined extends L[K] ? undefined : never) } :\n\n  // Any Json value already is a legal Json value\n  L extends Json ? L :\n\n  // Otherwise, this is not possible\n  never;\n\n/**\n * Returns PlainLson for a given Json or LiveStructure, suitable for calling the storage init api\n */\nexport function toPlainLson(lson: Lson): PlainLson {\n  if (lson instanceof LiveObject) {\n    return {\n      liveblocksType: \"LiveObject\",\n      data: Object.fromEntries(\n        Object.entries(lson.toObject()).flatMap(([key, value]) =>\n          value !== undefined ? [[key, toPlainLson(value)]] : []\n        )\n      ),\n    };\n  } else if (lson instanceof LiveMap) {\n    return {\n      liveblocksType: \"LiveMap\",\n      data: Object.fromEntries(\n        [...lson].map(([key, value]) => [key, toPlainLson(value)])\n      ),\n    };\n  } else if (lson instanceof LiveList) {\n    return {\n      liveblocksType: \"LiveList\",\n      data: [...lson].map((item) => toPlainLson(item)),\n    };\n  } else {\n    return lson;\n  }\n}\n","import {\n  findNonSerializableValue,\n  isLiveList,\n  isLiveObject,\n} from \"./crdts/liveblocks-helpers\";\nimport { LiveList } from \"./crdts/LiveList\";\nimport { LiveMap } from \"./crdts/LiveMap\";\nimport { LiveObject } from \"./crdts/LiveObject\";\nimport { LiveRegister } from \"./crdts/LiveRegister\";\nimport type { LiveNode, Lson, LsonObject, ToJson } from \"./crdts/Lson\";\nimport type { StorageUpdate } from \"./crdts/StorageUpdates\";\nimport * as console from \"./lib/fancy-console\";\nimport { isPlainObject } from \"./lib/guards\";\nimport type { Json, JsonObject } from \"./lib/Json\";\nimport { isJsonObject } from \"./lib/Json\";\n\nfunction lsonObjectToJson<O extends LsonObject>(\n  obj: O\n): { [K in keyof O]: Json } {\n  const result = {} as { [K in keyof O]: Json };\n  for (const key in obj) {\n    const val = obj[key];\n    if (val !== undefined) {\n      result[key] = lsonToJson(val);\n    }\n  }\n  return result;\n}\n\nexport function liveObjectToJson<O extends LsonObject>(\n  liveObject: LiveObject<O>\n): { [K in keyof O]: Json } {\n  return lsonObjectToJson(liveObject.toObject());\n}\n\nfunction liveMapToJson<TKey extends string>(\n  map: LiveMap<TKey, Lson>\n): { [K in TKey]: Json } {\n  const result = {} as { [K in TKey]: Json };\n  for (const [key, value] of map.entries()) {\n    result[key] = lsonToJson(value);\n  }\n  return result;\n}\n\nfunction lsonListToJson(value: Lson[]): Json[] {\n  return value.map(lsonToJson);\n}\n\nfunction liveListToJson(value: LiveList<Lson>): Json[] {\n  return lsonListToJson(value.toArray());\n}\n\nexport function lsonToJson(value: Lson): Json {\n  // Check for LiveStructure datastructures first\n  if (value instanceof LiveObject) {\n    return liveObjectToJson(value);\n  } else if (value instanceof LiveList) {\n    return liveListToJson(value);\n  } else if (value instanceof LiveMap) {\n    return liveMapToJson(value);\n  } else if (value instanceof LiveRegister) {\n    // NOTE: This branch should never be taken, because LiveRegister isn't a valid Lson value\n    return value.data as Json;\n  }\n\n  // Then for composite Lson values\n  if (Array.isArray(value)) {\n    return lsonListToJson(value);\n  } else if (isPlainObject(value)) {\n    return lsonObjectToJson(value);\n  }\n\n  // Finally, if value is an LsonScalar, then it's also a valid JsonScalar\n  return value;\n}\n\n/**\n * Deeply converts all nested lists to LiveLists, and all nested objects to\n * LiveObjects.\n *\n * As such, the returned result will not contain any Json arrays or Json\n * objects anymore.\n */\nfunction deepLiveify(value: Lson | LsonObject): Lson {\n  if (Array.isArray(value)) {\n    return new LiveList(value.map(deepLiveify));\n  } else if (isPlainObject(value)) {\n    const init: LsonObject = {};\n    for (const key in value) {\n      const val = value[key];\n      if (val === undefined) {\n        continue;\n      }\n      init[key] = deepLiveify(val);\n    }\n    return new LiveObject(init);\n  } else {\n    return value;\n  }\n}\n\nexport function patchLiveList<T extends Lson>(\n  liveList: LiveList<T>,\n  prev: Array<T>,\n  next: Array<T>\n): void {\n  let i = 0;\n  let prevEnd = prev.length - 1;\n  let nextEnd = next.length - 1;\n\n  let prevNode = prev[0];\n  let nextNode = next[0];\n\n  /**\n   * For A,B,C => A,B,C,D\n   * i = 3, prevEnd = 2, nextEnd = 3\n   *\n   * For A,B,C => B,C\n   * i = 2, prevEnd = 2, nextEnd = 1\n   *\n   * For B,C => A,B,C\n   * i = 0, pre\n   */\n\n  outer: {\n    while (prevNode === nextNode) {\n      ++i;\n      if (i > prevEnd || i > nextEnd) {\n        break outer;\n      }\n      prevNode = prev[i];\n      nextNode = next[i];\n    }\n\n    prevNode = prev[prevEnd];\n    nextNode = next[nextEnd];\n\n    while (prevNode === nextNode) {\n      prevEnd--;\n      nextEnd--;\n\n      if (i > prevEnd || i > nextEnd) {\n        break outer;\n      }\n\n      prevNode = prev[prevEnd];\n      nextNode = next[nextEnd];\n    }\n  }\n\n  if (i > prevEnd) {\n    if (i <= nextEnd) {\n      while (i <= nextEnd) {\n        liveList.insert(deepLiveify(next[i]) as T, i);\n        //                                   ^^^^ FIXME Not entirely true\n        i++;\n      }\n    }\n  } else if (i > nextEnd) {\n    let localI = i;\n    while (localI <= prevEnd) {\n      liveList.delete(i);\n      localI++;\n    }\n  } else {\n    while (i <= prevEnd && i <= nextEnd) {\n      prevNode = prev[i];\n      nextNode = next[i];\n      const liveListNode = liveList.get(i);\n\n      if (\n        isLiveObject(liveListNode) &&\n        isPlainObject(prevNode) &&\n        isPlainObject(nextNode)\n      ) {\n        patchLiveObject(liveListNode, prevNode, nextNode);\n      } else {\n        liveList.set(i, deepLiveify(nextNode) as T);\n        //                                    ^^^^ FIXME Not entirely true\n      }\n\n      i++;\n    }\n    while (i <= nextEnd) {\n      liveList.insert(deepLiveify(next[i]) as T, i);\n      //                                   ^^^^ FIXME Not entirely true\n      i++;\n    }\n    let localI = i;\n    while (localI <= prevEnd) {\n      liveList.delete(i);\n      localI++;\n    }\n  }\n}\n\nexport function patchLiveObjectKey<\n  O extends LsonObject,\n  K extends keyof O,\n  V extends Json,\n>(liveObject: LiveObject<O>, key: K, prev?: V, next?: V): void {\n  if (process.env.NODE_ENV !== \"production\") {\n    const nonSerializableValue = findNonSerializableValue(next);\n    if (nonSerializableValue) {\n      console.error(\n        `New state path: '${nonSerializableValue.path}' value: '${String(\n          nonSerializableValue.value\n        )}' is not serializable.\\nOnly serializable value can be synced with Liveblocks.`\n      );\n      return;\n    }\n  }\n\n  const value = liveObject.get(key);\n\n  if (next === undefined) {\n    liveObject.delete(key);\n  } else if (value === undefined) {\n    liveObject.set(key, deepLiveify(next) as O[K]);\n    //                                    ^^^^^^^ FIXME Not entirely true\n  } else if (prev === next) {\n    return;\n  } else if (isLiveList(value) && Array.isArray(prev) && Array.isArray(next)) {\n    patchLiveList(value, prev, next);\n  } else if (\n    isLiveObject(value) &&\n    isPlainObject(prev) &&\n    isPlainObject(next)\n  ) {\n    patchLiveObject(value, prev, next);\n  } else {\n    liveObject.set(key, deepLiveify(next) as O[K]);\n    //                                    ^^^^^^^ FIXME Not entirely true\n  }\n}\n\nexport function patchLiveObject<O extends LsonObject>(\n  root: LiveObject<O>,\n  prev: ToJson<O>,\n  next: ToJson<O>\n): void {\n  const updates: Partial<O> = {};\n\n  for (const key in next) {\n    patchLiveObjectKey(root, key, prev[key] as Json, next[key] as Json);\n  }\n\n  for (const key in prev) {\n    if (next[key] === undefined) {\n      root.delete(key);\n    }\n  }\n\n  if (Object.keys(updates).length > 0) {\n    root.update(updates);\n  }\n}\n\nfunction getParentsPath(node: LiveNode): Array<string | number> {\n  const path = [];\n  while (node.parent.type === \"HasParent\") {\n    if (isLiveList(node.parent.node)) {\n      path.push(node.parent.node._indexOfPosition(node.parent.key));\n    } else {\n      path.push(node.parent.key);\n    }\n    node = node.parent.node;\n  }\n  return path;\n}\n\n//\n// TODO: Remove `patchImmutableObject`!\n//\n// This helper is now only used internally, to support our Zustand and\n// Redux packages. We should be able to reimplement those using the new\n// `.toImmutable()` APIs.\n//\nexport function legacy_patchImmutableObject<TState extends JsonObject>(\n  state: TState,\n  updates: StorageUpdate[]\n): TState {\n  return updates.reduce(\n    (state, update) => legacy_patchImmutableObjectWithUpdate(state, update),\n    state\n  );\n}\n\nfunction legacy_patchImmutableObjectWithUpdate<TState extends JsonObject>(\n  state: TState,\n  update: StorageUpdate\n): TState {\n  const path = getParentsPath(update.node);\n  return legacy_patchImmutableNode(state, path, update);\n}\n\nfunction legacy_patchImmutableNode<S extends Json>(\n  state: S,\n  path: Array<string | number>,\n  update: StorageUpdate\n): S {\n  // FIXME: Split this function up into a few smaller ones! In each of them,\n  // the types can be define much more narrowly and correctly, and there will\n  // be less type shoehorning necessary.\n\n  const pathItem = path.pop();\n  if (pathItem === undefined) {\n    switch (update.type) {\n      case \"LiveObject\": {\n        if (!isJsonObject(state)) {\n          throw new Error(\n            \"Internal: received update on LiveObject but state was not an object\"\n          );\n        }\n\n        const newState: JsonObject = Object.assign({}, state);\n\n        for (const key in update.updates) {\n          if (update.updates[key]?.type === \"update\") {\n            const val = update.node.get(key);\n            if (val !== undefined) {\n              newState[key] = lsonToJson(val);\n            }\n          } else if (update.updates[key]?.type === \"delete\") {\n            delete newState[key];\n          }\n        }\n\n        return newState as S;\n        //              ^^^^\n        //              FIXME Not completely true, because we could have been\n        //              updating keys from StorageUpdate here that aren't in S,\n        //              technically.\n      }\n\n      case \"LiveList\": {\n        if (!Array.isArray(state)) {\n          throw new Error(\n            \"Internal: received update on LiveList but state was not an array\"\n          );\n        }\n\n        let newState: Json[] = state.map((x: Json) => x);\n\n        for (const listUpdate of update.updates) {\n          if (listUpdate.type === \"set\") {\n            newState = newState.map((item, index) =>\n              index === listUpdate.index ? lsonToJson(listUpdate.item) : item\n            );\n          } else if (listUpdate.type === \"insert\") {\n            if (listUpdate.index === newState.length) {\n              newState.push(lsonToJson(listUpdate.item));\n            } else {\n              newState = [\n                ...newState.slice(0, listUpdate.index),\n                lsonToJson(listUpdate.item),\n                ...newState.slice(listUpdate.index),\n              ];\n            }\n          } else if (listUpdate.type === \"delete\") {\n            newState.splice(listUpdate.index, 1);\n          } else if (listUpdate.type === \"move\") {\n            if (listUpdate.previousIndex > listUpdate.index) {\n              newState = [\n                ...newState.slice(0, listUpdate.index),\n                lsonToJson(listUpdate.item),\n                ...newState.slice(listUpdate.index, listUpdate.previousIndex),\n                ...newState.slice(listUpdate.previousIndex + 1),\n              ];\n            } else {\n              newState = [\n                ...newState.slice(0, listUpdate.previousIndex),\n                ...newState.slice(\n                  listUpdate.previousIndex + 1,\n                  listUpdate.index + 1\n                ),\n                lsonToJson(listUpdate.item),\n                ...newState.slice(listUpdate.index + 1),\n              ];\n            }\n          }\n        }\n\n        return newState as S;\n        //              ^^^^\n        //              FIXME Not completely true, because we could have been\n        //              updating keys from StorageUpdate here that aren't in S,\n        //              technically.\n      }\n\n      case \"LiveMap\": {\n        if (!isJsonObject(state)) {\n          throw new Error(\n            \"Internal: received update on LiveMap but state was not an object\"\n          );\n        }\n        const newState: JsonObject = Object.assign({}, state);\n\n        for (const key in update.updates) {\n          if (update.updates[key]?.type === \"update\") {\n            const value = update.node.get(key);\n            if (value !== undefined) {\n              newState[key] = lsonToJson(value);\n            }\n          } else if (update.updates[key]?.type === \"delete\") {\n            delete newState[key];\n          }\n        }\n\n        return newState as S;\n        //              ^^^^\n        //              FIXME Not completely true, because we could have been\n        //              updating keys from StorageUpdate here that aren't in S,\n        //              technically.\n      }\n    }\n  }\n\n  if (Array.isArray(state)) {\n    const newArray: Json[] = [...state];\n    newArray[pathItem as number] = legacy_patchImmutableNode(\n      state[pathItem as number],\n      path,\n      update\n    );\n    return newArray as S;\n    //              ^^^^\n    //              FIXME Not completely true, because we could have been\n    //              updating indexes from StorageUpdate here that aren't in S,\n    //              technically.\n  } else if (isJsonObject(state)) {\n    const node = state[pathItem];\n    if (node === undefined) {\n      return state;\n    } else {\n      const stateAsObj: JsonObject = state;\n      return {\n        ...stateAsObj,\n        [pathItem]: legacy_patchImmutableNode(node, path, update),\n      } as S;\n      //   ^\n      //   FIXME Not completely true, because we could have been updating\n      //   indexes from StorageUpdate here that aren't in S, technically.\n    }\n  } else {\n    return state;\n  }\n}\n","/**\n * Like `new AbortController()`, but where the result can be unpacked\n * safely, i.e. `const { signal, abort } = makeAbortController()`.\n *\n * This unpacking is unsafe to do with a regular `AbortController` because\n * the `abort` method is not bound to the controller instance.\n *\n * In addition to this, you can also pass an optional (external)\n * AbortSignal to \"wrap\", in which case the returned signal will be in\n * aborted state when either the signal is aborted externally or\n * internally.\n */\nexport function makeAbortController(externalSignal?: AbortSignal): {\n  signal: AbortSignal;\n  abort: (reason?: unknown) => void;\n} {\n  const ctl = new AbortController();\n  return {\n    signal: externalSignal\n      ? AbortSignal.any([ctl.signal, externalSignal])\n      : ctl.signal,\n    abort: ctl.abort.bind(ctl),\n  };\n}\n","import * as console from \"./fancy-console\";\n\n/**\n * Tools to help with the controlled deprecation of public APIs.\n *\n * First warn, then error, then remove eventually.\n */\n\n// Keeps a set of deprecation messages in memory that it has warned about\n// already. There will be only one deprecation message in the console, no\n// matter how often it gets called.\nconst _emittedDeprecationWarnings: Set<string> = new Set();\n\n/**\n * Displays a deprecation warning in the dev console. Only in dev mode, and\n * only once per message/key. In production, this is a no-op.\n */\n// istanbul ignore next\nexport function deprecate(message: string, key = message): void {\n  if (process.env.NODE_ENV !== \"production\") {\n    if (!_emittedDeprecationWarnings.has(key)) {\n      _emittedDeprecationWarnings.add(key);\n      console.errorWithTitle(\"Deprecation warning\", message);\n    }\n  }\n}\n\n/**\n * Conditionally displays a deprecation warning in the dev\n * console if the first argument is truthy. Only in dev mode, and\n * only once per message/key. In production, this is a no-op.\n */\n// istanbul ignore next\nexport function deprecateIf(\n  condition: unknown,\n  message: string,\n  key = message\n): void {\n  if (process.env.NODE_ENV !== \"production\") {\n    // istanbul ignore if\n    if (condition) {\n      deprecate(message, key);\n    }\n  }\n}\n\n/**\n * Throws a deprecation error in the dev console.\n *\n * Only triggers in dev mode. In production, this is a no-op.\n */\n// istanbul ignore next\nexport function throwUsageError(message: string): void {\n  if (process.env.NODE_ENV !== \"production\") {\n    const usageError = new Error(message);\n    usageError.name = \"Usage error\";\n    console.errorWithTitle(\"Usage error\", message);\n    throw usageError;\n  }\n}\n\n/**\n * Conditionally throws a usage error in the dev console if the first argument\n * is truthy. Use this to \"escalate\" usage patterns that in previous versions\n * we already warned about with deprecation warnings.\n *\n * Only has effect in dev mode. In production, this is a no-op.\n */\n// istanbul ignore next\nexport function errorIf(condition: unknown, message: string): void {\n  if (process.env.NODE_ENV !== \"production\") {\n    if (condition) {\n      throwUsageError(message);\n    }\n  }\n}\n","import { FSM } from \"./fsm\";\n\nexport type Poller = {\n  /**\n   * Increments the subscriber count for this poller. If it becomes > 0, the\n   * poller will be enabled.\n   */\n  inc(): void;\n  /**\n   * Decrements the subscriber count for this poller. If it becomes = 0, the\n   * poller will be disabled.\n   */\n  dec(): void;\n\n  /**\n   * Polls immediately only if it has been more than `maxStaleTimeMs` milliseconds since\n   * the last poll and no poll is currently in progress. After polling, schedules\n   * the next poll at the regular interval.\n   */\n  pollNowIfStale(): void;\n\n  /**\n   * Marks the poller as stale. This can be used to force the next call\n   * to `.pollNowIfStale()` to poll immediately.\n   */\n  markAsStale(): void;\n\n  /**\n   * Used in unit tests only.\n   * @internal\n   */\n  setInForeground(condition: boolean): void;\n};\n\ntype Context = {\n  inForeground: boolean; // Whether the visibility state is visible\n  lastSuccessfulPollAt: number; // The timestamp of the last successful poll (or when the poller was initialized)\n  count: number; // Subscriber count\n  backoff: number; // Backoff delay in ms\n};\n\ntype State =\n  | \"@idle\" //\n  | \"@enabled\" //\n  | \"@polling\";\n\ntype Event =\n  | { type: \"START\" } //\n  | { type: \"STOP\" } //\n  | { type: \"POLL\" };\n\nconst BACKOFF_DELAYS = [1_000, 2_000, 4_000, 8_000, 10_000] as const;\n\n/**\n * Makes a poller that will call `await callback()` at the desired interval (in\n * millis).\n *\n * The poller has only three public APIs, all side effects:\n * - .inc(): void\n * - .dec(): void\n * - .pollNowIfStale(): void\n *\n * It has the following behaviors/guarantees:\n * - Performing a \"poll\" literally means calling the provided callback (and\n *   awaiting it)\n * - It will only ever start polling if .inc() was called (more often than .dec())\n * - It will not _immediately_ poll if .inc() is called. The first poll\n *   can be expected no earlier than the specified interval.\n * - If .dec() is called as many times as .inc(), it stops the poller. This\n *   means that any next poll will get unscheduled. If .dev() is called while\n *   a poll is ongoing, it will still finish that poll, but after that stop\n *   further polling.\n * - If the document's visibility state changes to hidden (tab is moved to the\n *   background), polling will be paused until the document's made visible again\n * - If the document becomes visible again, the poller will:\n *   - Still do nothing if the poller isn't enabled\n *   - Still do nothing if the poller is enabled, but the last time a poll\n *     happened recently enough (= less than the maxStaleTimeMs, which defaults\n *     to infinity)\n *   - Trigger a poll right away otherwise. If an existing poll was already\n *     scheduled, think of it as if this future poll is \"earlied\" and just\n *     happening right now instead\n */\nexport function makePoller(\n  callback: (signal: AbortSignal) => Promise<void> | void,\n  intervalMs: number,\n  options?: {\n    maxStaleTimeMs?: number;\n  }\n): Poller {\n  const startTime = performance.now();\n  const doc = typeof document !== \"undefined\" ? document : undefined;\n  const win = typeof window !== \"undefined\" ? window : undefined;\n\n  const maxStaleTimeMs = options?.maxStaleTimeMs ?? Number.POSITIVE_INFINITY;\n  const context: Context = {\n    inForeground: doc?.visibilityState !== \"hidden\",\n    lastSuccessfulPollAt: startTime,\n    count: 0,\n    backoff: 0,\n  };\n\n  function mayPoll() {\n    return context.count > 0 && context.inForeground;\n  }\n\n  /**\n   *                                    +----------+\n   *        +-------------------------> |  @idle   |\n   *        |   else                    +----------+\n   *        |                             |      ^\n   *        |                     on STOP |      | on START\n   *        |                             v      |\n   *   +--------+   if mayPoll()        +----------+      on POLL             +----------+\n   *   | decide |---------------------> | @enabled | -----------------------> | @polling |\n   *   +--------+                       +----------+   after POLL_INTERVAL    +----------+\n   *        ^                                                                      |\n   *        |                                                                      |\n   *        +----------------------------------------------------------------------+\n   */\n  const fsm = new FSM<object, Event, State>({})\n    .addState(\"@idle\")\n    .addState(\"@enabled\")\n    .addState(\"@polling\");\n\n  fsm.addTransitions(\"@idle\", { START: \"@enabled\" });\n  fsm.addTransitions(\"@enabled\", { STOP: \"@idle\", POLL: \"@polling\" });\n  fsm.addTimedTransition(\n    \"@enabled\",\n    () => {\n      const lastPoll = context.lastSuccessfulPollAt;\n      const nextPoll = lastPoll + intervalMs;\n      return Math.max(0, nextPoll - performance.now()) + context.backoff;\n    },\n    \"@polling\"\n  );\n\n  fsm.onEnterAsync(\n    \"@polling\",\n    async (_ctx, signal) => {\n      await callback(signal);\n      if (!signal.aborted) {\n        context.lastSuccessfulPollAt = performance.now();\n      }\n    },\n    // When OK\n    () => {\n      return {\n        target: mayPoll() ? \"@enabled\" : \"@idle\",\n        effect: () => {\n          // Reset backoff delay to 0 if the callback was successful\n          context.backoff = 0;\n        },\n      };\n    },\n    // When error\n    () => {\n      return {\n        target: mayPoll() ? \"@enabled\" : \"@idle\",\n        effect: () => {\n          // Increase the backoff delay if an error occured\n          context.backoff =\n            BACKOFF_DELAYS.find((delay) => delay > context.backoff) ??\n            BACKOFF_DELAYS[BACKOFF_DELAYS.length - 1];\n        },\n      };\n    },\n    30_000 // Abort the poll if the callback takes more than 30 seconds to complete\n  );\n\n  function startOrStop() {\n    if (mayPoll()) {\n      fsm.send({ type: \"START\" });\n    } else {\n      fsm.send({ type: \"STOP\" });\n    }\n  }\n\n  function inc() {\n    context.count++;\n    startOrStop();\n  }\n\n  function dec() {\n    context.count--;\n    if (context.count < 0) {\n      context.count = 0;\n    }\n    startOrStop();\n  }\n\n  function pollNowIfStale() {\n    if (performance.now() - context.lastSuccessfulPollAt > maxStaleTimeMs) {\n      fsm.send({ type: \"POLL\" });\n    }\n  }\n\n  function markAsStale() {\n    // Set the last successful poll timestamp to a stale time\n    context.lastSuccessfulPollAt = performance.now() - maxStaleTimeMs - 1;\n  }\n\n  function setInForeground(inForeground: boolean) {\n    context.inForeground = inForeground;\n    startOrStop();\n    pollNowIfStale(); // Won't do anything if in @idle\n  }\n\n  function onVisibilityChange() {\n    setInForeground(doc?.visibilityState !== \"hidden\");\n  }\n\n  // NOTE: Currently, poller instances are only ever created and never\n  // destroyed. If we add a destroy() method in the future, then we should also\n  // unregister these event handlers.\n  doc?.addEventListener(\"visibilitychange\", onVisibilityChange);\n  win?.addEventListener(\"online\", onVisibilityChange);\n  win?.addEventListener(\"focus\", pollNowIfStale);\n\n  fsm.start();\n  return {\n    inc,\n    dec,\n    pollNowIfStale,\n    markAsStale,\n\n    // Internal API, used by unit tests only to simulate visibility events\n    setInForeground,\n  };\n}\n","import type { DAD } from \"../globals/augmentation\";\nimport type { DateToString } from \"../lib/DateToString\";\nimport type { NotificationKind } from \"./NotificationSettings\";\n\nexport type SubscriptionData<K extends keyof DAD = keyof DAD> = {\n  kind: NotificationKind<K>;\n  subjectId: string;\n  createdAt: Date;\n};\n\nexport type SubscriptionDataPlain = DateToString<SubscriptionData>;\n\nexport type UserSubscriptionData<K extends keyof DAD = keyof DAD> =\n  SubscriptionData<K> & {\n    userId: string;\n  };\n\nexport type UserSubscriptionDataPlain = DateToString<UserSubscriptionData>;\n\nexport type SubscriptionDeleteInfo = {\n  type: \"deletedSubscription\";\n  kind: NotificationKind;\n  subjectId: string;\n  deletedAt: Date;\n};\n\nexport type SubscriptionDeleteInfoPlain = DateToString<SubscriptionDeleteInfo>;\n\nexport type SubscriptionKey = `${NotificationKind}:${string}`;\n\nexport function getSubscriptionKey(\n  subscription: SubscriptionData | SubscriptionDeleteInfo\n): SubscriptionKey;\nexport function getSubscriptionKey(\n  kind: NotificationKind,\n  subjectId: string\n): SubscriptionKey;\nexport function getSubscriptionKey(\n  subscription: SubscriptionData | SubscriptionDeleteInfo | NotificationKind,\n  subjectId?: string\n): SubscriptionKey {\n  if (typeof subscription === \"string\") {\n    return `${subscription}:${subjectId}`;\n  }\n\n  return `${subscription.kind}:${subscription.subjectId}`;\n}\n","import type { DP, DU } from \"../globals/augmentation\";\nimport type { JsonObject } from \"../lib/Json\";\nimport type { Relax } from \"../lib/Relax\";\nimport type { Resolve } from \"../lib/Resolve\";\nimport type { BaseUserMeta } from \"../protocol/BaseUserMeta\";\nimport type { User } from \"./User\";\n\nexport type InternalOthersEvent<\n  P extends JsonObject,\n  U extends BaseUserMeta,\n> = Relax<\n  | { type: \"leave\"; user: User<P, U> }\n  | { type: \"enter\"; user: User<P, U> }\n  | {\n      type: \"update\";\n      user: User<P, U>;\n      updates: Partial<P>;\n    }\n  | { type: \"reset\" }\n>;\n\nexport type OthersEvent<\n  P extends JsonObject = DP,\n  U extends BaseUserMeta = DU,\n> = Resolve<\n  InternalOthersEvent<P, U> & {\n    others: readonly User<P, U>[];\n  }\n>;\n\nexport enum TextEditorType {\n  Lexical = \"lexical\",\n  TipTap = \"tiptap\",\n  BlockNote = \"blocknote\",\n}\n\nexport type BadgeLocation =\n  | \"top-right\"\n  | \"bottom-right\"\n  | \"bottom-left\"\n  | \"top-left\";\n","import { detectDupes } from \"./dupe-detection\";\nimport { PKG_FORMAT, PKG_NAME, PKG_VERSION } from \"./version\";\n\ndetectDupes(PKG_NAME, PKG_VERSION, PKG_FORMAT);\n\n/**\n * PRIVATE / INTERNAL APIS\n * -----------------------\n *\n * This module is intended for internal use only, PLEASE DO NOT RELY ON ANY OF\n * THE EXPORTS IN HERE. These are implementation details that can change at any\n * time and without announcement. This module purely exists to share code\n * between the several Liveblocks packages.\n *\n * But since you're so deep inside Liveblocks code... we're hiring!\n * https://join.team/liveblocks ;)\n */\n\nexport type {\n  AiOpaqueToolDefinition,\n  AiOpaqueToolInvocationProps,\n  AiToolDefinition,\n  AiToolExecuteCallback,\n  AiToolExecuteContext,\n  AiToolInvocationProps,\n  AiToolTypePack,\n  LayerKey,\n  WithNavigation,\n} from \"./ai\";\nexport { defineAiTool } from \"./ai\";\nexport type {\n  Client,\n  ClientOptions,\n  EnterOptions,\n  OpaqueClient,\n  PrivateClientApi,\n  ResolveGroupsInfoArgs,\n  ResolveMentionSuggestionsArgs,\n  ResolveRoomsInfoArgs,\n  ResolveUsersArgs,\n  SyncStatus,\n} from \"./client\";\nexport { checkBounds, createClient } from \"./client\";\nexport type {\n  CommentBodyLinkElementArgs,\n  CommentBodyMentionElementArgs,\n  CommentBodyParagraphElementArgs,\n  CommentBodyTextElementArgs,\n  StringifyCommentBodyElements,\n  StringifyCommentBodyOptions,\n} from \"./comments/comment-body\";\nexport {\n  getMentionsFromCommentBody,\n  html,\n  htmlSafe,\n  isCommentBodyLink,\n  isCommentBodyMention,\n  isCommentBodyText,\n  resolveMentionsInCommentBody,\n  stringifyCommentBody,\n} from \"./comments/comment-body\";\nexport type { BaseAuthResult, Delegates } from \"./connection\";\nexport type { LostConnectionEvent, Status } from \"./connection\";\nexport { MENTION_CHARACTER } from \"./constants\";\nexport {\n  convertToCommentData,\n  convertToCommentUserReaction,\n  convertToGroupData,\n  convertToInboxNotificationData,\n  convertToSubscriptionData,\n  convertToThreadData,\n  convertToUserSubscriptionData,\n} from \"./convert-plain-data\";\nexport type {\n  CreateManagedPoolOptions,\n  ManagedPool,\n} from \"./crdts/AbstractCrdt\";\nexport { createManagedPool } from \"./crdts/AbstractCrdt\";\nexport { cloneLson, isLiveNode } from \"./crdts/liveblocks-helpers\";\nexport { LiveList } from \"./crdts/LiveList\";\nexport { LiveMap } from \"./crdts/LiveMap\";\nexport { LiveObject } from \"./crdts/LiveObject\";\nexport type {\n  LiveNode,\n  LiveStructure,\n  Lson,\n  LsonObject,\n  ToJson,\n} from \"./crdts/Lson\";\nexport type {\n  LiveListUpdate,\n  LiveMapUpdate,\n  LiveObjectUpdate,\n  StorageUpdate,\n} from \"./crdts/StorageUpdates\";\nexport type { ToImmutable } from \"./crdts/utils\";\nexport { toPlainLson } from \"./crdts/utils\";\nexport type {\n  DAD,\n  DCM,\n  DE,\n  DGI,\n  DP,\n  DRI,\n  DS,\n  DTM,\n  DU,\n  KDAD,\n} from \"./globals/augmentation\";\nexport {\n  legacy_patchImmutableObject,\n  lsonToJson,\n  patchLiveObjectKey,\n} from \"./immutable\";\nexport { kInternal } from \"./internal\";\nexport { makeAbortController } from \"./lib/abortController\";\nexport { assert, assertNever, nn } from \"./lib/assert\";\nexport type {\n  AsyncError,\n  AsyncLoading,\n  AsyncResult,\n  AsyncSuccess,\n} from \"./lib/AsyncResult\";\nexport { autoRetry, HttpError } from \"./lib/autoRetry\";\nexport { chunk } from \"./lib/chunk\";\nexport { Promise_withResolvers } from \"./lib/controlledPromise\";\nexport {\n  createCommentAttachmentId,\n  createCommentId,\n  createInboxNotificationId,\n  createThreadId,\n} from \"./lib/createIds\";\nexport { DefaultMap } from \"./lib/DefaultMap\";\nexport {\n  deprecate,\n  deprecateIf,\n  errorIf,\n  throwUsageError,\n} from \"./lib/deprecation\";\nexport { Deque } from \"./lib/Deque\";\nexport type {\n  EventSource,\n  Observable,\n  UnsubscribeCallback,\n} from \"./lib/EventSource\";\nexport { makeEventSource } from \"./lib/EventSource\";\nexport * as console from \"./lib/fancy-console\";\nexport { freeze } from \"./lib/freeze\";\nexport {\n  isNumberOperator,\n  isPlainObject,\n  isStartsWithOperator,\n} from \"./lib/guards\";\nexport type { Json, JsonArray, JsonObject, JsonScalar } from \"./lib/Json\";\nexport { isJsonArray, isJsonObject, isJsonScalar } from \"./lib/Json\";\nexport { nanoid } from \"./lib/nanoid\";\nexport type { NoInfr } from \"./lib/NoInfer\";\nexport { objectToQuery } from \"./lib/objectToQuery\";\nexport type { Poller } from \"./lib/Poller\";\nexport { makePoller } from \"./lib/Poller\";\nexport { asPos, makePosition } from \"./lib/position\";\nexport type { Relax } from \"./lib/Relax\";\nexport type { Resolve } from \"./lib/Resolve\";\nexport { shallow, shallow2 } from \"./lib/shallow\";\nexport type { ISignal, SignalType } from \"./lib/signals\";\nexport { batch, DerivedSignal, MutableSignal, Signal } from \"./lib/signals\";\nexport { SortedList } from \"./lib/SortedList\";\nexport { stableStringify } from \"./lib/stringify\";\nexport type { QueryParams, URLSafeString } from \"./lib/url\";\nexport { generateUrl, isUrl, sanitizeUrl, url, urljoin } from \"./lib/url\";\nexport type {\n  Brand,\n  DistributiveOmit,\n  ISODateString,\n  WithOptional,\n  WithRequired,\n} from \"./lib/utils\";\nexport {\n  b64decode,\n  compactObject,\n  entries,\n  findLastIndex,\n  keys,\n  mapValues,\n  memoizeOnSuccess,\n  raise,\n  tryParseJson,\n  wait,\n  withTimeout,\n} from \"./lib/utils\";\nexport { warnOnce, warnOnceIf } from \"./lib/warnings\";\nexport type {\n  ContextualPromptContext,\n  ContextualPromptResponse,\n} from \"./protocol/Ai\";\nexport type { CustomAuthenticationResult } from \"./protocol/Authentication\";\nexport { Permission } from \"./protocol/AuthToken\";\nexport type { BaseActivitiesData } from \"./protocol/BaseActivitiesData\";\nexport type { BaseGroupInfo } from \"./protocol/BaseGroupInfo\";\nexport type { BaseRoomInfo } from \"./protocol/BaseRoomInfo\";\nexport type { BaseUserMeta, IUserInfo } from \"./protocol/BaseUserMeta\";\nexport type {\n  BroadcastEventClientMsg,\n  ClientMsg,\n  FetchStorageClientMsg,\n  FetchYDocClientMsg,\n  UpdatePresenceClientMsg,\n  UpdateStorageClientMsg,\n  UpdateYDocClientMsg,\n} from \"./protocol/ClientMsg\";\nexport { ClientMsgCode } from \"./protocol/ClientMsg\";\nexport type { BaseMetadata } from \"./protocol/Comments\";\nexport type {\n  CommentBody,\n  CommentBodyBlockElement,\n  CommentBodyElement,\n  CommentBodyInlineElement,\n  CommentBodyLink,\n  CommentBodyMention,\n  CommentBodyParagraph,\n  CommentBodyText,\n} from \"./protocol/Comments\";\nexport type {\n  CommentAttachment,\n  CommentData,\n  CommentDataPlain,\n  CommentLocalAttachment,\n  CommentMixedAttachment,\n  CommentReaction,\n} from \"./protocol/Comments\";\nexport type {\n  CommentUserReaction,\n  CommentUserReactionPlain,\n} from \"./protocol/Comments\";\nexport type { QueryMetadata } from \"./protocol/Comments\";\nexport type {\n  SearchCommentsResult,\n  ThreadData,\n  ThreadDataPlain,\n  ThreadDataWithDeleteInfo,\n} from \"./protocol/Comments\";\nexport type { ThreadDeleteInfo } from \"./protocol/Comments\";\nexport type {\n  GroupData,\n  GroupDataPlain,\n  GroupMemberData,\n  GroupScopes,\n} from \"./protocol/Groups\";\nexport type {\n  ActivityData,\n  InboxNotificationCustomData,\n  InboxNotificationCustomDataPlain,\n  InboxNotificationData,\n  InboxNotificationDataPlain,\n  InboxNotificationTextMentionData,\n  InboxNotificationTextMentionDataPlain,\n  InboxNotificationThreadData,\n  InboxNotificationThreadDataPlain,\n} from \"./protocol/InboxNotifications\";\nexport type { InboxNotificationDeleteInfo } from \"./protocol/InboxNotifications\";\nexport type {\n  NotificationChannel,\n  NotificationChannelSettings,\n  NotificationKind,\n  NotificationSettings,\n  NotificationSettingsPlain,\n  PartialNotificationSettings,\n} from \"./protocol/NotificationSettings\";\nexport {\n  createNotificationSettings,\n  isNotificationChannelEnabled,\n  patchNotificationSettings,\n} from \"./protocol/NotificationSettings\";\nexport type {\n  ClientWireOp,\n  CreateListOp,\n  CreateMapOp,\n  CreateObjectOp,\n  CreateOp,\n  CreateRegisterOp,\n  DeleteCrdtOp,\n  DeleteObjectKeyOp,\n  HasOpId,\n  IgnoredOp,\n  Op,\n  ServerWireOp,\n  SetParentKeyOp,\n  UpdateObjectOp,\n} from \"./protocol/Op\";\nexport { OpCode } from \"./protocol/Op\";\nexport type {\n  RoomSubscriptionSettings,\n  UserRoomSubscriptionSettings,\n} from \"./protocol/RoomSubscriptionSettings\";\nexport type {\n  BroadcastedEventServerMsg,\n  CommentsEventServerMsg,\n  RejectedStorageOpServerMsg,\n  RoomStateServerMsg,\n  ServerMsg,\n  StorageChunkServerMsg,\n  UpdatePresenceServerMsg,\n  UpdateStorageServerMsg,\n  UserJoinServerMsg,\n  UserLeftServerMsg,\n  YDocUpdateServerMsg,\n} from \"./protocol/ServerMsg\";\nexport { ServerMsgCode } from \"./protocol/ServerMsg\";\nexport type {\n  ChildStorageNode,\n  CompactChildNode,\n  CompactListNode,\n  CompactMapNode,\n  CompactNode,\n  CompactObjectNode,\n  CompactRegisterNode,\n  CompactRootNode,\n  ListStorageNode,\n  MapStorageNode,\n  NodeMap,\n  NodeStream,\n  ObjectStorageNode,\n  RegisterStorageNode,\n  RootStorageNode,\n  SerializedChild,\n  SerializedCrdt,\n  SerializedList,\n  SerializedMap,\n  SerializedObject,\n  SerializedRegister,\n  SerializedRootObject,\n  StorageNode,\n} from \"./protocol/StorageNode\";\nexport {\n  compactNodesToNodeStream,\n  CrdtType,\n  isListStorageNode,\n  isMapStorageNode,\n  isObjectStorageNode,\n  isRegisterStorageNode,\n  isRootStorageNode,\n  nodeStreamToCompactNodes,\n} from \"./protocol/StorageNode\";\nexport type {\n  SubscriptionData,\n  SubscriptionDataPlain,\n  SubscriptionDeleteInfo,\n  SubscriptionDeleteInfoPlain,\n  SubscriptionKey,\n  UserSubscriptionData,\n  UserSubscriptionDataPlain,\n} from \"./protocol/Subscriptions\";\nexport { getSubscriptionKey } from \"./protocol/Subscriptions\";\nexport type { UrlMetadata } from \"./protocol/UrlMetadata\";\nexport type { HistoryVersion } from \"./protocol/VersionHistory\";\nexport type { IYjsProvider, PrivateRoomApi, YjsSyncStatus } from \"./room\";\nexport type {\n  BroadcastOptions,\n  History,\n  OpaqueRoom,\n  OptionalTupleUnless,\n  PartialUnless,\n  Room,\n  RoomEventMessage,\n  StorageStatus,\n  SyncSource,\n} from \"./room\";\nexport type { GetThreadsOptions, UploadAttachmentOptions } from \"./room\";\nexport type {\n  AiAssistantContentPart,\n  AiAssistantMessage,\n  AiChat,\n  AiChatMessage,\n  AiChatsQuery,\n  AiKnowledgeRetrievalPart,\n  AiKnowledgeSource,\n  AiReasoningPart,\n  AiRetrievalPart,\n  AiSourcesPart,\n  AiTextPart,\n  AiToolInvocationPart,\n  AiUrlSource,\n  AiUserMessage,\n  AiWebRetrievalPart,\n  CopilotId,\n  Cursor,\n  MessageId,\n  RenderableToolResultResponse,\n  ToolResultResponse,\n} from \"./types/ai\";\nexport type { Awaitable } from \"./types/Awaitable\";\nexport type { Immutable } from \"./types/Immutable\";\nexport type { InferFromSchema } from \"./types/InferFromSchema\";\nexport type {\n  IWebSocket,\n  IWebSocketCloseEvent,\n  IWebSocketEvent,\n  IWebSocketInstance,\n  IWebSocketMessageEvent,\n} from \"./types/IWebSocket\";\nexport { WebsocketCloseCodes } from \"./types/IWebSocket\";\nexport type { LiveblocksErrorContext } from \"./types/LiveblocksError\";\nexport { LiveblocksError } from \"./types/LiveblocksError\";\nexport type { ParentToChildNodeMap } from \"./types/NodeMap\";\nexport type { OthersEvent } from \"./types/Others\";\nexport { TextEditorType } from \"./types/Others\";\nexport type { Patchable } from \"./types/Patchable\";\nexport type {\n  PlainLson,\n  PlainLsonFields,\n  PlainLsonList,\n  PlainLsonMap,\n  PlainLsonObject,\n} from \"./types/PlainLson\";\nexport type { User } from \"./types/User\";\nexport { detectDupes };\nexport type {\n  GroupMentionData,\n  MentionData,\n  UserMentionData,\n} from \"./protocol/MentionData\";\n\n/**\n * Helper type to help users adopt to Lson types from interface definitions.\n * You should only use this to wrap interfaces you don't control. For more\n * information, see\n * https://liveblocks.io/docs/guides/limits#lson-constraint-and-interfaces\n */\n// prettier-ignore\nexport type EnsureJson<T> =\n  // Retain all valid `JSON` fields\n  T extends Json ? T :\n  // Retain all valid arrays\n  T extends Array<infer I> ? (EnsureJson<I>)[] :\n  // Retain `unknown` fields, but just treat them as if they're Json | undefined\n  [unknown] extends [T] ? Json | undefined :\n  // Dates become strings when serialized to JSON\n  T extends Date ? string :\n  // Remove functions\n  T extends (...args: any[]) => any ? never :\n  // Resolve all other values explicitly\n  { [K in keyof T as EnsureJson<T[K]> extends never ? never : K]: EnsureJson<T[K]> };\n\n// Support for DevTools\nimport type * as DevToolsMsg from \"./devtools/protocol\";\nexport type { DevToolsMsg };\nimport type { Json } from \"./lib/Json\";\nimport type * as DevTools from \"./types/DevToolsTreeNode\";\nexport type { DevTools };\n"],"names":["eventSource","error","error","call","batch","entries","t","entries","entries","url","values","parts","error","batch","url","err","after","now","WebsocketCloseCodes","error","log","ctx","id","error","message","url","now","Permission","now","error","hideButton","badge","parentKey","deleteDelta","before","after","entries","key","key","values","value","now","chunk","error","options","updates","event","now","batch","url","options","error","values","error","state","BACKOFF_DELAYS","TextEditorType"],"mappings":"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"}}]
}