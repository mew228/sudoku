{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/MAHARSHI%20NATH/OneDrive/Documents/sudoku/node_modules/%40liveblocks/react/src/contexts.ts","file:///C:/Users/MAHARSHI%20NATH/OneDrive/Documents/sudoku/node_modules/%40liveblocks/react/src/lib/use-latest.ts","file:///C:/Users/MAHARSHI%20NATH/OneDrive/Documents/sudoku/node_modules/%40liveblocks/react/src/ai.tsx","file:///C:/Users/MAHARSHI%20NATH/OneDrive/Documents/sudoku/node_modules/%40liveblocks/react/src/use-sync-external-store-with-selector.ts","file:///C:/Users/MAHARSHI%20NATH/OneDrive/Documents/sudoku/node_modules/%40liveblocks/react/src/use-signal.ts","file:///C:/Users/MAHARSHI%20NATH/OneDrive/Documents/sudoku/node_modules/%40liveblocks/react/src/liveblocks.tsx","file:///C:/Users/MAHARSHI%20NATH/OneDrive/Documents/sudoku/node_modules/%40liveblocks/react/src/config.ts","file:///C:/Users/MAHARSHI%20NATH/OneDrive/Documents/sudoku/node_modules/%40liveblocks/react/src/lib/AsyncResult.ts","file:///C:/Users/MAHARSHI%20NATH/OneDrive/Documents/sudoku/node_modules/%40liveblocks/react/src/lib/ssr.ts","file:///C:/Users/MAHARSHI%20NATH/OneDrive/Documents/sudoku/node_modules/%40liveblocks/react/src/lib/use-initial.ts","file:///C:/Users/MAHARSHI%20NATH/OneDrive/Documents/sudoku/node_modules/%40liveblocks/react/src/lib/use-polyfill.ts","file:///C:/Users/MAHARSHI%20NATH/OneDrive/Documents/sudoku/node_modules/%40liveblocks/react/src/umbrella-store.ts","file:///C:/Users/MAHARSHI%20NATH/OneDrive/Documents/sudoku/node_modules/%40liveblocks/react/src/lib/autobind.ts","file:///C:/Users/MAHARSHI%20NATH/OneDrive/Documents/sudoku/node_modules/%40liveblocks/react/src/lib/itertools.ts","file:///C:/Users/MAHARSHI%20NATH/OneDrive/Documents/sudoku/node_modules/%40liveblocks/react/src/lib/querying.ts","file:///C:/Users/MAHARSHI%20NATH/OneDrive/Documents/sudoku/node_modules/%40liveblocks/react/src/ThreadDB.ts","file:///C:/Users/MAHARSHI%20NATH/OneDrive/Documents/sudoku/node_modules/%40liveblocks/react/src/room.tsx","file:///C:/Users/MAHARSHI%20NATH/OneDrive/Documents/sudoku/node_modules/%40liveblocks/react/src/use-scroll-to-comment-on-load-effect.ts"],"sourcesContent":["import type {\n  BaseMetadata,\n  BaseUserMeta,\n  Client,\n  Json,\n  JsonObject,\n  LsonObject,\n  Room,\n} from \"@liveblocks/client\";\nimport type { OpaqueClient, OpaqueRoom } from \"@liveblocks/core\";\nimport { raise } from \"@liveblocks/core\";\nimport { createContext, useContext } from \"react\";\n\n/**\n * Raw access to the React context where the LiveblocksProvider stores the\n * current client. Exposed for advanced use cases only.\n *\n * @private This is a private/advanced API. Do not rely on it.\n */\nexport const ClientContext = createContext<OpaqueClient | null>(null);\n\n/**\n * @private This is an internal API.\n */\nexport function useClientOrNull<U extends BaseUserMeta>() {\n  return useContext(ClientContext) as Client<U> | null;\n}\n\n/**\n * Obtains a reference to the current Liveblocks client.\n */\nexport function useClient<U extends BaseUserMeta>() {\n  return (\n    useClientOrNull<U>() ??\n    raise(\"LiveblocksProvider is missing from the React tree.\")\n  );\n}\n\n/**\n * Raw access to the React context where the RoomProvider stores the current\n * room. Exposed for advanced use cases only.\n *\n * @private This is a private/advanced API. Do not rely on it.\n */\nexport const RoomContext = createContext<OpaqueRoom | null>(null);\n\n/** @private */\nexport function useRoomOrNull<\n  P extends JsonObject,\n  S extends LsonObject,\n  U extends BaseUserMeta,\n  E extends Json,\n  TM extends BaseMetadata,\n  CM extends BaseMetadata,\n>(): Room<P, S, U, E, TM, CM> | null {\n  return useContext(RoomContext) as Room<P, S, U, E, TM, CM> | null;\n}\n\n/**\n * Returns whether the hook is called within a RoomProvider context.\n *\n * @example\n * const isInsideRoom = useIsInsideRoom();\n */\nexport function useIsInsideRoom(): boolean {\n  const room = useRoomOrNull();\n  return room !== null;\n}\n","import type { MutableRefObject } from \"react\";\nimport { useEffect, useRef } from \"react\";\n\n/**\n * Keeps a ref in sync with a given value that may or may not change on\n * every render.\n *\n * The purpose of this hook is to return a stable ref that can be passed\n * to a callback function so the callback can be registered but still can\n * access the latest value at a later point in time.\n */\nexport function useLatest<T>(value: T): MutableRefObject<T> {\n  const ref = useRef(value);\n  useEffect(() => {\n    ref.current = value;\n  }, [value]);\n  return ref;\n}\n","import type { LayerKey } from \"@liveblocks/core\";\nimport { kInternal, nanoid } from \"@liveblocks/core\";\nimport { memo, useEffect, useId, useState } from \"react\";\n\nimport { useClient } from \"./contexts\";\nimport type { RegisterAiKnowledgeProps, RegisterAiToolProps } from \"./types/ai\";\n\nfunction useAi() {\n  return useClient()[kInternal].ai;\n}\n\nfunction useRandom() {\n  return useState(nanoid)[0];\n}\n\n/**\n * Make knowledge about your application state available to any AI used in\n * a chat or a one-off request.\n *\n * For example:\n *\n *     <RegisterAiKnowledge\n *        description=\"The current mode of my application\"\n *        value=\"dark\" />\n *\n * Or scoped to a specific chat:\n *\n *     <RegisterAiKnowledge\n *        description=\"The current list of todos\"\n *        value={todos}\n *        chatId=\"chat-1234\" />\n *\n * By mounting this component, the AI will get access to this knwoledge.\n * By unmounting this component, the AI will no longer have access to it.\n * It can choose to use or ignore this knowledge in its responses.\n */\nexport const RegisterAiKnowledge = memo(function RegisterAiKnowledge(\n  props: RegisterAiKnowledgeProps\n) {\n  const layerId = useId();\n  const ai = useAi();\n  const { description, value, chatId } = props;\n\n  const [layerKey, setLayerKey] = useState<LayerKey | undefined>();\n\n  // Executes at mount / unmount\n  useEffect(() => {\n    const { layerKey, deregister } = ai.registerKnowledgeLayer(layerId, chatId);\n    setLayerKey(layerKey);\n    return () => {\n      deregister();\n      setLayerKey(undefined);\n    };\n  }, [ai, layerId, chatId]);\n\n  // Executes every render (if the props have changed)\n  const randomKey = useRandom();\n  const knowledgeKey = props.id ?? randomKey;\n  useEffect(() => {\n    if (layerKey !== undefined) {\n      ai.updateKnowledge(\n        layerKey,\n        { description, value },\n        knowledgeKey,\n        chatId\n      );\n    }\n  }, [ai, layerKey, knowledgeKey, description, value, chatId]);\n\n  return null;\n});\n\n/**\n * Make a tool available to your AI chat or a one-off request.\n * A tool is a piece of functionality that the AI can call to perform an action\n * or look up information on the user's behalf.\n *\n * Also, tools are used to render custom UIs for tool invocations, which are\n * embedded inside the AI chat.\n *\n * For example:\n *\n *   <RegisterAiTool\n *     name=\"list-todos\"\n *     tool={defineAiTool()({ ... })}\n *     />\n *\n * Or scoped to a specific chat:\n *\n *   <RegisterAiTool\n *     name=\"list-todos\"\n *     tool={defineAiTool()({ ... })}\n *     chatId=\"chat-1234\"\n *     />\n *\n * By mounting this component, the tool is made available.\n * By unmounting this component, the tool will no longer be available.\n */\nexport const RegisterAiTool = memo(function RegisterAiTool({\n  chatId,\n  name,\n  tool,\n  enabled,\n}: RegisterAiToolProps) {\n  // Register the provided tools to the chat on mount and unregister them on unmount\n  const client = useClient();\n  const ai = client[kInternal].ai;\n  useEffect(() => {\n    // The `enabled` prop, when specified, will take precedence over the\n    // `enabled` property of the tool itself. This allows enabling or disabling\n    // the tool dynamically.\n    const toolWithEnabled = enabled !== undefined ? { ...tool, enabled } : tool;\n    return ai.registerTool(name, toolWithEnabled, chatId);\n  }, [ai, chatId, name, tool, enabled]);\n\n  return null;\n});\n","/* eslint-disable @typescript-eslint/no-unsafe-assignment */\n/* eslint-disable react-hooks/exhaustive-deps */\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport {\n  useDebugValue,\n  useEffect,\n  useMemo,\n  useRef,\n  useSyncExternalStore,\n} from \"react\";\n\n/**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */\nfunction is(x: any, y: any) {\n  return (\n    (x === y && (x !== 0 || 1 / x === 1 / y)) || (x !== x && y !== y) // eslint-disable-line no-self-compare\n  );\n}\n\n// Same as useSyncExternalStore, but supports selector and isEqual arguments.\nexport function useSyncExternalStoreWithSelector<Snapshot, Selection>(\n  subscribe: (callback: () => void) => () => void,\n  getSnapshot: () => Snapshot,\n  getServerSnapshot: void | null | (() => Snapshot),\n  selector: (snapshot: Snapshot) => Selection,\n  isEqual?: (a: Selection, b: Selection) => boolean\n): Selection {\n  type X =\n    | { hasValue: true; value: Selection }\n    | { hasValue: false; value: null }\n    | null;\n\n  // Use this to track the rendered snapshot.\n  const instRef = useRef<X>(null);\n\n  let inst: X;\n  if (instRef.current === null) {\n    inst = {\n      hasValue: false,\n      value: null,\n    };\n    instRef.current = inst;\n  } else {\n    inst = instRef.current;\n  }\n\n  const [getSelection, getServerSelection] = useMemo(() => {\n    // Track the memoized state using closure variables that are local to this\n    // memoized instance of a getSnapshot function. Intentionally not using a\n    // useRef hook, because that state would be shared across all concurrent\n    // copies of the hook/component.\n    let hasMemo = false;\n    let memoizedSnapshot: unknown;\n    let memoizedSelection: Selection;\n    const memoizedSelector = (nextSnapshot: Snapshot) => {\n      if (!hasMemo) {\n        // The first time the hook is called, there is no memoized result.\n        hasMemo = true;\n        memoizedSnapshot = nextSnapshot;\n        const nextSelection = selector(nextSnapshot);\n        if (isEqual !== undefined) {\n          // Even if the selector has changed, the currently rendered selection\n          // may be equal to the new selection. We should attempt to reuse the\n          // current value if possible, to preserve downstream memoizations.\n          if (inst.hasValue) {\n            const currentSelection = inst.value;\n            if (isEqual(currentSelection, nextSelection)) {\n              memoizedSelection = currentSelection!;\n              return currentSelection;\n            }\n          }\n        }\n        memoizedSelection = nextSelection;\n        return nextSelection;\n      }\n\n      // We may be able to reuse the previous invocation's result.\n      const prevSnapshot: Snapshot = memoizedSnapshot as any;\n      const prevSelection: Selection = memoizedSelection as any;\n\n      if (is(prevSnapshot, nextSnapshot)) {\n        // The snapshot is the same as last time. Reuse the previous selection.\n        return prevSelection;\n      }\n\n      // The snapshot has changed, so we need to compute a new selection.\n      const nextSelection = selector(nextSnapshot);\n\n      // If a custom isEqual function is provided, use that to check if the data\n      // has changed. If it hasn't, return the previous selection. That signals\n      // to React that the selections are conceptually equal, and we can bail\n      // out of rendering.\n      if (isEqual !== undefined && isEqual(prevSelection, nextSelection)) {\n        // The snapshot still has changed, so make sure to update to not keep\n        // old references alive\n        memoizedSnapshot = nextSnapshot;\n        return prevSelection;\n      }\n\n      memoizedSnapshot = nextSnapshot;\n      memoizedSelection = nextSelection;\n      return nextSelection;\n    };\n\n    const maybeGetServerSnapshot =\n      getServerSnapshot === undefined ? null : getServerSnapshot;\n    const getSnapshotWithSelector = () => memoizedSelector(getSnapshot());\n    const getServerSnapshotWithSelector =\n      maybeGetServerSnapshot === null\n        ? undefined\n        : () => memoizedSelector(maybeGetServerSnapshot());\n    return [getSnapshotWithSelector, getServerSnapshotWithSelector];\n  }, [getSnapshot, getServerSnapshot, selector, isEqual]);\n\n  const value = useSyncExternalStore(\n    subscribe,\n    getSelection,\n    getServerSelection\n  );\n\n  useEffect(() => {\n    inst.hasValue = true;\n    inst.value = value;\n  }, [value]);\n\n  useDebugValue(value);\n  return value;\n}\n","import type { ISignal } from \"@liveblocks/core\";\nimport { MutableSignal } from \"@liveblocks/core\";\n\nimport { useSyncExternalStoreWithSelector } from \"./use-sync-external-store-with-selector\";\n\nconst identity = <T>(value: T): T => value;\n\nexport function useSignal<T>(signal: ISignal<T>): T;\nexport function useSignal<T, V>(\n  signal: ISignal<T>,\n  selector: (value: T) => V,\n  isEqual?: (a: V, b: V) => boolean\n): V;\nexport function useSignal<T, V>(\n  signal: ISignal<T>,\n  selector?: (value: T) => V,\n  isEqual?: (a: V, b: V) => boolean\n): T | V {\n  if (signal instanceof MutableSignal) {\n    throw new Error(\n      \"Using a mutable Signal with useSignal will likely not work as expected.\"\n    );\n  }\n  return useSyncExternalStoreWithSelector(\n    signal.subscribe,\n    signal.get,\n    signal.get,\n    selector ?? (identity as (value: T) => V),\n    isEqual\n  );\n}\n","import type {\n  BaseMetadata,\n  BaseUserMeta,\n  Client,\n  ClientOptions,\n  ThreadData,\n} from \"@liveblocks/client\";\nimport type {\n  AiUserMessage,\n  AsyncResult,\n  BaseGroupInfo,\n  BaseRoomInfo,\n  CopilotId,\n  DCM,\n  DTM,\n  DU,\n  LiveblocksError,\n  MessageId,\n  OpaqueClient,\n  PartialNotificationSettings,\n  SyncStatus,\n  WithRequired,\n} from \"@liveblocks/core\";\nimport {\n  assert,\n  console,\n  createClient,\n  DefaultMap,\n  HttpError,\n  kInternal,\n  makePoller,\n  raise,\n  shallow,\n} from \"@liveblocks/core\";\nimport type { PropsWithChildren } from \"react\";\nimport {\n  useCallback,\n  useEffect,\n  useMemo,\n  useState,\n  useSyncExternalStore,\n} from \"react\";\n\nimport { RegisterAiKnowledge, RegisterAiTool } from \"./ai\";\nimport { config } from \"./config\";\nimport {\n  ClientContext,\n  useClient,\n  useClientOrNull,\n  useIsInsideRoom,\n} from \"./contexts\";\nimport { ASYNC_OK } from \"./lib/AsyncResult\";\nimport { ensureNotServerSide } from \"./lib/ssr\";\nimport { useInitial, useInitialUnlessFunction } from \"./lib/use-initial\";\nimport { useLatest } from \"./lib/use-latest\";\nimport { use } from \"./lib/use-polyfill\";\nimport type {\n  AiChatAsyncResult,\n  AiChatAsyncSuccess,\n  AiChatMessagesAsyncResult,\n  AiChatMessagesAsyncSuccess,\n  AiChatsAsyncResult,\n  AiChatsAsyncSuccess,\n  AiChatStatus,\n  CreateAiChatOptions,\n  GroupInfoAsyncResult,\n  GroupInfoAsyncSuccess,\n  InboxNotificationsAsyncResult,\n  LiveblocksContextBundle,\n  NotificationSettingsAsyncResult,\n  NotificationSettingsAsyncSuccess,\n  RoomInfoAsyncResult,\n  RoomInfoAsyncSuccess,\n  SendAiMessageOptions,\n  SharedContextBundle,\n  ThreadsAsyncResult,\n  ThreadsAsyncSuccess,\n  UnreadInboxNotificationsCountAsyncResult,\n  UrlMetadataAsyncResult,\n  UrlMetadataAsyncSuccess,\n  UseAiChatsOptions,\n  UseInboxNotificationsOptions,\n  UserAsyncResult,\n  UserAsyncSuccess,\n  UseSendAiMessageOptions,\n  UseSyncStatusOptions,\n  UseUserThreadsOptions,\n} from \"./types\";\nimport {\n  makeAiChatsQueryKey,\n  makeInboxNotificationsQueryKey,\n  makeUserThreadsQueryKey,\n  UmbrellaStore,\n} from \"./umbrella-store\";\nimport { useSignal } from \"./use-signal\";\nimport { useSyncExternalStoreWithSelector } from \"./use-sync-external-store-with-selector\";\n\nfunction missingUserError(userId: string) {\n  return new Error(`resolveUsers didn't return anything for user '${userId}'`);\n}\n\nfunction missingRoomInfoError(roomId: string) {\n  return new Error(\n    `resolveRoomsInfo didn't return anything for room '${roomId}'`\n  );\n}\n\nfunction missingGroupInfoError(groupId: string) {\n  return new Error(\n    `resolveGroupsInfo didn't return anything for group '${groupId}'`\n  );\n}\n\nfunction identity<T>(x: T): T {\n  return x;\n}\n\nconst _umbrellaStores = new WeakMap<\n  OpaqueClient,\n  UmbrellaStore<BaseMetadata, BaseMetadata>\n>();\nconst _extras = new WeakMap<\n  OpaqueClient,\n  ReturnType<typeof makeLiveblocksExtrasForClient>\n>();\nconst _bundles = new WeakMap<\n  OpaqueClient,\n  LiveblocksContextBundle<BaseUserMeta, BaseMetadata, BaseMetadata>\n>();\n\nfunction selectorFor_useUnreadInboxNotificationsCount(\n  result: UnreadInboxNotificationsCountAsyncResult\n): UnreadInboxNotificationsCountAsyncResult {\n  if (!(\"count\" in result) || result.count === undefined) {\n    // Can be loading or error states\n    return result;\n  }\n\n  return ASYNC_OK(\"count\", result.count);\n}\n\nfunction selectorFor_useUser<U extends BaseUserMeta>(\n  state: AsyncResult<U[\"info\"] | undefined> | undefined,\n  userId: string\n): UserAsyncResult<U[\"info\"]> {\n  if (state === undefined || state?.isLoading) {\n    return state ?? { isLoading: true };\n  }\n\n  if (state.error) {\n    return state;\n  }\n\n  // If this is a \"success\" state, but there still is no data, then it means\n  // the \"resolving of this user\" returned undefined. In that case, still treat\n  // this as an error state.\n  if (!state.data) {\n    return {\n      isLoading: false,\n      error: missingUserError(userId),\n    };\n  }\n\n  return {\n    isLoading: false,\n    user: state.data,\n  };\n}\n\nfunction selectorFor_useRoomInfo(\n  state: AsyncResult<BaseRoomInfo | undefined> | undefined,\n  roomId: string\n): RoomInfoAsyncResult {\n  if (state === undefined || state?.isLoading) {\n    return state ?? { isLoading: true };\n  }\n\n  if (state.error) {\n    return state;\n  }\n\n  // If this is a \"success\" state, but there still is no data, then it means\n  // the \"resolving of this room info\" returned undefined. In that case, still treat\n  // this as an error state.\n  if (!state.data) {\n    return {\n      isLoading: false,\n      error: missingRoomInfoError(roomId),\n    };\n  }\n\n  return {\n    isLoading: false,\n    info: state.data,\n  };\n}\n\nfunction selectorFor_useGroupInfo(\n  state: AsyncResult<BaseGroupInfo | undefined> | undefined,\n  groupId: string\n): GroupInfoAsyncResult {\n  if (state === undefined || state?.isLoading) {\n    return state ?? { isLoading: true };\n  }\n\n  if (state.error) {\n    return state;\n  }\n\n  // If this is a \"success\" state, but there still is no data, then it means\n  // the \"resolving of this group info\" returned undefined. In that case, still treat\n  // this as an error state.\n  if (!state.data) {\n    return {\n      isLoading: false,\n      error: missingGroupInfoError(groupId),\n    };\n  }\n\n  return {\n    isLoading: false,\n    info: state.data,\n  };\n}\n\nfunction getOrCreateContextBundle<\n  U extends BaseUserMeta,\n  TM extends BaseMetadata,\n  CM extends BaseMetadata,\n>(client: OpaqueClient): LiveblocksContextBundle<U, TM, CM> {\n  let bundle = _bundles.get(client);\n  if (!bundle) {\n    bundle = makeLiveblocksContextBundle(client);\n    _bundles.set(client, bundle);\n  }\n  return bundle as unknown as LiveblocksContextBundle<U, TM, CM>;\n}\n\n/**\n * Gets or creates a unique Umbrella store for each unique client instance.\n *\n * @private\n */\nexport function getUmbrellaStoreForClient<\n  TM extends BaseMetadata,\n  CM extends BaseMetadata,\n>(client: OpaqueClient): UmbrellaStore<TM, CM> {\n  let store = _umbrellaStores.get(client);\n  if (!store) {\n    store = new UmbrellaStore(client);\n    _umbrellaStores.set(client, store);\n  }\n  return store as unknown as UmbrellaStore<TM, CM>;\n}\n\n// TODO: Likely a better / more clear name for this helper will arise. I'll\n// rename this later. All of these are implementation details to support inbox\n// notifications on a per-client basis.\n/** @internal Only exported for unit tests. */\nexport function getLiveblocksExtrasForClient<\n  TM extends BaseMetadata,\n  CM extends BaseMetadata,\n>(client: OpaqueClient) {\n  let extras = _extras.get(client);\n  if (!extras) {\n    extras = makeLiveblocksExtrasForClient(client);\n    _extras.set(client, extras);\n  }\n\n  return extras as unknown as Omit<typeof extras, \"store\"> & {\n    store: UmbrellaStore<TM, CM>;\n  };\n}\n\n// Connect to the AI socket whenever this hook is called, to use in all AI-related hooks.\n//\n// The internal `ManagedSocket` no-ops when calling `connect()` if it is already connected,\n// so we don't need any conditional logic here. And we don't call `disconnect()` in cleanup\n// here because we don't want to disconnect whenever a single hook unmounts, instead we\n// disconnect when `LiveblocksProvider` unmounts.\n//\n// This is a short-term solution to avoid always asking for an auth token on mount\n// even when AI isn't used.\n//\n// - We maybe could disconnect whenever the last AI-related hook unmounts\n// - We maybe could avoid connecting if we already have a token (from another Liveblocks feature),\n//   and already know that the user doesn't have AI enabled\nfunction useEnsureAiConnection(client: OpaqueClient) {\n  useEffect(() => {\n    client[kInternal].ai.connectInitially();\n  }, [client]);\n}\n\nfunction makeLiveblocksExtrasForClient(client: OpaqueClient) {\n  const store = getUmbrellaStoreForClient(client);\n  // TODO                                ^ Bind to M type param here\n\n  //\n  // How pagination and delta updates work\n  // =====================================\n  //\n  // Suppose we call fetchInboxNotifications() for the first time. Then,\n  // eventually we'll see this timeline of notifications:\n  //\n  // <-- Newer                        Older -->\n  //       |---o---------o----------o---|\n  //\n  //       o = an inbox notification\n  //\n  // In this array, there are three entries, ordered from latest to oldest.\n  //\n  // Now if we call fetchInboxNotifications() again (which is what the\n  // periodic poller does), then the array may get updated with newer inbox\n  // notifications, meaning entries will appear at the head end of the array.\n  // This is a so called \"delta update\".\n  //\n  // <-- Newer                                 Older -->\n  //       |--o---o-|---o---------o----------o---|\n  //          delta\n  //\n  // Here, two new entries have appeared at the start.\n  //\n  // Another way to update this array is to use \"pagination\". Pagination will\n  // update this list at the _tail_ end.\n  //\n  // After calling fetchMore():\n  //\n  // <-- Newer                                                  Older -->\n  //       |--o---o-|---o---------o----------o---|--o--o-o-o-o-o--|\n  //                                                   page 2\n  //\n  // And calling fetchMore() another time:\n  //\n  // <-- Newer                                                                  Older -->\n  //       |--o---o-|---o---------o----------o---|--o--o-o-o-o-o--|--o-o---o---o--|\n  //                                                   page 2           page 3\n  //\n  // In terms of HTTP requests:\n  // - A delta update will perform a GET /v2/c/inbox-notifications?since=...\n  // - Pagination will perform a GET /v2/c/inbox-notifications?cursor=...\n  //\n\n  const notificationsPoller = makePoller(\n    async (signal) => {\n      try {\n        return await store.fetchNotificationsDeltaUpdate(signal);\n      } catch (err) {\n        console.warn(`Polling new inbox notifications failed: ${String(err)}`);\n        throw err;\n      }\n    },\n    config.NOTIFICATIONS_POLL_INTERVAL,\n    { maxStaleTimeMs: config.NOTIFICATIONS_MAX_STALE_TIME }\n  );\n\n  const unreadNotificationsCountPollersByQueryKey = new DefaultMap(\n    (queryKey: string) =>\n      makePoller(\n        async (signal) => {\n          try {\n            return await store.fetchUnreadNotificationsCount(queryKey, signal);\n          } catch (err) {\n            console.warn(\n              `Polling unread inbox notifications countfailed: ${String(err)}`\n            );\n            throw err;\n          }\n        },\n        config.NOTIFICATIONS_POLL_INTERVAL,\n        { maxStaleTimeMs: config.NOTIFICATIONS_MAX_STALE_TIME }\n      )\n  );\n\n  const userThreadsPoller = makePoller(\n    async (signal) => {\n      try {\n        return await store.fetchUserThreadsDeltaUpdate(signal);\n      } catch (err) {\n        console.warn(`Polling new user threads failed: ${String(err)}`);\n        throw err;\n      }\n    },\n    config.USER_THREADS_POLL_INTERVAL,\n    { maxStaleTimeMs: config.USER_THREADS_MAX_STALE_TIME }\n  );\n\n  const notificationSettingsPoller = makePoller(\n    async (signal) => {\n      try {\n        return await store.refreshNotificationSettings(signal);\n      } catch (err) {\n        console.warn(\n          `Polling new notification settings failed: ${String(err)}`\n        );\n        throw err;\n      }\n    },\n    config.USER_NOTIFICATION_SETTINGS_INTERVAL,\n    { maxStaleTimeMs: config.USER_NOTIFICATION_SETTINGS_MAX_STALE_TIME }\n  );\n\n  return {\n    store,\n    notificationsPoller,\n    userThreadsPoller,\n    notificationSettingsPoller,\n    unreadNotificationsCountPollersByQueryKey,\n  };\n}\n\nfunction makeLiveblocksContextBundle<\n  U extends BaseUserMeta,\n  TM extends BaseMetadata,\n  CM extends BaseMetadata,\n>(client: Client<U>): LiveblocksContextBundle<U, TM, CM> {\n  // Bind all hooks to the current client instance\n  const useInboxNotificationThread = (inboxNotificationId: string) =>\n    useInboxNotificationThread_withClient<TM, CM>(client, inboxNotificationId);\n\n  const useMarkInboxNotificationAsRead = () =>\n    useMarkInboxNotificationAsRead_withClient(client);\n\n  const useMarkAllInboxNotificationsAsRead = () =>\n    useMarkAllInboxNotificationsAsRead_withClient(client);\n\n  const useDeleteInboxNotification = () =>\n    useDeleteInboxNotification_withClient(client);\n\n  const useDeleteAllInboxNotifications = () =>\n    useDeleteAllInboxNotifications_withClient(client);\n\n  const useUpdateNotificationSettings = () =>\n    useUpdateNotificationSettings_withClient(client);\n\n  // NOTE: This version of the LiveblocksProvider does _not_ take any props.\n  // This is because we already have a client bound to it.\n  function LiveblocksProvider(props: PropsWithChildren) {\n    useEnsureNoLiveblocksProvider();\n    return (\n      <ClientContext.Provider value={client}>\n        {props.children}\n      </ClientContext.Provider>\n    );\n  }\n\n  const shared = createSharedContext<U>(client);\n\n  const bundle: LiveblocksContextBundle<U, TM, CM> = {\n    LiveblocksProvider,\n\n    useInboxNotifications: (options?: UseInboxNotificationsOptions) =>\n      useInboxNotifications_withClient(client, identity, shallow, options),\n    useUnreadInboxNotificationsCount: (\n      options?: UseInboxNotificationsOptions\n    ) => useUnreadInboxNotificationsCount_withClient(client, options),\n\n    useMarkInboxNotificationAsRead,\n    useMarkAllInboxNotificationsAsRead,\n\n    useDeleteInboxNotification,\n    useDeleteAllInboxNotifications,\n\n    useNotificationSettings: () => useNotificationSettings_withClient(client),\n    useUpdateNotificationSettings,\n\n    useInboxNotificationThread,\n    useUserThreads_experimental,\n\n    useAiChats,\n    useAiChat,\n    useAiChatMessages,\n    useAiChatStatus,\n    useCreateAiChat,\n    useDeleteAiChat,\n    useSendAiMessage,\n\n    useUrlMetadata,\n\n    ...shared.classic,\n\n    suspense: {\n      LiveblocksProvider,\n\n      useInboxNotifications: (options?: UseInboxNotificationsOptions) =>\n        useInboxNotificationsSuspense_withClient(client, options),\n      useUnreadInboxNotificationsCount: (\n        options?: UseInboxNotificationsOptions\n      ) => useUnreadInboxNotificationsCountSuspense_withClient(client, options),\n\n      useMarkInboxNotificationAsRead,\n      useMarkAllInboxNotificationsAsRead,\n\n      useDeleteInboxNotification,\n      useDeleteAllInboxNotifications,\n\n      useInboxNotificationThread,\n\n      useNotificationSettings: () =>\n        useNotificationSettingsSuspense_withClient(client),\n      useUpdateNotificationSettings,\n\n      useUserThreads_experimental: useUserThreadsSuspense_experimental,\n\n      useAiChats: useAiChatsSuspense,\n      useAiChat: useAiChatSuspense,\n      useAiChatMessages: useAiChatMessagesSuspense,\n      useAiChatStatus,\n      useCreateAiChat,\n      useDeleteAiChat,\n      useSendAiMessage,\n\n      useUrlMetadata: useUrlMetadataSuspense,\n\n      ...shared.suspense,\n    },\n  };\n  return bundle;\n}\n\nfunction useInboxNotifications_withClient<T>(\n  client: OpaqueClient,\n  selector: (result: InboxNotificationsAsyncResult) => T,\n  isEqual: (a: T, b: T) => boolean,\n  options?: UseInboxNotificationsOptions\n): T {\n  const { store, notificationsPoller: poller } =\n    getLiveblocksExtrasForClient(client);\n\n  const queryKey = makeInboxNotificationsQueryKey(options?.query);\n\n  // Trigger initial loading of inbox notifications if it hasn't started\n  // already, but don't await its promise.\n  useEffect(\n    () =>\n      void store.outputs.loadingNotifications\n        .getOrCreate(queryKey)\n        .waitUntilLoaded()\n\n    // NOTE: Deliberately *not* using a dependency array here!\n    //\n    // It is important to call waitUntil on *every* render.\n    // This is harmless though, on most renders, except:\n    // 1. The very first render, in which case we'll want to trigger the initial page fetch.\n    // 2. All other subsequent renders now \"just\" return the same promise (a quick operation).\n    // 3. If ever the promise would fail, then after 5 seconds it would reset, and on the very\n    //    *next* render after that, a *new* fetch/promise will get created.\n  );\n\n  useEffect(() => {\n    poller.inc();\n    poller.pollNowIfStale();\n    return () => {\n      poller.dec();\n    };\n  }, [poller]);\n\n  return useSignal(\n    store.outputs.loadingNotifications.getOrCreate(queryKey).signal,\n    selector,\n    isEqual\n  );\n}\n\nfunction useInboxNotificationsSuspense_withClient(\n  client: OpaqueClient,\n  options?: UseInboxNotificationsOptions\n) {\n  // Throw error if we're calling this hook server side\n  ensureNotServerSide();\n\n  const store = getLiveblocksExtrasForClient(client).store;\n\n  const queryKey = makeInboxNotificationsQueryKey(options?.query);\n\n  // Suspend until there are at least some inbox notifications\n  use(\n    store.outputs.loadingNotifications.getOrCreate(queryKey).waitUntilLoaded()\n  );\n\n  // We're in a Suspense world here, and as such, the useInboxNotifications()\n  // hook is expected to only return success results when we're here.\n  const result = useInboxNotifications_withClient(\n    client,\n    identity,\n    shallow,\n    options\n  );\n  assert(!result.error, \"Did not expect error\");\n  assert(!result.isLoading, \"Did not expect loading\");\n  return result;\n}\n\nfunction useUnreadInboxNotificationsCount_withClient(\n  client: OpaqueClient,\n  options?: UseInboxNotificationsOptions\n) {\n  const { store, unreadNotificationsCountPollersByQueryKey: pollers } =\n    getLiveblocksExtrasForClient(client);\n\n  const queryKey = makeInboxNotificationsQueryKey(options?.query);\n\n  const poller = pollers.getOrCreate(queryKey);\n\n  useEffect(\n    () =>\n      void store.outputs.unreadNotificationsCount\n        .getOrCreate(queryKey)\n        .waitUntilLoaded()\n\n    // NOTE: Deliberately *not* using a dependency array here!\n    //\n    // It is important to call waitUntil on *every* render.\n    // This is harmless though, on most renders, except:\n    // 1. The very first render, in which case we'll want to trigger the initial page fetch.\n    // 2. All other subsequent renders now \"just\" return the same promise (a quick operation).\n    // 3. If ever the promise would fail, then after 5 seconds it would reset, and on the very\n    //    *next* render after that, a *new* fetch/promise will get created.\n  );\n\n  useEffect(() => {\n    poller.inc();\n    poller.pollNowIfStale();\n    return () => {\n      poller.dec();\n    };\n  }, [poller]);\n\n  return useSignal(\n    store.outputs.unreadNotificationsCount.getOrCreate(queryKey).signal,\n    selectorFor_useUnreadInboxNotificationsCount,\n    shallow\n  );\n}\n\nfunction useUnreadInboxNotificationsCountSuspense_withClient(\n  client: OpaqueClient,\n  options?: UseInboxNotificationsOptions\n) {\n  // Throw error if we're calling this hook server side\n  ensureNotServerSide();\n\n  const store = getLiveblocksExtrasForClient(client).store;\n\n  const queryKey = makeInboxNotificationsQueryKey(options?.query);\n\n  // Suspend until there are at least some unread inbox notifications count\n  use(\n    store.outputs.unreadNotificationsCount\n      .getOrCreate(queryKey)\n      .waitUntilLoaded()\n  );\n\n  const result = useUnreadInboxNotificationsCount_withClient(client, options);\n  assert(!result.isLoading, \"Did not expect loading\");\n  assert(!result.error, \"Did not expect error\");\n  return result;\n}\n\nfunction useMarkInboxNotificationAsRead_withClient(client: OpaqueClient) {\n  return useCallback(\n    (inboxNotificationId: string) => {\n      const { store, unreadNotificationsCountPollersByQueryKey } =\n        getLiveblocksExtrasForClient(client);\n\n      const readAt = new Date();\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"mark-inbox-notification-as-read\",\n        inboxNotificationId,\n        readAt,\n      });\n\n      client.markInboxNotificationAsRead(inboxNotificationId).then(\n        () => {\n          // Replace the optimistic update by the real thing\n          store.markInboxNotificationRead(\n            inboxNotificationId,\n            readAt,\n            optimisticId\n          );\n\n          // Force a re-fetch of the unread notifications count\n          for (const poller of unreadNotificationsCountPollersByQueryKey.values()) {\n            poller.markAsStale();\n            poller.pollNowIfStale();\n          }\n        },\n        (err: Error) => {\n          store.optimisticUpdates.remove(optimisticId);\n          // XXX_vincent Add unit test for this error\n          client[kInternal].emitError(\n            {\n              type: \"MARK_INBOX_NOTIFICATION_AS_READ_ERROR\",\n              inboxNotificationId,\n            },\n            err\n          );\n        }\n      );\n    },\n    [client]\n  );\n}\n\nfunction useMarkAllInboxNotificationsAsRead_withClient(client: OpaqueClient) {\n  return useCallback(() => {\n    const { store, unreadNotificationsCountPollersByQueryKey } =\n      getLiveblocksExtrasForClient(client);\n    const readAt = new Date();\n    const optimisticId = store.optimisticUpdates.add({\n      type: \"mark-all-inbox-notifications-as-read\",\n      readAt,\n    });\n\n    client.markAllInboxNotificationsAsRead().then(\n      () => {\n        // Replace the optimistic update by the real thing\n        store.markAllInboxNotificationsRead(optimisticId, readAt);\n\n        // Force a re-fetch of the unread notifications count\n        for (const poller of unreadNotificationsCountPollersByQueryKey.values()) {\n          poller.markAsStale();\n          poller.pollNowIfStale();\n        }\n      },\n      (err: Error) => {\n        store.optimisticUpdates.remove(optimisticId);\n        client[kInternal].emitError(\n          // No roomId, threadId, commentId to include for this error\n          { type: \"MARK_ALL_INBOX_NOTIFICATIONS_AS_READ_ERROR\" },\n          err\n        );\n      }\n    );\n  }, [client]);\n}\n\nfunction useDeleteInboxNotification_withClient(client: OpaqueClient) {\n  return useCallback(\n    (inboxNotificationId: string) => {\n      const { store, unreadNotificationsCountPollersByQueryKey } =\n        getLiveblocksExtrasForClient(client);\n\n      const deletedAt = new Date();\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"delete-inbox-notification\",\n        inboxNotificationId,\n        deletedAt,\n      });\n\n      client.deleteInboxNotification(inboxNotificationId).then(\n        () => {\n          // Replace the optimistic update by the real thing\n          store.deleteInboxNotification(inboxNotificationId, optimisticId);\n\n          // Force a re-fetch of the unread notifications count\n          for (const poller of unreadNotificationsCountPollersByQueryKey.values()) {\n            poller.markAsStale();\n            poller.pollNowIfStale();\n          }\n        },\n        (err: Error) => {\n          store.optimisticUpdates.remove(optimisticId);\n          // XXX_vincent Add unit test for this error\n          client[kInternal].emitError(\n            { type: \"DELETE_INBOX_NOTIFICATION_ERROR\", inboxNotificationId },\n            err\n          );\n        }\n      );\n    },\n    [client]\n  );\n}\n\nfunction useDeleteAllInboxNotifications_withClient(client: OpaqueClient) {\n  return useCallback(() => {\n    const { store, unreadNotificationsCountPollersByQueryKey } =\n      getLiveblocksExtrasForClient(client);\n    const deletedAt = new Date();\n    const optimisticId = store.optimisticUpdates.add({\n      type: \"delete-all-inbox-notifications\",\n      deletedAt,\n    });\n\n    client.deleteAllInboxNotifications().then(\n      () => {\n        // Replace the optimistic update by the real thing\n        store.deleteAllInboxNotifications(optimisticId);\n\n        // Force a re-fetch of the unread notifications count\n        for (const poller of unreadNotificationsCountPollersByQueryKey.values()) {\n          poller.markAsStale();\n          poller.pollNowIfStale();\n        }\n      },\n      (err: Error) => {\n        store.optimisticUpdates.remove(optimisticId);\n        // XXX_vincent Add unit test for this error\n        client[kInternal].emitError(\n          { type: \"DELETE_ALL_INBOX_NOTIFICATIONS_ERROR\" },\n          err\n        );\n      }\n    );\n  }, [client]);\n}\n\nfunction useInboxNotificationThread_withClient<\n  TM extends BaseMetadata,\n  CM extends BaseMetadata,\n>(client: OpaqueClient, inboxNotificationId: string): ThreadData<TM, CM> {\n  const { store } = getLiveblocksExtrasForClient<TM, CM>(client);\n  return useSignal(\n    store.outputs.threadifications,\n    useCallback(\n      (state) => {\n        const inboxNotification =\n          state.notificationsById[inboxNotificationId] ??\n          raise(\n            `Inbox notification with ID \"${inboxNotificationId}\" not found`\n          );\n\n        if (inboxNotification.kind !== \"thread\") {\n          raise(\n            `Inbox notification with ID \"${inboxNotificationId}\" is not of kind \"thread\"`\n          );\n        }\n\n        const thread =\n          state.threadsDB.get(inboxNotification.threadId) ??\n          raise(\n            `Thread with ID \"${inboxNotification.threadId}\" not found, this inbox notification might not be of kind \"thread\"`\n          );\n\n        return thread;\n      },\n      [inboxNotificationId]\n    )\n  );\n}\n\nfunction useUpdateNotificationSettings_withClient(\n  client: OpaqueClient\n): (settings: PartialNotificationSettings) => void {\n  return useCallback(\n    (settings: PartialNotificationSettings): void => {\n      const { store } = getLiveblocksExtrasForClient(client);\n      const optimisticUpdateId = store.optimisticUpdates.add({\n        type: \"update-notification-settings\",\n        settings,\n      });\n\n      client.updateNotificationSettings(settings).then(\n        (settings) => {\n          // Replace the optimistic update by the real thing\n          store.updateNotificationSettings_confirmOptimisticUpdate(\n            settings,\n            optimisticUpdateId\n          );\n        },\n        (err: Error) => {\n          // Remove optimistic update when it fails\n          store.optimisticUpdates.remove(optimisticUpdateId);\n          // Check if the error is an HTTP error\n          if (err instanceof HttpError) {\n            if (err.status === 422) {\n              const msg = [err.details?.error, err.details?.reason]\n                .filter(Boolean)\n                .join(\"\\n\");\n              console.error(msg);\n            }\n\n            client[kInternal].emitError(\n              {\n                type: \"UPDATE_NOTIFICATION_SETTINGS_ERROR\",\n              },\n              err\n            );\n          }\n          // A non-HTTP error is unexpected and must be considered as a bug.\n          // We should fix it and do not notify users about it.\n          else {\n            throw err;\n          }\n        }\n      );\n    },\n    [client]\n  );\n}\n\nfunction useNotificationSettings_withClient(\n  client: OpaqueClient\n): [\n  NotificationSettingsAsyncResult,\n  (settings: PartialNotificationSettings) => void,\n] {\n  const updateNotificationSettings =\n    useUpdateNotificationSettings_withClient(client);\n\n  const { store, notificationSettingsPoller: poller } =\n    getLiveblocksExtrasForClient(client);\n\n  useEffect(() => {\n    void store.outputs.notificationSettings.waitUntilLoaded();\n    // NOTE: Deliberately *not* using a dependency array here!\n    //\n    // It is important to call waitUntil on *every* render.\n    // This is harmless though, on most renders, except:\n    // 1. The very first render, in which case we'll want to trigger the initial page fetch.\n    // 2. All other subsequent renders now \"just\" return the same promise (a quick operation).\n    // 3. If ever the promise would fail, then after 5 seconds it would reset, and on the very\n    //    *next* render after that, a *new* fetch/promise will get created.\n  });\n\n  useEffect(() => {\n    poller.inc();\n    poller.pollNowIfStale();\n    return () => {\n      poller.dec();\n    };\n  }, [poller]);\n\n  const result = useSignal(store.outputs.notificationSettings.signal);\n\n  return useMemo(() => {\n    return [result, updateNotificationSettings];\n  }, [result, updateNotificationSettings]);\n}\n\nfunction useNotificationSettingsSuspense_withClient(\n  client: OpaqueClient\n): [\n  NotificationSettingsAsyncSuccess,\n  (settings: PartialNotificationSettings) => void,\n] {\n  // Throw error if we're calling this hook server side\n  ensureNotServerSide();\n\n  const store = getLiveblocksExtrasForClient(client).store;\n\n  // Suspend until there are at least some notification settings\n  use(store.outputs.notificationSettings.waitUntilLoaded());\n\n  // We're in a Suspense world here, and as such, the useNotificationSettings()\n  // hook is expected to only return success results when we're here.\n  const [result, updateNotificationSettings] =\n    useNotificationSettings_withClient(client);\n\n  assert(!result.error, \"Did not expect error\");\n  assert(!result.isLoading, \"Did not expect loading\");\n\n  return useMemo(() => {\n    return [result, updateNotificationSettings];\n  }, [result, updateNotificationSettings]);\n}\n\nfunction useUser_withClient<U extends BaseUserMeta>(\n  client: Client<U>,\n  userId: string\n): UserAsyncResult<U[\"info\"]> {\n  const usersStore = client[kInternal].usersStore;\n\n  const getUserState = useCallback(\n    () => usersStore.getItemState(userId),\n    [usersStore, userId]\n  );\n\n  const selector = useCallback(\n    (state: ReturnType<typeof getUserState>) =>\n      selectorFor_useUser(state, userId),\n    [userId]\n  );\n\n  const result = useSyncExternalStoreWithSelector(\n    usersStore.subscribe,\n    getUserState,\n    getUserState,\n    selector,\n    shallow\n  );\n\n  // Trigger a fetch if we don't have any data yet (whether initially or after an invalidation)\n  useEffect(\n    () => void usersStore.enqueue(userId)\n\n    // NOTE: Deliberately *not* using a dependency array here!\n    //\n    // It is important to call usersStore.enqueue on *every* render.\n    // This is harmless though, on most renders, except:\n    // 1. The very first render, in which case we'll want to trigger evaluation\n    //    of the userId.\n    // 2. All other subsequent renders now are a no-op (from the implementation\n    //    of .enqueue)\n    // 3. If ever the userId gets invalidated, the user would be fetched again.\n  );\n\n  return result;\n}\n\nfunction useUserSuspense_withClient<U extends BaseUserMeta>(\n  client: Client<U>,\n  userId: string\n) {\n  const usersStore = client[kInternal].usersStore;\n\n  const getUserState = useCallback(\n    () => usersStore.getItemState(userId),\n    [usersStore, userId]\n  );\n  const userState = getUserState();\n\n  if (!userState || userState.isLoading) {\n    throw usersStore.enqueue(userId);\n  }\n\n  if (userState.error) {\n    throw userState.error;\n  }\n\n  // Throw an error if `undefined` was returned by `resolveUsers` for this user ID\n  if (!userState.data) {\n    throw missingUserError(userId);\n  }\n\n  const state = useSyncExternalStore(\n    usersStore.subscribe,\n    getUserState,\n    getUserState\n  );\n  assert(state !== undefined, \"Unexpected missing state\");\n  assert(!state.isLoading, \"Unexpected loading state\");\n  assert(!state.error, \"Unexpected error state\");\n  return {\n    isLoading: false,\n    user: state.data,\n    error: undefined,\n  } as const;\n}\n\nfunction useRoomInfo_withClient(\n  client: OpaqueClient,\n  roomId: string\n): RoomInfoAsyncResult {\n  const roomsInfoStore = client[kInternal].roomsInfoStore;\n\n  const getRoomInfoState = useCallback(\n    () => roomsInfoStore.getItemState(roomId),\n    [roomsInfoStore, roomId]\n  );\n\n  const selector = useCallback(\n    (state: ReturnType<typeof getRoomInfoState>) =>\n      selectorFor_useRoomInfo(state, roomId),\n    [roomId]\n  );\n\n  const result = useSyncExternalStoreWithSelector(\n    roomsInfoStore.subscribe,\n    getRoomInfoState,\n    getRoomInfoState,\n    selector,\n    shallow\n  );\n\n  // Trigger a fetch if we don't have any data yet (whether initially or after an invalidation)\n  useEffect(\n    () => void roomsInfoStore.enqueue(roomId)\n\n    // NOTE: Deliberately *not* using a dependency array here!\n    //\n    // It is important to call roomsInfoStore.enqueue on *every* render.\n    // This is harmless though, on most renders, except:\n    // 1. The very first render, in which case we'll want to trigger evaluation\n    //    of the roomId.\n    // 2. All other subsequent renders now are a no-op (from the implementation\n    //    of .enqueue)\n    // 3. If ever the roomId gets invalidated, the room info would be fetched again.\n  );\n\n  return result;\n}\n\nfunction useRoomInfoSuspense_withClient(client: OpaqueClient, roomId: string) {\n  const roomsInfoStore = client[kInternal].roomsInfoStore;\n\n  const getRoomInfoState = useCallback(\n    () => roomsInfoStore.getItemState(roomId),\n    [roomsInfoStore, roomId]\n  );\n  const roomInfoState = getRoomInfoState();\n\n  if (!roomInfoState || roomInfoState.isLoading) {\n    throw roomsInfoStore.enqueue(roomId);\n  }\n\n  if (roomInfoState.error) {\n    throw roomInfoState.error;\n  }\n\n  // Throw an error if `undefined` was returned by `resolveRoomsInfo` for this room ID\n  if (!roomInfoState.data) {\n    throw missingRoomInfoError(roomId);\n  }\n\n  const state = useSyncExternalStore(\n    roomsInfoStore.subscribe,\n    getRoomInfoState,\n    getRoomInfoState\n  );\n  assert(state !== undefined, \"Unexpected missing state\");\n  assert(!state.isLoading, \"Unexpected loading state\");\n  assert(!state.error, \"Unexpected error state\");\n  assert(state.data !== undefined, \"Unexpected missing room info data\");\n  return {\n    isLoading: false,\n    info: state.data,\n    error: undefined,\n  } as const;\n}\n\nfunction useGroupInfo_withClient(\n  client: OpaqueClient,\n  groupId: string\n): GroupInfoAsyncResult {\n  const groupsInfoStore = client[kInternal].groupsInfoStore;\n\n  const getGroupInfoState = useCallback(\n    () => groupsInfoStore.getItemState(groupId),\n    [groupsInfoStore, groupId]\n  );\n\n  const selector = useCallback(\n    (state: ReturnType<typeof getGroupInfoState>) =>\n      selectorFor_useGroupInfo(state, groupId),\n    [groupId]\n  );\n\n  const result = useSyncExternalStoreWithSelector(\n    groupsInfoStore.subscribe,\n    getGroupInfoState,\n    getGroupInfoState,\n    selector,\n    shallow\n  );\n\n  // Trigger a fetch if we don't have any data yet (whether initially or after an invalidation)\n  useEffect(\n    () => void groupsInfoStore.enqueue(groupId)\n\n    // NOTE: Deliberately *not* using a dependency array here!\n    //\n    // It is important to call groupsInfoStore.enqueue on *every* render.\n    // This is harmless though, on most renders, except:\n    // 1. The very first render, in which case we'll want to trigger evaluation\n    //    of the groupId.\n    // 2. All other subsequent renders now are a no-op (from the implementation\n    //    of .enqueue)\n    // 3. If ever the groupId gets invalidated, the group info would be fetched again.\n  );\n\n  return result;\n}\n\nfunction useGroupInfoSuspense_withClient(\n  client: OpaqueClient,\n  groupId: string\n) {\n  const groupsInfoStore = client[kInternal].groupsInfoStore;\n\n  const getGroupInfoState = useCallback(\n    () => groupsInfoStore.getItemState(groupId),\n    [groupsInfoStore, groupId]\n  );\n  const groupInfoState = getGroupInfoState();\n\n  if (!groupInfoState || groupInfoState.isLoading) {\n    throw groupsInfoStore.enqueue(groupId);\n  }\n\n  if (groupInfoState.error) {\n    throw groupInfoState.error;\n  }\n\n  // Throw an error if `undefined` was returned by `resolveGroupsInfo` for this group ID\n  if (!groupInfoState.data) {\n    throw missingGroupInfoError(groupId);\n  }\n\n  const state = useSyncExternalStore(\n    groupsInfoStore.subscribe,\n    getGroupInfoState,\n    getGroupInfoState\n  );\n  assert(state !== undefined, \"Unexpected missing state\");\n  assert(!state.isLoading, \"Unexpected loading state\");\n  assert(!state.error, \"Unexpected error state\");\n  assert(state.data !== undefined, \"Unexpected missing group info data\");\n  return {\n    isLoading: false,\n    info: state.data,\n    error: undefined,\n  } as const;\n}\n\n/**\n * (Private beta)  Returns the chats for the current user.\n *\n * @example\n * const { chats } = useAiChats();\n */\nfunction useAiChats(options?: UseAiChatsOptions): AiChatsAsyncResult {\n  const client = useClient();\n  const store = getUmbrellaStoreForClient(client);\n\n  const queryKey = makeAiChatsQueryKey(options?.query);\n\n  useEnsureAiConnection(client);\n\n  useEffect(\n    () => void store.outputs.aiChats.getOrCreate(queryKey).waitUntilLoaded()\n\n    // NOTE: Deliberately *not* using a dependency array here!\n    //\n    // It is important to call waitUntil on *every* render.\n    // This is harmless though, on most renders, except:\n    // 1. The very first render, in which case we'll want to trigger the initial page fetch.\n    // 2. All other subsequent renders now \"just\" return the same promise (a quick operation).\n    // 3. If ever the promise would fail, then after 5 seconds it would reset, and on the very\n    //    *next* render after that, a *new* fetch/promise will get created.\n  );\n\n  return useSignal(\n    store.outputs.aiChats.getOrCreate(queryKey).signal,\n    identity,\n    shallow\n  );\n}\n\nfunction useAiChatsSuspense(options?: UseAiChatsOptions): AiChatsAsyncSuccess {\n  // Throw error if we're calling this hook server side\n  ensureNotServerSide();\n\n  const client = useClient();\n  const store = getUmbrellaStoreForClient(client);\n\n  useEnsureAiConnection(client);\n\n  const queryKey = makeAiChatsQueryKey(options?.query);\n\n  use(store.outputs.aiChats.getOrCreate(queryKey).waitUntilLoaded());\n\n  const result = useAiChats(options);\n  assert(!result.error, \"Did not expect error\");\n  assert(!result.isLoading, \"Did not expect loading\");\n  return result;\n}\n\nfunction useAiChatMessages(\n  chatId: string,\n  /** @internal */\n  options?: { branchId?: MessageId }\n): AiChatMessagesAsyncResult {\n  const client = useClient();\n  const store = getUmbrellaStoreForClient(client);\n\n  useEnsureAiConnection(client);\n\n  useEffect(\n    () =>\n      void store.outputs.messagesByChatId\n        .getOrCreate(chatId)\n        .getOrCreate(options?.branchId ?? null)\n        .waitUntilLoaded()\n\n    // NOTE: Deliberately *not* using a dependency array here!\n    //\n    // It is important to call waitUntil on *every* render.\n    // This is harmless though, on most renders, except:\n    // 1. The very first render, in which case we'll want to trigger the initial page fetch.\n    // 2. All other subsequent renders now \"just\" return the same promise (a quick operation).\n    // 3. If ever the promise would fail, then after 5 seconds it would reset, and on the very\n    //    *next* render after that, a *new* fetch/promise will get created.\n  );\n\n  return useSignal(\n    store.outputs.messagesByChatId\n      .getOrCreate(chatId)\n      .getOrCreate(options?.branchId ?? null).signal\n  );\n}\n\nfunction useAiChatMessagesSuspense(\n  chatId: string,\n  /** @internal */\n  options?: { branchId?: MessageId }\n): AiChatMessagesAsyncSuccess {\n  // Throw error if we're calling this hook server side\n  ensureNotServerSide();\n\n  const client = useClient();\n  const store = getUmbrellaStoreForClient(client);\n\n  useEnsureAiConnection(client);\n\n  use(\n    store.outputs.messagesByChatId\n      .getOrCreate(chatId)\n      .getOrCreate(options?.branchId ?? null)\n      .waitUntilLoaded()\n  );\n\n  const result = useAiChatMessages(chatId, options);\n  assert(!result.error, \"Did not expect error\");\n  assert(!result.isLoading, \"Did not expect loading\");\n  return result;\n}\n\nfunction useAiChat(chatId: string): AiChatAsyncResult {\n  const client = useClient();\n  const store = getUmbrellaStoreForClient(client);\n\n  useEnsureAiConnection(client);\n\n  useEffect(\n    () => void store.outputs.aiChatById.getOrCreate(chatId).waitUntilLoaded()\n\n    // NOTE: Deliberately *not* using a dependency array here!\n    //\n    // It is important to call waitUntil on *every* render.\n    // This is harmless though, on most renders, except:\n    // 1. The very first render, in which case we'll want to trigger the initial page fetch.\n    // 2. All other subsequent renders now \"just\" return the same promise (a quick operation).\n    // 3. If ever the promise would fail, then after 5 seconds it would reset, and on the very\n    //    *next* render after that, a *new* fetch/promise will get created.\n  );\n\n  return useSignal(store.outputs.aiChatById.getOrCreate(chatId).signal);\n}\n\nfunction useAiChatSuspense(chatId: string): AiChatAsyncSuccess {\n  // Throw error if we're calling this hook server side\n  ensureNotServerSide();\n\n  const client = useClient();\n  const store = getUmbrellaStoreForClient(client);\n\n  useEnsureAiConnection(client);\n\n  use(store.outputs.aiChatById.getOrCreate(chatId).waitUntilLoaded());\n\n  const result = useAiChat(chatId);\n  assert(!result.error, \"Did not expect error\");\n  assert(!result.isLoading, \"Did not expect loading\");\n  return result;\n}\n\n/**\n * Returns metadata for a given URL.\n *\n * @example\n * const { metadata, error, isLoading } = useUrlMetadata(\"https://liveblocks.io\");\n */\nfunction useUrlMetadata(url: string): UrlMetadataAsyncResult {\n  const client = useClient();\n  const store = getUmbrellaStoreForClient(client);\n\n  useEffect(\n    () => void store.outputs.urlMetadataByUrl.getOrCreate(url).waitUntilLoaded()\n\n    // NOTE: Deliberately *not* using a dependency array here!\n    //\n    // It is important to call waitUntil on *every* render.\n    // This is harmless though, on most renders, except:\n    // 1. The very first render, in which case we'll want to trigger the initial page fetch.\n    // 2. All other subsequent renders now \"just\" return the same promise (a quick operation).\n    // 3. If ever the promise would fail, then after 5 seconds it would reset, and on the very\n    //    *next* render after that, a *new* fetch/promise will get created.\n  );\n\n  return useSignal(store.outputs.urlMetadataByUrl.getOrCreate(url).signal);\n}\n\n/**\n * Returns metadata for a given URL.\n *\n * @example\n * const { metadata } = useUrlMetadata(\"https://liveblocks.io\");\n */\nfunction useUrlMetadataSuspense(url: string): UrlMetadataAsyncSuccess {\n  // Throw error if we're calling this hook server side\n  ensureNotServerSide();\n\n  const client = useClient();\n  const store = getUmbrellaStoreForClient(client);\n\n  use(store.outputs.urlMetadataByUrl.getOrCreate(url).waitUntilLoaded());\n\n  const result = useUrlMetadata(url);\n  assert(!result.error, \"Did not expect error\");\n  assert(!result.isLoading, \"Did not expect loading\");\n  return result;\n}\n\n/**\n * Returns a function that creates an AI chat.\n *\n * If you do not pass a title for the chat, it will be automatically computed\n * after the first AI response.\n *\n * @example\n * const createAiChat = useCreateAiChat();\n *\n * // Create a chat with an automatically generated title\n * createAiChat(\"ai-chat-id\");\n *\n * // Create a chat with a custom title\n * createAiChat({ id: \"ai-chat-id\", title: \"My AI chat\" });\n */\nfunction useCreateAiChat(): {\n  (chatId: string): void;\n  (options: CreateAiChatOptions): void;\n} {\n  const client = useClient();\n\n  return useCallback(\n    (options: string | CreateAiChatOptions) => {\n      if (typeof options === \"string\") {\n        options = { id: options };\n      }\n\n      client[kInternal].ai\n        .getOrCreateChat(options.id, {\n          title: options.title,\n          metadata: options.metadata,\n        })\n        .catch((err) => {\n          console.error(\n            `Failed to create chat with ID \"${options.id}\": ${String(err)}`\n          );\n        });\n    },\n    [client]\n  );\n}\n\n/**\n * Returns a function that deletes the AI chat with the specified id.\n *\n * @example\n * const deleteAiChat = useDeleteAiChat();\n * deleteAiChat(\"ai-chat-id\");\n */\nfunction useDeleteAiChat() {\n  const client = useClient();\n\n  return useCallback(\n    (chatId: string) => {\n      client[kInternal].ai.deleteChat(chatId).catch((err) => {\n        console.error(\n          `Failed to delete chat with ID \"${chatId}\": ${String(err)}`\n        );\n      });\n    },\n    [client]\n  );\n}\n\nconst DISCONNECTED = Object.freeze({ status: \"disconnected\" });\nconst LOADING = Object.freeze({ status: \"loading\" });\nconst IDLE = Object.freeze({ status: \"idle\" });\n\n/**\n * Returns the status of an AI chat, indicating whether it's disconnected, loading, idle\n * or actively generating content. This is a convenience hook that derives its state from\n * the latest assistant message in the chat.\n *\n * Re-renders whenever any of the relevant fields change.\n *\n * @param chatId - The ID of the chat to monitor\n * @returns The current status of the AI chat\n *\n * @example\n * ```tsx\n * import { useAiChatStatus } from \"@liveblocks/react\";\n *\n * function ChatStatus() {\n *   const { status, partType, toolName } = useAiChatStatus(\"my-chat\");\n *   console.log(status);          // \"disconnected\" | \"loading\" | \"idle\" | \"generating\"\n *   console.log(status.partType); // \"text\" | \"tool-invocation\" | ...\n *   console.log(status.toolName); // string | undefined\n * }\n * ```\n */\nfunction useAiChatStatus(\n  chatId: string,\n  /** @internal */\n  branchId?: MessageId\n): AiChatStatus {\n  const client = useClient();\n  const store = getUmbrellaStoreForClient(client);\n\n  useEnsureAiConnection(client);\n\n  useEffect(\n    () =>\n      void store.outputs.messagesByChatId\n        .getOrCreate(chatId)\n        .getOrCreate(branchId ?? null)\n        .waitUntilLoaded()\n  );\n\n  const isAvailable = useSignal(\n    // Subscribe to connection status signal\n    client[kInternal].ai.signals.status,\n    // \"Disconnected\" means the AI service is not available\n    // as it represents a final error status.\n    (status) => status !== \"disconnected\"\n  );\n\n  const chatStatus = useSignal(\n    // Signal\n    store.outputs.messagesByChatId\n      .getOrCreate(chatId)\n      .getOrCreate(branchId ?? null).signal,\n\n    // Selector\n    (result) => {\n      if (result.isLoading) return LOADING satisfies AiChatStatus;\n      if (result.error) return IDLE satisfies AiChatStatus;\n\n      const messages = result.messages;\n      const lastMessage = messages[messages.length - 1];\n\n      if (lastMessage?.role !== \"assistant\") return IDLE satisfies AiChatStatus;\n      if (\n        lastMessage.status !== \"generating\" &&\n        lastMessage.status !== \"awaiting-tool\"\n      )\n        return IDLE satisfies AiChatStatus;\n\n      const contentSoFar = lastMessage.contentSoFar;\n      const lastPart = contentSoFar[contentSoFar.length - 1];\n\n      if (lastPart?.type === \"tool-invocation\") {\n        return {\n          status: \"generating\",\n          partType: \"tool-invocation\",\n          toolName: lastPart.name,\n        } satisfies AiChatStatus;\n      } else {\n        return {\n          status: \"generating\",\n          partType: lastPart?.type,\n        } satisfies AiChatStatus;\n      }\n    },\n\n    // Consider { status: \"generating\", partType: \"text\" } and { status: \"generating\", partType: \"text\" } equal\n    shallow\n  );\n\n  if (!isAvailable) {\n    return DISCONNECTED;\n  }\n\n  return chatStatus;\n}\n\n/**\n * Returns a function to send a message in an AI chat.\n *\n * @example\n * const sendAiMessage = useSendAiMessage(\"chat-id\");\n * sendAiMessage(\"Hello, Liveblocks AI!\");\n *\n * You can set options related to the message being sent, such as the copilot ID to use.\n *\n * @example\n * const sendAiMessage = useSendAiMessage(\"chat-id\", { copilotId: \"co_xxx\" });\n * sendAiMessage(\"Hello, Liveblocks AI!\");\n *\n * @example\n * const sendAiMessage = useSendAiMessage(\"chat-id\", { copilotId: \"co_xxx\" });\n * sendAiMessage({ text: \"Hello, Liveblocks AI!\", copilotId: \"co_yyy\" });\n */\nfunction useSendAiMessage(\n  chatId: string,\n  options?: UseSendAiMessageOptions\n): {\n  (text: string): AiUserMessage;\n  (options: SendAiMessageOptions): AiUserMessage;\n};\n\n/**\n * Returns a function to send a message in an AI chat.\n *\n * @example\n * const sendAiMessage = useSendAiMessage();\n * sendAiMessage({ chatId: \"chat-id\", text: \"Hello, Liveblocks AI!\" });\n *\n * You can set options related to the message being sent, such as the copilot ID to use.\n *\n * @example\n * const sendAiMessage = useSendAiMessage();\n * sendAiMessage({ chatId: \"chat-id\", text: \"Hello, Liveblocks AI!\", copilotId: \"co_xxx\" });\n */\nfunction useSendAiMessage(): (\n  options: WithRequired<SendAiMessageOptions, \"chatId\">\n) => AiUserMessage;\n\n/**\n * Returns a function to send a message in an AI chat.\n *\n * @example\n * const sendAiMessage = useSendAiMessage(chatId);\n * sendAiMessage(\"Hello, Liveblocks AI!\");\n *\n * You can set options related to the message being sent, such as the copilot ID to use.\n *\n * @example\n * const sendAiMessage = useSendAiMessage(chatId, { copilotId: \"co_xxx\" });\n * sendAiMessage(\"Hello, Liveblocks AI!\");\n *\n * You can also pass the chat ID dynamically if it's not known when calling the hook.\n *\n * @example\n * const sendAiMessage = useSendAiMessage();\n * sendAiMessage({ chatId: \"chat-id\", text: \"Hello, Liveblocks AI!\" });\n *\n * @example\n * const sendAiMessage = useSendAiMessage();\n * sendAiMessage({ chatId: \"chat-id\", text: \"Hello, Liveblocks AI!\", copilotId: \"co_xxx\" });\n */\nfunction useSendAiMessage(\n  chatId?: string,\n  options?: UseSendAiMessageOptions\n): {\n  (text: string): AiUserMessage;\n  (options: SendAiMessageOptions): AiUserMessage;\n  (options: WithRequired<SendAiMessageOptions, \"chatId\">): AiUserMessage;\n} {\n  const client = useClient();\n\n  return useCallback(\n    (message: string | SendAiMessageOptions) => {\n      const {\n        text: messageText,\n        chatId: messageOptionsChatId,\n        copilotId: messageOptionsCopilotId,\n        ...messageOptions\n      } = typeof message === \"string\" ? { text: message } : message;\n      const resolvedChatId =\n        messageOptionsChatId ??\n        chatId ??\n        // The `useSendAiMessage` overloads prevent this scenario from happening\n        // at the type level, and this error prevents it from happening at runtime.\n        raise(\n          \"chatId must be provided to either `useSendAiMessage` or its returned function.\"\n        );\n\n      const messages = client[kInternal].ai.signals\n        .getChatMessagesForBranch(resolvedChatId)\n        .get();\n\n      if (\n        process.env.NODE_ENV !== \"production\" &&\n        !messageOptionsCopilotId &&\n        !options?.copilotId\n      ) {\n        console.warn(\n          `No copilot ID was provided to useSendAiMessage when sending the message \"${messageText.slice(\n            0,\n            20\n          )}\". As a result, the message will use the chat's previous copilot ID, which could lead to unexpected behavior.\\nTo ensure the correct copilot ID is used, specify it either through the hook as 'useSendAiMessage(\"${resolvedChatId}\", { copilotId: \"co_xxx\" })' or via the function as 'sendAiMessage({ text: \"${messageText.slice(\n            0,\n            20\n          )}\", copilotId: \"co_xxx\" })'`\n        );\n      }\n      const resolvedCopilotId = (messageOptionsCopilotId ??\n        options?.copilotId ??\n        client[kInternal].ai.getLastUsedCopilotId(resolvedChatId)) as\n        | CopilotId\n        | undefined;\n\n      const lastMessageId = messages[messages.length - 1]?.id ?? null;\n\n      const content = [{ type: \"text\" as const, text: messageText }];\n      const newMessageId = client[kInternal].ai[\n        kInternal\n      ].context.messagesStore.createOptimistically(\n        resolvedChatId,\n        \"user\",\n        lastMessageId,\n        content\n      );\n      const newMessage = client[kInternal].ai[\n        kInternal\n      ].context.messagesStore.getMessageById(newMessageId) as AiUserMessage;\n\n      const targetMessageId = client[kInternal].ai[\n        kInternal\n      ].context.messagesStore.createOptimistically(\n        resolvedChatId,\n        \"assistant\",\n        newMessageId,\n        resolvedCopilotId as CopilotId\n      );\n\n      void client[kInternal].ai.askUserMessageInChat(\n        resolvedChatId,\n        { id: newMessageId, parentMessageId: lastMessageId, content },\n        targetMessageId,\n        {\n          stream: messageOptions.stream ?? options?.stream,\n          copilotId: resolvedCopilotId,\n          timeout: messageOptions.timeout ?? options?.timeout,\n        }\n      );\n\n      return newMessage;\n    },\n    [client, chatId, options?.copilotId, options?.stream, options?.timeout]\n  );\n}\n\n/** @internal */\nexport function createSharedContext<U extends BaseUserMeta>(\n  client: Client<U>\n): SharedContextBundle<U> {\n  const useClient = () => client;\n\n  function useSyncStatus(options?: UseSyncStatusOptions) {\n    return useSyncStatus_withClient(client, options);\n  }\n\n  return {\n    classic: {\n      useClient,\n      useUser: (userId: string) => useUser_withClient(client, userId),\n      useRoomInfo: (roomId: string) => useRoomInfo_withClient(client, roomId),\n      useGroupInfo: (groupId: string) =>\n        useGroupInfo_withClient(client, groupId),\n      useIsInsideRoom,\n      useErrorListener,\n      useSyncStatus,\n      RegisterAiKnowledge,\n      RegisterAiTool,\n    },\n    suspense: {\n      useClient,\n      useUser: (userId: string) => useUserSuspense_withClient(client, userId),\n      useRoomInfo: (roomId: string) =>\n        useRoomInfoSuspense_withClient(client, roomId),\n      useGroupInfo: (groupId: string) =>\n        useGroupInfoSuspense_withClient(client, groupId),\n      useIsInsideRoom,\n      useErrorListener,\n      useSyncStatus,\n      RegisterAiKnowledge,\n      RegisterAiTool,\n    },\n  };\n}\n\n/**\n * @private This is an internal API.\n */\nfunction useEnsureNoLiveblocksProvider(options?: { allowNesting?: boolean }) {\n  const existing = useClientOrNull();\n  if (!options?.allowNesting && existing !== null) {\n    throw new Error(\n      \"You cannot nest multiple LiveblocksProvider instances in the same React tree.\"\n    );\n  }\n}\n\n/**\n * @private This is a private API.\n */\nexport function LiveblocksProviderWithClient(\n  props: PropsWithChildren<{\n    client: OpaqueClient;\n\n    // Private flag, used only to skip the nesting check if this is\n    // a LiveblocksProvider created implicitly by a factory-bound RoomProvider.\n    allowNesting?: boolean;\n  }>\n) {\n  useEnsureNoLiveblocksProvider(props);\n  return (\n    <ClientContext.Provider value={props.client}>\n      {props.children}\n    </ClientContext.Provider>\n  );\n}\n\n/**\n * Sets up a client for connecting to Liveblocks, and is the recommended way to do\n * this for React apps. You must define either `authEndpoint` or `publicApiKey`.\n * Resolver functions should be placed inside here, and a number of other options\n * are available, which correspond with those passed to `createClient`.\n * Unlike `RoomProvider`, `LiveblocksProvider` doesnt call Liveblocks servers when mounted,\n * and it should be placed higher in your apps component tree.\n */\nexport function LiveblocksProvider<U extends BaseUserMeta = DU>(\n  props: PropsWithChildren<ClientOptions<U>>\n) {\n  const { children, ...o } = props;\n\n  // It's important that the static options remain stable, otherwise we'd be\n  // creating new client instances on every render.\n  const options = {\n    publicApiKey: useInitial(o.publicApiKey),\n    throttle: useInitial(o.throttle),\n    lostConnectionTimeout: useInitial(o.lostConnectionTimeout),\n    backgroundKeepAliveTimeout: useInitial(o.backgroundKeepAliveTimeout),\n    polyfills: useInitial(o.polyfills),\n    unstable_streamData: useInitial(o.unstable_streamData),\n    preventUnsavedChanges: useInitial(o.preventUnsavedChanges),\n    badgeLocation: useInitial(o.badgeLocation),\n\n    authEndpoint: useInitialUnlessFunction(o.authEndpoint),\n    resolveMentionSuggestions: useInitialUnlessFunction(\n      o.resolveMentionSuggestions\n    ),\n    resolveUsers: useInitialUnlessFunction(o.resolveUsers),\n    resolveRoomsInfo: useInitialUnlessFunction(o.resolveRoomsInfo),\n    resolveGroupsInfo: useInitialUnlessFunction(o.resolveGroupsInfo),\n\n    baseUrl: useInitial(o.baseUrl),\n    enableDebugLogging: useInitial(\n      // @ts-expect-error - Hidden config options\n      o.enableDebugLogging as boolean | undefined\n    ),\n  } as ClientOptions<U>;\n\n  // NOTE: Deliberately not passing any deps here, because we'll _never_ want\n  // to recreate a client instance after the first render.\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  const client = useMemo(() => createClient<U>(options), []);\n\n  // The AI socket is connected to via `useEnsureAiConnection` whenever at least one\n  // AI-related hook is used. We only handle disconnecting here when `LiveblocksProvider` unmounts.\n  useEffect(() => {\n    return () => {\n      client[kInternal].ai.disconnect();\n    };\n  }, [client]);\n\n  return (\n    <LiveblocksProviderWithClient client={client}>\n      {children}\n    </LiveblocksProviderWithClient>\n  );\n}\n\n/**\n * Creates a LiveblocksProvider and a set of typed hooks. Note that any\n * LiveblocksProvider created in this way takes no props, because it uses\n * settings from the given client instead.\n */\nexport function createLiveblocksContext<\n  U extends BaseUserMeta = DU,\n  TM extends BaseMetadata = DTM,\n  CM extends BaseMetadata = DCM,\n>(client: OpaqueClient): LiveblocksContextBundle<U, TM, CM> {\n  return getOrCreateContextBundle<U, TM, CM>(client);\n}\n\n/**\n * @experimental\n *\n * This hook is experimental and could be removed or changed at any time!\n * Do not use unless explicitly recommended by the Liveblocks team.\n *\n * WARNING:\n * Please note that this hook currently returns all threads by most recently\n * updated threads first. This is inconsistent with the default sort order of\n * the useThreads() hook, which returns them in chronological order (by\n * creation date). In the final version, we will make these hooks behave\n * consistently, so expect that in the final version, you'll have to explicitly\n * specify the sort order to be by most recently updated first somehow.\n * The final API for that is still TBD.\n *\n */\nfunction useUserThreads_experimental<\n  TM extends BaseMetadata,\n  CM extends BaseMetadata,\n>(options: UseUserThreadsOptions<TM> = {}): ThreadsAsyncResult<TM, CM> {\n  const client = useClient();\n  const { store, userThreadsPoller: poller } = getLiveblocksExtrasForClient<\n    TM,\n    CM\n  >(client);\n  const queryKey = makeUserThreadsQueryKey(options.query);\n\n  useEffect(\n    () =>\n      void store.outputs.loadingUserThreads\n        .getOrCreate(queryKey)\n        .waitUntilLoaded()\n\n    // NOTE: Deliberately *not* using a dependency array here!\n    //\n    // It is important to call waitUntil on *every* render.\n    // This is harmless though, on most renders, except:\n    // 1. The very first render, in which case we'll want to trigger the initial page fetch.\n    // 2. All other subsequent renders now \"just\" return the same promise (a quick operation).\n    // 3. If ever the promise would fail, then after 5 seconds it would reset, and on the very\n    //    *next* render after that, a *new* fetch/promise will get created.\n  );\n\n  useEffect(() => {\n    poller.inc();\n    poller.pollNowIfStale();\n    return () => {\n      poller.dec();\n    };\n  }, [poller]);\n\n  return useSignal(\n    store.outputs.loadingUserThreads.getOrCreate(queryKey).signal\n  );\n}\n\n/**\n * @experimental\n *\n * This hook is experimental and could be removed or changed at any time!\n * Do not use unless explicitly recommended by the Liveblocks team.\n *\n * WARNING:\n * Please note that this hook currently returns all threads by most recently\n * updated threads first. This is inconsistent with the default sort order of\n * the useThreads() hook, which returns them in chronological order (by\n * creation date). In the final version, we will make these hooks behave\n * consistently, so expect that in the final version, you'll have to explicitly\n * specify the sort order to be by most recently updated first somehow.\n * The final API for that is still TBD.\n */\nfunction useUserThreadsSuspense_experimental<\n  TM extends BaseMetadata,\n  CM extends BaseMetadata,\n>(options: UseUserThreadsOptions<TM> = {}): ThreadsAsyncSuccess<TM, CM> {\n  // Throw error if we're calling this hook server side\n  ensureNotServerSide();\n\n  const client = useClient();\n  const { store } = getLiveblocksExtrasForClient<TM, CM>(client);\n  const queryKey = makeUserThreadsQueryKey(options.query);\n\n  use(store.outputs.loadingUserThreads.getOrCreate(queryKey).waitUntilLoaded());\n\n  const result = useUserThreads_experimental<TM, CM>(options);\n  assert(!result.error, \"Did not expect error\");\n  assert(!result.isLoading, \"Did not expect loading\");\n  return result;\n}\n\n/**\n * Returns the inbox notifications for the current user.\n *\n * @example\n * const { inboxNotifications, error, isLoading } = useInboxNotifications();\n */\nfunction useInboxNotifications(options?: UseInboxNotificationsOptions) {\n  return useInboxNotifications_withClient(\n    useClient(),\n    identity,\n    shallow,\n    options\n  );\n}\n\n/**\n * Returns the inbox notifications for the current user.\n *\n * @example\n * const { inboxNotifications } = useInboxNotifications();\n */\nfunction useInboxNotificationsSuspense(options?: UseInboxNotificationsOptions) {\n  return useInboxNotificationsSuspense_withClient(useClient(), options);\n}\n\nfunction useInboxNotificationThread<\n  TM extends BaseMetadata,\n  CM extends BaseMetadata,\n>(inboxNotificationId: string) {\n  return useInboxNotificationThread_withClient<TM, CM>(\n    useClient(),\n    inboxNotificationId\n  );\n}\n\n/**\n * Returns a function that marks all of the current user's inbox notifications as read.\n *\n * @example\n * const markAllInboxNotificationsAsRead = useMarkAllInboxNotificationsAsRead();\n * markAllInboxNotificationsAsRead();\n */\nfunction useMarkAllInboxNotificationsAsRead() {\n  return useMarkAllInboxNotificationsAsRead_withClient(useClient());\n}\n\n/**\n * Returns a function that marks an inbox notification as read for the current user.\n *\n * @example\n * const markInboxNotificationAsRead = useMarkInboxNotificationAsRead();\n * markInboxNotificationAsRead(\"in_xxx\");\n */\nfunction useMarkInboxNotificationAsRead() {\n  return useMarkInboxNotificationAsRead_withClient(useClient());\n}\n\n/**\n * Returns a function that deletes all of the current user's inbox notifications.\n *\n * @example\n * const deleteAllInboxNotifications = useDeleteAllInboxNotifications();\n * deleteAllInboxNotifications();\n */\nfunction useDeleteAllInboxNotifications() {\n  return useDeleteAllInboxNotifications_withClient(useClient());\n}\n\n/**\n * Returns a function that deletes an inbox notification for the current user.\n *\n * @example\n * const deleteInboxNotification = useDeleteInboxNotification();\n * deleteInboxNotification(\"in_xxx\");\n */\nfunction useDeleteInboxNotification() {\n  return useDeleteInboxNotification_withClient(useClient());\n}\n\n/**\n * Returns the number of unread inbox notifications for the current user.\n *\n * @example\n * const { count, error, isLoading } = useUnreadInboxNotificationsCount();\n */\nfunction useUnreadInboxNotificationsCount(\n  options?: UseInboxNotificationsOptions\n) {\n  return useUnreadInboxNotificationsCount_withClient(useClient(), options);\n}\n\n/**\n * Returns the number of unread inbox notifications for the current user.\n *\n * @example\n * const { count } = useUnreadInboxNotificationsCount();\n */\nfunction useUnreadInboxNotificationsCountSuspense(\n  options?: UseInboxNotificationsOptions\n) {\n  return useUnreadInboxNotificationsCountSuspense_withClient(\n    useClient(),\n    options\n  );\n}\n\n/**\n * Returns notification settings for the current user.\n *\n * @example\n * const [{ settings }, updateNotificationSettings] = useNotificationSettings()\n */\nfunction useNotificationSettings() {\n  return useNotificationSettings_withClient(useClient());\n}\n\n/**\n * Returns notification settings for the current user.\n *\n * @example\n * const [{ settings }, updateNotificationSettings] = useNotificationSettings()\n */\nfunction useNotificationSettingsSuspense() {\n  return useNotificationSettingsSuspense_withClient(useClient());\n}\n\n/**\n * Returns a function that updates the user's notification\n * settings for a project.\n *\n * @example\n * const updateNotificationSettings = useUpdateNotificationSettings()\n */\nfunction useUpdateNotificationSettings() {\n  return useUpdateNotificationSettings_withClient(useClient());\n}\n\nfunction useUser<U extends BaseUserMeta>(userId: string) {\n  const client = useClient<U>();\n  return useUser_withClient(client, userId);\n}\n\nfunction useUserSuspense<U extends BaseUserMeta>(\n  userId: string\n): UserAsyncSuccess<U[\"info\"]> {\n  const client = useClient<U>();\n  return useUserSuspense_withClient(client, userId);\n}\n\n/**\n * Returns room info from a given room ID.\n *\n * @example\n * const { info, error, isLoading } = useRoomInfo(\"room-id\");\n */\nfunction useRoomInfo(roomId: string): RoomInfoAsyncResult {\n  return useRoomInfo_withClient(useClient(), roomId);\n}\n\n/**\n * Returns room info from a given room ID.\n *\n * @example\n * const { info } = useRoomInfo(\"room-id\");\n */\nfunction useRoomInfoSuspense(roomId: string): RoomInfoAsyncSuccess {\n  return useRoomInfoSuspense_withClient(useClient(), roomId);\n}\n\n/**\n * Returns group info from a given group ID.\n *\n * @example\n * const { info, error, isLoading } = useGroupInfo(\"group-id\");\n */\nfunction useGroupInfo(groupId: string): GroupInfoAsyncResult {\n  return useGroupInfo_withClient(useClient(), groupId);\n}\n\n/**\n * Returns group info from a given group ID.\n *\n * @example\n * const { info } = useGroupInfo(\"group-id\");\n */\nfunction useGroupInfoSuspense(groupId: string): GroupInfoAsyncSuccess {\n  return useGroupInfoSuspense_withClient(useClient(), groupId);\n}\n\ntype TypedBundle = LiveblocksContextBundle<DU, DTM, DCM>;\n\n/**\n * Returns the thread associated with a `\"thread\"` inbox notification.\n *\n * It can **only** be called with IDs of `\"thread\"` inbox notifications,\n * so we recommend only using it when customizing the rendering or in other\n * situations where you can guarantee the kind of the notification.\n *\n * When `useInboxNotifications` returns `\"thread\"` inbox notifications,\n * it also receives the associated threads and caches them behind the scenes.\n * When you call `useInboxNotificationThread`, it simply returns the cached thread\n * for the inbox notification ID you passed to it, without any fetching or waterfalls.\n *\n * @example\n * const thread = useInboxNotificationThread(\"in_xxx\");\n */\nconst _useInboxNotificationThread: TypedBundle[\"useInboxNotificationThread\"] =\n  useInboxNotificationThread;\n\n/**\n * Returns user info from a given user ID.\n *\n * @example\n * const { user, error, isLoading } = useUser(\"user-id\");\n */\nconst _useUser: TypedBundle[\"useUser\"] = useUser;\n\n/**\n * Returns user info from a given user ID.\n *\n * @example\n * const { user } = useUser(\"user-id\");\n */\nconst _useUserSuspense: TypedBundle[\"suspense\"][\"useUser\"] = useUserSuspense;\n\n/**\n * @experimental\n *\n * This hook is experimental and could be removed or changed at any time!\n * Do not use unless explicitly recommended by the Liveblocks team.\n *\n * WARNING:\n * Please note that this hook currently returns all threads by most recently\n * updated threads first. This is inconsistent with the default sort order of\n * the useThreads() hook, which returns them in chronological order (by\n * creation date). In the final version, we will make these hooks behave\n * consistently, so expect that in the final version, you'll have to explicitly\n * specify the sort order to be by most recently updated first somehow.\n * The final API for that is still TBD.\n */\nconst _useUserThreads_experimental: TypedBundle[\"useUserThreads_experimental\"] =\n  useUserThreads_experimental;\n\n/**\n * @experimental\n *\n * This hook is experimental and could be removed or changed at any time!\n * Do not use unless explicitly recommended by the Liveblocks team.\n *\n * WARNING:\n * Please note that this hook currently returns all threads by most recently\n * updated threads first. This is inconsistent with the default sort order of\n * the useThreads() hook, which returns them in chronological order (by\n * creation date). In the final version, we will make these hooks behave\n * consistently, so expect that in the final version, you'll have to explicitly\n * specify the sort order to be by most recently updated first somehow.\n * The final API for that is still TBD.\n */\nconst _useUserThreadsSuspense_experimental: TypedBundle[\"suspense\"][\"useUserThreads_experimental\"] =\n  useUserThreadsSuspense_experimental;\n\n/**\n * (Private beta)  Returns the chats for the current user.\n *\n * @example\n * const { chats, error, isLoading } = useAiChats();\n */\nconst _useAiChats: TypedBundle[\"useAiChats\"] = useAiChats;\n\n/**\n * (Private beta)  Returns the chats for the current user.\n *\n * @example\n * const { chats, error, isLoading } = useAiChats();\n */\nconst _useAiChatsSuspense: TypedBundle[\"suspense\"][\"useAiChats\"] =\n  useAiChatsSuspense;\n\n/**\n * (Private beta)  Returns the information of the given chat.\n *\n * @example\n * const { chat, error, isLoading } = useAiChat(\"my-chat\");\n */\nconst _useAiChat: TypedBundle[\"useAiChat\"] = useAiChat;\n\n/**\n * (Private beta)  Returns the information of the given chat.\n *\n * @example\n * const { chat, error, isLoading } = useAiChat(\"my-chat\");\n */\nconst _useAiChatSuspense: TypedBundle[\"suspense\"][\"useAiChat\"] =\n  useAiChatSuspense;\n\n/**\n * (Private beta)  Returns the messages in the given chat.\n *\n * @example\n * const { messages, error, isLoading } = useAiChatMessages(\"my-chat\");\n */\nconst _useAiChatMessages: TypedBundle[\"useAiChatMessages\"] = useAiChatMessages;\n\n/**\n * (Private beta)  Returns the messages in the given chat.\n *\n * @example\n * const { messages, error, isLoading } = useAiChatMessages(\"my-chat\");\n */\nconst _useAiChatMessagesSuspense: TypedBundle[\"suspense\"][\"useAiChatMessages\"] =\n  useAiChatMessagesSuspense;\n\n/**\n * Returns metadata for a given URL.\n *\n * @example\n * const { metadata, error, isLoading } = useUrlMetadata(\"https://liveblocks.io\");\n */\nconst _useUrlMetadata: TypedBundle[\"useUrlMetadata\"] = useUrlMetadata;\n\n/**\n * Returns metadata for a given URL.\n *\n * @example\n * const { metadata } = useUrlMetadata(\"https://liveblocks.io\");\n */\nconst _useUrlMetadataSuspense: TypedBundle[\"suspense\"][\"useUrlMetadata\"] =\n  useUrlMetadataSuspense;\n\nfunction useSyncStatus_withClient(\n  client: OpaqueClient,\n  options?: UseSyncStatusOptions\n): SyncStatus {\n  // Normally the Rules of Hooks dictate that you should not call hooks\n  // conditionally. In this case, we're good here, because the same code path\n  // will always be taken on every subsequent render here, because we've frozen\n  // the value.\n  /* eslint-disable react-hooks/rules-of-hooks */\n  const smooth = useInitial(options?.smooth ?? false);\n  if (smooth) {\n    return useSyncStatusSmooth_withClient(client);\n  } else {\n    return useSyncStatusImmediate_withClient(client);\n  }\n  /* eslint-enable react-hooks/rules-of-hooks */\n}\n\nfunction useSyncStatusImmediate_withClient(client: OpaqueClient): SyncStatus {\n  return useSyncExternalStore(\n    client.events.syncStatus.subscribe,\n    client.getSyncStatus,\n    client.getSyncStatus\n  );\n}\n\nfunction useSyncStatusSmooth_withClient(client: OpaqueClient): SyncStatus {\n  const getter = client.getSyncStatus;\n  const [status, setStatus] = useState(getter);\n  const oldStatus = useLatest(getter());\n\n  useEffect(() => {\n    let timeoutId: ReturnType<typeof setTimeout>;\n    const unsub = client.events.syncStatus.subscribe(() => {\n      const newStatus = getter();\n      if (\n        oldStatus.current === \"synchronizing\" &&\n        newStatus === \"synchronized\"\n      ) {\n        // Delay delivery of the \"synchronized\" event\n        timeoutId = setTimeout(() => setStatus(newStatus), config.SMOOTH_DELAY);\n      } else {\n        clearTimeout(timeoutId);\n        setStatus(newStatus);\n      }\n    });\n\n    // Clean up\n    return () => {\n      clearTimeout(timeoutId);\n      unsub();\n    };\n  }, [client, getter, oldStatus]);\n\n  return status;\n}\n\n/**\n * Returns the current Liveblocks sync status, and triggers a re-render\n * whenever it changes. Can be used to render a \"Saving...\" indicator, or for\n * preventing that a browser tab can be closed until all changes have been\n * synchronized with the server.\n *\n * @example\n * const syncStatus = useSyncStatus();  // \"synchronizing\" | \"synchronized\"\n * const syncStatus = useSyncStatus({ smooth: true });\n */\nfunction useSyncStatus(options?: UseSyncStatusOptions): SyncStatus {\n  return useSyncStatus_withClient(useClient(), options);\n}\n\n/**\n * useErrorListener is a React hook that allows you to respond to any\n * Liveblocks error, for example room connection errors, errors\n * creating/editing/deleting threads, etc.\n *\n * @example\n * useErrorListener(err => {\n *   console.error(err);\n * })\n */\nfunction useErrorListener(callback: (err: LiveblocksError) => void): void {\n  const client = useClient();\n  const savedCallback = useLatest(callback);\n  useEffect(\n    () => client.events.error.subscribe((e) => savedCallback.current(e)),\n    [client, savedCallback]\n  );\n}\n\n// eslint-disable-next-line simple-import-sort/exports\nexport {\n  _useInboxNotificationThread as useInboxNotificationThread,\n  _useUser as useUser,\n  _useUserSuspense as useUserSuspense,\n  useInboxNotifications,\n  useInboxNotificationsSuspense,\n  useMarkAllInboxNotificationsAsRead,\n  useMarkInboxNotificationAsRead,\n  useDeleteAllInboxNotifications,\n  useDeleteInboxNotification,\n  useErrorListener,\n  useRoomInfo,\n  useRoomInfoSuspense,\n  useGroupInfo,\n  useGroupInfoSuspense,\n  useSyncStatus,\n  useUnreadInboxNotificationsCount,\n  useUnreadInboxNotificationsCountSuspense,\n  useNotificationSettings,\n  useNotificationSettingsSuspense,\n  useUpdateNotificationSettings,\n  _useUserThreads_experimental as useUserThreads_experimental,\n  _useUserThreadsSuspense_experimental as useUserThreadsSuspense_experimental,\n  _useAiChats as useAiChats,\n  _useAiChatsSuspense as useAiChatsSuspense,\n  _useAiChat as useAiChat,\n  _useAiChatSuspense as useAiChatSuspense,\n  _useAiChatMessages as useAiChatMessages,\n  _useAiChatMessagesSuspense as useAiChatMessagesSuspense,\n  useAiChatStatus,\n  useCreateAiChat,\n  useDeleteAiChat,\n  useSendAiMessage,\n  _useUrlMetadata as useUrlMetadata,\n  _useUrlMetadataSuspense as useUrlMetadataSuspense,\n};\n","const SECONDS = 1000;\nconst MINUTES = 60 * SECONDS;\n\n// Poller config\nexport const config = {\n  SMOOTH_DELAY: 1 * SECONDS,\n\n  NOTIFICATIONS_POLL_INTERVAL: 1 * MINUTES,\n  NOTIFICATIONS_MAX_STALE_TIME: 5 * SECONDS,\n\n  ROOM_THREADS_POLL_INTERVAL: 5 * MINUTES,\n  ROOM_THREADS_MAX_STALE_TIME: 5 * SECONDS,\n\n  USER_THREADS_POLL_INTERVAL: 1 * MINUTES,\n  USER_THREADS_MAX_STALE_TIME: 30 * SECONDS,\n\n  HISTORY_VERSIONS_POLL_INTERVAL: 1 * MINUTES,\n  HISTORY_VERSIONS_MAX_STALE_TIME: 5 * SECONDS,\n\n  ROOM_SUBSCRIPTION_SETTINGS_POLL_INTERVAL: 1 * MINUTES,\n  ROOM_SUBSCRIPTION_SETTINGS_MAX_STALE_TIME: 5 * SECONDS,\n\n  USER_NOTIFICATION_SETTINGS_INTERVAL: 5 * MINUTES,\n  USER_NOTIFICATION_SETTINGS_MAX_STALE_TIME: 1 * MINUTES,\n};\n","import type { AsyncError, AsyncLoading, AsyncSuccess } from \"@liveblocks/core\";\n\n// TODO Maybe move these into @liveblocks/core if they are useful?\n\nexport const ASYNC_LOADING: AsyncLoading = Object.freeze({ isLoading: true });\n\nexport const ASYNC_ERR = (error: Error): AsyncError =>\n  Object.freeze({ isLoading: false, error });\n\nexport function ASYNC_OK<T>(data: T): AsyncSuccess<T>;\nexport function ASYNC_OK<T, F extends string>(\n  field: F,\n  data: T\n): AsyncSuccess<T, F>;\nexport function ASYNC_OK<T, F extends string>(\n  fieldOrData: F | T,\n  data?: T\n): AsyncSuccess<T, F> {\n  if (arguments.length === 1) {\n    // @ts-expect-error too dynamic to type\n    return Object.freeze({ isLoading: false, data: fieldOrData });\n  } else {\n    // @ts-expect-error too dynamic to type\n    return Object.freeze({ isLoading: false, [fieldOrData as F]: data });\n  }\n}\n","export function ensureNotServerSide(): void {\n  // Error early if suspense is used in a server-side context\n  if (typeof window === \"undefined\") {\n    throw new Error(\n      \"You cannot use the Suspense version of Liveblocks hooks server side. Make sure to only call them client side by using a ClientSideSuspense wrapper.\\nFor tips, see https://liveblocks.io/docs/api-reference/liveblocks-react#ClientSideSuspense\"\n    );\n  }\n}\n","import { useCallback, useMemo } from \"react\";\n\nimport { useLatest } from \"./use-latest\";\n\n/**\n * \"Freezes\" a given value, so that it will return the same value/instance on\n * each subsequent render. This can be used to freeze \"initial\" values for\n * custom hooks, much like how `useState(initialState)` or\n * `useRef(initialValue)` works.\n */\nexport function useInitial<T>(value: T, roomId?: string): T {\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  return useMemo(() => value, [roomId]);\n}\n\n/**\n * Like `useInitial`, but if the provided value is a function instance, will\n * instead return a stable wrapper that _is_ a stable reference itself between\n * re-renders, but one which will always call the _latest_ provided callback\n * instance.\n */\nexport function useInitialUnlessFunction<T>(\n  latestValue: T,\n  roomId?: string\n): T {\n  const frozenValue = useInitial(latestValue, roomId);\n\n  type Fn = T & ((...args: unknown[]) => unknown);\n  const ref = useLatest(latestValue as Fn);\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  const wrapper = useCallback(\n    ((...args: unknown[]) => ref.current(...args)) as Fn,\n    [ref]\n  );\n\n  // Return the wrapper only if the frozen value is a function\n  if (typeof frozenValue === \"function\") {\n    return wrapper;\n  } else {\n    return frozenValue;\n  }\n}\n","import * as React from \"react\";\n\ntype Use = <T>(promise: Promise<T>) => T;\n\n// Prevent bundlers from trying to `import { use } from \"react\";`\nconst reactUse = React[\" use \".trim().toString() as keyof typeof React] as\n  | Use\n  | undefined;\n\n/**\n * Drop-in replacement for React 19's `use` hook,\n * with a partial polyfill for older versions of React.\n *\n *  Only supports `use(promise)`, not `use(context)`.\n */\nexport const use =\n  reactUse ??\n  (<T>(\n    promise: Promise<T> & {\n      status?: \"pending\" | \"fulfilled\" | \"rejected\";\n      value?: T;\n      reason?: unknown;\n    }\n  ): T => {\n    if (promise.status === \"pending\") {\n      throw promise;\n    } else if (promise.status === \"fulfilled\") {\n      return promise.value as T;\n    } else if (promise.status === \"rejected\") {\n      throw promise.reason;\n    } else {\n      promise.status = \"pending\";\n      promise.then(\n        (v) => {\n          promise.status = \"fulfilled\";\n          promise.value = v;\n        },\n        (e) => {\n          promise.status = \"rejected\";\n          promise.reason = e;\n        }\n      );\n      throw promise;\n    }\n  });\n","import type {\n  AiChatsQuery,\n  AsyncResult,\n  BaseMetadata,\n  BaseUserMeta,\n  Client,\n  CommentData,\n  CommentReaction,\n  CommentUserReaction,\n  Cursor,\n  DistributiveOmit,\n  HistoryVersion,\n  InboxNotificationData,\n  InboxNotificationDeleteInfo,\n  ISignal,\n  MessageId,\n  NotificationSettings,\n  OpaqueClient,\n  PartialNotificationSettings,\n  Patchable,\n  Permission,\n  Resolve,\n  RoomSubscriptionSettings,\n  SubscriptionData,\n  SubscriptionDeleteInfo,\n  SubscriptionKey,\n  ThreadData,\n  ThreadDataWithDeleteInfo,\n  ThreadDeleteInfo,\n  UrlMetadata,\n} from \"@liveblocks/core\";\nimport {\n  assertNever,\n  autoRetry,\n  batch,\n  compactObject,\n  console,\n  createNotificationSettings,\n  DefaultMap,\n  DerivedSignal,\n  getSubscriptionKey,\n  kInternal,\n  MutableSignal,\n  nanoid,\n  nn,\n  patchNotificationSettings,\n  shallow,\n  shallow2,\n  Signal,\n  stableStringify,\n} from \"@liveblocks/core\";\n\nimport { ASYNC_ERR, ASYNC_LOADING, ASYNC_OK } from \"./lib/AsyncResult\";\nimport { autobind } from \"./lib/autobind\";\nimport { find } from \"./lib/itertools\";\nimport { makeInboxNotificationsFilter } from \"./lib/querying\";\nimport type { ReadonlyThreadDB } from \"./ThreadDB\";\nimport { ThreadDB } from \"./ThreadDB\";\nimport type {\n  AiChatAsyncResult,\n  AiChatMessagesAsyncResult,\n  AiChatsAsyncResult,\n  HistoryVersionsAsyncResult,\n  InboxNotificationsAsyncResult,\n  InboxNotificationsQuery,\n  NotificationSettingsAsyncResult,\n  RoomSubscriptionSettingsAsyncResult,\n  ThreadsAsyncResult,\n  ThreadsQuery,\n  UnreadInboxNotificationsCountAsyncResult,\n  UrlMetadataAsyncResult,\n} from \"./types\";\n\ntype OptimisticUpdate<TM extends BaseMetadata, CM extends BaseMetadata> =\n  | CreateThreadOptimisticUpdate<TM, CM>\n  | DeleteThreadOptimisticUpdate\n  | EditThreadMetadataOptimisticUpdate<TM>\n  | MarkThreadAsResolvedOptimisticUpdate\n  | MarkThreadAsUnresolvedOptimisticUpdate\n  | SubscribeToThreadOptimisticUpdate\n  | UnsubscribeFromThreadOptimisticUpdate\n  | CreateCommentOptimisticUpdate<CM>\n  | EditCommentOptimisticUpdate<CM>\n  | EditCommentMetadataOptimisticUpdate<CM>\n  | DeleteCommentOptimisticUpdate\n  | AddReactionOptimisticUpdate\n  | RemoveReactionOptimisticUpdate\n  | MarkInboxNotificationAsReadOptimisticUpdate\n  | MarkAllInboxNotificationsAsReadOptimisticUpdate\n  | DeleteInboxNotificationOptimisticUpdate\n  | DeleteAllInboxNotificationsOptimisticUpdate\n  | UpdateRoomSubscriptionSettingsOptimisticUpdate\n  | UpdateNotificationSettingsOptimisticUpdate;\n\ntype CreateThreadOptimisticUpdate<\n  TM extends BaseMetadata,\n  CM extends BaseMetadata,\n> = {\n  type: \"create-thread\";\n  id: string;\n  roomId: string;\n  thread: ThreadData<TM, CM>;\n};\n\ntype DeleteThreadOptimisticUpdate = {\n  type: \"delete-thread\";\n  id: string;\n  roomId: string;\n  threadId: string;\n  deletedAt: Date;\n};\n\ntype EditThreadMetadataOptimisticUpdate<TM extends BaseMetadata> = {\n  type: \"edit-thread-metadata\";\n  id: string;\n  threadId: string;\n  metadata: Resolve<Patchable<TM>>;\n  updatedAt: Date;\n};\n\ntype MarkThreadAsResolvedOptimisticUpdate = {\n  type: \"mark-thread-as-resolved\";\n  id: string;\n  threadId: string;\n  updatedAt: Date;\n};\n\ntype MarkThreadAsUnresolvedOptimisticUpdate = {\n  type: \"mark-thread-as-unresolved\";\n  id: string;\n  threadId: string;\n  updatedAt: Date;\n};\n\ntype SubscribeToThreadOptimisticUpdate = {\n  type: \"subscribe-to-thread\";\n  id: string;\n  threadId: string;\n  subscribedAt: Date;\n};\n\ntype UnsubscribeFromThreadOptimisticUpdate = {\n  type: \"unsubscribe-from-thread\";\n  id: string;\n  threadId: string;\n  unsubscribedAt: Date;\n};\n\ntype CreateCommentOptimisticUpdate<CM extends BaseMetadata> = {\n  type: \"create-comment\";\n  id: string;\n  comment: CommentData<CM>;\n};\n\ntype EditCommentOptimisticUpdate<CM extends BaseMetadata> = {\n  type: \"edit-comment\";\n  id: string;\n  comment: CommentData<CM>;\n};\n\ntype EditCommentMetadataOptimisticUpdate<CM extends BaseMetadata> = {\n  type: \"edit-comment-metadata\";\n  id: string;\n  threadId: string;\n  commentId: string;\n  metadata: Resolve<Patchable<CM>>;\n  updatedAt: Date;\n};\n\ntype DeleteCommentOptimisticUpdate = {\n  type: \"delete-comment\";\n  id: string;\n  roomId: string;\n  threadId: string;\n  deletedAt: Date;\n  commentId: string;\n};\n\ntype AddReactionOptimisticUpdate = {\n  type: \"add-reaction\";\n  id: string;\n  threadId: string;\n  commentId: string;\n  reaction: CommentUserReaction;\n};\n\ntype RemoveReactionOptimisticUpdate = {\n  type: \"remove-reaction\";\n  id: string;\n  threadId: string;\n  commentId: string;\n  emoji: string;\n  userId: string;\n  removedAt: Date;\n};\n\ntype MarkInboxNotificationAsReadOptimisticUpdate = {\n  type: \"mark-inbox-notification-as-read\";\n  id: string;\n  inboxNotificationId: string;\n  readAt: Date;\n};\n\ntype MarkAllInboxNotificationsAsReadOptimisticUpdate = {\n  type: \"mark-all-inbox-notifications-as-read\";\n  id: string;\n  readAt: Date;\n};\n\ntype DeleteInboxNotificationOptimisticUpdate = {\n  type: \"delete-inbox-notification\";\n  id: string;\n  inboxNotificationId: string;\n  deletedAt: Date;\n};\n\ntype DeleteAllInboxNotificationsOptimisticUpdate = {\n  type: \"delete-all-inbox-notifications\";\n  id: string;\n  deletedAt: Date;\n};\n\ntype UpdateRoomSubscriptionSettingsOptimisticUpdate = {\n  type: \"update-room-subscription-settings\";\n  id: string;\n  roomId: string;\n  userId: string;\n  settings: Partial<RoomSubscriptionSettings>;\n};\n\ntype UpdateNotificationSettingsOptimisticUpdate = {\n  type: \"update-notification-settings\";\n  id: string;\n  settings: PartialNotificationSettings;\n};\n\ntype PaginationState = {\n  cursor: string | null; // If `null`, it's the last page\n  hasFetchedAll: boolean;\n  isFetchingMore: boolean;\n  fetchMoreError?: Error;\n  fetchMore: () => void;\n};\n\n/**\n * Valid combinations of field patches to the pagination state.\n */\ntype PaginationStatePatch =\n  | { isFetchingMore: true }\n  | {\n      hasFetchedAll: boolean;\n      isFetchingMore: false;\n      cursor: string | null;\n      fetchMoreError: undefined;\n    }\n  | { isFetchingMore: false; fetchMoreError: Error };\n\n/**\n * Example:\n * makeRoomThreadsQueryKey('room-abc', { xyz: 123, abc: \"red\" })\n *  '[\"room-abc\",{\"color\":\"red\",\"xyz\":123}]'\n */\nexport function makeRoomThreadsQueryKey<TM extends BaseMetadata>(\n  roomId: string,\n  query: ThreadsQuery<TM> | undefined\n) {\n  return stableStringify([roomId, query ?? {}]);\n}\n\nexport function makeUserThreadsQueryKey<TM extends BaseMetadata>(\n  query: ThreadsQuery<TM> | undefined\n) {\n  return stableStringify(query ?? {});\n}\n\nexport function makeAiChatsQueryKey(\n  query: AiChatsQuery | undefined\n): AiChatsQueryKey {\n  return stableStringify(query ?? {});\n}\n\nexport function makeInboxNotificationsQueryKey(\n  query: InboxNotificationsQuery | undefined\n) {\n  return stableStringify(query ?? {});\n}\n\n/**\n * Like Promise<T>, except it will have a synchronously readable `status`\n * field, indicating the status of the promise.\n * This is compatible with React's `use()` promises, hence the name.\n */\ntype UsablePromise<T> = Promise<T> &\n  (\n    | { status: \"pending\" }\n    | { status: \"rejected\"; reason: Error }\n    | { status: \"fulfilled\"; value: T }\n  );\n\n/**\n * Given any Promise<T>, monkey-patches it to a UsablePromise<T>, whose\n * asynchronous status can be synchronously observed.\n */\nfunction usify<T>(promise: Promise<T>): UsablePromise<T> {\n  if (\"status\" in promise) {\n    // Already a usable promise\n    return promise as UsablePromise<T>;\n  }\n\n  const usable: UsablePromise<T> = promise as UsablePromise<T>;\n  usable.status = \"pending\";\n  usable.then(\n    (value) => {\n      usable.status = \"fulfilled\";\n      (usable as UsablePromise<T> & { status: \"fulfilled\" }).value = value;\n    },\n    (err) => {\n      usable.status = \"rejected\";\n      (usable as UsablePromise<T> & { status: \"rejected\" }).reason =\n        err as Error;\n    }\n  );\n  return usable;\n}\n\nconst noop = Promise.resolve();\n\n/**\n * The PaginatedResource helper class is responsible for and abstracts away the\n * following:\n *\n * - It receives a \"page fetch\" function of the following signature:\n *     (cursor?: Cursor) => Promise<Cursor | null>\n *\n * - Note that there is no data in the returned value!!! Storing or handling\n *   the data is NOT the responsibility of this helper class. This may be a bit\n *   counter-intuitive at first. The provided page fetcher callback function\n *   should store the data elsewhere, outside of the PaginatedResource state\n *   machine, as a side-effect of this \"page fetch\" function, but it can always\n *   assume the happy path. This class will deal with all the required\n *   complexity for handling the non-happy path conditions.\n *\n * - This class exposes a \"getter\" that you can call synchronously to get the\n *   current fetching/paginationo status for this resource. It will look like\n *   the pagination hooks, except it will not contain any data. In other words,\n *   it can return any of these shapes:\n *\n *   - { isLoading: true }\n *   - {\n *       isLoading: false,\n *       error: new Error('error while fetching'),\n *     }\n *   - {\n *       isLoading: false,\n *       data: {\n *         cursor: string | null;\n *         isFetchingMore: boolean;\n *         fetchMoreError?: Error;\n *       }\n *     }\n *\n * - When calling the getter multiple times, the return value is always\n *   referentially equal to the previous call.\n *\n * - When in this error state, the error will remain in error state for\n *   5 seconds. After those 5 seconds, the resource status gets reset, and the\n *   next time the \"getter\" is accessed, the resource will re-initiate the\n *   initial fetching process.\n *\n * - This class exposes an Observable that is notified whenever the state\n *   changes. For now, this observable can be used to call a no-op update to\n *   the Store (eg `.set(state => ({...state})`), to trigger a re-render for\n *   all React components.\n *\n * - This class will also expose a function that can be exposed as the\n *   `fetchMore` function which can be called externally.\n *\n * - This nicely bundles the internal state that should always be mutated\n *   together to manage all the pagination state.\n *\n * - For InboxNotifications we will have one instance of this class.\n *\n * - For Threads we will have one for each query.\n *\n * ---------------------------------------------------------------------------\n *\n * NOT 100% SURE ABOUT THE FOLLOWING YET:\n *\n * - Maybe we could eventually also let this manage the \"delta updates\" and the\n *   \"last requested at\" for this resource? Seems nice to add it here somehow.\n *   Need to think about the exact implications though.\n *\n * @internal Only exported for unit tests.\n */\nexport class PaginatedResource {\n  readonly #signal: Signal<AsyncResult<PaginationState>>;\n  public readonly signal: ISignal<AsyncResult<PaginationState>>;\n\n  #fetchPage: (cursor?: string) => Promise<string | null>;\n  #pendingFetchMore: Promise<void> | null;\n\n  constructor(fetchPage: (cursor?: string) => Promise<string | null>) {\n    this.#signal = new Signal<AsyncResult<PaginationState>>(ASYNC_LOADING);\n    this.#fetchPage = fetchPage;\n    this.#pendingFetchMore = null;\n    this.signal = this.#signal.asReadonly();\n\n    autobind(this);\n  }\n\n  get(): AsyncResult<PaginationState> {\n    return this.#signal.get();\n  }\n\n  #patch(patch: PaginationStatePatch): void {\n    const state = this.#signal.get();\n    if (state.data === undefined) return;\n    this.#signal.set(ASYNC_OK({ ...state.data, ...patch }));\n  }\n\n  async #fetchMore(): Promise<void> {\n    const state = this.#signal.get();\n    if (!state.data?.cursor || state.data.isFetchingMore) {\n      // Either:\n      // - We don't have a cursor yet (first fetch not happened successfully yet)\n      // - We don't have a cursor any longer (we're on the last page)\n      return;\n    }\n\n    this.#patch({ isFetchingMore: true });\n    try {\n      const nextCursor = await this.#fetchPage(state.data.cursor);\n      this.#patch({\n        cursor: nextCursor,\n        hasFetchedAll: nextCursor === null,\n        fetchMoreError: undefined,\n        isFetchingMore: false,\n      });\n    } catch (err) {\n      this.#patch({\n        isFetchingMore: false,\n        fetchMoreError: err as Error,\n      });\n    }\n  }\n\n  public fetchMore(): Promise<void> {\n    // We do not proceed with fetching more if any of the following is true:\n    // 1) the pagination state has not be initialized\n    // 2) the cursor is null, i.e., there are no more pages to fetch\n    // 3) a request to fetch more is currently in progress\n    const state = this.#signal.get();\n    if (!state.data?.cursor) return noop;\n\n    // Case (3)\n    if (!this.#pendingFetchMore) {\n      this.#pendingFetchMore = this.#fetchMore().finally(() => {\n        this.#pendingFetchMore = null;\n      });\n    }\n    return this.#pendingFetchMore;\n  }\n\n  #cachedPromise: UsablePromise<void> | null = null;\n\n  public waitUntilLoaded(): UsablePromise<void> {\n    if (this.#cachedPromise) {\n      return this.#cachedPromise;\n    }\n\n    // Wrap the request to load room threads (and notifications) in an auto-retry function so that if the request fails,\n    // we retry for at most 5 times with incremental backoff delays. If all retries fail, the auto-retry function throws an error\n    const initialPageFetch$ = autoRetry(\n      () => this.#fetchPage(/* cursor */ undefined),\n      5,\n      [5000, 5000, 10000, 15000]\n    );\n\n    const promise = usify(initialPageFetch$);\n\n    // NOTE: However tempting it may be, we cannot simply move this block into\n    // the promise definition above. The reason is that we should not call\n    // notify() before the UsablePromise is actually in resolved status. While\n    // still inside the .then() block, the UsablePromise is still in pending status.\n    promise.then(\n      (cursor) => {\n        this.#signal.set(\n          ASYNC_OK({\n            cursor,\n            hasFetchedAll: cursor === null,\n            isFetchingMore: false,\n            fetchMoreError: undefined,\n            fetchMore: this.fetchMore,\n          })\n        );\n      },\n      (err) => {\n        this.#signal.set(ASYNC_ERR(err as Error));\n\n        // Wait for 5 seconds before removing the request\n        setTimeout(() => {\n          this.#cachedPromise = null;\n          this.#signal.set(ASYNC_LOADING);\n        }, 5_000);\n      }\n    );\n\n    this.#cachedPromise =\n      promise as UsablePromise<unknown> as UsablePromise<void>;\n    return this.#cachedPromise;\n  }\n}\n\n// TODO Find better name?\ntype LoadableResource<T> = {\n  signal: ISignal<T>;\n  waitUntilLoaded: () => UsablePromise<void>;\n};\n\nclass SinglePageResource {\n  readonly #signal: Signal<AsyncResult<void>>;\n  public readonly signal: ISignal<AsyncResult<void>>;\n\n  #fetchPage: () => Promise<void>;\n\n  #autoRetry: boolean = true;\n\n  constructor(fetchPage: () => Promise<void>, autoRetry: boolean = true) {\n    this.#signal = new Signal<AsyncResult<void>>(ASYNC_LOADING);\n    this.signal = this.#signal.asReadonly();\n    this.#fetchPage = fetchPage;\n    this.#autoRetry = autoRetry;\n\n    autobind(this);\n  }\n\n  get(): AsyncResult<void> {\n    return this.#signal.get();\n  }\n\n  #cachedPromise: UsablePromise<void> | null = null;\n\n  public waitUntilLoaded(): UsablePromise<void> {\n    if (this.#cachedPromise) {\n      return this.#cachedPromise;\n    }\n\n    // Wrap the request to load room threads (and notifications) in an auto-retry function so that if the request fails,\n    // we retry for at most 5 times with incremental backoff delays. If all retries fail, the auto-retry function throws an error\n    const initialFetcher$ = this.#autoRetry\n      ? autoRetry(() => this.#fetchPage(), 5, [5000, 5000, 10000, 15000])\n      : this.#fetchPage();\n\n    const promise = usify(initialFetcher$);\n\n    // NOTE: However tempting it may be, we cannot simply move this block into\n    // the promise definition above. The reason is that we should not call\n    // notify() before the UsablePromise is actually in resolved status. While\n    // still inside the .then() block, the UsablePromise is still in pending status.\n    promise.then(\n      () => {\n        this.#signal.set(ASYNC_OK(undefined));\n      },\n      (err) => {\n        this.#signal.set(ASYNC_ERR(err as Error));\n\n        if (this.#autoRetry) {\n          // Wait for 5 seconds before removing the request\n          setTimeout(() => {\n            this.#cachedPromise = null;\n            this.#signal.set(ASYNC_LOADING);\n          }, 5_000);\n        }\n      }\n    );\n\n    this.#cachedPromise = promise;\n    return promise;\n  }\n}\n\ntype RoomId = string;\ntype UserQueryKey = string;\ntype RoomQueryKey = string;\ntype InboxNotificationsQueryKey = string;\n\ntype AiChatsQueryKey = string;\n\n/**\n * A lookup table (LUT) for all the history versions.\n */\ntype VersionsLUT = DefaultMap<RoomId, Map<string, HistoryVersion>>;\n\n/**\n * A lookup table (LUT) for all the inbox notifications.\n */\ntype NotificationsLUT = Map<string, InboxNotificationData>;\n\n/**\n * A lookup table (LUT) for all the unread inbox notifications count.\n */\ntype UnreadInboxNotificationsCountLUT = Map<string, number>;\n\n/**\n * A lookup table (LUT) for all the subscriptions.\n */\ntype SubscriptionsLUT = Map<SubscriptionKey, SubscriptionData>;\n\n/**\n * A lookup table (LUT) for all the room subscription settings.\n */\ntype RoomSubscriptionSettingsLUT = Map<RoomId, RoomSubscriptionSettings>;\n\n/**\n * Room subscription settings by room ID.\n * e.g. { 'room-abc': { threads: \"all\" },\n *        'room-def': { threads: \"replies_and_mentions\" },\n *        'room-xyz': { threads: \"none\" },\n *      }\n */\ntype RoomSubscriptionSettingsByRoomId = Record<\n  RoomId,\n  RoomSubscriptionSettings\n>;\n\nexport type SubscriptionsByKey = Record<SubscriptionKey, SubscriptionData>;\n\nexport type CleanThreadifications<\n  TM extends BaseMetadata,\n  CM extends BaseMetadata,\n> =\n  // Threads + Notifications = Threadifications\n  CleanThreads<TM, CM> &\n    //\n    CleanNotifications;\n\nexport type CleanThreads<TM extends BaseMetadata, CM extends BaseMetadata> = {\n  /**\n   * Keep track of loading and error status of all the queries made by the client.\n   * e.g. 'room-abc-{\"color\":\"red\"}'  - ok\n   * e.g. 'room-abc-{}'               - loading\n   */\n  threadsDB: ReadonlyThreadDB<TM, CM>;\n};\n\nexport type CleanNotifications = {\n  /**\n   * All inbox notifications in a sorted array, optimistic updates applied.\n   */\n  sortedNotifications: InboxNotificationData[];\n\n  /**\n   * Inbox notifications by ID.\n   * e.g. `in_${string}`\n   */\n  notificationsById: Record<string, InboxNotificationData>;\n};\n\nexport type CleanThreadSubscriptions = {\n  /**\n   * Thread subscriptions by key (kind + subject ID).\n   * e.g. `thread:${string}`, `$custom:${string}`, etc\n   */\n  subscriptions: SubscriptionsByKey;\n\n  /**\n   * All inbox notifications in a sorted array, optimistic updates applied.\n   *\n   * `useThreadSubscription` returns the subscription status based on subscriptions\n   * but also the `readAt` value of the associated notification, so we need to\n   * expose the notifications here as well.\n   */\n  notifications: InboxNotificationData[];\n};\n\nfunction createStore_forNotifications() {\n  const signal = new MutableSignal<NotificationsLUT>(new Map());\n\n  function markRead(notificationId: string, readAt: Date) {\n    signal.mutate((lut) => {\n      const existing = lut.get(notificationId);\n      if (!existing) {\n        return false;\n      }\n      lut.set(notificationId, { ...existing, readAt });\n      return true;\n    });\n  }\n\n  function markAllRead(readAt: Date) {\n    signal.mutate((lut) => {\n      for (const n of lut.values()) {\n        n.readAt = readAt;\n      }\n    });\n  }\n\n  function deleteOne(inboxNotificationId: string) {\n    signal.mutate((lut) => lut.delete(inboxNotificationId));\n  }\n\n  function clear() {\n    signal.mutate((lut) => lut.clear());\n  }\n\n  function applyDelta(\n    newNotifications: InboxNotificationData[],\n    deletedNotifications: InboxNotificationDeleteInfo[]\n  ) {\n    signal.mutate((lut) => {\n      let mutated = false;\n\n      // Add new notifications or update existing notifications if the existing notification is older than the new notification.\n      for (const n of newNotifications) {\n        const existing = lut.get(n.id);\n        // If the notification already exists, we need to compare the two notifications to determine which one is newer.\n        if (existing) {\n          const result = compareInboxNotifications(existing, n);\n          // If the existing notification is newer than the new notification, we do not update the existing notification.\n          if (result === 1) continue;\n        }\n\n        // If the new notification is newer than the existing notification, we update the existing notification.\n        lut.set(n.id, n);\n        mutated = true;\n      }\n\n      for (const n of deletedNotifications) {\n        lut.delete(n.id);\n        mutated = true;\n      }\n      return mutated;\n    });\n  }\n\n  function updateAssociatedNotification<CM extends BaseMetadata>(\n    newComment: CommentData<CM>\n  ) {\n    signal.mutate((lut) => {\n      const existing = find(\n        lut.values(),\n        (notification) =>\n          notification.kind === \"thread\" &&\n          notification.threadId === newComment.threadId\n      );\n      if (!existing) return false; // Nothing to udate here\n\n      // If the thread has an inbox notification associated with it, we update the notification's `notifiedAt` and `readAt` values\n      lut.set(existing.id, {\n        ...existing,\n        notifiedAt: newComment.createdAt,\n        readAt: newComment.createdAt,\n      });\n      return true;\n    });\n  }\n\n  function upsert(notification: InboxNotificationData) {\n    signal.mutate((lut) => {\n      lut.set(notification.id, notification);\n    });\n  }\n\n  return {\n    signal: signal.asReadonly(),\n\n    // Mutations\n    markAllRead,\n    markRead,\n    delete: deleteOne,\n    applyDelta,\n    clear,\n    updateAssociatedNotification,\n    upsert,\n  };\n}\n\nfunction createStore_forUnreadNotificationsCount() {\n  const baseSignal = new MutableSignal<UnreadInboxNotificationsCountLUT>(\n    new Map()\n  );\n\n  function update(queryKey: InboxNotificationsQueryKey, count: number): void {\n    baseSignal.mutate((lut) => {\n      lut.set(queryKey, count);\n    });\n  }\n\n  return {\n    signal: DerivedSignal.from(baseSignal, (c) => Object.fromEntries(c)),\n\n    // Mutations\n    update,\n  };\n}\n\nfunction createStore_forSubscriptions(\n  updates: ISignal<readonly OptimisticUpdate<BaseMetadata, BaseMetadata>[]>,\n  threads: ReadonlyThreadDB<BaseMetadata, BaseMetadata>\n) {\n  const baseSignal = new MutableSignal<SubscriptionsLUT>(new Map());\n\n  function applyDelta(\n    newSubscriptions: SubscriptionData[],\n    deletedSubscriptions: SubscriptionDeleteInfo[]\n  ) {\n    baseSignal.mutate((lut) => {\n      let mutated = false;\n\n      for (const s of newSubscriptions) {\n        lut.set(getSubscriptionKey(s), s);\n        mutated = true;\n      }\n\n      for (const s of deletedSubscriptions) {\n        lut.delete(getSubscriptionKey(s));\n        mutated = true;\n      }\n\n      return mutated;\n    });\n  }\n\n  function create(subscription: SubscriptionData) {\n    baseSignal.mutate((lut) => {\n      lut.set(getSubscriptionKey(subscription), subscription);\n    });\n  }\n\n  function deleteOne(subscriptionKey: SubscriptionKey) {\n    baseSignal.mutate((lut) => {\n      lut.delete(subscriptionKey);\n    });\n  }\n\n  return {\n    signal: DerivedSignal.from(baseSignal, updates, (base, updates) =>\n      applyOptimisticUpdates_forSubscriptions(base, threads, updates)\n    ),\n\n    // Mutations\n    applyDelta,\n    create,\n    delete: deleteOne,\n  };\n}\n\nfunction createStore_forRoomSubscriptionSettings(\n  updates: ISignal<readonly OptimisticUpdate<BaseMetadata, BaseMetadata>[]>\n) {\n  const baseSignal = new MutableSignal<RoomSubscriptionSettingsLUT>(new Map());\n\n  function update(roomId: string, settings: RoomSubscriptionSettings): void {\n    baseSignal.mutate((lut) => {\n      lut.set(roomId, settings);\n    });\n  }\n\n  return {\n    signal: DerivedSignal.from(baseSignal, updates, (base, updates) =>\n      applyOptimisticUpdates_forRoomSubscriptionSettings(base, updates)\n    ),\n\n    // Mutations\n    update,\n  };\n}\n\nfunction createStore_forHistoryVersions() {\n  const baseSignal = new MutableSignal(\n    new DefaultMap(() => new Map()) as VersionsLUT\n  );\n\n  function update(roomId: string, versions: HistoryVersion[]): void {\n    baseSignal.mutate((lut) => {\n      const versionsById = lut.getOrCreate(roomId);\n      for (const version of versions) {\n        versionsById.set(version.id, version);\n      }\n    });\n  }\n\n  return {\n    signal: DerivedSignal.from(baseSignal, (hv) =>\n      Object.fromEntries(\n        [...hv].map(([roomId, versions]) => [\n          roomId,\n          Object.fromEntries(versions),\n        ])\n      )\n    ),\n\n    // Mutations\n    update,\n  };\n}\n\nfunction createStore_forUrlsMetadata() {\n  const baseSignal = new MutableSignal<Map<string, UrlMetadata>>(new Map());\n\n  function update(url: string, metadata: UrlMetadata): void {\n    baseSignal.mutate((lut) => {\n      lut.set(url, metadata);\n    });\n  }\n\n  return {\n    signal: DerivedSignal.from(baseSignal, (m) => Object.fromEntries(m)),\n\n    // Mutations\n    update,\n  };\n}\n\nfunction createStore_forPermissionHints() {\n  const permissionsByRoomId = new DefaultMap(\n    () => new Signal<Set<Permission>>(new Set())\n  );\n\n  function update(newHints: Record<string, Permission[]>) {\n    batch(() => {\n      for (const [roomId, permissions] of Object.entries(newHints)) {\n        const signal = permissionsByRoomId.getOrCreate(roomId);\n        // Get the existing set of permissions for the room and only ever add permission to this set\n        const existingPermissions = new Set(signal.get());\n        for (const permission of permissions) {\n          existingPermissions.add(permission);\n        }\n        signal.set(existingPermissions);\n      }\n    });\n  }\n\n  function getPermissionForRoom(roomId: string): ISignal<Set<Permission>> {\n    return permissionsByRoomId.getOrCreate(roomId);\n  }\n\n  return {\n    getPermissionForRoom,\n\n    // Mutations\n    update,\n  };\n}\n\n/**\n * Notification settings\n *\n * e.g.\n *  {\n *    email: {\n *      thread: true,\n *      textMention: false,\n *      $customKind: true | false,\n *    }\n *    slack: {\n *      thread: true,\n *      textMention: false,\n *      $customKind: true | false,\n *    }\n *  }\n * e.g. {} when before the first successful fetch.\n */\nfunction createStore_forNotificationSettings(\n  updates: ISignal<readonly OptimisticUpdate<BaseMetadata, BaseMetadata>[]>\n) {\n  const signal = new Signal<NotificationSettings>(\n    createNotificationSettings({})\n  );\n\n  function update(settings: NotificationSettings) {\n    signal.set(settings);\n  }\n\n  return {\n    signal: DerivedSignal.from(signal, updates, (base, updates) =>\n      applyOptimisticUpdates_forNotificationSettings(base, updates)\n    ),\n    // Mutations\n    update,\n  };\n}\n\n// A list of optimistic updates that should not trigger `preventUnsavedChanges`\n// behaviors (e.g prevent closing the tab or navigating to another page).\n// These mutations can be considered non-critical.\nconst NON_BLOCKING_OPTIMISTIC_UPDATES: ReadonlySet<\n  OptimisticUpdate<never, never>[\"type\"]\n> = new Set([\"mark-inbox-notification-as-read\"]);\n\nfunction createStore_forOptimistic<\n  TM extends BaseMetadata,\n  CM extends BaseMetadata,\n>(client: Client<BaseUserMeta, TM, CM>) {\n  const signal = new Signal<readonly OptimisticUpdate<TM, CM>[]>([]);\n  const syncSource = client[kInternal].createSyncSource();\n\n  // Automatically update the global sync status as an effect whenever there\n  // are any blocking optimistic updates.\n  signal.subscribe(() =>\n    syncSource.setSyncStatus(\n      signal\n        .get()\n        .some((update) => !NON_BLOCKING_OPTIMISTIC_UPDATES.has(update.type))\n        ? \"synchronizing\"\n        : \"synchronized\"\n    )\n  );\n\n  function add(\n    optimisticUpdate: DistributiveOmit<OptimisticUpdate<TM, CM>, \"id\">\n  ): string {\n    const id = nanoid();\n    const newUpdate: OptimisticUpdate<TM, CM> = { ...optimisticUpdate, id };\n    signal.set((state) => [...state, newUpdate]);\n    return id;\n  }\n\n  function remove(optimisticId: string): void {\n    signal.set((state) => state.filter((ou) => ou.id !== optimisticId));\n  }\n\n  return {\n    signal: signal.asReadonly(),\n\n    // Mutations\n    add,\n    remove,\n  };\n}\n\nexport class UmbrellaStore<TM extends BaseMetadata, CM extends BaseMetadata> {\n  #client: Client<BaseUserMeta, TM, CM>;\n\n  //\n  // Internally, the UmbrellaStore keeps track of a few source signals that can\n  // be set and mutated individually. When any of those are mutated then the\n  // clean \"external state\" is recomputed.\n  //\n  //   Mutate inputs...                                             ...observe clean/consistent output!\n  //\n  //            .-> Base ThreadDB ---------+                 +-------> Clean threads by ID         (Part 1)\n  //           /                           |                 |\n  //   mutate ----> Base Notifications --+ |                 | +-----> Clean notifications         (Part 1)\n  //          \\                          | |                 | |       & notifications by ID\n  //         | \\                         | |      Apply      | |\n  //         |   `-> OptimisticUpdates --+--+--> Optimistic -+-+-+-+-> Subscriptions               (Part 2)\n  //          \\                          |        Updates    |   | |\n  //           `------- etc etc ---------+                   |   | +-> History Versions            (Part 3)\n  //                       ^                                 |   |\n  //                       |                                 |   +---> Room Subscription Settings  (Part 4)\n  //                       |                                 |\n  //                       |                                 +-------> Notification Settings       (Part 5)\n  //                       |\n  //                       |\n  //                       |                        ^                  ^\n  //                    Signal                      |                  |\n  //                      or                   DerivedSignal      DerivedSignals\n  //                  MutableSignal\n  //\n\n  //\n  // Input signals.\n  // (Can be mutated directly.)\n  //\n  // XXX_vincent Now that we have createStore_forX, we should probably also change\n  // `threads` to this pattern, ie create a createStore_forThreads helper as\n  // well. It almost works like that already anyway!\n  readonly threads: ThreadDB<TM, CM>; // Exposes its signal under `.signal` prop\n  readonly notifications: ReturnType<typeof createStore_forNotifications>;\n  readonly subscriptions: ReturnType<typeof createStore_forSubscriptions>;\n  readonly roomSubscriptionSettings: ReturnType<typeof createStore_forRoomSubscriptionSettings>; // prettier-ignore\n  readonly historyVersions: ReturnType<typeof createStore_forHistoryVersions>;\n  readonly unreadNotificationsCount: ReturnType<\n    typeof createStore_forUnreadNotificationsCount\n  >;\n  readonly urlsMetadata: ReturnType<typeof createStore_forUrlsMetadata>;\n  readonly permissionHints: ReturnType<typeof createStore_forPermissionHints>;\n  readonly notificationSettings: ReturnType<\n    typeof createStore_forNotificationSettings\n  >;\n  readonly optimisticUpdates: ReturnType<\n    typeof createStore_forOptimistic<TM, CM>\n  >;\n\n  //\n  // Output signals.\n  // (Readonly, clean, consistent. With optimistic updates applied.)\n  //\n  // Note that the output of threadifications signal is the same as the ones for\n  // threads and notifications separately, but the threadifications signal will\n  // be updated whenever either of them change.\n  //\n  readonly outputs: {\n    readonly threadifications: DerivedSignal<CleanThreadifications<TM, CM>>;\n    readonly threads: DerivedSignal<ReadonlyThreadDB<TM, CM>>;\n    readonly loadingRoomThreads: DefaultMap<\n      RoomQueryKey,\n      LoadableResource<ThreadsAsyncResult<TM, CM>>\n    >;\n    readonly loadingUserThreads: DefaultMap<\n      UserQueryKey,\n      LoadableResource<ThreadsAsyncResult<TM, CM>>\n    >;\n    readonly notifications: DerivedSignal<CleanNotifications>;\n    readonly threadSubscriptions: DerivedSignal<CleanThreadSubscriptions>;\n\n    readonly loadingNotifications: DefaultMap<\n      InboxNotificationsQueryKey,\n      LoadableResource<InboxNotificationsAsyncResult>\n    >;\n    readonly unreadNotificationsCount: DefaultMap<\n      InboxNotificationsQueryKey,\n      LoadableResource<UnreadInboxNotificationsCountAsyncResult>\n    >;\n    readonly roomSubscriptionSettingsByRoomId: DefaultMap<\n      RoomId,\n      LoadableResource<RoomSubscriptionSettingsAsyncResult>\n    >;\n    readonly versionsByRoomId: DefaultMap<\n      RoomId,\n      LoadableResource<HistoryVersionsAsyncResult>\n    >;\n    readonly notificationSettings: LoadableResource<NotificationSettingsAsyncResult>;\n    readonly aiChats: DefaultMap<\n      AiChatsQueryKey,\n      LoadableResource<AiChatsAsyncResult>\n    >;\n    readonly messagesByChatId: DefaultMap<\n      string,\n      DefaultMap<MessageId | null, LoadableResource<AiChatMessagesAsyncResult>>\n    >;\n    readonly aiChatById: DefaultMap<\n      string,\n      LoadableResource<AiChatAsyncResult>\n    >;\n    readonly urlMetadataByUrl: DefaultMap<\n      string,\n      LoadableResource<UrlMetadataAsyncResult>\n    >;\n  };\n\n  // Notifications\n  #notificationsLastRequestedAt: Date | null = null; // Keeps track of when we successfully requested an inbox notifications update for the last time. Will be `null` as long as the first successful fetch hasn't happened yet.\n\n  // Room Threads\n  #roomThreadsLastRequestedAtByRoom = new Map<RoomId, Date>();\n\n  // User Threads\n  #userThreadsLastRequestedAt: Date | null = null;\n\n  // Room versions\n  #roomVersionsLastRequestedAtByRoom = new Map<RoomId, Date>();\n\n  // Notification Settings\n  #notificationSettings: SinglePageResource;\n\n  constructor(client: OpaqueClient) {\n    this.#client = client[kInternal].as<TM, CM>();\n\n    this.optimisticUpdates = createStore_forOptimistic<TM, CM>(this.#client);\n    this.permissionHints = createStore_forPermissionHints();\n\n    const notificationSettingsFetcher = async (): Promise<void> => {\n      const result = await this.#client.getNotificationSettings();\n      this.notificationSettings.update(result);\n    };\n\n    this.notificationSettings = createStore_forNotificationSettings(\n      this.optimisticUpdates.signal\n    );\n\n    this.#notificationSettings = new SinglePageResource(\n      notificationSettingsFetcher\n    );\n\n    this.threads = new ThreadDB();\n\n    this.subscriptions = createStore_forSubscriptions(\n      this.optimisticUpdates.signal,\n      this.threads\n    );\n\n    this.notifications = createStore_forNotifications();\n    this.roomSubscriptionSettings = createStore_forRoomSubscriptionSettings(\n      this.optimisticUpdates.signal\n    );\n    this.historyVersions = createStore_forHistoryVersions();\n    this.unreadNotificationsCount = createStore_forUnreadNotificationsCount();\n    this.urlsMetadata = createStore_forUrlsMetadata();\n\n    const threadifications = DerivedSignal.from(\n      this.threads.signal,\n      this.notifications.signal,\n      this.optimisticUpdates.signal,\n      (ts, ns, updates) =>\n        applyOptimisticUpdates_forThreadifications(ts, ns, updates)\n    );\n\n    const threads = DerivedSignal.from(threadifications, (s) => s.threadsDB);\n\n    const notifications = DerivedSignal.from(\n      threadifications,\n      (s) => ({\n        sortedNotifications: s.sortedNotifications,\n        notificationsById: s.notificationsById,\n      }),\n      shallow\n    );\n\n    const threadSubscriptions = DerivedSignal.from(\n      notifications,\n      this.subscriptions.signal,\n      (n, s) => ({\n        subscriptions: s,\n        notifications: n.sortedNotifications,\n      })\n    );\n\n    const loadingUserThreads = new DefaultMap(\n      (\n        queryKey: UserQueryKey\n      ): LoadableResource<ThreadsAsyncResult<TM, CM>> => {\n        const query = JSON.parse(queryKey) as ThreadsQuery<TM>;\n\n        const resource = new PaginatedResource(async (cursor?: string) => {\n          const result = await this.#client[\n            kInternal\n          ].httpClient.getUserThreads_experimental({\n            cursor,\n            query,\n          });\n          this.updateThreadifications(\n            result.threads,\n            result.inboxNotifications,\n            result.subscriptions\n          );\n\n          this.permissionHints.update(result.permissionHints);\n\n          // We initialize the `_userThreadsLastRequestedAt` date using the server timestamp after we've loaded the first page of inbox notifications.\n          if (this.#userThreadsLastRequestedAt === null) {\n            this.#userThreadsLastRequestedAt = result.requestedAt;\n          }\n\n          return result.nextCursor;\n        });\n\n        const signal = DerivedSignal.from((): ThreadsAsyncResult<TM, CM> => {\n          const result = resource.get();\n          if (result.isLoading || result.error) {\n            return result;\n          }\n\n          const subscriptions = threadSubscriptions.get().subscriptions;\n\n          const threads = this.outputs.threads.get().findMany(\n            undefined, // Do _not_ filter by roomId\n            query ?? {},\n            \"desc\",\n            subscriptions\n          );\n\n          const page = result.data;\n          return {\n            isLoading: false,\n            threads,\n            hasFetchedAll: page.hasFetchedAll,\n            isFetchingMore: page.isFetchingMore,\n            fetchMoreError: page.fetchMoreError,\n            fetchMore: page.fetchMore,\n          };\n        }, shallow2);\n\n        return { signal, waitUntilLoaded: resource.waitUntilLoaded };\n      }\n    );\n\n    const loadingRoomThreads = new DefaultMap(\n      (\n        queryKey: RoomQueryKey\n      ): LoadableResource<ThreadsAsyncResult<TM, CM>> => {\n        const [roomId, query] = JSON.parse(queryKey) as [\n          roomId: RoomId,\n          query: ThreadsQuery<TM>,\n        ];\n\n        const resource = new PaginatedResource(async (cursor?: string) => {\n          const result = await this.#client[kInternal].httpClient.getThreads({\n            roomId,\n            cursor,\n            query,\n          });\n          this.updateThreadifications(\n            result.threads,\n            result.inboxNotifications,\n            result.subscriptions\n          );\n\n          this.permissionHints.update(result.permissionHints);\n\n          const lastRequestedAt =\n            this.#roomThreadsLastRequestedAtByRoom.get(roomId);\n\n          /**\n           * We set the `lastRequestedAt` value for the room to the timestamp returned by the current request if:\n           * 1. The `lastRequestedAt` value for the room has not been set\n           * OR\n           * 2. The `lastRequestedAt` value for the room is older than the timestamp returned by the current request\n           */\n          if (\n            lastRequestedAt === undefined ||\n            lastRequestedAt > result.requestedAt\n          ) {\n            this.#roomThreadsLastRequestedAtByRoom.set(\n              roomId,\n              result.requestedAt\n            );\n          }\n\n          return result.nextCursor;\n        });\n\n        const signal = DerivedSignal.from((): ThreadsAsyncResult<TM, CM> => {\n          const result = resource.get();\n          if (result.isLoading || result.error) {\n            return result;\n          }\n\n          const subscriptions = threadSubscriptions.get().subscriptions;\n\n          const threads = this.outputs.threads\n            .get()\n            .findMany(roomId, query ?? {}, \"asc\", subscriptions);\n\n          const page = result.data;\n          return {\n            isLoading: false,\n            threads,\n            hasFetchedAll: page.hasFetchedAll,\n            isFetchingMore: page.isFetchingMore,\n            fetchMoreError: page.fetchMoreError,\n            fetchMore: page.fetchMore,\n          };\n        }, shallow2);\n\n        return { signal, waitUntilLoaded: resource.waitUntilLoaded };\n      }\n    );\n\n    const loadingNotifications = new DefaultMap(\n      (\n        queryKey: InboxNotificationsQueryKey\n      ): LoadableResource<InboxNotificationsAsyncResult> => {\n        const query = JSON.parse(queryKey) as InboxNotificationsQuery;\n\n        const resource = new PaginatedResource(async (cursor?: string) => {\n          const result = await this.#client.getInboxNotifications({\n            cursor,\n            query,\n          });\n\n          this.updateThreadifications(\n            result.threads,\n            result.inboxNotifications,\n            result.subscriptions\n          );\n\n          // We initialize the `_lastRequestedNotificationsAt` date using the server timestamp after we've loaded the first page of inbox notifications.\n          if (this.#notificationsLastRequestedAt === null) {\n            this.#notificationsLastRequestedAt = result.requestedAt;\n          }\n\n          const nextCursor = result.nextCursor;\n          return nextCursor;\n        });\n\n        const signal = DerivedSignal.from((): InboxNotificationsAsyncResult => {\n          const result = resource.get();\n          if (result.isLoading || result.error) {\n            return result;\n          }\n\n          const crit: ((\n            inboxNotification: InboxNotificationData\n          ) => boolean)[] = [];\n\n          if (query !== undefined) {\n            crit.push(makeInboxNotificationsFilter(query));\n          }\n          const inboxNotifications = this.outputs.notifications\n            .get()\n            .sortedNotifications.filter((inboxNotification) =>\n              crit.every((pred) => pred(inboxNotification))\n            );\n\n          const page = result.data;\n          return {\n            isLoading: false,\n            inboxNotifications,\n            hasFetchedAll: page.hasFetchedAll,\n            isFetchingMore: page.isFetchingMore,\n            fetchMoreError: page.fetchMoreError,\n            fetchMore: page.fetchMore,\n          };\n        }, shallow2);\n\n        return {\n          signal,\n          waitUntilLoaded: resource.waitUntilLoaded,\n        };\n      }\n    );\n\n    const unreadNotificationsCount = new DefaultMap(\n      (\n        queryKey: InboxNotificationsQueryKey\n      ): LoadableResource<UnreadInboxNotificationsCountAsyncResult> => {\n        const query = JSON.parse(queryKey) as InboxNotificationsQuery;\n\n        const resource = new SinglePageResource(async () => {\n          const result = await this.#client.getUnreadInboxNotificationsCount({\n            query,\n          });\n\n          this.unreadNotificationsCount.update(queryKey, result);\n        });\n\n        const signal = DerivedSignal.from(\n          (): UnreadInboxNotificationsCountAsyncResult => {\n            const result = resource.get();\n            if (result.isLoading || result.error) {\n              return result;\n            } else {\n              return ASYNC_OK(\n                \"count\",\n                nn(this.unreadNotificationsCount.signal.get()[queryKey])\n              );\n            }\n          },\n          shallow\n        );\n\n        return {\n          signal,\n          waitUntilLoaded: resource.waitUntilLoaded,\n        };\n      }\n    );\n\n    const roomSubscriptionSettingsByRoomId = new DefaultMap(\n      (roomId: RoomId) => {\n        const resource = new SinglePageResource(async () => {\n          const room = this.#client.getRoom(roomId);\n          if (room === null) {\n            throw new Error(`Room '${roomId}' is not available on client`);\n          }\n\n          const result = await room.getSubscriptionSettings();\n          this.roomSubscriptionSettings.update(roomId, result);\n        });\n\n        const signal = DerivedSignal.from(() => {\n          const result = resource.get();\n          if (result.isLoading || result.error) {\n            return result;\n          } else {\n            return ASYNC_OK(\n              \"settings\",\n              nn(this.roomSubscriptionSettings.signal.get()[roomId])\n            );\n          }\n        }, shallow);\n\n        return { signal, waitUntilLoaded: resource.waitUntilLoaded };\n      }\n    );\n\n    const versionsByRoomId = new DefaultMap(\n      (roomId: RoomId): LoadableResource<HistoryVersionsAsyncResult> => {\n        const resource = new SinglePageResource(async () => {\n          const room = this.#client.getRoom(roomId);\n          if (room === null) {\n            throw new Error(`Room '${roomId}' is not available on client`);\n          }\n\n          const result = await room[kInternal].listTextVersions();\n          this.historyVersions.update(roomId, result.versions);\n\n          const lastRequestedAt =\n            this.#roomVersionsLastRequestedAtByRoom.get(roomId);\n\n          if (\n            lastRequestedAt === undefined ||\n            lastRequestedAt > result.requestedAt\n          ) {\n            this.#roomVersionsLastRequestedAtByRoom.set(\n              roomId,\n              result.requestedAt\n            );\n          }\n        });\n\n        const signal = DerivedSignal.from((): HistoryVersionsAsyncResult => {\n          const result = resource.get();\n          if (result.isLoading || result.error) {\n            return result;\n          } else {\n            return ASYNC_OK(\n              \"versions\",\n              Object.values(this.historyVersions.signal.get()[roomId] ?? {})\n            );\n          }\n        }, shallow);\n\n        return { signal, waitUntilLoaded: resource.waitUntilLoaded };\n      }\n    );\n\n    const notificationSettings: LoadableResource<NotificationSettingsAsyncResult> =\n      {\n        signal: DerivedSignal.from((): NotificationSettingsAsyncResult => {\n          const result = this.#notificationSettings.get();\n          if (result.isLoading || result.error) {\n            return result;\n          }\n\n          return ASYNC_OK(\n            \"settings\",\n            nn(this.notificationSettings.signal.get())\n          );\n        }, shallow),\n        waitUntilLoaded: this.#notificationSettings.waitUntilLoaded,\n      };\n\n    const aiChats = new DefaultMap(\n      (queryKey: AiChatsQueryKey): LoadableResource<AiChatsAsyncResult> => {\n        const query = JSON.parse(queryKey) as AiChatsQuery;\n        const resource = new PaginatedResource(async (cursor?: string) => {\n          const result = await this.#client[kInternal].ai.getChats({\n            cursor: cursor as Cursor,\n            query,\n          });\n          return result.nextCursor;\n        });\n\n        const signal = DerivedSignal.from((): AiChatsAsyncResult => {\n          const result = resource.get();\n          if (result.isLoading || result.error) {\n            return result;\n          }\n\n          const chats = this.#client[kInternal].ai.queryChats(query);\n\n          return {\n            isLoading: false,\n            chats,\n            hasFetchedAll: result.data.hasFetchedAll,\n            isFetchingMore: result.data.isFetchingMore,\n            fetchMore: result.data.fetchMore,\n            fetchMoreError: result.data.fetchMoreError,\n          };\n        }, shallow);\n\n        return { signal, waitUntilLoaded: resource.waitUntilLoaded };\n      }\n    );\n\n    const messagesByChatId = new DefaultMap((chatId: string) => {\n      const resource = new SinglePageResource(async () => {\n        await this.#client[kInternal].ai.getMessageTree(chatId);\n      });\n\n      return new DefaultMap(\n        (\n          branch: MessageId | null\n        ): LoadableResource<AiChatMessagesAsyncResult> => {\n          const signal = DerivedSignal.from((): AiChatMessagesAsyncResult => {\n            const result = resource.get();\n            if (result.isLoading || result.error) {\n              return result;\n            }\n\n            return ASYNC_OK(\n              \"messages\",\n              this.#client[kInternal].ai.signals\n                .getChatMessagesForBranch(chatId, branch ?? undefined)\n                .get()\n            );\n          });\n\n          return { signal, waitUntilLoaded: resource.waitUntilLoaded };\n        }\n      );\n    });\n\n    const aiChatById = new DefaultMap((chatId: string) => {\n      const resource = new SinglePageResource(async () => {\n        await this.#client[kInternal].ai.getOrCreateChat(chatId);\n      });\n\n      const signal = DerivedSignal.from(() => {\n        const chat = this.#client[kInternal].ai.getChatById(chatId);\n        if (chat === undefined) {\n          const result = resource.get();\n          if (result.isLoading || result.error) {\n            return result;\n          } else {\n            return ASYNC_OK(\n              \"chat\",\n              nn(this.#client[kInternal].ai.getChatById(chatId))\n            );\n          }\n        } else {\n          return ASYNC_OK(\n            \"chat\",\n            nn(this.#client[kInternal].ai.getChatById(chatId))\n          );\n        }\n      }, shallow);\n\n      return { signal, waitUntilLoaded: resource.waitUntilLoaded };\n    });\n\n    const urlMetadataByUrl = new DefaultMap(\n      (url: string): LoadableResource<UrlMetadataAsyncResult> => {\n        const resource = new SinglePageResource(async () => {\n          const metadata =\n            await this.#client[kInternal].httpClient.getUrlMetadata(url);\n          this.urlsMetadata.update(url, metadata);\n        }, false);\n\n        const signal = DerivedSignal.from((): UrlMetadataAsyncResult => {\n          const result = resource.get();\n          if (result.isLoading || result.error) {\n            return result;\n          }\n\n          return ASYNC_OK(\"metadata\", nn(this.urlsMetadata.signal.get()[url]));\n        }, shallow);\n\n        return { signal, waitUntilLoaded: resource.waitUntilLoaded };\n      }\n    );\n\n    this.outputs = {\n      threadifications,\n      threads,\n      loadingRoomThreads,\n      loadingUserThreads,\n      notifications,\n      loadingNotifications,\n      unreadNotificationsCount,\n      roomSubscriptionSettingsByRoomId,\n      versionsByRoomId,\n      notificationSettings,\n      threadSubscriptions,\n      aiChats,\n      messagesByChatId,\n      aiChatById,\n      urlMetadataByUrl,\n    };\n\n    // Auto-bind all of this class' methods here, so we can use stable\n    // references to them (most important for use in useSyncExternalStore)\n    autobind(this);\n  }\n\n  /**\n   * Updates an existing inbox notification with a new value, replacing the\n   * corresponding optimistic update.\n   *\n   * This will not update anything if the inbox notification ID isn't found.\n   */\n  public markInboxNotificationRead(\n    inboxNotificationId: string,\n    readAt: Date,\n    optimisticId: string\n  ): void {\n    batch(() => {\n      this.optimisticUpdates.remove(optimisticId);\n      this.notifications.markRead(inboxNotificationId, readAt);\n    });\n  }\n\n  public markAllInboxNotificationsRead(\n    optimisticId: string,\n    readAt: Date\n  ): void {\n    batch(() => {\n      this.optimisticUpdates.remove(optimisticId);\n      this.notifications.markAllRead(readAt);\n    });\n  }\n\n  /**\n   * Deletes an existing inbox notification, replacing the corresponding\n   * optimistic update.\n   */\n  public deleteInboxNotification(\n    inboxNotificationId: string,\n    optimisticId: string\n  ): void {\n    batch(() => {\n      this.optimisticUpdates.remove(optimisticId);\n      this.notifications.delete(inboxNotificationId);\n    });\n  }\n\n  /**\n   * Deletes *all* inbox notifications, replacing the corresponding optimistic\n   * update.\n   */\n  public deleteAllInboxNotifications(optimisticId: string): void {\n    batch(() => {\n      this.optimisticUpdates.remove(optimisticId);\n      this.notifications.clear();\n    });\n  }\n\n  /**\n   * Creates an existing subscription, replacing the corresponding\n   * optimistic update.\n   */\n  public createSubscription(\n    subscription: SubscriptionData,\n    optimisticId: string\n  ): void {\n    batch(() => {\n      this.optimisticUpdates.remove(optimisticId);\n      this.subscriptions.create(subscription);\n    });\n  }\n\n  /**\n   * Deletes an existing subscription, replacing the corresponding\n   * optimistic update.\n   */\n  public deleteSubscription(\n    subscriptionKey: SubscriptionKey,\n    optimisticId: string\n  ): void {\n    batch(() => {\n      this.optimisticUpdates.remove(optimisticId);\n      this.subscriptions.delete(subscriptionKey);\n    });\n  }\n\n  /**\n   * Creates an new thread, replacing the corresponding optimistic update.\n   */\n  public createThread(\n    optimisticId: string,\n    thread: Readonly<ThreadDataWithDeleteInfo<TM, CM>>\n  ): void {\n    batch(() => {\n      this.optimisticUpdates.remove(optimisticId);\n      this.threads.upsert(thread);\n    });\n  }\n\n  /**\n   * Updates an existing thread with a new value, replacing the corresponding\n   * optimistic update.\n   *\n   * This will not update anything if:\n   * - The thread ID isn't found; or\n   * - The thread ID was already deleted; or\n   * - The thread ID was updated more recently than the optimistic update's\n   *   timestamp (if given)\n   */\n  #updateThread(\n    threadId: string,\n    optimisticId: string | null,\n    callback: (\n      thread: Readonly<ThreadDataWithDeleteInfo<TM, CM>>\n    ) => Readonly<ThreadDataWithDeleteInfo<TM, CM>>,\n    updatedAt?: Date // TODO We could look this up from the optimisticUpdate instead?\n  ): void {\n    batch(() => {\n      if (optimisticId !== null) {\n        this.optimisticUpdates.remove(optimisticId);\n      }\n\n      const db = this.threads;\n      const existing = db.get(threadId);\n      if (!existing) return;\n      if (!!updatedAt && existing.updatedAt > updatedAt) return;\n      db.upsert(callback(existing));\n    });\n  }\n\n  public patchThread(\n    threadId: string,\n    optimisticId: string | null,\n    patch: {\n      // Only these fields are currently supported to patch\n      metadata?: TM;\n      resolved?: boolean;\n    },\n    updatedAt: Date // TODO We could look this up from the optimisticUpdate instead?\n  ): void {\n    return this.#updateThread(\n      threadId,\n      optimisticId,\n      (thread) => ({ ...thread, ...compactObject(patch) }),\n      updatedAt\n    );\n  }\n\n  public addReaction(\n    threadId: string,\n    optimisticId: string | null,\n    commentId: string,\n    reaction: CommentUserReaction,\n    createdAt: Date // TODO We could look this up from the optimisticUpdate instead?\n  ): void {\n    this.#updateThread(\n      threadId,\n      optimisticId,\n      (thread) => applyAddReaction(thread, commentId, reaction),\n      createdAt\n    );\n  }\n\n  public removeReaction(\n    threadId: string,\n    optimisticId: string | null,\n    commentId: string,\n    emoji: string,\n    userId: string,\n    removedAt: Date\n  ): void {\n    this.#updateThread(\n      threadId,\n      optimisticId,\n      (thread) =>\n        applyRemoveReaction(thread, commentId, emoji, userId, removedAt),\n      removedAt\n    );\n  }\n\n  /**\n   * Soft-deletes an existing thread by setting its `deletedAt` value,\n   * replacing the corresponding optimistic update.\n   *\n   * This will not update anything if:\n   * - The thread ID isn't found; or\n   * - The thread ID was already deleted\n   */\n  public deleteThread(threadId: string, optimisticId: string | null): void {\n    return this.#updateThread(\n      threadId,\n      optimisticId,\n\n      // A deletion is actually an update of the deletedAt property internally\n      (thread) => ({ ...thread, updatedAt: new Date(), deletedAt: new Date() })\n    );\n  }\n\n  /**\n   * Creates an existing comment and ensures the associated notification is\n   * updated correctly, replacing the corresponding optimistic update.\n   */\n  public createComment(\n    newComment: CommentData<CM>,\n    optimisticId: string\n  ): void {\n    // Batch 1 + 2 + 3\n    batch(() => {\n      // 1\n      this.optimisticUpdates.remove(optimisticId);\n\n      // If the associated thread is not found, we cannot create a comment under it\n      const existingThread = this.threads.get(newComment.threadId);\n      if (!existingThread) {\n        return;\n      }\n\n      // 2 Update the thread instance by adding a comment under it\n      this.threads.upsert(applyUpsertComment(existingThread, newComment));\n\n      // 3 Update the associated inbox notification (if any)\n      this.notifications.updateAssociatedNotification(newComment);\n    });\n  }\n\n  public editComment(\n    threadId: string,\n    optimisticId: string,\n    editedComment: CommentData<CM>\n  ): void {\n    return this.#updateThread(threadId, optimisticId, (thread) =>\n      applyUpsertComment(thread, editedComment)\n    );\n  }\n\n  public editCommentMetadata(\n    threadId: string,\n    commentId: string,\n    optimisticId: string,\n    updatedMetadata: CM,\n    updatedAt: Date\n  ): void {\n    return this.#updateThread(\n      threadId,\n      optimisticId,\n      (thread) => {\n        const comment = thread.comments.find((c) => c.id === commentId);\n        if (comment === undefined) {\n          return thread;\n        }\n        return {\n          ...thread,\n          updatedAt,\n          comments: thread.comments.map((c) =>\n            c.id === commentId ? { ...c, metadata: updatedMetadata } : c\n          ),\n        };\n      },\n      updatedAt\n    );\n  }\n\n  public deleteComment(\n    threadId: string,\n    optimisticId: string,\n    commentId: string,\n    deletedAt: Date\n  ): void {\n    return this.#updateThread(\n      threadId,\n      optimisticId,\n      (thread) => applyDeleteComment(thread, commentId, deletedAt),\n      deletedAt\n    );\n  }\n\n  public updateThreadifications(\n    threads: ThreadData<TM, CM>[],\n    notifications: InboxNotificationData[],\n    subscriptions: SubscriptionData[],\n    deletedThreads: ThreadDeleteInfo[] = [],\n    deletedNotifications: InboxNotificationDeleteInfo[] = [],\n    deletedSubscriptions: SubscriptionDeleteInfo[] = []\n  ): void {\n    batch(() => {\n      this.threads.applyDelta(threads, deletedThreads);\n      this.notifications.applyDelta(notifications, deletedNotifications);\n      this.subscriptions.applyDelta(subscriptions, deletedSubscriptions);\n    });\n  }\n\n  /**\n   * Updates existing subscription settings for a room with a new value,\n   * replacing the corresponding optimistic update.\n   */\n  public updateRoomSubscriptionSettings(\n    roomId: string,\n    optimisticId: string,\n    settings: Readonly<RoomSubscriptionSettings>\n  ): void {\n    batch(() => {\n      this.optimisticUpdates.remove(optimisticId);\n      this.roomSubscriptionSettings.update(roomId, settings);\n    });\n  }\n\n  public async fetchNotificationsDeltaUpdate(signal: AbortSignal) {\n    const lastRequestedAt = this.#notificationsLastRequestedAt;\n    if (lastRequestedAt === null) {\n      return;\n    }\n\n    const result = await this.#client.getInboxNotificationsSince({\n      since: lastRequestedAt,\n      signal,\n    });\n\n    if (lastRequestedAt < result.requestedAt) {\n      this.#notificationsLastRequestedAt = result.requestedAt;\n    }\n\n    this.updateThreadifications(\n      result.threads.updated,\n      result.inboxNotifications.updated,\n      result.subscriptions.updated,\n      result.threads.deleted,\n      result.inboxNotifications.deleted,\n      result.subscriptions.deleted\n    );\n  }\n\n  public async fetchUnreadNotificationsCount(\n    queryKey: InboxNotificationsQueryKey,\n    signal: AbortSignal\n  ) {\n    const query = JSON.parse(queryKey) as InboxNotificationsQuery;\n\n    const result = await this.#client.getUnreadInboxNotificationsCount({\n      query,\n      signal,\n    });\n\n    this.unreadNotificationsCount.update(queryKey, result);\n  }\n\n  public async fetchRoomThreadsDeltaUpdate(\n    roomId: string,\n    signal: AbortSignal\n  ) {\n    const lastRequestedAt = this.#roomThreadsLastRequestedAtByRoom.get(roomId);\n    if (lastRequestedAt === undefined) {\n      return;\n    }\n\n    const updates = await this.#client[kInternal].httpClient.getThreadsSince({\n      roomId,\n      since: lastRequestedAt,\n      signal,\n    });\n\n    this.updateThreadifications(\n      updates.threads.updated,\n      updates.inboxNotifications.updated,\n      updates.subscriptions.updated,\n      updates.threads.deleted,\n      updates.inboxNotifications.deleted,\n      updates.subscriptions.deleted\n    );\n\n    this.permissionHints.update(updates.permissionHints);\n\n    if (lastRequestedAt < updates.requestedAt) {\n      // Update the `lastRequestedAt` value for the room to the timestamp returned by the current request\n      this.#roomThreadsLastRequestedAtByRoom.set(roomId, updates.requestedAt);\n    }\n  }\n\n  public async fetchUserThreadsDeltaUpdate(signal: AbortSignal) {\n    const lastRequestedAt = this.#userThreadsLastRequestedAt;\n    if (lastRequestedAt === null) {\n      return;\n    }\n\n    const result = await this.#client[\n      kInternal\n    ].httpClient.getUserThreadsSince_experimental({\n      since: lastRequestedAt,\n      signal,\n    });\n\n    if (lastRequestedAt < result.requestedAt) {\n      this.#notificationsLastRequestedAt = result.requestedAt;\n    }\n\n    this.updateThreadifications(\n      result.threads.updated,\n      result.inboxNotifications.updated,\n      result.subscriptions.updated,\n      result.threads.deleted,\n      result.inboxNotifications.deleted,\n      result.subscriptions.deleted\n    );\n\n    this.permissionHints.update(result.permissionHints);\n  }\n\n  public async fetchRoomVersionsDeltaUpdate(\n    roomId: string,\n    signal: AbortSignal\n  ) {\n    const lastRequestedAt = this.#roomVersionsLastRequestedAtByRoom.get(roomId);\n    if (lastRequestedAt === undefined) {\n      return;\n    }\n\n    const room = nn(\n      this.#client.getRoom(roomId),\n      `Room with id ${roomId} is not available on client`\n    );\n\n    const updates = await room[kInternal].listTextVersionsSince({\n      since: lastRequestedAt,\n      signal,\n    });\n\n    this.historyVersions.update(roomId, updates.versions);\n\n    if (lastRequestedAt < updates.requestedAt) {\n      // Update the `lastRequestedAt` value for the room to the timestamp returned by the current request\n      this.#roomVersionsLastRequestedAtByRoom.set(roomId, updates.requestedAt);\n    }\n  }\n\n  public async refreshRoomSubscriptionSettings(\n    roomId: string,\n    signal: AbortSignal\n  ) {\n    const room = nn(\n      this.#client.getRoom(roomId),\n      `Room with id ${roomId} is not available on client`\n    );\n    const result = await room.getSubscriptionSettings({ signal });\n    this.roomSubscriptionSettings.update(roomId, result);\n  }\n\n  /**\n   * Refresh notification settings from poller\n   */\n  public async refreshNotificationSettings(signal: AbortSignal) {\n    const result = await this.#client.getNotificationSettings({\n      signal,\n    });\n    this.notificationSettings.update(result);\n  }\n\n  /**\n   * Updates notification settings with a new value, replacing the\n   * corresponding optimistic update.\n   */\n  public updateNotificationSettings_confirmOptimisticUpdate(\n    settings: NotificationSettings,\n    optimisticUpdateId: string\n  ): void {\n    // Batch 1 + 2\n    batch(() => {\n      this.optimisticUpdates.remove(optimisticUpdateId); // 1\n      this.notificationSettings.update(settings); // 2\n    });\n  }\n}\n\n/**\n * Applies optimistic updates, removes deleted threads, sorts results in\n * a stable way, removes internal fields that should not be exposed publicly.\n */\nfunction applyOptimisticUpdates_forThreadifications<\n  TM extends BaseMetadata,\n  CM extends BaseMetadata,\n>(\n  baseThreadsDB: ThreadDB<TM, CM>,\n  notificationsLUT: NotificationsLUT,\n  optimisticUpdates: readonly OptimisticUpdate<TM, CM>[]\n): CleanThreadifications<TM, CM> {\n  const threadsDB = baseThreadsDB.clone();\n  let notificationsById = Object.fromEntries(notificationsLUT);\n\n  for (const optimisticUpdate of optimisticUpdates) {\n    switch (optimisticUpdate.type) {\n      case \"create-thread\": {\n        threadsDB.upsert(optimisticUpdate.thread);\n        break;\n      }\n\n      case \"edit-thread-metadata\": {\n        const thread = threadsDB.get(optimisticUpdate.threadId);\n        if (thread === undefined) break;\n\n        // If the thread has been updated since the optimistic update, we do not apply the update\n        if (thread.updatedAt > optimisticUpdate.updatedAt) {\n          break;\n        }\n\n        threadsDB.upsert({\n          ...thread,\n          updatedAt: optimisticUpdate.updatedAt,\n          metadata: {\n            ...thread.metadata,\n            ...optimisticUpdate.metadata,\n          },\n        });\n        break;\n      }\n\n      case \"mark-thread-as-resolved\": {\n        const thread = threadsDB.get(optimisticUpdate.threadId);\n        if (thread === undefined) break;\n\n        threadsDB.upsert({ ...thread, resolved: true });\n        break;\n      }\n\n      case \"mark-thread-as-unresolved\": {\n        const thread = threadsDB.get(optimisticUpdate.threadId);\n        if (thread === undefined) break;\n\n        threadsDB.upsert({ ...thread, resolved: false });\n        break;\n      }\n\n      case \"create-comment\": {\n        const thread = threadsDB.get(optimisticUpdate.comment.threadId);\n        if (thread === undefined) break;\n\n        threadsDB.upsert(applyUpsertComment(thread, optimisticUpdate.comment));\n\n        const inboxNotification = Object.values(notificationsById).find(\n          (notification) =>\n            notification.kind === \"thread\" &&\n            notification.threadId === thread.id\n        );\n\n        if (inboxNotification === undefined) {\n          break;\n        }\n\n        notificationsById[inboxNotification.id] = {\n          ...inboxNotification,\n          notifiedAt: optimisticUpdate.comment.createdAt,\n          readAt: optimisticUpdate.comment.createdAt,\n        };\n\n        break;\n      }\n\n      case \"edit-comment\": {\n        const thread = threadsDB.get(optimisticUpdate.comment.threadId);\n        if (thread === undefined) break;\n\n        threadsDB.upsert(applyUpsertComment(thread, optimisticUpdate.comment));\n        break;\n      }\n\n      case \"edit-comment-metadata\": {\n        const thread = threadsDB.get(optimisticUpdate.threadId);\n        if (thread === undefined) break;\n\n        // If the thread has been updated since the optimistic update, we do not apply the update\n        if (thread.updatedAt > optimisticUpdate.updatedAt) {\n          break;\n        }\n\n        const existingComment = thread.comments.find(\n          (c) => c.id === optimisticUpdate.commentId\n        );\n        if (existingComment === undefined) break;\n\n        threadsDB.upsert(\n          applyUpsertComment(thread, {\n            ...existingComment,\n            metadata: {\n              ...existingComment.metadata,\n              ...optimisticUpdate.metadata,\n            },\n          })\n        );\n        break;\n      }\n\n      case \"delete-comment\": {\n        const thread = threadsDB.get(optimisticUpdate.threadId);\n        if (thread === undefined) break;\n\n        threadsDB.upsert(\n          applyDeleteComment(\n            thread,\n            optimisticUpdate.commentId,\n            optimisticUpdate.deletedAt\n          )\n        );\n        break;\n      }\n\n      case \"delete-thread\": {\n        const thread = threadsDB.get(optimisticUpdate.threadId);\n        if (thread === undefined) break;\n\n        threadsDB.upsert({\n          ...thread,\n          deletedAt: optimisticUpdate.deletedAt,\n          updatedAt: optimisticUpdate.deletedAt,\n          comments: [],\n        });\n        break;\n      }\n\n      case \"add-reaction\": {\n        const thread = threadsDB.get(optimisticUpdate.threadId);\n        if (thread === undefined) break;\n\n        threadsDB.upsert(\n          applyAddReaction(\n            thread,\n            optimisticUpdate.commentId,\n            optimisticUpdate.reaction\n          )\n        );\n        break;\n      }\n\n      case \"remove-reaction\": {\n        const thread = threadsDB.get(optimisticUpdate.threadId);\n        if (thread === undefined) break;\n\n        threadsDB.upsert(\n          applyRemoveReaction(\n            thread,\n            optimisticUpdate.commentId,\n            optimisticUpdate.emoji,\n            optimisticUpdate.userId,\n            optimisticUpdate.removedAt\n          )\n        );\n        break;\n      }\n\n      case \"mark-inbox-notification-as-read\": {\n        const ibn = notificationsById[optimisticUpdate.inboxNotificationId];\n\n        // If the inbox notification doesn't exist, we do not apply the update\n        if (ibn === undefined) {\n          break;\n        }\n\n        notificationsById[optimisticUpdate.inboxNotificationId] = {\n          ...ibn,\n          readAt: optimisticUpdate.readAt,\n        };\n        break;\n      }\n      case \"mark-all-inbox-notifications-as-read\": {\n        for (const id in notificationsById) {\n          const ibn = notificationsById[id];\n\n          // If the inbox notification doesn't exist, we do not apply the update\n          if (ibn === undefined) {\n            break;\n          }\n\n          notificationsById[id] = {\n            ...ibn,\n            readAt: optimisticUpdate.readAt,\n          };\n        }\n        break;\n      }\n      case \"delete-inbox-notification\": {\n        delete notificationsById[optimisticUpdate.inboxNotificationId];\n        break;\n      }\n      case \"delete-all-inbox-notifications\": {\n        notificationsById = {};\n        break;\n      }\n    }\n  }\n\n  // TODO Maybe consider also removing these from the inboxNotificationsById registry?\n  const sortedNotifications =\n    // Sort so that the most recent notifications are first\n    Object.values(notificationsById)\n      .filter((ibn) =>\n        ibn.kind === \"thread\" ? threadsDB.get(ibn.threadId) !== undefined : true\n      )\n      .sort((a, b) => b.notifiedAt.getTime() - a.notifiedAt.getTime());\n\n  return {\n    sortedNotifications,\n    notificationsById,\n    threadsDB,\n  };\n}\n\n/**\n * Applies optimistic updates to room subscription settings in a stable way.\n */\nfunction applyOptimisticUpdates_forRoomSubscriptionSettings(\n  settingsLUT: RoomSubscriptionSettingsLUT,\n  optimisticUpdates: readonly OptimisticUpdate<BaseMetadata, BaseMetadata>[]\n): RoomSubscriptionSettingsByRoomId {\n  const roomSubscriptionSettingsByRoomId = Object.fromEntries(settingsLUT);\n\n  for (const optimisticUpdate of optimisticUpdates) {\n    switch (optimisticUpdate.type) {\n      case \"update-room-subscription-settings\": {\n        const settings =\n          roomSubscriptionSettingsByRoomId[optimisticUpdate.roomId];\n\n        // If the settings don't exist, we do not apply the update\n        if (settings === undefined) {\n          break;\n        }\n\n        roomSubscriptionSettingsByRoomId[optimisticUpdate.roomId] = {\n          ...settings,\n          ...optimisticUpdate.settings,\n        };\n      }\n    }\n  }\n  return roomSubscriptionSettingsByRoomId;\n}\n\n/**\n * Applies optimistic updates to subscriptions in a stable way.\n */\nfunction applyOptimisticUpdates_forSubscriptions(\n  subscriptionsLUT: SubscriptionsLUT,\n  threads: ReadonlyThreadDB<BaseMetadata, BaseMetadata>,\n  optimisticUpdates: readonly OptimisticUpdate<BaseMetadata, BaseMetadata>[]\n): SubscriptionsByKey {\n  const subscriptions = Object.fromEntries(subscriptionsLUT);\n\n  for (const update of optimisticUpdates) {\n    switch (update.type) {\n      case \"update-room-subscription-settings\": {\n        // Other room subscription settings don't affect optimistic updates at the moment\n        if (!update.settings.threads) {\n          continue;\n        }\n\n        const roomThreads = threads.findMany(\n          update.roomId,\n          undefined,\n          \"desc\",\n          undefined\n        );\n\n        for (const thread of roomThreads) {\n          const subscriptionKey = getSubscriptionKey(\"thread\", thread.id);\n\n          switch (update.settings.threads) {\n            // Create subscriptions for all existing threads in the room\n            case \"all\": {\n              subscriptions[subscriptionKey] = {\n                kind: \"thread\",\n                subjectId: thread.id,\n                createdAt: new Date(),\n              };\n              break;\n            }\n\n            // Delete subscriptions for all existing threads in the room\n            case \"none\": {\n              delete subscriptions[subscriptionKey];\n              break;\n            }\n\n            case \"replies_and_mentions\": {\n              // TODO: We can't go through the comments and create subscriptions optimistically because\n              //       we might not have group members for all group IDs which means we can't reliably\n              //       know if the user was mentioned with a group mention.\n              break;\n            }\n\n            default:\n              assertNever(\n                update.settings.threads,\n                \"Unexpected thread subscription settings.\"\n              );\n          }\n        }\n      }\n\n      // TODO: We can't do the following pseudo-code yet because we don't have the room subscription settings\n      // in the umbrella store when `useRoomSubscriptionSettings` isn't used.\n      //\n      // case \"create-thread\":\n      // case \"create-comment\":\n      //  // Create a subscription (if it doesn't exist yet) for the thread optimistically, unless the `\"thread\"`\n      //  // room subscription settings for the user and the thread's room are set to `\"none\"`.\n    }\n  }\n\n  return subscriptions;\n}\n\n/**\n * Applies optimistic update to notification settings in a stable way.\n * It's a deep update, and remove potential `undefined` properties from the final\n * output object because we update with a deep partial of `NotificationSettings`.\n *\n * Exported for unit tests only.\n */\nexport function applyOptimisticUpdates_forNotificationSettings(\n  settings: NotificationSettings,\n  optimisticUpdates: readonly OptimisticUpdate<BaseMetadata, BaseMetadata>[]\n): NotificationSettings {\n  let outcoming: NotificationSettings = settings;\n\n  for (const update of optimisticUpdates) {\n    if (update.type === \"update-notification-settings\") {\n      outcoming = patchNotificationSettings(outcoming, update.settings);\n    }\n  }\n\n  return outcoming;\n}\n\n/**\n * Compares two inbox notifications to determine which one is newer.\n * @param inboxNotificationA The first inbox notification to compare.\n * @param inboxNotificationB The second inbox notification to compare.\n * @returns 1 if inboxNotificationA is newer, -1 if inboxNotificationB is newer, or 0 if they are the same age or can't be compared.\n */\nexport function compareInboxNotifications(\n  inboxNotificationA: InboxNotificationData,\n  inboxNotificationB: InboxNotificationData\n): number {\n  if (inboxNotificationA.notifiedAt > inboxNotificationB.notifiedAt) {\n    return 1;\n  } else if (inboxNotificationA.notifiedAt < inboxNotificationB.notifiedAt) {\n    return -1;\n  }\n\n  // notifiedAt times are the same, compare readAt times if both are not null\n  if (inboxNotificationA.readAt && inboxNotificationB.readAt) {\n    return inboxNotificationA.readAt > inboxNotificationB.readAt\n      ? 1\n      : inboxNotificationA.readAt < inboxNotificationB.readAt\n        ? -1\n        : 0;\n  } else if (inboxNotificationA.readAt || inboxNotificationB.readAt) {\n    return inboxNotificationA.readAt ? 1 : -1;\n  }\n\n  // If all dates are equal, return 0\n  return 0;\n}\n\n/** @internal Exported for unit tests only. */\nexport function applyUpsertComment<\n  TM extends BaseMetadata,\n  CM extends BaseMetadata,\n>(\n  thread: ThreadDataWithDeleteInfo<TM, CM>,\n  comment: CommentData<CM>\n): ThreadDataWithDeleteInfo<TM, CM> {\n  // If the thread has been deleted, we do not apply the update\n  if (thread.deletedAt !== undefined) {\n    // Note: only the unit tests are passing in deleted threads here. In all\n    // production code, this is never invoked for deleted threads.\n    return thread;\n  }\n\n  // Validate that the comment belongs to the thread\n  if (comment.threadId !== thread.id) {\n    console.warn(\n      `Comment ${comment.id} does not belong to thread ${thread.id}`\n    );\n    return thread;\n  }\n\n  const existingComment = thread.comments.find(\n    (existingComment) => existingComment.id === comment.id\n  );\n\n  // If the comment doesn't exist in the thread, add the comment\n  if (existingComment === undefined) {\n    const updatedAt = new Date(\n      Math.max(thread.updatedAt.getTime(), comment.createdAt.getTime())\n    );\n\n    const updatedThread = {\n      ...thread,\n      updatedAt,\n      comments: [...thread.comments, comment],\n    };\n\n    return updatedThread;\n  }\n\n  // If the comment exists in the thread and has been deleted, only update its metadata\n  if (existingComment.deletedAt !== undefined) {\n    const updatedComment = {\n      ...existingComment,\n      metadata: {\n        ...existingComment.metadata,\n        ...comment.metadata,\n      },\n    };\n\n    const updatedComments = thread.comments.map((c) =>\n      c.id === comment.id ? updatedComment : c\n    );\n\n    return {\n      ...thread,\n      comments: updatedComments,\n    };\n  }\n\n  // Proceed to update the comment if:\n  // 1. The existing comment has not been edited\n  // 2. The incoming comment has not been edited (i.e. it's a new comment)\n  // 3. The incoming comment has been edited more recently than the existing comment\n  if (\n    existingComment.editedAt === undefined ||\n    comment.editedAt === undefined ||\n    existingComment.editedAt <= comment.editedAt\n  ) {\n    const updatedComments = thread.comments.map((existingComment) =>\n      existingComment.id === comment.id ? comment : existingComment\n    );\n\n    const updatedThread = {\n      ...thread,\n      updatedAt: new Date(\n        Math.max(\n          thread.updatedAt.getTime(),\n          comment.editedAt?.getTime() || comment.createdAt.getTime()\n        )\n      ),\n      comments: updatedComments,\n    };\n    return updatedThread;\n  }\n\n  return thread;\n}\n\n/** @internal Exported for unit tests only. */\nexport function applyDeleteComment<\n  TM extends BaseMetadata,\n  CM extends BaseMetadata,\n>(\n  thread: ThreadDataWithDeleteInfo<TM, CM>,\n  commentId: string,\n  deletedAt: Date\n): ThreadDataWithDeleteInfo<TM, CM> {\n  // If the thread has been deleted, we do not delete the comment\n  if (thread.deletedAt !== undefined) {\n    return thread;\n  }\n\n  const existingComment = thread.comments.find(\n    (comment) => comment.id === commentId\n  );\n\n  // If the comment doesn't exist in the thread, we cannot perform the deletion\n  if (existingComment === undefined) {\n    return thread;\n  }\n\n  // If the comment has been deleted since the deletion request, we do not delete the comment\n  if (existingComment.deletedAt !== undefined) {\n    return thread;\n  }\n\n  const updatedComments = thread.comments.map((comment) =>\n    comment.id === commentId\n      ? {\n          ...comment,\n          deletedAt,\n          // We optimistically remove the comment body and attachments when marking it as deleted\n          body: undefined,\n          attachments: [],\n        }\n      : comment\n  );\n\n  // If all comments have been deleted (or there are no comments in the first\n  // place), we mark the thread as deleted.\n  if (updatedComments.every((comment) => comment.deletedAt !== undefined)) {\n    return {\n      ...thread,\n      deletedAt,\n      updatedAt: deletedAt,\n    };\n  }\n\n  return {\n    ...thread,\n    updatedAt: deletedAt,\n    comments: updatedComments,\n  };\n}\n\n/** @internal Exported for unit tests only. */\nexport function applyAddReaction<\n  TM extends BaseMetadata,\n  CM extends BaseMetadata,\n>(\n  thread: ThreadDataWithDeleteInfo<TM, CM>,\n  commentId: string,\n  reaction: CommentUserReaction\n): ThreadDataWithDeleteInfo<TM, CM> {\n  // If the thread has been deleted, we do not add the reaction\n  if (thread.deletedAt !== undefined) {\n    return thread;\n  }\n\n  const existingComment = thread.comments.find(\n    (comment) => comment.id === commentId\n  );\n\n  // If the comment doesn't exist in the thread, we do not add the reaction\n  if (existingComment === undefined) {\n    return thread;\n  }\n\n  // If the comment has been deleted since the reaction addition request, we do not add the reaction\n  if (existingComment.deletedAt !== undefined) {\n    return thread;\n  }\n\n  const updatedComments = thread.comments.map((comment) =>\n    comment.id === commentId\n      ? {\n          ...comment,\n          reactions: upsertReaction(comment.reactions, reaction),\n        }\n      : comment\n  );\n\n  return {\n    ...thread,\n    updatedAt: new Date(\n      Math.max(reaction.createdAt.getTime(), thread.updatedAt.getTime())\n    ),\n    comments: updatedComments,\n  };\n}\n\n/** @internal Exported for unit tests only. */\nexport function applyRemoveReaction<\n  TM extends BaseMetadata,\n  CM extends BaseMetadata,\n>(\n  thread: ThreadDataWithDeleteInfo<TM, CM>,\n  commentId: string,\n  emoji: string,\n  userId: string,\n  removedAt: Date\n): ThreadDataWithDeleteInfo<TM, CM> {\n  // If the thread has been deleted, we do not remove the reaction\n  if (thread.deletedAt !== undefined) {\n    return thread;\n  }\n\n  const existingComment = thread.comments.find(\n    (comment) => comment.id === commentId\n  );\n\n  // If the comment doesn't exist in the thread, we do not remove the reaction\n  if (existingComment === undefined) {\n    return thread;\n  }\n\n  // If the comment has been deleted since the reaction removal request, we do not remove the reaction\n  if (existingComment.deletedAt !== undefined) {\n    return thread;\n  }\n\n  const updatedComments = thread.comments.map((comment) =>\n    comment.id === commentId\n      ? {\n          ...comment,\n          reactions: comment.reactions\n            .map((reaction) =>\n              reaction.emoji === emoji\n                ? {\n                    ...reaction,\n                    users: reaction.users.filter((user) => user.id !== userId),\n                  }\n                : reaction\n            )\n            .filter((reaction) => reaction.users.length > 0), // Remove reactions with no users left\n        }\n      : comment\n  );\n\n  return {\n    ...thread,\n    updatedAt: new Date(\n      Math.max(removedAt.getTime(), thread.updatedAt.getTime())\n    ),\n    comments: updatedComments,\n  };\n}\n\nfunction upsertReaction(\n  reactions: CommentReaction[],\n  reaction: CommentUserReaction\n): CommentReaction[] {\n  const existingReaction = reactions.find(\n    (existingReaction) => existingReaction.emoji === reaction.emoji\n  );\n\n  // If the reaction doesn't exist in the comment, we add it\n  if (existingReaction === undefined) {\n    return [\n      ...reactions,\n      {\n        emoji: reaction.emoji,\n        createdAt: reaction.createdAt,\n        users: [{ id: reaction.userId }],\n      },\n    ];\n  }\n\n  // If the reaction exists in the comment, we add the user to the reaction if they are not already in it\n  if (\n    existingReaction.users.some((user) => user.id === reaction.userId) === false\n  ) {\n    return reactions.map((existingReaction) =>\n      existingReaction.emoji === reaction.emoji\n        ? {\n            ...existingReaction,\n            users: [...existingReaction.users, { id: reaction.userId }],\n          }\n        : existingReaction\n    );\n  }\n\n  return reactions;\n}\n","/**\n * Binds all methods on a class instance to \"this\". Call this from the\n * constructor if you want to be able to reference the methods like this:\n *\n * ------------------------------------------------------------------------\n *\n *   class MyClass {}\n *   const thing = new MyClass();\n *   const getter1 = thing.someMethod;     //  Cannot refer to someMethod this way, because \"this\" will not be bound to \"thing\" here\n *   const getter2 = thing.anotherMethod;  // \n *\n * ------------------------------------------------------------------------\n *\n *   class MyClass {\n *     constructor() {\n *       // ...\n *       autobind(this);                   // \n *     }\n *   }\n *   const thing = new MyClass();\n *   const getter1 = thing.someMethod;     //  Now \"this\" will be correctly bound to \"thing\" inside someMethod()\n *   const getter2 = thing.anotherMethod;  //  Now\n *\n */\nexport function autobind(self: object): void {\n  const seen = new Set<string | symbol>();\n  seen.add(\"constructor\"); // We'll never want to bind the constructor\n\n  let obj = self.constructor.prototype as object;\n  do {\n    for (const key of Reflect.ownKeys(obj)) {\n      if (seen.has(key)) continue;\n      const descriptor = Reflect.getOwnPropertyDescriptor(obj, key);\n      if (typeof descriptor?.value === \"function\") {\n        seen.add(key);\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-call\n        (self as any)[key] = (self as any)[key].bind(self);\n      }\n    }\n  } while ((obj = Reflect.getPrototypeOf(obj)!) && obj !== Object.prototype);\n}\n","/**\n * Like Array.prototype.find(), but for iterables.\n *\n * Returns the first item in the iterable for which the predicate holds.\n * Returns undefined if item matches the predicate.\n */\nexport function find<T>(\n  it: Iterable<T>,\n  predicate: (value: T) => boolean\n): T | undefined {\n  for (const item of it) {\n    if (predicate(item)) return item;\n  }\n  return undefined;\n}\n\n/**\n * Counts the number of items in an iterable that match the predicate.\n */\nexport function count<T>(\n  it: Iterable<T>,\n  predicate: (value: T) => boolean\n): number {\n  let total = 0;\n  for (const item of it) {\n    if (predicate(item)) total++;\n  }\n  return total;\n}\n","import type {\n  BaseMetadata,\n  InboxNotificationData,\n  ThreadData,\n} from \"@liveblocks/client\";\nimport {\n  getSubscriptionKey,\n  isNumberOperator,\n  isStartsWithOperator,\n  type QueryMetadata,\n  type SubscriptionData,\n  type SubscriptionKey,\n} from \"@liveblocks/core\";\n\nimport type { InboxNotificationsQuery, ThreadsQuery } from \"../types\";\n\n/**\n * Creates a predicate function that will filter all ThreadData instances that\n * match the given query.\n */\nexport function makeThreadsFilter<\n  TM extends BaseMetadata,\n  CM extends BaseMetadata,\n>(\n  query: ThreadsQuery<TM>,\n  subscriptions: Record<SubscriptionKey, SubscriptionData> | undefined\n): (thread: ThreadData<TM, CM>) => boolean {\n  return (thread: ThreadData<TM, CM>) =>\n    matchesThreadsQuery(thread, query, subscriptions) &&\n    matchesThreadMetadata(thread, query);\n}\n\nfunction matchesThreadsQuery<TM extends BaseMetadata, CM extends BaseMetadata>(\n  thread: ThreadData<TM, CM>,\n  q: ThreadsQuery<TM>,\n  subscriptions: Record<SubscriptionKey, SubscriptionData> | undefined\n) {\n  let subscription = undefined;\n  if (subscriptions) {\n    subscription = subscriptions?.[getSubscriptionKey(\"thread\", thread.id)];\n  }\n\n  return (\n    (q.resolved === undefined || thread.resolved === q.resolved) &&\n    (q.subscribed === undefined ||\n      (q.subscribed === true && subscription !== undefined) ||\n      (q.subscribed === false && subscription === undefined))\n  );\n}\n\nfunction matchesThreadMetadata<\n  TM extends BaseMetadata,\n  CM extends BaseMetadata,\n>(thread: ThreadData<TM, CM>, q: ThreadsQuery<TM>) {\n  // Boolean logic: query.metadata? => all metadata matches\n  const metadata = thread.metadata;\n  return (\n    q.metadata === undefined ||\n    Object.entries(q.metadata).every(\n      ([key, op]: [keyof TM, QueryMetadata<TM>[keyof TM] | undefined]) =>\n        // Ignore explicit-undefined filters\n        // Boolean logic: op? => value matches the operator\n        op === undefined || matchesOperator(metadata[key], op)\n    )\n  );\n}\n\nfunction matchesOperator(\n  value: BaseMetadata[string],\n  op:\n    | Exclude<BaseMetadata[string], undefined>\n    | { startsWith: string }\n    | {\n        lt?: number;\n        gt?: number;\n        lte?: number;\n        gte?: number;\n      }\n    | null\n) {\n  if (op === null) {\n    // If the operator is `null`, we're doing an explicit query for absence\n    return value === undefined;\n  } else if (isStartsWithOperator(op)) {\n    return typeof value === \"string\" && value.startsWith(op.startsWith);\n  } else if (isNumberOperator(op)) {\n    return typeof value === \"number\" && matchesNumberOperator(value, op);\n  } else {\n    return value === op;\n  }\n}\n\nfunction matchesNumberOperator(\n  value: number,\n  op: {\n    lt?: number;\n    gt?: number;\n    lte?: number;\n    gte?: number;\n  }\n) {\n  return (\n    (op.lt === undefined || value < op.lt) &&\n    (op.gt === undefined || value > op.gt) &&\n    (op.lte === undefined || value <= op.lte) &&\n    (op.gte === undefined || value >= op.gte)\n  );\n}\n\nexport function makeInboxNotificationsFilter(\n  query: InboxNotificationsQuery\n): (inboxNotification: InboxNotificationData) => boolean {\n  return (inboxNotification: InboxNotificationData) =>\n    matchesInboxNotificationsQuery(inboxNotification, query);\n}\n\nfunction matchesInboxNotificationsQuery(\n  inboxNotification: InboxNotificationData,\n  q: InboxNotificationsQuery\n) {\n  return (\n    (q.roomId === undefined || q.roomId === inboxNotification.roomId) &&\n    (q.kind === undefined || q.kind === inboxNotification.kind)\n  );\n}\n","import type {\n  BaseMetadata,\n  SubscriptionData,\n  SubscriptionKey,\n  ThreadData,\n  ThreadDataWithDeleteInfo,\n  ThreadDeleteInfo,\n} from \"@liveblocks/core\";\nimport { batch, MutableSignal, SortedList } from \"@liveblocks/core\";\n\nimport { makeThreadsFilter } from \"./lib/querying\";\nimport type { ThreadsQuery } from \"./types\";\n\nfunction sanitizeThread<TM extends BaseMetadata, CM extends BaseMetadata>(\n  thread: ThreadDataWithDeleteInfo<TM, CM>\n): ThreadDataWithDeleteInfo<TM, CM> {\n  // First, if a thread has a deletedAt date, it should not have any comments\n  if (thread.deletedAt) {\n    // Thread is deleted, it should wipe all comments\n    if (thread.comments.length > 0) {\n      return { ...thread, comments: [] };\n    }\n  }\n\n  // Otherwise, if a thread is not deleted, it _should_ have at least one non-deleted comment\n  const hasComment = thread.comments.some((c) => !c.deletedAt);\n  if (!hasComment) {\n    // Delete it after all if it doesn't have at least one comment\n    return { ...thread, deletedAt: new Date(), comments: [] };\n  }\n\n  return thread;\n}\n\nexport type ReadonlyThreadDB<\n  TM extends BaseMetadata,\n  CM extends BaseMetadata,\n> = Omit<ThreadDB<TM, CM>, \"upsert\" | \"delete\" | \"signal\">;\n\n/**\n * This class implements a lightweight, in-memory, \"database\" for all Thread\n * instances.\n *\n * It exposes the following methods:\n *\n * - upsert: To add/update a thread\n * - upsertIfNewer: To add/update a thread. Only update an existing thread if\n *                  its newer\n * - delete: To mark existing threads as deleted\n * - get: To get any non-deleted thread\n * - getEvenIfDeleted: To get a thread which is possibly deleted\n * - findMany: To filter an ordered list of non-deleted threads\n * - clone: To clone the DB to mutate it further. This is used to mix in\n *          optimistic updates without losing the original thread contents.\n *\n */\nexport class ThreadDB<TM extends BaseMetadata, CM extends BaseMetadata> {\n  #byId: Map<string, ThreadDataWithDeleteInfo<TM, CM>>;\n  #asc: SortedList<ThreadData<TM, CM>>;\n  #desc: SortedList<ThreadData<TM, CM>>;\n\n  // This signal will be notified on every mutation\n  public readonly signal: MutableSignal<this>;\n\n  constructor() {\n    this.#asc = SortedList.from<ThreadData<TM, CM>>([], (t1, t2) => {\n      const d1 = t1.createdAt;\n      const d2 = t2.createdAt;\n      return d1 < d2 ? true : d1 === d2 ? t1.id < t2.id : false;\n    });\n\n    this.#desc = SortedList.from<ThreadData<TM, CM>>([], (t1, t2) => {\n      const d2 = t2.updatedAt;\n      const d1 = t1.updatedAt;\n      return d2 < d1 ? true : d2 === d1 ? t2.id < t1.id : false;\n    });\n\n    this.#byId = new Map();\n\n    this.signal = new MutableSignal(this);\n  }\n\n  //\n  // Public APIs\n  //\n\n  public clone(): ThreadDB<TM, CM> {\n    const newPool = new ThreadDB<TM, CM>();\n    newPool.#byId = new Map(this.#byId);\n    newPool.#asc = this.#asc.clone();\n    newPool.#desc = this.#desc.clone();\n    return newPool;\n  }\n\n  /** Returns an existing thread by ID. Will never return a deleted thread. */\n  public get(threadId: string): ThreadData<TM, CM> | undefined {\n    const thread = this.getEvenIfDeleted(threadId);\n    return thread?.deletedAt ? undefined : thread;\n  }\n\n  /** Returns the (possibly deleted) thread by ID. */\n  public getEvenIfDeleted(\n    threadId: string\n  ): ThreadDataWithDeleteInfo<TM, CM> | undefined {\n    return this.#byId.get(threadId);\n  }\n\n  /** Adds or updates a thread in the DB. If the newly given thread is a deleted one, it will get deleted. */\n  public upsert(thread: ThreadDataWithDeleteInfo<TM, CM>): void {\n    this.signal.mutate(() => {\n      thread = sanitizeThread(thread);\n\n      const id = thread.id;\n\n      const toRemove = this.#byId.get(id);\n      if (toRemove) {\n        // Don't do anything if the existing thread is already deleted!\n        if (toRemove.deletedAt) return false;\n\n        this.#asc.remove(toRemove);\n        this.#desc.remove(toRemove);\n      }\n\n      if (!thread.deletedAt) {\n        this.#asc.add(thread);\n        this.#desc.add(thread);\n      }\n      this.#byId.set(id, thread);\n      return true;\n    });\n  }\n\n  /** Like .upsert(), except it won't update if a thread by this ID already exists. */\n  // TODO Consider renaming this to just .upsert(). I'm not sure if we really\n  // TODO need the raw .upsert(). Would be nice if this behavior was the default.\n  public upsertIfNewer(thread: ThreadDataWithDeleteInfo<TM, CM>): void {\n    const existing = this.get(thread.id);\n    if (!existing || thread.updatedAt >= existing.updatedAt) {\n      this.upsert(thread);\n    }\n  }\n\n  public applyDelta(\n    newThreads: ThreadData<TM, CM>[],\n    deletedThreads: ThreadDeleteInfo[]\n  ): void {\n    batch(() => {\n      // Add new threads or update existing threads if the existing thread is older than the new thread.\n      for (const thread of newThreads) {\n        this.upsertIfNewer(thread);\n      }\n\n      // Mark threads in the deletedThreads list as deleted\n      for (const { id, deletedAt } of deletedThreads) {\n        const existing = this.getEvenIfDeleted(id);\n        if (!existing) continue;\n        this.delete(id, deletedAt);\n      }\n    });\n  }\n\n  /**\n   * Marks a thread as deleted. It will no longer pop up in .findMany()\n   * queries, but it can still be accessed via `.getEvenIfDeleted()`.\n   */\n  public delete(threadId: string, deletedAt: Date): void {\n    const existing = this.#byId.get(threadId);\n    if (existing && !existing.deletedAt) {\n      this.upsert({ ...existing, deletedAt, updatedAt: deletedAt });\n    }\n  }\n\n  /**\n   * Returns all threads matching a given roomId and query. If roomId is not\n   * specified, it will return all threads matching the query, across all\n   * rooms.\n   *\n   * Returns the results in the requested order. Please note:\n   *   'asc'  means by createdAt ASC\n   *   'desc' means by updatedAt DESC\n   *\n   * Will never return deleted threads in the result.\n   *\n   * Subscriptions are needed to filter threads based on the user's subscriptions.\n   */\n  public findMany(\n    // TODO: Implement caching here\n    roomId: string | undefined,\n    query: ThreadsQuery<TM> | undefined,\n    direction: \"asc\" | \"desc\",\n    subscriptions?: Record<SubscriptionKey, SubscriptionData>\n  ): ThreadData<TM, CM>[] {\n    const index = direction === \"desc\" ? this.#desc : this.#asc;\n    const crit: ((thread: ThreadData<TM, CM>) => boolean)[] = [];\n    if (roomId !== undefined) {\n      crit.push((t) => t.roomId === roomId);\n    }\n    if (query !== undefined) {\n      crit.push(makeThreadsFilter(query, subscriptions));\n    }\n    return Array.from(index.filter((t) => crit.every((pred) => pred(t))));\n  }\n}\n","import type {\n  BaseMetadata,\n  BaseUserMeta,\n  BroadcastOptions,\n  Client,\n  CommentData,\n  History,\n  Json,\n  JsonObject,\n  LiveObject,\n  LostConnectionEvent,\n  LsonObject,\n  OthersEvent,\n  Room,\n  Status,\n  ThreadData,\n  User,\n} from \"@liveblocks/client\";\nimport { shallow } from \"@liveblocks/client\";\nimport type {\n  AsyncResult,\n  CommentsEventServerMsg,\n  DCM,\n  DE,\n  DP,\n  DS,\n  DTM,\n  DU,\n  EnterOptions,\n  IYjsProvider,\n  LiveblocksErrorContext,\n  MentionData,\n  OpaqueClient,\n  RoomEventMessage,\n  RoomSubscriptionSettings,\n  SignalType,\n  TextEditorType,\n  ToImmutable,\n  UnsubscribeCallback,\n} from \"@liveblocks/core\";\nimport {\n  assert,\n  console,\n  createCommentId,\n  createThreadId,\n  DefaultMap,\n  errorIf,\n  getSubscriptionKey,\n  HttpError,\n  kInternal,\n  makePoller,\n  ServerMsgCode,\n  stableStringify,\n} from \"@liveblocks/core\";\nimport type { Context } from \"react\";\nimport {\n  useCallback,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n  useSyncExternalStore,\n  version as reactVersion,\n} from \"react\";\n\nimport { config } from \"./config\";\nimport {\n  RoomContext,\n  useClient,\n  useIsInsideRoom,\n  useRoomOrNull,\n} from \"./contexts\";\nimport { ensureNotServerSide } from \"./lib/ssr\";\nimport { useInitial } from \"./lib/use-initial\";\nimport { useLatest } from \"./lib/use-latest\";\nimport { use } from \"./lib/use-polyfill\";\nimport {\n  createSharedContext,\n  getUmbrellaStoreForClient,\n  LiveblocksProviderWithClient,\n} from \"./liveblocks\";\nimport type {\n  AttachmentUrlAsyncResult,\n  CommentReactionOptions,\n  CreateCommentOptions,\n  CreateThreadOptions,\n  DeleteCommentOptions,\n  EditCommentMetadataOptions,\n  EditCommentOptions,\n  EditThreadMetadataOptions,\n  HistoryVersionDataAsyncResult,\n  HistoryVersionsAsyncResult,\n  HistoryVersionsAsyncSuccess,\n  MutationContext,\n  OmitFirstArg,\n  RoomContextBundle,\n  RoomProviderProps,\n  RoomSubscriptionSettingsAsyncResult,\n  RoomSubscriptionSettingsAsyncSuccess,\n  SearchCommentsAsyncResult,\n  ThreadsAsyncResult,\n  ThreadsAsyncSuccess,\n  ThreadSubscription,\n  UseSearchCommentsOptions,\n  UseThreadsOptions,\n} from \"./types\";\nimport type { UmbrellaStore } from \"./umbrella-store\";\nimport { makeRoomThreadsQueryKey } from \"./umbrella-store\";\nimport { useScrollToCommentOnLoadEffect } from \"./use-scroll-to-comment-on-load-effect\";\nimport { useSignal } from \"./use-signal\";\nimport { useSyncExternalStoreWithSelector } from \"./use-sync-external-store-with-selector\";\n\nconst noop = () => {};\nconst identity: <T>(x: T) => T = (x) => x;\n\nconst STABLE_EMPTY_LIST = Object.freeze([]);\n\n// Don't try to inline this. This function is intended to be a stable\n// reference, to avoid a useCallback() wrapper.\nfunction alwaysEmptyList() {\n  return STABLE_EMPTY_LIST;\n}\n\n// Don't try to inline this. This function is intended to be a stable\n// reference, to avoid a useCallback() wrapper.\nfunction alwaysNull() {\n  return null;\n}\n\nfunction selectorFor_useOthersConnectionIds(\n  others: readonly User<JsonObject, BaseUserMeta>[]\n): number[] {\n  return others.map((user) => user.connectionId);\n}\n\nfunction makeMutationContext<\n  P extends JsonObject,\n  S extends LsonObject,\n  U extends BaseUserMeta,\n  E extends Json,\n  TM extends BaseMetadata,\n  CM extends BaseMetadata,\n>(room: Room<P, S, U, E, TM, CM>): MutationContext<P, S, U> {\n  const cannotUseUntil = \"This mutation cannot be used until\";\n  const needsPresence = `${cannotUseUntil} connected to the Liveblocks room`;\n  const needsStorage = `${cannotUseUntil} storage has been loaded`;\n\n  return {\n    get storage() {\n      const mutableRoot = room.getStorageSnapshot();\n      if (mutableRoot === null) {\n        throw new Error(needsStorage);\n      }\n      return mutableRoot;\n    },\n\n    get self() {\n      const self = room.getSelf();\n      if (self === null) {\n        throw new Error(needsPresence);\n      }\n      return self;\n    },\n\n    get others() {\n      const others = room.getOthers();\n      if (room.getSelf() === null) {\n        throw new Error(needsPresence);\n      }\n      return others;\n    },\n\n    setMyPresence: room.updatePresence,\n  };\n}\n\nfunction getCurrentUserId(client: Client): string {\n  const userId = client[kInternal].currentUserId.get();\n  if (userId === undefined) {\n    return \"anonymous\";\n  }\n  return userId;\n}\n\nconst _extras = new WeakMap<\n  OpaqueClient,\n  ReturnType<typeof makeRoomExtrasForClient>\n>();\nconst _bundles = new WeakMap<\n  OpaqueClient,\n  RoomContextBundle<\n    JsonObject,\n    LsonObject,\n    BaseUserMeta,\n    Json,\n    BaseMetadata,\n    BaseMetadata\n  >\n>();\n\nfunction getOrCreateRoomContextBundle<\n  P extends JsonObject,\n  S extends LsonObject,\n  U extends BaseUserMeta,\n  E extends Json,\n  TM extends BaseMetadata,\n  CM extends BaseMetadata,\n>(client: OpaqueClient): RoomContextBundle<P, S, U, E, TM, CM> {\n  let bundle = _bundles.get(client);\n  if (!bundle) {\n    bundle = makeRoomContextBundle(client);\n    _bundles.set(client, bundle);\n  }\n  return bundle as unknown as RoomContextBundle<P, S, U, E, TM, CM>;\n}\n\n// TODO: Likely a better / more clear name for this helper will arise. I'll\n// rename this later. All of these are implementation details to support inbox\n// notifications on a per-client basis.\nfunction getRoomExtrasForClient<\n  TM extends BaseMetadata,\n  CM extends BaseMetadata,\n>(client: OpaqueClient) {\n  let extras = _extras.get(client);\n  if (!extras) {\n    extras = makeRoomExtrasForClient(client);\n    _extras.set(client, extras);\n  }\n\n  return extras as unknown as Omit<typeof extras, \"store\"> & {\n    store: UmbrellaStore<TM, CM>;\n  };\n}\n\nfunction makeRoomExtrasForClient(client: OpaqueClient) {\n  const store = getUmbrellaStoreForClient(client);\n\n  function onMutationFailure(\n    optimisticId: string,\n    context: LiveblocksErrorContext & { roomId: string },\n    innerError: Error\n  ): void {\n    store.optimisticUpdates.remove(optimisticId);\n\n    // All mutation failures are expected to be HTTP errors ultimately - only\n    // ever notify the user about those.\n    if (innerError instanceof HttpError) {\n      // Always log details about 403 Forbidden errors to the console as well\n      if (innerError.status === 403) {\n        const detailedMessage = [\n          innerError.message,\n          innerError.details?.suggestion,\n          innerError.details?.docs,\n        ]\n          .filter(Boolean)\n          .join(\"\\n\");\n\n        console.error(detailedMessage);\n      }\n\n      client[kInternal].emitError(context, innerError);\n    } else {\n      // In this context, a non-HTTP error is unexpected and should be\n      // considered a bug we should get fixed. Don't notify the user about it.\n      throw innerError;\n    }\n  }\n\n  const threadsPollersByRoomId = new DefaultMap((roomId: string) =>\n    makePoller(\n      async (signal) => {\n        try {\n          return await store.fetchRoomThreadsDeltaUpdate(roomId, signal);\n        } catch (err) {\n          console.warn(`Polling new threads for '${roomId}' failed: ${String(err)}`); // prettier-ignore\n          throw err;\n        }\n      },\n      config.ROOM_THREADS_POLL_INTERVAL,\n      { maxStaleTimeMs: config.ROOM_THREADS_MAX_STALE_TIME }\n    )\n  );\n\n  const versionsPollersByRoomId = new DefaultMap((roomId: string) =>\n    makePoller(\n      async (signal) => {\n        try {\n          return await store.fetchRoomVersionsDeltaUpdate(roomId, signal);\n        } catch (err) {\n          console.warn(`Polling new history versions for '${roomId}' failed: ${String(err)}`); // prettier-ignore\n          throw err;\n        }\n      },\n      config.HISTORY_VERSIONS_POLL_INTERVAL,\n      { maxStaleTimeMs: config.HISTORY_VERSIONS_MAX_STALE_TIME }\n    )\n  );\n\n  const roomSubscriptionSettingsPollersByRoomId = new DefaultMap(\n    (roomId: string) =>\n      makePoller(\n        async (signal) => {\n          try {\n            return await store.refreshRoomSubscriptionSettings(roomId, signal);\n          } catch (err) {\n            console.warn(`Polling subscription settings for '${roomId}' failed: ${String(err)}`); // prettier-ignore\n            throw err;\n          }\n        },\n        config.ROOM_SUBSCRIPTION_SETTINGS_POLL_INTERVAL,\n        { maxStaleTimeMs: config.ROOM_SUBSCRIPTION_SETTINGS_MAX_STALE_TIME }\n      )\n  );\n\n  return {\n    store,\n    onMutationFailure,\n    pollThreadsForRoomId: (roomId: string) => {\n      const threadsPoller = threadsPollersByRoomId.getOrCreate(roomId);\n\n      // If there's a threads poller for this room, immediately trigger it\n      if (threadsPoller) {\n        threadsPoller.markAsStale();\n        threadsPoller.pollNowIfStale();\n      }\n    },\n    getOrCreateThreadsPollerForRoomId: threadsPollersByRoomId.getOrCreate.bind(\n      threadsPollersByRoomId\n    ),\n    getOrCreateVersionsPollerForRoomId:\n      versionsPollersByRoomId.getOrCreate.bind(versionsPollersByRoomId),\n    getOrCreateSubscriptionSettingsPollerForRoomId:\n      roomSubscriptionSettingsPollersByRoomId.getOrCreate.bind(\n        roomSubscriptionSettingsPollersByRoomId\n      ),\n  };\n}\n\ntype RoomLeavePair<\n  P extends JsonObject,\n  S extends LsonObject,\n  U extends BaseUserMeta,\n  E extends Json,\n  TM extends BaseMetadata,\n  CM extends BaseMetadata,\n> = {\n  room: Room<P, S, U, E, TM, CM>;\n  leave: () => void;\n};\n\nfunction makeRoomContextBundle<\n  P extends JsonObject,\n  S extends LsonObject,\n  U extends BaseUserMeta,\n  E extends Json,\n  TM extends BaseMetadata,\n  CM extends BaseMetadata,\n>(client: Client<U>): RoomContextBundle<P, S, U, E, TM, CM> {\n  type TRoom = Room<P, S, U, E, TM, CM>;\n\n  function RoomProvider_withImplicitLiveblocksProvider(\n    props: RoomProviderProps<P, S>\n  ) {\n    // NOTE: Normally, nesting LiveblocksProvider is not allowed. This\n    // factory-bound version of the RoomProvider will create an implicit\n    // LiveblocksProvider. This means that if an end user nests this\n    // RoomProvider under a LiveblocksProvider context, that would be an error.\n    // However, we'll allow that nesting only in this specific situation, and\n    // only because this wrapper will keep the Liveblocks context and the Room\n    // context consistent internally.\n    return (\n      <LiveblocksProviderWithClient client={client} allowNesting>\n        {/* @ts-expect-error {...props} is the same type as props */}\n        <RoomProvider {...props} />\n      </LiveblocksProviderWithClient>\n    );\n  }\n\n  const shared = createSharedContext<U>(client);\n\n  const bundle: RoomContextBundle<P, S, U, E, TM, CM> = {\n    RoomContext: RoomContext as Context<TRoom | null>,\n    RoomProvider: RoomProvider_withImplicitLiveblocksProvider,\n\n    useRoom,\n    useStatus,\n\n    useBroadcastEvent,\n    useOthersListener,\n    useLostConnectionListener,\n    useEventListener,\n\n    useHistory,\n    useUndo,\n    useRedo,\n    useCanRedo,\n    useCanUndo,\n\n    useStorageRoot,\n    useStorage,\n\n    useSelf,\n    useMyPresence,\n    useUpdateMyPresence,\n    useOthers,\n    useOthersMapped,\n    useOthersConnectionIds,\n    useOther,\n\n    // prettier-ignore\n    useMutation: useMutation as RoomContextBundle<P, S, U, E, TM, CM>[\"useMutation\"],\n\n    useThreads,\n    useSearchComments,\n\n    // prettier-ignore\n    useCreateThread: useCreateThread as RoomContextBundle<P, S, U, E, TM, CM>[\"useCreateThread\"],\n\n    useDeleteThread,\n    useEditThreadMetadata,\n    useMarkThreadAsResolved,\n    useMarkThreadAsUnresolved,\n    useSubscribeToThread,\n    useUnsubscribeFromThread,\n    useCreateComment,\n    useEditComment,\n    useEditCommentMetadata,\n    useDeleteComment,\n    useAddReaction,\n    useRemoveReaction,\n    useMarkThreadAsRead,\n    useThreadSubscription,\n    useAttachmentUrl,\n\n    useHistoryVersions,\n    useHistoryVersionData,\n\n    useRoomSubscriptionSettings,\n    useUpdateRoomSubscriptionSettings,\n\n    ...shared.classic,\n\n    suspense: {\n      RoomContext: RoomContext as Context<TRoom | null>,\n      RoomProvider: RoomProvider_withImplicitLiveblocksProvider,\n\n      useRoom,\n      useStatus,\n\n      useBroadcastEvent,\n      useOthersListener,\n      useLostConnectionListener,\n      useEventListener,\n\n      useHistory,\n      useUndo,\n      useRedo,\n      useCanRedo,\n      useCanUndo,\n\n      useStorageRoot,\n      useStorage: useStorageSuspense,\n\n      useSelf: useSelfSuspense,\n      useMyPresence,\n      useUpdateMyPresence,\n      useOthers: useOthersSuspense,\n      useOthersMapped: useOthersMappedSuspense,\n      useOthersConnectionIds: useOthersConnectionIdsSuspense,\n      useOther: useOtherSuspense,\n\n      // prettier-ignore\n      useMutation: useMutation as RoomContextBundle<P, S, U, E, TM, CM>[\"suspense\"][\"useMutation\"],\n\n      useThreads: useThreadsSuspense,\n\n      // prettier-ignore\n      useCreateThread: useCreateThread as RoomContextBundle<P, S, U, E, TM, CM>[\"suspense\"][\"useCreateThread\"],\n\n      useDeleteThread,\n      useEditThreadMetadata,\n      useMarkThreadAsResolved,\n      useMarkThreadAsUnresolved,\n      useSubscribeToThread,\n      useUnsubscribeFromThread,\n      useCreateComment,\n      useEditComment,\n      useEditCommentMetadata,\n      useDeleteComment,\n      useAddReaction,\n      useRemoveReaction,\n      useMarkThreadAsRead,\n      useThreadSubscription,\n      useAttachmentUrl: useAttachmentUrlSuspense,\n\n      // TODO: useHistoryVersionData: useHistoryVersionDataSuspense,\n      useHistoryVersions: useHistoryVersionsSuspense,\n\n      useRoomSubscriptionSettings: useRoomSubscriptionSettingsSuspense,\n      useUpdateRoomSubscriptionSettings,\n\n      ...shared.suspense,\n    },\n  };\n\n  return Object.defineProperty(bundle, kInternal, {\n    enumerable: false,\n  });\n}\n\nfunction RoomProvider<\n  P extends JsonObject,\n  S extends LsonObject,\n  U extends BaseUserMeta,\n  E extends Json,\n  TM extends BaseMetadata,\n  CM extends BaseMetadata,\n>(props: RoomProviderProps<P, S>) {\n  const client = useClient<U>();\n  const [cache] = useState(\n    () => new Map<string, RoomLeavePair<P, S, U, E, TM, CM>>()\n  );\n\n  // Produce a version of client.enterRoom() that when called for the same\n  // room ID multiple times, will not keep producing multiple leave\n  // functions, but instead return the cached one.\n  const stableEnterRoom: typeof client.enterRoom<P, S, E, TM, CM> = useCallback(\n    (\n      roomId: string,\n      options: EnterOptions<P, S>\n    ): RoomLeavePair<P, S, U, E, TM, CM> => {\n      const cached = cache.get(roomId);\n      if (cached) return cached;\n\n      const rv = client.enterRoom<P, S, E, TM, CM>(roomId, options);\n\n      // Wrap the leave function to also delete the cached value\n      const origLeave = rv.leave;\n      rv.leave = () => {\n        origLeave();\n        cache.delete(roomId);\n      };\n\n      cache.set(roomId, rv);\n      return rv;\n    },\n    [client, cache]\n  );\n\n  //\n  // RATIONALE:\n  // At the \"Outer\" RoomProvider level, we keep a cache and produce\n  // a stableEnterRoom function, which we pass down to the real \"Inner\"\n  // RoomProvider level.\n  //\n  // The purpose is to ensure that if `stableEnterRoom(\"my-room\")` is called\n  // multiple times for the same room ID, it will always return the exact same\n  // (cached) value, so that in total only a single \"leave\" function gets\n  // produced and registered in the client.\n  //\n  // If we didn't use this cache, then in React StrictMode\n  // stableEnterRoom(\"my-room\") might get called multiple (at least 4) times,\n  // causing more leave functions to be produced in the client, some of which\n  // we cannot get a hold on (because StrictMode would discard those results by\n  // design). This would make it appear to the Client that the Room is still in\n  // use by some party that hasn't called `leave()` on it yet, thus causing the\n  // Room to not be freed and destroyed when the component unmounts later.\n  //\n  return (\n    <RoomProviderInner<P, S, U, E, TM, CM>\n      {...(props as any)}\n      stableEnterRoom={stableEnterRoom}\n    />\n  );\n}\n\ntype EnterRoomType<\n  P extends JsonObject,\n  S extends LsonObject,\n  U extends BaseUserMeta,\n  E extends Json,\n  TM extends BaseMetadata,\n  CM extends BaseMetadata,\n> = (\n  roomId: string,\n  options: EnterOptions<P, S>\n) => RoomLeavePair<P, S, U, E, TM, CM>;\n\n/** @internal */\nfunction RoomProviderInner<\n  P extends JsonObject,\n  S extends LsonObject,\n  U extends BaseUserMeta,\n  E extends Json,\n  TM extends BaseMetadata,\n  CM extends BaseMetadata,\n>(\n  props: RoomProviderProps<P, S> & {\n    stableEnterRoom: EnterRoomType<P, S, U, E, TM, CM>;\n  }\n) {\n  const client = useClient<U>();\n  const { id: roomId, stableEnterRoom } = props;\n\n  if (process.env.NODE_ENV !== \"production\") {\n    if (!roomId) {\n      throw new Error(\n        \"RoomProvider id property is required. For more information: https://liveblocks.io/docs/errors/liveblocks-react/RoomProvider-id-property-is-required\"\n      );\n    }\n\n    if (typeof roomId !== \"string\") {\n      throw new Error(\"RoomProvider id property should be a string.\");\n    }\n\n    const majorReactVersion = parseInt(reactVersion) || 1;\n    const requiredVersion = 18;\n    errorIf(\n      majorReactVersion < requiredVersion,\n      `React ${requiredVersion} or higher is required (youre on ${reactVersion})`\n    );\n  }\n\n  // Note: We'll hold on to the initial value given here, and ignore any\n  // changes to this argument in subsequent renders, except when roomId changes\n  const frozenProps = useInitial(\n    {\n      initialPresence: props.initialPresence,\n      initialStorage: props.initialStorage,\n      autoConnect: props.autoConnect ?? typeof window !== \"undefined\",\n      engine: props.engine,\n    },\n    roomId\n  ) as EnterOptions<P, S>;\n\n  const [{ room }, setRoomLeavePair] = useState(() =>\n    stableEnterRoom(roomId, {\n      ...frozenProps,\n      autoConnect: false, // Deliberately using false here on the first render, see below\n    })\n  );\n\n  useEffect(() => {\n    const { store } = getRoomExtrasForClient(client);\n\n    async function handleCommentEvent(message: CommentsEventServerMsg) {\n      // If thread deleted event is received, we remove the thread from the local cache\n      // no need for more processing\n      if (message.type === ServerMsgCode.THREAD_DELETED) {\n        store.deleteThread(message.threadId, null);\n        return;\n      }\n\n      // TODO: Error handling\n      const info = await room.getThread(message.threadId);\n\n      // If no thread info was returned (i.e., 404), we remove the thread and relevant inbox notifications from local cache.\n      if (!info.thread) {\n        store.deleteThread(message.threadId, null);\n        return;\n      }\n      const {\n        thread,\n        inboxNotification: maybeNotification,\n        subscription: maybeSubscription,\n      } = info;\n\n      const existingThread = store.outputs.threads\n        .get()\n        .getEvenIfDeleted(message.threadId);\n\n      switch (message.type) {\n        case ServerMsgCode.COMMENT_EDITED:\n        case ServerMsgCode.THREAD_METADATA_UPDATED:\n        case ServerMsgCode.THREAD_UPDATED:\n        case ServerMsgCode.COMMENT_REACTION_ADDED:\n        case ServerMsgCode.COMMENT_REACTION_REMOVED:\n        case ServerMsgCode.COMMENT_DELETED:\n        case ServerMsgCode.COMMENT_METADATA_UPDATED:\n          // If the thread doesn't exist in the local cache, we do not update it with the server data as an optimistic update could have deleted the thread locally.\n          if (!existingThread) break;\n\n          store.updateThreadifications(\n            [thread],\n            maybeNotification ? [maybeNotification] : [],\n            maybeSubscription ? [maybeSubscription] : []\n          );\n          break;\n\n        case ServerMsgCode.COMMENT_CREATED:\n          store.updateThreadifications(\n            [thread],\n            maybeNotification ? [maybeNotification] : [],\n            maybeSubscription ? [maybeSubscription] : []\n          );\n          break;\n        default:\n          break;\n      }\n    }\n\n    return room.events.comments.subscribe(\n      (message) => void handleCommentEvent(message)\n    );\n  }, [client, room]);\n\n  useEffect(() => {\n    const pair = stableEnterRoom(roomId, frozenProps);\n\n    setRoomLeavePair(pair);\n    const { room, leave } = pair;\n\n    // In React, it's important to start connecting to the room as an effect,\n    // rather than doing this during the initial render. This means that\n    // during the initial render (both on the server-side, and on the first\n    // hydration on the client-side), the value of the `useStatus()` hook\n    // will correctly be \"initial\", and transition to \"connecting\" as an\n    // effect.\n    if (frozenProps.autoConnect) {\n      room.connect();\n    }\n\n    return () => {\n      leave();\n    };\n  }, [roomId, frozenProps, stableEnterRoom]);\n\n  return (\n    <RoomContext.Provider value={room}>{props.children}</RoomContext.Provider>\n  );\n}\n\nfunction useRoom<\n  P extends JsonObject = DP,\n  S extends LsonObject = DS,\n  U extends BaseUserMeta = DU,\n  E extends Json = DE,\n  TM extends BaseMetadata = DTM,\n  CM extends BaseMetadata = DCM,\n>(options?: { allowOutsideRoom: false }): Room<P, S, U, E, TM, CM>;\nfunction useRoom<\n  P extends JsonObject = DP,\n  S extends LsonObject = DS,\n  U extends BaseUserMeta = DU,\n  E extends Json = DE,\n  TM extends BaseMetadata = DTM,\n  CM extends BaseMetadata = DCM,\n>(options: { allowOutsideRoom: boolean }): Room<P, S, U, E, TM, CM> | null;\nfunction useRoom<\n  P extends JsonObject = DP,\n  S extends LsonObject = DS,\n  U extends BaseUserMeta = DU,\n  E extends Json = DE,\n  TM extends BaseMetadata = DTM,\n  CM extends BaseMetadata = DCM,\n>(options?: { allowOutsideRoom: boolean }): Room<P, S, U, E, TM, CM> | null {\n  const room = useRoomOrNull<P, S, U, E, TM, CM>();\n  if (room === null && !options?.allowOutsideRoom) {\n    throw new Error(\"RoomProvider is missing from the React tree.\");\n  }\n  return room;\n}\n\n/**\n * Returns the current connection status for the Room, and triggers\n * a re-render whenever it changes. Can be used to render a status badge.\n */\nfunction useStatus(): Status {\n  const room = useRoom();\n  const subscribe = room.events.status.subscribe;\n  const getSnapshot = room.getStatus;\n  const getServerSnapshot = room.getStatus;\n  return useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n}\n\n/** @private - Internal API, do not rely on it. */\nfunction useReportTextEditor(editor: TextEditorType, rootKey: string): void {\n  const isReported = useRef<boolean>(false);\n  const room = useRoom();\n\n  useEffect(() => {\n    // We use a \"locker\" reference to avoid to spam / harass our backend\n    // and to not add / remove subscribers in case when the text editor type\n    // has been already reported.\n    if (isReported.current) {\n      return;\n    }\n\n    const unsubscribe = room.events.status.subscribe((status: Status): void => {\n      if (status === \"connected\" && !isReported.current) {\n        isReported.current = true;\n        // We do not catch because this method never throw (e.g `rawPost`)\n        void room[kInternal].reportTextEditor(editor, rootKey);\n      }\n    });\n\n    return unsubscribe;\n  }, [room, editor, rootKey]);\n}\n\n/** @private - Internal API, do not rely on it. */\nfunction useYjsProvider(): IYjsProvider | undefined {\n  const room = useRoom();\n\n  const subscribe = useCallback(\n    (onStoreChange: () => void): UnsubscribeCallback => {\n      return room[kInternal].yjsProviderDidChange.subscribe(onStoreChange);\n    },\n    [room]\n  );\n\n  const getSnapshot = useCallback((): IYjsProvider | undefined => {\n    return room[kInternal].getYjsProvider();\n  }, [room]);\n\n  return useSyncExternalStore(subscribe, getSnapshot, getSnapshot);\n}\n\n/** @private - Internal API, do not rely on it. */\nfunction useCreateTextMention(): (\n  mentionId: string,\n  mention: MentionData\n) => void {\n  const room = useRoom();\n  return useCallback(\n    (mentionId: string, mention: MentionData): void => {\n      room[kInternal]\n        .createTextMention(mentionId, mention)\n        .catch((err): void => {\n          console.error(\n            `Cannot create text mention for mention '${mentionId}'`,\n            err\n          );\n        });\n    },\n    [room]\n  );\n}\n\n/** @private - Internal API, do not rely on it. */\nfunction useDeleteTextMention(): (mentionId: string) => void {\n  const room = useRoom();\n  return useCallback(\n    (mentionId: string): void => {\n      room[kInternal].deleteTextMention(mentionId).catch((err): void => {\n        console.error(`Cannot delete text mention '${mentionId}'`, err);\n      });\n    },\n    [room]\n  );\n}\n\n/** @private - Internal API, do not rely on it. */\nfunction useResolveMentionSuggestions() {\n  const client = useClient();\n  return client[kInternal].resolveMentionSuggestions;\n}\n\n/** @private - Internal API, do not rely on it. */\nfunction useMentionSuggestionsCache() {\n  const client = useClient();\n  return client[kInternal].mentionSuggestionsCache;\n}\n\nfunction useBroadcastEvent<E extends Json>(): (\n  event: E,\n  options?: BroadcastOptions\n) => void {\n  const room = useRoom<never, never, never, E, never>();\n  return useCallback(\n    (\n      event: E,\n      options: BroadcastOptions = { shouldQueueEventIfNotReady: false }\n    ) => {\n      room.broadcastEvent(event, options);\n    },\n    [room]\n  );\n}\n\nfunction useOthersListener<P extends JsonObject, U extends BaseUserMeta>(\n  callback: (event: OthersEvent<P, U>) => void\n) {\n  const room = useRoom<P, never, U, never, never>();\n  const savedCallback = useLatest(callback);\n  useEffect(\n    () => room.events.others.subscribe((event) => savedCallback.current(event)),\n    [room, savedCallback]\n  );\n}\n\n/**\n * Get informed when reconnecting to the Liveblocks servers is taking\n * longer than usual. This typically is a sign of a client that has lost\n * internet connectivity.\n *\n * This isn't problematic (because the Liveblocks client is still trying to\n * reconnect), but it's typically a good idea to inform users about it if\n * the connection takes too long to recover.\n *\n * @example\n * useLostConnectionListener(event => {\n *   if (event === 'lost') {\n *     toast.warn('Reconnecting to the Liveblocks servers is taking longer than usual...')\n *   } else if (event === 'failed') {\n *     toast.warn('Reconnecting to the Liveblocks servers failed.')\n *   } else if (event === 'restored') {\n *     toast.clear();\n *   }\n * })\n */\nfunction useLostConnectionListener(\n  callback: (event: LostConnectionEvent) => void\n): void {\n  const room = useRoom();\n  const savedCallback = useLatest(callback);\n  useEffect(\n    () =>\n      room.events.lostConnection.subscribe((event) =>\n        savedCallback.current(event)\n      ),\n    [room, savedCallback]\n  );\n}\n\nfunction useEventListener<\n  P extends JsonObject,\n  U extends BaseUserMeta,\n  E extends Json,\n>(callback: (data: RoomEventMessage<P, U, E>) => void): void {\n  const room = useRoom<P, never, U, E, never>();\n  const savedCallback = useLatest(callback);\n  useEffect(() => {\n    const listener = (eventData: RoomEventMessage<P, U, E>) => {\n      savedCallback.current(eventData);\n    };\n\n    return room.events.customEvent.subscribe(listener);\n  }, [room, savedCallback]);\n}\n\n/**\n * Returns the room.history\n */\nfunction useHistory(): History {\n  return useRoom().history;\n}\n\n/**\n * Returns a function that undoes the last operation executed by the current\n * client. It does not impact operations made by other clients.\n */\nfunction useUndo(): () => void {\n  return useHistory().undo;\n}\n\n/**\n * Returns a function that redoes the last operation executed by the current\n * client. It does not impact operations made by other clients.\n */\nfunction useRedo(): () => void {\n  return useHistory().redo;\n}\n\n/**\n * Returns whether there are any operations to undo.\n */\nfunction useCanUndo(): boolean {\n  const room = useRoom();\n  const subscribe = room.events.history.subscribe;\n  const canUndo = room.history.canUndo;\n  return useSyncExternalStore(subscribe, canUndo, canUndo);\n}\n\n/**\n * Returns whether there are any operations to redo.\n */\nfunction useCanRedo(): boolean {\n  const room = useRoom();\n  const subscribe = room.events.history.subscribe;\n  const canRedo = room.history.canRedo;\n  return useSyncExternalStore(subscribe, canRedo, canRedo);\n}\n\nfunction useSelf<P extends JsonObject, U extends BaseUserMeta>(): User<\n  P,\n  U\n> | null;\nfunction useSelf<P extends JsonObject, U extends BaseUserMeta, T>(\n  selector: (me: User<P, U>) => T,\n  isEqual?: (prev: T | null, curr: T | null) => boolean\n): T | null;\nfunction useSelf<P extends JsonObject, U extends BaseUserMeta, T>(\n  maybeSelector?: (me: User<P, U>) => T,\n  isEqual?: (prev: T | null, curr: T | null) => boolean\n): T | User<P, U> | null {\n  type Snapshot = User<P, U> | null;\n  type Selection = T | null;\n\n  const room = useRoom<P, never, U, never, never>();\n  const subscribe = room.events.self.subscribe;\n  const getSnapshot: () => Snapshot = room.getSelf;\n\n  const selector = maybeSelector ?? (identity as (me: User<P, U>) => T);\n  const wrappedSelector = useCallback(\n    (me: Snapshot): Selection => (me !== null ? selector(me) : null),\n    [selector]\n  );\n\n  const getServerSnapshot = alwaysNull;\n\n  return useSyncExternalStoreWithSelector(\n    subscribe,\n    getSnapshot,\n    getServerSnapshot,\n    wrappedSelector,\n    isEqual\n  );\n}\n\nfunction useMyPresence<P extends JsonObject>(): [\n  P,\n  (patch: Partial<P>, options?: { addToHistory: boolean }) => void,\n] {\n  const room = useRoom<P, never, never, never, never>();\n  const subscribe = room.events.myPresence.subscribe;\n  const getSnapshot = room.getPresence;\n  const presence = useSyncExternalStore(subscribe, getSnapshot, getSnapshot);\n  const setPresence = room.updatePresence;\n  return [presence, setPresence];\n}\n\nfunction useUpdateMyPresence<P extends JsonObject>(): (\n  patch: Partial<P>,\n  options?: { addToHistory: boolean }\n) => void {\n  return useRoom<P, never, never, never, never>().updatePresence;\n}\n\nfunction useOthers<\n  P extends JsonObject,\n  U extends BaseUserMeta,\n>(): readonly User<P, U>[];\nfunction useOthers<P extends JsonObject, U extends BaseUserMeta, T>(\n  selector: (others: readonly User<P, U>[]) => T,\n  isEqual?: (prev: T, curr: T) => boolean\n): T;\nfunction useOthers<P extends JsonObject, U extends BaseUserMeta, T>(\n  selector?: (others: readonly User<P, U>[]) => T,\n  isEqual?: (prev: T, curr: T) => boolean\n): T | readonly User<P, U>[] {\n  const room = useRoom<P, never, U, never, never>();\n  const subscribe = room.events.others.subscribe;\n  const getSnapshot = room.getOthers;\n  const getServerSnapshot = alwaysEmptyList;\n  return useSyncExternalStoreWithSelector(\n    subscribe,\n    getSnapshot,\n    getServerSnapshot,\n    selector ?? (identity as (others: readonly User<P, U>[]) => T),\n    isEqual\n  );\n}\n\nfunction useOthersMapped<P extends JsonObject, U extends BaseUserMeta, T>(\n  itemSelector: (other: User<P, U>) => T,\n  itemIsEqual?: (prev: T, curr: T) => boolean\n): ReadonlyArray<readonly [connectionId: number, data: T]> {\n  const wrappedSelector = useCallback(\n    (others: readonly User<P, U>[]) =>\n      others.map((other) => [other.connectionId, itemSelector(other)] as const),\n    [itemSelector]\n  );\n\n  const wrappedIsEqual = useCallback(\n    (\n      a: ReadonlyArray<readonly [connectionId: number, data: T]>,\n      b: ReadonlyArray<readonly [connectionId: number, data: T]>\n    ): boolean => {\n      const eq = itemIsEqual ?? Object.is;\n      return (\n        a.length === b.length &&\n        a.every((atuple, index) => {\n          // We know btuple always exist because we checked the array length on the previous line\n          const btuple = b[index]!;\n          return atuple[0] === btuple[0] && eq(atuple[1], btuple[1]);\n        })\n      );\n    },\n    [itemIsEqual]\n  );\n\n  return useOthers(wrappedSelector, wrappedIsEqual);\n}\n\n/**\n * Returns an array of connection IDs. This matches the values you'll get by\n * using the `useOthers()` hook.\n *\n * Roughly equivalent to:\n *   useOthers((others) => others.map(other => other.connectionId), shallow)\n *\n * This is useful in particular to implement efficiently rendering components\n * for each user in the room, e.g. cursors.\n *\n * @example\n * const ids = useOthersConnectionIds();\n * // [2, 4, 7]\n */\nfunction useOthersConnectionIds(): readonly number[] {\n  return useOthers(selectorFor_useOthersConnectionIds, shallow);\n}\n\nconst NOT_FOUND = Symbol();\n\ntype NotFound = typeof NOT_FOUND;\n\nfunction useOther<P extends JsonObject, U extends BaseUserMeta, T>(\n  connectionId: number,\n  selector: (other: User<P, U>) => T,\n  isEqual?: (prev: T, curr: T) => boolean\n): T {\n  const wrappedSelector = useCallback(\n    (others: readonly User<P, U>[]) => {\n      // TODO: Make this O(1) instead of O(n)?\n      const other = others.find((other) => other.connectionId === connectionId);\n      return other !== undefined ? selector(other) : NOT_FOUND;\n    },\n    [connectionId, selector]\n  );\n\n  const wrappedIsEqual = useCallback(\n    (prev: T | NotFound, curr: T | NotFound): boolean => {\n      if (prev === NOT_FOUND || curr === NOT_FOUND) {\n        return prev === curr;\n      }\n\n      const eq = isEqual ?? Object.is;\n      return eq(prev, curr);\n    },\n    [isEqual]\n  );\n\n  const other = useOthers(wrappedSelector, wrappedIsEqual);\n  if (other === NOT_FOUND) {\n    throw new Error(\n      `No such other user with connection id ${connectionId} exists`\n    );\n  }\n\n  return other;\n}\n\n/** @internal */\nfunction useMutableStorageRoot<S extends LsonObject>(): LiveObject<S> | null {\n  const room = useRoom<never, S, never, never, never>();\n  const subscribe = room.events.storageDidLoad.subscribeOnce;\n  const getSnapshot = room.getStorageSnapshot;\n  const getServerSnapshot = alwaysNull;\n  return useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n}\n\n// NOTE: This API exists for backward compatible reasons\nfunction useStorageRoot<S extends LsonObject>(): [root: LiveObject<S> | null] {\n  return [useMutableStorageRoot<S>()];\n}\n\nfunction useStorage<S extends LsonObject, T>(\n  selector: (root: ToImmutable<S>) => T,\n  isEqual?: (prev: T | null, curr: T | null) => boolean\n): T | null {\n  type Snapshot = ToImmutable<S> | null;\n  type Selection = T | null;\n\n  const room = useRoom<never, S, never, never, never>();\n  const rootOrNull = useMutableStorageRoot<S>();\n\n  const wrappedSelector = useCallback(\n    (rootOrNull: Snapshot): Selection =>\n      rootOrNull !== null ? selector(rootOrNull) : null,\n    [selector]\n  );\n\n  const subscribe = useCallback(\n    (onStoreChange: () => void) =>\n      rootOrNull !== null\n        ? room.subscribe(rootOrNull, onStoreChange, { isDeep: true })\n        : noop,\n    [room, rootOrNull]\n  );\n\n  const getSnapshot = useCallback((): Snapshot => {\n    if (rootOrNull === null) {\n      return null;\n    } else {\n      const root = rootOrNull;\n      const imm = root.toImmutable();\n      return imm;\n    }\n  }, [rootOrNull]);\n\n  const getServerSnapshot = alwaysNull;\n\n  return useSyncExternalStoreWithSelector(\n    subscribe,\n    getSnapshot,\n    getServerSnapshot,\n    wrappedSelector,\n    isEqual\n  );\n}\n\nfunction useMutation<\n  P extends JsonObject,\n  S extends LsonObject,\n  U extends BaseUserMeta,\n  E extends Json,\n  TM extends BaseMetadata,\n  CM extends BaseMetadata,\n  F extends (context: MutationContext<P, S, U>, ...args: any[]) => any,\n>(callback: F, deps: readonly unknown[]): OmitFirstArg<F> {\n  const room = useRoom<P, S, U, E, TM, CM>();\n  return useMemo(\n    () => {\n      return ((...args) =>\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        room.batch(() =>\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n          callback(\n            makeMutationContext<P, S, U, E, TM, CM>(room),\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n            ...args\n          )\n        )) as OmitFirstArg<F>;\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [room, ...deps]\n  );\n}\n\nfunction useThreads<TM extends BaseMetadata, CM extends BaseMetadata>(\n  options: UseThreadsOptions<TM> = {}\n): ThreadsAsyncResult<TM, CM> {\n  const { scrollOnLoad = true } = options;\n\n  const client = useClient();\n  const room = useRoom();\n  const { store, getOrCreateThreadsPollerForRoomId } = getRoomExtrasForClient<\n    TM,\n    CM\n  >(client);\n  const queryKey = makeRoomThreadsQueryKey(room.id, options.query);\n\n  const poller = getOrCreateThreadsPollerForRoomId(room.id);\n\n  useEffect(\n    () =>\n      void store.outputs.loadingRoomThreads\n        .getOrCreate(queryKey)\n        .waitUntilLoaded()\n\n    // NOTE: Deliberately *not* using a dependency array here!\n    //\n    // It is important to call waitUntil on *every* render.\n    // This is harmless though, on most renders, except:\n    // 1. The very first render, in which case we'll want to trigger the initial page fetch.\n    // 2. All other subsequent renders now \"just\" return the same promise (a quick operation).\n    // 3. If ever the promise would fail, then after 5 seconds it would reset, and on the very\n    //    *next* render after that, a *new* fetch/promise will get created.\n  );\n\n  useEffect(() => {\n    poller.inc();\n    poller.pollNowIfStale();\n    return () => poller.dec();\n  }, [poller]);\n\n  const result = useSignal(\n    store.outputs.loadingRoomThreads.getOrCreate(queryKey).signal\n  );\n\n  useScrollToCommentOnLoadEffect(scrollOnLoad, result);\n  return result;\n}\n\nfunction useSearchComments<TM extends BaseMetadata>(\n  options: UseSearchCommentsOptions<TM>\n): SearchCommentsAsyncResult {\n  const [result, setResult] = useState<SearchCommentsAsyncResult>({\n    isLoading: true,\n  });\n\n  const currentRequestInfo = useRef<{\n    id: number;\n    controller: AbortController;\n  } | null>(null);\n\n  const timeout = useRef<number | null>(null);\n\n  const client = useClient();\n  const room = useRoom();\n\n  const queryKey = stableStringify([room.id, options.query]);\n\n  useEffect(() => {\n    const currentRequestId = (currentRequestInfo.current?.id ?? 0) + 1;\n    const controller = new AbortController();\n\n    currentRequestInfo.current = { id: currentRequestId, controller };\n    setResult((result) => {\n      if (result.isLoading) return result;\n      // **NOTE**: Should we keep the old result but only set loading to true.\n      // All our other hooks (useThreads) is defined in the way so that if the result is loading, the result is undefined.\n      return { isLoading: true };\n    });\n\n    timeout.current = window.setTimeout(() => {\n      client[kInternal].httpClient\n        .searchComments(\n          {\n            roomId: room.id,\n            query: options.query,\n          },\n          { signal: controller.signal }\n        )\n        .then(({ data }) => {\n          // If the request was aborted, we do not update the result received from this request as it may be stale.\n          if (controller.signal.aborted) return;\n\n          // If a new request was made while this request was in flight, we do not update the result received from this request as it may be stale.\n          if (currentRequestInfo.current?.id !== currentRequestId) return;\n\n          setResult({ isLoading: false, results: data });\n\n          // Clear the current request info to avoid stale results from the next request.\n          currentRequestInfo.current = null;\n        })\n        .catch((err) => {\n          // If the request was aborted, we do not update the result received from this request as it may be stale.\n          if (controller.signal.aborted) return;\n\n          // If a new request was made while this request was in flight, we do not update the result received from this request as it may be stale.\n          if (currentRequestInfo.current?.id !== currentRequestId) return;\n\n          setResult({ isLoading: false, error: err as Error });\n\n          // Clear the current request info to avoid stale results from the next request.\n          currentRequestInfo.current = null;\n        });\n    }, 300 /* debounce time */);\n\n    return () => {\n      // If there is a timeout in progress, cancel it before we initiate a new one\n      if (timeout.current !== null) {\n        window.clearTimeout(timeout.current);\n      }\n\n      // Cancel any in-flight request and initiate a new request\n      if (currentRequestInfo.current !== null) {\n        currentRequestInfo.current.controller.abort();\n      }\n    };\n\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [queryKey, client, room.id]);\n\n  return result;\n}\n\nfunction useCreateThread<TM extends BaseMetadata, CM extends BaseMetadata>(): (\n  options: CreateThreadOptions<TM, CM>\n) => ThreadData<TM, CM> {\n  return useCreateRoomThread(useRoom().id);\n}\n\n/**\n * @private\n */\nfunction useCreateRoomThread<TM extends BaseMetadata, CM extends BaseMetadata>(\n  roomId: string\n): (options: CreateThreadOptions<TM, CM>) => ThreadData<TM, CM> {\n  const client = useClient();\n\n  return useCallback(\n    (options: CreateThreadOptions<TM, CM>): ThreadData<TM, CM> => {\n      const body = options.body;\n      const metadata = options.metadata ?? ({} as TM);\n      const commentMetadata = options.commentMetadata ?? ({} as CM);\n      const attachments = options.attachments;\n\n      const threadId = createThreadId();\n      const commentId = createCommentId();\n      const createdAt = new Date();\n\n      const newComment: CommentData<CM> = {\n        id: commentId,\n        threadId,\n        roomId,\n        createdAt,\n        type: \"comment\",\n        userId: getCurrentUserId(client),\n        body,\n        reactions: [],\n        attachments: attachments ?? [],\n        metadata: commentMetadata,\n      };\n      const newThread: ThreadData<TM, CM> = {\n        id: threadId,\n        type: \"thread\",\n        createdAt,\n        updatedAt: createdAt,\n        roomId,\n        metadata,\n        comments: [newComment],\n        resolved: false,\n      };\n\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"create-thread\",\n        thread: newThread,\n        roomId,\n      });\n\n      const attachmentIds = attachments?.map((attachment) => attachment.id);\n\n      client[kInternal].httpClient\n        .createThread({\n          roomId,\n          threadId,\n          commentId,\n          body,\n          metadata,\n          commentMetadata,\n          attachmentIds,\n        })\n        .then(\n          (thread) => {\n            // Replace the optimistic update by the real thing\n            store.createThread(optimisticId, thread);\n          },\n          (err: Error) =>\n            onMutationFailure(\n              optimisticId,\n              {\n                type: \"CREATE_THREAD_ERROR\",\n                roomId,\n                threadId,\n                commentId,\n                body,\n                metadata,\n                commentMetadata,\n              },\n              err\n            )\n        );\n\n      return newThread;\n    },\n    [client, roomId]\n  );\n}\n\nfunction useDeleteThread(): (threadId: string) => void {\n  return useDeleteRoomThread(useRoom().id);\n}\n\nfunction useDeleteRoomThread(roomId: string): (threadId: string) => void {\n  const client = useClient();\n  return useCallback(\n    (threadId: string): void => {\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n\n      const userId = getCurrentUserId(client);\n\n      const existing = store.outputs.threads.get().get(threadId);\n      if (existing?.comments?.[0]?.userId !== userId) {\n        throw new Error(\"Only the thread creator can delete the thread\");\n      }\n\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"delete-thread\",\n        roomId,\n        threadId,\n        deletedAt: new Date(),\n      });\n\n      client[kInternal].httpClient.deleteThread({ roomId, threadId }).then(\n        () => {\n          // Replace the optimistic update by the real thing\n          store.deleteThread(threadId, optimisticId);\n        },\n        (err: Error) =>\n          onMutationFailure(\n            optimisticId,\n            { type: \"DELETE_THREAD_ERROR\", roomId, threadId },\n            err\n          )\n      );\n    },\n    [client, roomId]\n  );\n}\n\nfunction useEditThreadMetadata<TM extends BaseMetadata>() {\n  return useEditRoomThreadMetadata<TM>(useRoom().id);\n}\n\nfunction useEditRoomThreadMetadata<TM extends BaseMetadata>(roomId: string) {\n  const client = useClient();\n  return useCallback(\n    (options: EditThreadMetadataOptions<TM>): void => {\n      if (!options.metadata) {\n        return;\n      }\n\n      const threadId = options.threadId;\n      const metadata = options.metadata;\n      const updatedAt = new Date();\n\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"edit-thread-metadata\",\n        metadata,\n        threadId,\n        updatedAt,\n      });\n\n      client[kInternal].httpClient\n        .editThreadMetadata({ roomId, threadId, metadata })\n        .then(\n          (metadata) =>\n            // Replace the optimistic update by the real thing\n            store.patchThread(threadId, optimisticId, { metadata }, updatedAt),\n          (err: Error) =>\n            onMutationFailure(\n              optimisticId,\n              {\n                type: \"EDIT_THREAD_METADATA_ERROR\",\n                roomId,\n                threadId,\n                metadata,\n              },\n              err\n            )\n        );\n    },\n    [client, roomId]\n  );\n}\n\nfunction useEditCommentMetadata<CM extends BaseMetadata>() {\n  return useEditRoomCommentMetadata<CM>(useRoom().id);\n}\n\nfunction useEditRoomCommentMetadata<CM extends BaseMetadata>(roomId: string) {\n  const client = useClient();\n  return useCallback(\n    (options: EditCommentMetadataOptions<CM>): void => {\n      if (!options.metadata) {\n        return;\n      }\n\n      const threadId = options.threadId;\n      const commentId = options.commentId;\n      const metadata = options.metadata;\n      const updatedAt = new Date();\n\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"edit-comment-metadata\",\n        threadId,\n        commentId,\n        metadata,\n        updatedAt,\n      });\n\n      client[kInternal].httpClient\n        .editCommentMetadata({ roomId, threadId, commentId, metadata })\n        .then(\n          (updatedMetadata) =>\n            // Replace the optimistic update by the real thing\n            store.editCommentMetadata(\n              threadId,\n              commentId,\n              optimisticId,\n              updatedMetadata,\n              updatedAt\n            ),\n          (err: Error) =>\n            onMutationFailure(\n              optimisticId,\n              {\n                type: \"EDIT_COMMENT_METADATA_ERROR\",\n                roomId,\n                threadId,\n                commentId,\n                metadata,\n              },\n              err\n            )\n        );\n    },\n    [client, roomId]\n  );\n}\n\n/**\n * Returns a function that adds a comment to a thread.\n *\n * @example\n * const createComment = useCreateComment();\n * createComment({ threadId: \"th_xxx\", body: {} });\n */\nfunction useCreateComment<CM extends BaseMetadata>(): (\n  options: CreateCommentOptions<CM>\n) => CommentData<CM> {\n  return useCreateRoomComment(useRoom().id);\n}\n\n/**\n * @private\n */\nfunction useCreateRoomComment<CM extends BaseMetadata>(\n  roomId: string\n): (options: CreateCommentOptions<CM>) => CommentData<CM> {\n  const client = useClient();\n  return useCallback(\n    (options: CreateCommentOptions<CM>): CommentData<CM> => {\n      const { threadId, body } = options;\n      const metadata = options.metadata ?? ({} as CM);\n      const attachments = options.attachments ?? [];\n      const commentId = createCommentId();\n      const createdAt = new Date();\n\n      const comment: CommentData<CM> = {\n        id: commentId,\n        threadId,\n        roomId,\n        type: \"comment\",\n        createdAt,\n        userId: getCurrentUserId(client),\n        body,\n        reactions: [],\n        attachments: attachments ?? [],\n        metadata,\n      };\n\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"create-comment\",\n        comment,\n      });\n\n      const attachmentIds = attachments?.map((attachment) => attachment.id);\n\n      client[kInternal].httpClient\n        .createComment({\n          roomId,\n          threadId,\n          commentId,\n          body,\n          metadata,\n          attachmentIds,\n        })\n        .then(\n          (newComment) => {\n            // Replace the optimistic update by the real thing\n            store.createComment(newComment, optimisticId);\n          },\n          (err: Error) =>\n            onMutationFailure(\n              optimisticId,\n              {\n                type: \"CREATE_COMMENT_ERROR\",\n                roomId,\n                threadId,\n                commentId,\n                body,\n                metadata,\n              },\n              err\n            )\n        );\n\n      return comment;\n    },\n    [client, roomId]\n  );\n}\n\n/**\n * Returns a function that edits a comment.\n *\n * @example\n * const editComment = useEditComment()\n * editComment({ threadId: \"th_xxx\", commentId: \"cm_xxx\", body: {} })\n */\nfunction useEditComment<CM extends BaseMetadata>(): (\n  options: EditCommentOptions<CM>\n) => void {\n  return useEditRoomComment<CM>(useRoom().id);\n}\n\n/**\n * @private\n */\nfunction useEditRoomComment<CM extends BaseMetadata>(\n  roomId: string\n): (options: EditCommentOptions<CM>) => void {\n  const client = useClient();\n  return useCallback(\n    ({\n      threadId,\n      commentId,\n      body,\n      attachments,\n      metadata,\n    }: EditCommentOptions<CM>): void => {\n      const editedAt = new Date();\n\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const existing = store.outputs.threads.get().getEvenIfDeleted(threadId);\n\n      if (existing === undefined) {\n        console.warn(\n          `Internal unexpected behavior. Cannot edit comment in thread \"${threadId}\" because the thread does not exist in the cache.`\n        );\n        return;\n      }\n\n      const comment = existing.comments.find(\n        (comment) => comment.id === commentId\n      );\n\n      if (comment === undefined || comment.deletedAt !== undefined) {\n        console.warn(\n          `Internal unexpected behavior. Cannot edit comment \"${commentId}\" in thread \"${threadId}\" because the comment does not exist in the cache.`\n        );\n        return;\n      }\n\n      const updatedMetadata =\n        metadata !== undefined\n          ? {\n              ...comment.metadata,\n              ...metadata,\n            }\n          : comment.metadata;\n\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"edit-comment\",\n        comment: {\n          ...comment,\n          editedAt,\n          body,\n          attachments: attachments ?? [],\n          metadata: updatedMetadata,\n        },\n      });\n\n      const attachmentIds = attachments?.map((attachment) => attachment.id);\n\n      client[kInternal].httpClient\n        .editComment({\n          roomId,\n          threadId,\n          commentId,\n          body,\n          attachmentIds,\n          metadata,\n        })\n        .then(\n          (editedComment) => {\n            // Replace the optimistic update by the real thing\n            store.editComment(threadId, optimisticId, editedComment);\n          },\n          (err: Error) =>\n            onMutationFailure(\n              optimisticId,\n              {\n                type: \"EDIT_COMMENT_ERROR\",\n                roomId,\n                threadId,\n                commentId,\n                body,\n                metadata: updatedMetadata,\n              },\n              err\n            )\n        );\n    },\n    [client, roomId]\n  );\n}\n\n/**\n * Returns a function that deletes a comment.\n * If it is the last non-deleted comment, the thread also gets deleted.\n *\n * @example\n * const deleteComment = useDeleteComment();\n * deleteComment({ threadId: \"th_xxx\", commentId: \"cm_xxx\" })\n */\nfunction useDeleteComment() {\n  return useDeleteRoomComment(useRoom().id);\n}\n\n/**\n * @private\n */\nfunction useDeleteRoomComment(roomId: string) {\n  const client = useClient();\n\n  return useCallback(\n    ({ threadId, commentId }: DeleteCommentOptions): void => {\n      const deletedAt = new Date();\n\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"delete-comment\",\n        threadId,\n        commentId,\n        deletedAt,\n        roomId,\n      });\n\n      client[kInternal].httpClient\n        .deleteComment({ roomId, threadId, commentId })\n        .then(\n          () => {\n            // Replace the optimistic update by the real thing\n            store.deleteComment(threadId, optimisticId, commentId, deletedAt);\n          },\n          (err: Error) =>\n            onMutationFailure(\n              optimisticId,\n              { type: \"DELETE_COMMENT_ERROR\", roomId, threadId, commentId },\n              err\n            )\n        );\n    },\n    [client, roomId]\n  );\n}\n\nfunction useAddReaction() {\n  return useAddRoomCommentReaction(useRoom().id);\n}\n\n/**\n * @private\n */\nfunction useAddRoomCommentReaction(roomId: string) {\n  const client = useClient();\n  return useCallback(\n    ({ threadId, commentId, emoji }: CommentReactionOptions): void => {\n      const createdAt = new Date();\n      const userId = getCurrentUserId(client);\n\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"add-reaction\",\n        threadId,\n        commentId,\n        reaction: {\n          emoji,\n          userId,\n          createdAt,\n        },\n      });\n\n      client[kInternal].httpClient\n        .addReaction({ roomId, threadId, commentId, emoji })\n        .then(\n          (addedReaction) => {\n            // Replace the optimistic update by the real thing\n            store.addReaction(\n              threadId,\n              optimisticId,\n              commentId,\n              addedReaction,\n              createdAt\n            );\n          },\n          (err: Error) =>\n            onMutationFailure(\n              optimisticId,\n              {\n                type: \"ADD_REACTION_ERROR\",\n                roomId,\n                threadId,\n                commentId,\n                emoji,\n              },\n              err\n            )\n        );\n    },\n    [client, roomId]\n  );\n}\n\n/**\n * Returns a function that removes a reaction on a comment.\n *\n * @example\n * const removeReaction = useRemoveReaction();\n * removeReaction({ threadId: \"th_xxx\", commentId: \"cm_xxx\", emoji: \"\" })\n */\nfunction useRemoveReaction() {\n  return useRemoveRoomCommentReaction(useRoom().id);\n}\n\n/**\n * @private\n */\nfunction useRemoveRoomCommentReaction(roomId: string) {\n  const client = useClient();\n  return useCallback(\n    ({ threadId, commentId, emoji }: CommentReactionOptions): void => {\n      const userId = getCurrentUserId(client);\n\n      const removedAt = new Date();\n\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"remove-reaction\",\n        threadId,\n        commentId,\n        emoji,\n        userId,\n        removedAt,\n      });\n\n      client[kInternal].httpClient\n        .removeReaction({ roomId, threadId, commentId, emoji })\n        .then(\n          () => {\n            // Replace the optimistic update by the real thing\n            store.removeReaction(\n              threadId,\n              optimisticId,\n              commentId,\n              emoji,\n              userId,\n              removedAt\n            );\n          },\n          (err: Error) =>\n            onMutationFailure(\n              optimisticId,\n              {\n                type: \"REMOVE_REACTION_ERROR\",\n                roomId,\n                threadId,\n                commentId,\n                emoji,\n              },\n              err\n            )\n        );\n    },\n    [client, roomId]\n  );\n}\n/**\n * Returns a function that marks a thread as read.\n *\n * @example\n * const markThreadAsRead = useMarkThreadAsRead();\n * markThreadAsRead(\"th_xxx\");\n */\nfunction useMarkThreadAsRead() {\n  return useMarkRoomThreadAsRead(useRoom().id);\n}\n\n/**\n * @private\n */\nfunction useMarkRoomThreadAsRead(roomId: string) {\n  const client = useClient();\n  return useCallback(\n    (threadId: string) => {\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const inboxNotification = Object.values(\n        store.outputs.notifications.get().notificationsById\n      ).find(\n        (inboxNotification) =>\n          inboxNotification.kind === \"thread\" &&\n          inboxNotification.threadId === threadId\n      );\n\n      if (!inboxNotification) return;\n\n      const now = new Date();\n\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"mark-inbox-notification-as-read\",\n        inboxNotificationId: inboxNotification.id,\n        readAt: now,\n      });\n\n      client[kInternal].httpClient\n        .markRoomInboxNotificationAsRead({\n          roomId,\n          inboxNotificationId: inboxNotification.id,\n        })\n        .then(\n          () => {\n            // Replace the optimistic update by the real thing\n            store.markInboxNotificationRead(\n              inboxNotification.id,\n              now,\n              optimisticId\n            );\n          },\n          (err: Error) => {\n            onMutationFailure(\n              optimisticId,\n              {\n                type: \"MARK_INBOX_NOTIFICATION_AS_READ_ERROR\",\n                roomId,\n                inboxNotificationId: inboxNotification.id,\n              },\n              err\n            );\n            return;\n          }\n        );\n    },\n    [client, roomId]\n  );\n}\n\n/**\n * Returns a function that marks a thread as resolved.\n *\n * @example\n * const markThreadAsResolved = useMarkThreadAsResolved();\n * markThreadAsResolved(\"th_xxx\");\n */\nfunction useMarkThreadAsResolved() {\n  return useMarkRoomThreadAsResolved(useRoom().id);\n}\n\n/**\n * @private\n */\nfunction useMarkRoomThreadAsResolved(roomId: string) {\n  const client = useClient();\n  return useCallback(\n    (threadId: string) => {\n      const updatedAt = new Date();\n\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"mark-thread-as-resolved\",\n        threadId,\n        updatedAt,\n      });\n\n      client[kInternal].httpClient\n        .markThreadAsResolved({ roomId, threadId })\n        .then(\n          () => {\n            // Replace the optimistic update by the real thing\n            store.patchThread(\n              threadId,\n              optimisticId,\n              { resolved: true },\n              updatedAt\n            );\n          },\n          (err: Error) =>\n            onMutationFailure(\n              optimisticId,\n              { type: \"MARK_THREAD_AS_RESOLVED_ERROR\", roomId, threadId },\n              err\n            )\n        );\n    },\n    [client, roomId]\n  );\n}\n\n/**\n * Returns a function that marks a thread as unresolved.\n *\n * @example\n * const markThreadAsUnresolved = useMarkThreadAsUnresolved();\n * markThreadAsUnresolved(\"th_xxx\");\n */\nfunction useMarkThreadAsUnresolved() {\n  return useMarkRoomThreadAsUnresolved(useRoom().id);\n}\n\n/**\n * @private\n */\nfunction useMarkRoomThreadAsUnresolved(roomId: string) {\n  const client = useClient();\n  return useCallback(\n    (threadId: string) => {\n      const updatedAt = new Date();\n\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"mark-thread-as-unresolved\",\n        threadId,\n        updatedAt,\n      });\n\n      client[kInternal].httpClient\n        .markThreadAsUnresolved({ roomId, threadId })\n        .then(\n          () => {\n            // Replace the optimistic update by the real thing\n            store.patchThread(\n              threadId,\n              optimisticId,\n              { resolved: false },\n              updatedAt\n            );\n          },\n          (err: Error) =>\n            onMutationFailure(\n              optimisticId,\n              { type: \"MARK_THREAD_AS_UNRESOLVED_ERROR\", roomId, threadId },\n              err\n            )\n        );\n    },\n    [client, roomId]\n  );\n}\n\n/**\n * Returns a function that subscribes the user to a thread.\n *\n * @example\n * const subscribeToThread = useSubscribeToThread();\n * subscribeToThread(\"th_xxx\");\n */\nfunction useSubscribeToThread() {\n  return useSubscribeToRoomThread(useRoom().id);\n}\n\n/**\n * @private\n */\nfunction useSubscribeToRoomThread(roomId: string) {\n  const client = useClient();\n\n  return useCallback(\n    (threadId: string) => {\n      const subscribedAt = new Date();\n\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"subscribe-to-thread\",\n        threadId,\n        subscribedAt,\n      });\n\n      client[kInternal].httpClient.subscribeToThread({ roomId, threadId }).then(\n        (subscription) => {\n          store.createSubscription(subscription, optimisticId);\n        },\n        (err: Error) =>\n          onMutationFailure(\n            optimisticId,\n            { type: \"SUBSCRIBE_TO_THREAD_ERROR\", roomId, threadId },\n            err\n          )\n      );\n    },\n    [client, roomId]\n  );\n}\n\n/**\n * Returns a function that unsubscribes the user from a thread.\n *\n * @example\n * const unsubscribeFromThread = useUnsubscribeFromThread();\n * unsubscribeFromThread(\"th_xxx\");\n */\nfunction useUnsubscribeFromThread() {\n  return useUnsubscribeFromRoomThread(useRoom().id);\n}\n\n/**\n * @private\n */\nfunction useUnsubscribeFromRoomThread(roomId: string) {\n  const client = useClient();\n\n  return useCallback(\n    (threadId: string) => {\n      const unsubscribedAt = new Date();\n\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"unsubscribe-from-thread\",\n        threadId,\n        unsubscribedAt,\n      });\n\n      client[kInternal].httpClient\n        .unsubscribeFromThread({ roomId, threadId })\n        .then(\n          () => {\n            store.deleteSubscription(\n              getSubscriptionKey(\"thread\", threadId),\n              optimisticId\n            );\n          },\n          (err: Error) =>\n            onMutationFailure(\n              optimisticId,\n              { type: \"UNSUBSCRIBE_FROM_THREAD_ERROR\", roomId, threadId },\n              err\n            )\n        );\n    },\n    [client, roomId]\n  );\n}\n\n/**\n * Returns the subscription status of a thread, methods to update it, and when\n * the thread was last read.\n *\n * @example\n * const { status, subscribe, unsubscribe, unreadSince } = useThreadSubscription(\"th_xxx\");\n */\nfunction useThreadSubscription(threadId: string): ThreadSubscription {\n  return useRoomThreadSubscription(useRoom().id, threadId);\n}\n\n/**\n * @private\n */\nfunction useRoomThreadSubscription(\n  roomId: string,\n  threadId: string\n): ThreadSubscription {\n  const client = useClient();\n  const { store } = getRoomExtrasForClient(client);\n  const subscriptionKey = useMemo(\n    () => getSubscriptionKey(\"thread\", threadId),\n    [threadId]\n  );\n  const subscribeToThread = useSubscribeToRoomThread(roomId);\n  const unsubscribeFromThread = useUnsubscribeFromRoomThread(roomId);\n  const subscribe = useCallback(\n    () => subscribeToThread(threadId),\n    [subscribeToThread, threadId]\n  );\n  const unsubscribe = useCallback(\n    () => unsubscribeFromThread(threadId),\n    [unsubscribeFromThread, threadId]\n  );\n\n  const signal = store.outputs.threadSubscriptions;\n\n  const selector = useCallback(\n    (state: SignalType<typeof signal>): ThreadSubscription => {\n      const subscription = state.subscriptions[subscriptionKey];\n      const notification = state.notifications.find(\n        (inboxNotification) =>\n          inboxNotification.kind === \"thread\" &&\n          inboxNotification.threadId === threadId\n      );\n\n      if (subscription === undefined) {\n        return { status: \"not-subscribed\", subscribe, unsubscribe };\n      }\n\n      return {\n        status: \"subscribed\",\n        unreadSince: notification?.readAt ?? null,\n        subscribe,\n        unsubscribe,\n      };\n    },\n    [subscriptionKey, threadId, subscribe, unsubscribe]\n  );\n\n  return useSignal(signal, selector, shallow);\n}\n\n/**\n * Returns the user's subscription settings for the current room\n * and a function to update them.\n *\n * @example\n * const [{ settings }, updateSettings] = useRoomSubscriptionSettings();\n */\nfunction useRoomSubscriptionSettings(): [\n  RoomSubscriptionSettingsAsyncResult,\n  (settings: Partial<RoomSubscriptionSettings>) => void,\n] {\n  const updateRoomSubscriptionSettings = useUpdateRoomSubscriptionSettings();\n  const client = useClient();\n  const room = useRoom();\n  const { store, getOrCreateSubscriptionSettingsPollerForRoomId } =\n    getRoomExtrasForClient(client);\n\n  const poller = getOrCreateSubscriptionSettingsPollerForRoomId(room.id);\n\n  useEffect(\n    () =>\n      void store.outputs.roomSubscriptionSettingsByRoomId\n        .getOrCreate(room.id)\n        .waitUntilLoaded()\n\n    // NOTE: Deliberately *not* using a dependency array here!\n    //\n    // It is important to call waitUntil on *every* render.\n    // This is harmless though, on most renders, except:\n    // 1. The very first render, in which case we'll want to trigger the initial page fetch.\n    // 2. All other subsequent renders now \"just\" return the same promise (a quick operation).\n    // 3. If ever the promise would fail, then after 5 seconds it would reset, and on the very\n    //    *next* render after that, a *new* fetch/promise will get created.\n  );\n\n  useEffect(() => {\n    poller.inc();\n    poller.pollNowIfStale();\n    return () => {\n      poller.dec();\n    };\n  }, [poller]);\n\n  const settings = useSignal(\n    store.outputs.roomSubscriptionSettingsByRoomId.getOrCreate(room.id).signal\n  );\n\n  return useMemo(() => {\n    return [settings, updateRoomSubscriptionSettings];\n  }, [settings, updateRoomSubscriptionSettings]);\n}\n\n/**\n * Returns the user's subscription settings for the current room\n * and a function to update them.\n *\n * @example\n * const [{ settings }, updateSettings] = useRoomSubscriptionSettings();\n */\nfunction useRoomSubscriptionSettingsSuspense(): [\n  RoomSubscriptionSettingsAsyncSuccess,\n  (settings: Partial<RoomSubscriptionSettings>) => void,\n] {\n  // Throw error if we're calling this hook server side\n  ensureNotServerSide();\n\n  const client = useClient();\n  const store = getRoomExtrasForClient(client).store;\n  const room = useRoom();\n\n  // Suspend until there are at least some inbox notifications\n  use(\n    store.outputs.roomSubscriptionSettingsByRoomId\n      .getOrCreate(room.id)\n      .waitUntilLoaded()\n  );\n\n  // We're in a Suspense world here, and as such, the useRoomSubscriptionSettings()\n  // hook is expected to only return success results when we're here.\n  const [settings, updateRoomSubscriptionSettings] =\n    useRoomSubscriptionSettings();\n  assert(!settings.error, \"Did not expect error\");\n  assert(!settings.isLoading, \"Did not expect loading\");\n\n  return useMemo(() => {\n    return [settings, updateRoomSubscriptionSettings];\n  }, [settings, updateRoomSubscriptionSettings]);\n}\n\n/**\n * Returns the version data bianry for a given version\n *\n * @example\n * const {data} = useHistoryVersionData(versionId);\n */\nfunction useHistoryVersionData(\n  versionId: string\n): HistoryVersionDataAsyncResult {\n  const [state, setState] = useState<HistoryVersionDataAsyncResult>({\n    isLoading: true,\n  });\n  const room = useRoom();\n  useEffect(() => {\n    setState({ isLoading: true });\n    const load = async () => {\n      try {\n        const response = await room[kInternal].getTextVersion(versionId);\n        const buffer = await response.arrayBuffer();\n        const data = new Uint8Array(buffer);\n        setState({\n          isLoading: false,\n          data,\n        });\n      } catch (error) {\n        setState({\n          isLoading: false,\n          error:\n            error instanceof Error\n              ? error\n              : new Error(\n                  \"An unknown error occurred while loading this version\"\n                ),\n        });\n      }\n    };\n    void load();\n  }, [room, versionId]);\n  return state;\n}\n\n/**\n * (Private beta) Returns a history of versions of the current room.\n *\n * @example\n * const { versions, error, isLoading } = useHistoryVersions();\n */\nfunction useHistoryVersions(): HistoryVersionsAsyncResult {\n  const client = useClient();\n  const room = useRoom();\n\n  const { store, getOrCreateVersionsPollerForRoomId } =\n    getRoomExtrasForClient(client);\n\n  const poller = getOrCreateVersionsPollerForRoomId(room.id);\n\n  useEffect(() => {\n    poller.inc();\n    poller.pollNowIfStale();\n    return () => poller.dec();\n  }, [poller]);\n\n  useEffect(\n    () =>\n      void store.outputs.versionsByRoomId.getOrCreate(room.id).waitUntilLoaded()\n\n    // NOTE: Deliberately *not* using a dependency array here!\n    //\n    // It is important to call waitUntil on *every* render.\n    // This is harmless though, on most renders, except:\n    // 1. The very first render, in which case we'll want to trigger the initial page fetch.\n    // 2. All other subsequent renders now \"just\" return the same promise (a quick operation).\n    // 3. If ever the promise would fail, then after 5 seconds it would reset, and on the very\n    //    *next* render after that, a *new* fetch/promise will get created.\n  );\n\n  return useSignal(store.outputs.versionsByRoomId.getOrCreate(room.id).signal);\n}\n\n/**\n * (Private beta) Returns a history of versions of the current room.\n *\n * @example\n * const { versions } = useHistoryVersions();\n */\nfunction useHistoryVersionsSuspense(): HistoryVersionsAsyncSuccess {\n  // Throw error if we're calling this hook server side\n  ensureNotServerSide();\n\n  const client = useClient();\n  const room = useRoom();\n  const store = getRoomExtrasForClient(client).store;\n\n  use(store.outputs.versionsByRoomId.getOrCreate(room.id).waitUntilLoaded());\n\n  const result = useHistoryVersions();\n  assert(!result.error, \"Did not expect error\");\n  assert(!result.isLoading, \"Did not expect loading\");\n  return result;\n}\n\n/**\n * Returns a function that updates the user's subscription settings\n * for the current room.\n *\n * @example\n * const updateRoomSubscriptionSettings = useUpdateRoomSubscriptionSettings();\n * updateRoomSubscriptionSettings({ threads: \"all\" });\n */\nfunction useUpdateRoomSubscriptionSettings() {\n  const client = useClient();\n  const room = useRoom();\n  return useCallback(\n    (settings: Partial<RoomSubscriptionSettings>) => {\n      const { store, onMutationFailure, pollThreadsForRoomId } =\n        getRoomExtrasForClient(client);\n      const userId = getCurrentUserId(client);\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"update-room-subscription-settings\",\n        roomId: room.id,\n        userId,\n        settings,\n      });\n\n      room.updateSubscriptionSettings(settings).then(\n        (udpatedSettings) => {\n          // Replace the optimistic update by the real thing\n          store.updateRoomSubscriptionSettings(\n            room.id,\n            optimisticId,\n            udpatedSettings\n          );\n\n          // If the `threads` settings are changed, trigger a polling to update thread subscriptions\n          if (settings.threads) {\n            pollThreadsForRoomId(room.id);\n          }\n        },\n        (err: Error) =>\n          onMutationFailure(\n            optimisticId,\n            {\n              type: \"UPDATE_ROOM_SUBSCRIPTION_SETTINGS_ERROR\",\n              roomId: room.id,\n            },\n            err\n          )\n      );\n    },\n    [client, room]\n  );\n}\n\nfunction useSuspendUntilPresenceReady(): void {\n  // Throw error if we're calling this hook server side\n  ensureNotServerSide();\n\n  const room = useRoom();\n  use(room.waitUntilPresenceReady());\n}\n\nfunction useSelfSuspense<P extends JsonObject, U extends BaseUserMeta>(): User<\n  P,\n  U\n>;\nfunction useSelfSuspense<P extends JsonObject, U extends BaseUserMeta, T>(\n  selector: (me: User<P, U>) => T,\n  isEqual?: (prev: T, curr: T) => boolean\n): T;\nfunction useSelfSuspense<P extends JsonObject, U extends BaseUserMeta, T>(\n  selector?: (me: User<P, U>) => T,\n  isEqual?: (prev: T, curr: T) => boolean\n): T | User<P, U> {\n  useSuspendUntilPresenceReady();\n  return useSelf(\n    selector as (me: User<P, U>) => T,\n    isEqual as (prev: T | null, curr: T | null) => boolean\n  ) as T | User<P, U>;\n}\n\nfunction useOthersSuspense<\n  P extends JsonObject,\n  U extends BaseUserMeta,\n>(): readonly User<P, U>[];\nfunction useOthersSuspense<P extends JsonObject, U extends BaseUserMeta, T>(\n  selector: (others: readonly User<P, U>[]) => T,\n  isEqual?: (prev: T, curr: T) => boolean\n): T;\nfunction useOthersSuspense<P extends JsonObject, U extends BaseUserMeta, T>(\n  selector?: (others: readonly User<P, U>[]) => T,\n  isEqual?: (prev: T, curr: T) => boolean\n): T | readonly User<P, U>[] {\n  useSuspendUntilPresenceReady();\n  return useOthers(\n    selector as (others: readonly User<P, U>[]) => T,\n    isEqual as (prev: T, curr: T) => boolean\n  ) as T | readonly User<P, U>[];\n}\n\n/**\n * Returns an array of connection IDs. This matches the values you'll get by\n * using the `useOthers()` hook.\n *\n * Roughly equivalent to:\n *   useOthers((others) => others.map(other => other.connectionId), shallow)\n *\n * This is useful in particular to implement efficiently rendering components\n * for each user in the room, e.g. cursors.\n *\n * @example\n * const ids = useOthersConnectionIds();\n * // [2, 4, 7]\n */\nfunction useOthersConnectionIdsSuspense(): readonly number[] {\n  useSuspendUntilPresenceReady();\n  return useOthersConnectionIds();\n}\n\nfunction useOthersMappedSuspense<\n  P extends JsonObject,\n  U extends BaseUserMeta,\n  T,\n>(\n  itemSelector: (other: User<P, U>) => T,\n  itemIsEqual?: (prev: T, curr: T) => boolean\n): ReadonlyArray<readonly [connectionId: number, data: T]> {\n  useSuspendUntilPresenceReady();\n  return useOthersMapped(itemSelector, itemIsEqual);\n}\n\nfunction useOtherSuspense<P extends JsonObject, U extends BaseUserMeta, T>(\n  connectionId: number,\n  selector: (other: User<P, U>) => T,\n  isEqual?: (prev: T, curr: T) => boolean\n): T {\n  useSuspendUntilPresenceReady();\n  return useOther(connectionId, selector, isEqual);\n}\n\nfunction useSuspendUntilStorageReady(): void {\n  // Throw error if we're calling this hook server side\n  ensureNotServerSide();\n\n  const room = useRoom();\n  use(room.waitUntilStorageReady());\n}\n\nfunction useStorageSuspense<S extends LsonObject, T>(\n  selector: (root: ToImmutable<S>) => T,\n  isEqual?: (prev: T, curr: T) => boolean\n): T {\n  useSuspendUntilStorageReady();\n  return useStorage(\n    selector,\n    isEqual as (prev: T | null, curr: T | null) => boolean\n  ) as T;\n}\n\nfunction useThreadsSuspense<TM extends BaseMetadata, CM extends BaseMetadata>(\n  options: UseThreadsOptions<TM> = {}\n): ThreadsAsyncSuccess<TM, CM> {\n  // Throw error if we're calling this hook server side\n  ensureNotServerSide();\n\n  const client = useClient();\n  const room = useRoom();\n\n  const { store } = getRoomExtrasForClient<TM, CM>(client);\n  const queryKey = makeRoomThreadsQueryKey(room.id, options.query);\n\n  use(store.outputs.loadingRoomThreads.getOrCreate(queryKey).waitUntilLoaded());\n\n  const result = useThreads<TM, CM>(options);\n  assert(!result.error, \"Did not expect error\");\n  assert(!result.isLoading, \"Did not expect loading\");\n  return result;\n}\n\nfunction selectorFor_useAttachmentUrl(\n  state: AsyncResult<string | undefined> | undefined\n): AttachmentUrlAsyncResult {\n  if (state === undefined || state?.isLoading) {\n    return state ?? { isLoading: true };\n  }\n\n  if (state.error) {\n    return state;\n  }\n\n  // For now `useAttachmentUrl` doesn't support a custom resolver so this case\n  // will never happen as `getAttachmentUrl` will either return a URL or throw.\n  // But we might decide to offer a custom resolver in the future to allow\n  // self-hosting attachments.\n  assert(state.data !== undefined, \"Unexpected missing attachment URL\");\n\n  return {\n    isLoading: false,\n    url: state.data,\n  };\n}\n\n/**\n * Returns a presigned URL for an attachment by its ID.\n *\n * @example\n * const { url, error, isLoading } = useAttachmentUrl(\"at_xxx\");\n */\nfunction useAttachmentUrl(attachmentId: string): AttachmentUrlAsyncResult {\n  const room = useRoom();\n  return useRoomAttachmentUrl(attachmentId, room.id);\n}\n\n/**\n * @private For internal use only. Do not rely on this hook. Use `useAttachmentUrl` instead.\n */\nfunction useRoomAttachmentUrl(\n  attachmentId: string,\n  roomId: string\n): AttachmentUrlAsyncResult {\n  const client = useClient();\n  const store =\n    client[kInternal].httpClient.getOrCreateAttachmentUrlsStore(roomId);\n\n  const getAttachmentUrlState = useCallback(\n    () => store.getItemState(attachmentId),\n    [store, attachmentId]\n  );\n\n  useEffect(() => {\n    void store.enqueue(attachmentId);\n  }, [store, attachmentId]);\n\n  return useSyncExternalStoreWithSelector(\n    store.subscribe,\n    getAttachmentUrlState,\n    getAttachmentUrlState,\n    selectorFor_useAttachmentUrl,\n    shallow\n  );\n}\n\n/**\n * Returns a presigned URL for an attachment by its ID.\n *\n * @example\n * const { url } = useAttachmentUrl(\"at_xxx\");\n */\nfunction useAttachmentUrlSuspense(attachmentId: string) {\n  const room = useRoom();\n  const { attachmentUrlsStore } = room[kInternal];\n\n  const getAttachmentUrlState = useCallback(\n    () => attachmentUrlsStore.getItemState(attachmentId),\n    [attachmentUrlsStore, attachmentId]\n  );\n  const attachmentUrlState = getAttachmentUrlState();\n\n  if (!attachmentUrlState || attachmentUrlState.isLoading) {\n    throw attachmentUrlsStore.enqueue(attachmentId);\n  }\n\n  if (attachmentUrlState.error) {\n    throw attachmentUrlState.error;\n  }\n\n  const state = useSyncExternalStore(\n    attachmentUrlsStore.subscribe,\n    getAttachmentUrlState,\n    getAttachmentUrlState\n  );\n  assert(state !== undefined, \"Unexpected missing state\");\n  assert(!state.isLoading, \"Unexpected loading state\");\n  assert(!state.error, \"Unexpected error state\");\n  return {\n    isLoading: false,\n    url: state.data,\n    error: undefined,\n  } as const;\n}\n\n/**\n * @private For internal use only. Do not rely on this hook.\n */\nfunction useRoomPermissions(roomId: string) {\n  const client = useClient();\n  const store = getRoomExtrasForClient(client).store;\n  return useSignal(store.permissionHints.getPermissionForRoom(roomId));\n}\n\n/**\n * Creates a RoomProvider and a set of typed hooks to use in your app. Note\n * that any RoomProvider created in this way does not need to be nested in\n * LiveblocksProvider, as it already has access to the client.\n */\nexport function createRoomContext<\n  P extends JsonObject = DP,\n  S extends LsonObject = DS,\n  U extends BaseUserMeta = DU,\n  E extends Json = DE,\n  TM extends BaseMetadata = DTM,\n  CM extends BaseMetadata = DCM,\n>(client: OpaqueClient): RoomContextBundle<P, S, U, E, TM, CM> {\n  return getOrCreateRoomContextBundle<P, S, U, E, TM, CM>(client);\n}\n\ntype TypedBundle = RoomContextBundle<DP, DS, DU, DE, DTM, DCM>;\n\n/**\n * Makes a Room available in the component hierarchy below.\n * Joins the room when the component is mounted, and automatically leaves\n * the room when the component is unmounted.\n */\nconst _RoomProvider: TypedBundle[\"RoomProvider\"] = RoomProvider;\n\n/**\n * Returns a callback that lets you broadcast custom events to other users in the room\n *\n * @example\n * const broadcast = useBroadcastEvent();\n *\n * broadcast({ type: \"CUSTOM_EVENT\", data: { x: 0, y: 0 } });\n */\nconst _useBroadcastEvent: TypedBundle[\"useBroadcastEvent\"] = useBroadcastEvent;\n\n/**\n * Get informed when users enter or leave the room, as an event.\n *\n * @example\n * useOthersListener({ type, user, others }) => {\n *   if (type === 'enter') {\n *     // `user` has joined the room\n *   } else if (type === 'leave') {\n *     // `user` has left the room\n *   }\n * })\n */\nconst _useOthersListener: TypedBundle[\"useOthersListener\"] = useOthersListener;\n\n/**\n * Returns the Room of the nearest RoomProvider above in the React component\n * tree.\n */\nconst _useRoom: TypedBundle[\"useRoom\"] = useRoom;\n\n/**\n * Returns whether the hook is called within a RoomProvider context.\n *\n * @example\n * const isInsideRoom = useIsInsideRoom();\n */\nconst _useIsInsideRoom: TypedBundle[\"useIsInsideRoom\"] = useIsInsideRoom;\n\n/**\n * Returns a function that adds a reaction from a comment.\n *\n * @example\n * const addReaction = useAddReaction();\n * addReaction({ threadId: \"th_xxx\", commentId: \"cm_xxx\", emoji: \"\" })\n */\nconst _useAddReaction: TypedBundle[\"useAddReaction\"] = useAddReaction;\n\n/**\n * Create a callback function that lets you mutate Liveblocks state.\n *\n * The first argument that gets passed into your callback will be\n * a \"mutation context\", which exposes the following:\n *\n *   - `storage` - The mutable Storage root.\n *                 You can mutate any Live structures with this, for example:\n *                 `storage.get('layers').get('layer1').set('fill', 'red')`\n *\n *   - `setMyPresence` - Call this with a new (partial) Presence value.\n *\n *   - `self` - A read-only version of the latest self, if you need it to\n *              compute the next state.\n *\n *   - `others` - A read-only version of the latest others list, if you\n *                need it to compute the next state.\n *\n * useMutation is like React's useCallback, except that the first argument\n * that gets passed into your callback will be a \"mutation context\".\n *\n * If you want get access to the immutable root somewhere in your mutation,\n * you can use `storage.ToImmutable()`.\n *\n * @example\n * const fillLayers = useMutation(\n *   ({ storage }, color: Color) => {\n *     ...\n *   },\n *   [],\n * );\n *\n * fillLayers('red');\n *\n * const deleteLayers = useMutation(\n *   ({ storage }) => {\n *     ...\n *   },\n *   [],\n * );\n *\n * deleteLayers();\n */\nconst _useMutation: TypedBundle[\"useMutation\"] = useMutation;\n\n/**\n * Returns a function that creates a thread with an initial comment, and optionally some metadata.\n *\n * @example\n * const createThread = useCreateThread();\n * createThread({ body: {}, metadata: {} });\n */\nconst _useCreateThread: TypedBundle[\"useCreateThread\"] = useCreateThread;\n\n/**\n * Returns a function that deletes a thread and its associated comments.\n * Only the thread creator can delete a thread, it will throw otherwise.\n *\n * @example\n * const deleteThread = useDeleteThread();\n * deleteThread(\"th_xxx\");\n */\nconst _useDeleteThread: TypedBundle[\"useDeleteThread\"] = useDeleteThread;\n\n/**\n * Returns a function that edits a thread's metadata.\n * To delete an existing metadata property, set its value to `null`.\n *\n * @example\n * const editThreadMetadata = useEditThreadMetadata();\n * editThreadMetadata({ threadId: \"th_xxx\", metadata: {} })\n */\nconst _useEditThreadMetadata: TypedBundle[\"useEditThreadMetadata\"] =\n  useEditThreadMetadata;\n\n/**\n * Returns a function that adds a comment to a thread.\n *\n * @example\n * const createComment = useCreateComment();\n * createComment({ threadId: \"th_xxx\", body: {} });\n */\nconst _useCreateComment: TypedBundle[\"useCreateComment\"] = useCreateComment;\n\n/**\n * Returns a function that edits a comment.\n *\n * @example\n * const editComment = useEditComment()\n * editComment({ threadId: \"th_xxx\", commentId: \"cm_xxx\", body: {} })\n */\nconst _useEditComment: TypedBundle[\"useEditComment\"] = useEditComment;\n\n/**\n * Returns a function that edits a comment's metadata.\n * To delete an existing metadata property, set its value to `null`.\n *\n * @example\n * const editCommentMetadata = useEditCommentMetadata();\n * editCommentMetadata({ threadId: \"th_xxx\", commentId: \"cm_xxx\", metadata: { tag: \"important\", externalId: 1234  } })\n */\nconst _useEditCommentMetadata: TypedBundle[\"useEditCommentMetadata\"] =\n  useEditCommentMetadata;\n\n/**\n * useEventListener is a React hook that allows you to respond to events broadcast\n * by other users in the room.\n *\n * The `user` argument will indicate which `User` instance sent the message.\n * This will be equal to one of the others in the room, but it can be `null`\n * in case this event was broadcasted from the server.\n *\n * @example\n * useEventListener(({ event, user, connectionId }) => {\n * //                         ^^^^ Will be Client A\n *   if (event.type === \"CUSTOM_EVENT\") {\n *     // Do something\n *   }\n * });\n */\nconst _useEventListener: TypedBundle[\"useEventListener\"] = useEventListener;\n\n/**\n * Returns the presence of the current user of the current room, and a function to update it.\n * It is different from the setState function returned by the useState hook from\n * You don't need to pass the full presence object to update it.\n *\n * @example\n * const [myPresence, updateMyPresence] = useMyPresence();\n * updateMyPresence({ x: 0 });\n * updateMyPresence({ y: 0 });\n *\n * // At the next render, \"myPresence\" will be equal to \"{ x: 0, y: 0 }\"\n */\nconst _useMyPresence: TypedBundle[\"useMyPresence\"] = useMyPresence;\n\n/**\n * Related to useOthers(), but optimized for selecting only \"subsets\" of\n * others. This is useful for performance reasons in particular, because\n * selecting only a subset of users also means limiting the number of\n * re-renders that will be triggered.\n *\n * @example\n * const avatars = useOthersMapped(user => user.info.avatar);\n * //    ^^^^^^^\n * //    { connectionId: number; data: string }[]\n *\n * The selector function you pass to useOthersMapped() is called an \"item\n * selector\", and operates on a single user at a time. If you provide an\n * (optional) \"item comparison\" function, it will be used to compare each\n * item pairwise.\n *\n * For example, to select multiple properties:\n *\n * @example\n * const avatarsAndCursors = useOthersMapped(\n *   user => [u.info.avatar, u.presence.cursor],\n *   shallow,  // \n * );\n */\nconst _useOthersMapped: TypedBundle[\"useOthersMapped\"] = useOthersMapped;\n\n/**\n * Related to useOthers(), but optimized for selecting only \"subsets\" of\n * others. This is useful for performance reasons in particular, because\n * selecting only a subset of users also means limiting the number of\n * re-renders that will be triggered.\n *\n * @example\n * const avatars = useOthersMapped(user => user.info.avatar);\n * //    ^^^^^^^\n * //    { connectionId: number; data: string }[]\n *\n * The selector function you pass to useOthersMapped() is called an \"item\n * selector\", and operates on a single user at a time. If you provide an\n * (optional) \"item comparison\" function, it will be used to compare each\n * item pairwise.\n *\n * For example, to select multiple properties:\n *\n * @example\n * const avatarsAndCursors = useOthersMapped(\n *   user => [u.info.avatar, u.presence.cursor],\n *   shallow,  // \n * );\n */\nconst _useOthersMappedSuspense: TypedBundle[\"suspense\"][\"useOthersMapped\"] =\n  useOthersMappedSuspense;\n\n/**\n * Returns the threads within the current room.\n *\n * @example\n * const { threads, error, isLoading } = useThreads();\n */\nconst _useThreads: TypedBundle[\"useThreads\"] = useThreads;\n\n/**\n * Returns the result of searching comments by text in the current room. The result includes the id and the plain text content of the matched comments along with the parent thread id of the comment.\n *\n * @example\n * const { results, error, isLoading } = useSearchComments({ query: { text: \"hello\"} });\n */\nconst _useSearchComments: TypedBundle[\"useSearchComments\"] = useSearchComments;\n\n/**\n * Returns the threads within the current room.\n *\n * @example\n * const { threads } = useThreads();\n */\nconst _useThreadsSuspense: TypedBundle[\"suspense\"][\"useThreads\"] =\n  useThreadsSuspense;\n\n/**\n * Returns the user's subscription settings for the current room\n * and a function to update them.\n *\n * @example\n * const [{ settings }, updateSettings] = useRoomSubscriptionSettings();\n */\nconst _useRoomSubscriptionSettings: TypedBundle[\"useRoomSubscriptionSettings\"] =\n  useRoomSubscriptionSettings;\n\n/**\n * Returns the user's subscription settings for the current room\n * and a function to update them.\n *\n * @example\n * const [{ settings }, updateSettings] = useRoomSubscriptionSettings();\n */\nconst _useRoomSubscriptionSettingsSuspense: TypedBundle[\"suspense\"][\"useRoomSubscriptionSettings\"] =\n  useRoomSubscriptionSettingsSuspense;\n\n/**\n * (Private beta) Returns a history of versions of the current room.\n *\n * @example\n * const { versions, error, isLoading } = useHistoryVersions();\n */\nconst _useHistoryVersions: TypedBundle[\"useHistoryVersions\"] =\n  useHistoryVersions;\n\n/**\n * (Private beta) Returns a history of versions of the current room.\n *\n * @example\n * const { versions } = useHistoryVersions();\n */\nconst _useHistoryVersionsSuspense: TypedBundle[\"suspense\"][\"useHistoryVersions\"] =\n  useHistoryVersionsSuspense;\n\n/**\n * Given a connection ID (as obtained by using `useOthersConnectionIds`), you\n * can call this selector deep down in your component stack to only have the\n * component re-render if properties for this particular user change.\n *\n * @example\n * // Returns only the selected values re-renders whenever that selection changes)\n * const { x, y } = useOther(2, user => user.presence.cursor);\n */\nconst _useOther: TypedBundle[\"useOther\"] = useOther;\n\n/**\n * Returns an array with information about all the users currently connected in\n * the room (except yourself).\n *\n * @example\n * const others = useOthers();\n *\n * // Example to map all cursors in JSX\n * return (\n *   <>\n *     {others.map((user) => {\n *        if (user.presence.cursor == null) {\n *          return null;\n *        }\n *        return <Cursor key={user.connectionId} cursor={user.presence.cursor} />\n *      })}\n *   </>\n * )\n */\nfunction _useOthers(): readonly User<DP, DU>[];\n/**\n * Extract arbitrary data based on all the users currently connected in the\n * room (except yourself).\n *\n * The selector function will get re-evaluated any time a user enters or\n * leaves the room, as well as whenever their presence data changes.\n *\n * The component that uses this hook will automatically re-render if your\n * selector function returns a different value from its previous run.\n *\n * By default `useOthers()` uses strict `===` to check for equality. Take\n * extra care when returning a computed object or list, for example when you\n * return the result of a .map() or .filter() call from the selector. In\n * those cases, you'll probably want to use a `shallow` comparison check.\n *\n * @example\n * const avatars = useOthers(users => users.map(u => u.info.avatar), shallow);\n * const cursors = useOthers(users => users.map(u => u.presence.cursor), shallow);\n * const someoneIsTyping = useOthers(users => users.some(u => u.presence.isTyping));\n *\n */\nfunction _useOthers<T>(\n  selector: (others: readonly User<DP, DU>[]) => T,\n  isEqual?: (prev: T, curr: T) => boolean\n): T;\nfunction _useOthers(...args: any[]) {\n  return useOthers(...(args as []));\n}\n\n/**\n * Given a connection ID (as obtained by using `useOthersConnectionIds`), you\n * can call this selector deep down in your component stack to only have the\n * component re-render if properties for this particular user change.\n *\n * @example\n * // Returns only the selected values re-renders whenever that selection changes)\n * const { x, y } = useOther(2, user => user.presence.cursor);\n */\nconst _useOtherSuspense: TypedBundle[\"suspense\"][\"useOther\"] = useOtherSuspense;\n\n/**\n * Returns an array with information about all the users currently connected in\n * the room (except yourself).\n *\n * @example\n * const others = useOthers();\n *\n * // Example to map all cursors in JSX\n * return (\n *   <>\n *     {others.map((user) => {\n *        if (user.presence.cursor == null) {\n *          return null;\n *        }\n *        return <Cursor key={user.connectionId} cursor={user.presence.cursor} />\n *      })}\n *   </>\n * )\n */\nfunction _useOthersSuspense(): readonly User<DP, DU>[];\n/**\n * Extract arbitrary data based on all the users currently connected in the\n * room (except yourself).\n *\n * The selector function will get re-evaluated any time a user enters or\n * leaves the room, as well as whenever their presence data changes.\n *\n * The component that uses this hook will automatically re-render if your\n * selector function returns a different value from its previous run.\n *\n * By default `useOthers()` uses strict `===` to check for equality. Take\n * extra care when returning a computed object or list, for example when you\n * return the result of a .map() or .filter() call from the selector. In\n * those cases, you'll probably want to use a `shallow` comparison check.\n *\n * @example\n * const avatars = useOthers(users => users.map(u => u.info.avatar), shallow);\n * const cursors = useOthers(users => users.map(u => u.presence.cursor), shallow);\n * const someoneIsTyping = useOthers(users => users.some(u => u.presence.isTyping));\n *\n */\nfunction _useOthersSuspense<T>(\n  selector: (others: readonly User<DP, DU>[]) => T,\n  isEqual?: (prev: T, curr: T) => boolean\n): T;\nfunction _useOthersSuspense(...args: any[]) {\n  return useOthersSuspense(...(args as []));\n}\n\n/**\n * Extract arbitrary data from the Liveblocks Storage state, using an\n * arbitrary selector function.\n *\n * The selector function will get re-evaluated any time something changes in\n * Storage. The value returned by your selector function will also be the\n * value returned by the hook.\n *\n * The `root` value that gets passed to your selector function is\n * a immutable/readonly version of your Liveblocks storage root.\n *\n * The component that uses this hook will automatically re-render if the\n * returned value changes.\n *\n * By default `useStorage()` uses strict `===` to check for equality. Take\n * extra care when returning a computed object or list, for example when you\n * return the result of a .map() or .filter() call from the selector. In\n * those cases, you'll probably want to use a `shallow` comparison check.\n */\nconst _useStorage: TypedBundle[\"useStorage\"] = useStorage;\n\n/**\n * Extract arbitrary data from the Liveblocks Storage state, using an\n * arbitrary selector function.\n *\n * The selector function will get re-evaluated any time something changes in\n * Storage. The value returned by your selector function will also be the\n * value returned by the hook.\n *\n * The `root` value that gets passed to your selector function is\n * a immutable/readonly version of your Liveblocks storage root.\n *\n * The component that uses this hook will automatically re-render if the\n * returned value changes.\n *\n * By default `useStorage()` uses strict `===` to check for equality. Take\n * extra care when returning a computed object or list, for example when you\n * return the result of a .map() or .filter() call from the selector. In\n * those cases, you'll probably want to use a `shallow` comparison check.\n */\nconst _useStorageSuspense: TypedBundle[\"suspense\"][\"useStorage\"] =\n  useStorageSuspense;\n\n/**\n * Gets the current user once it is connected to the room.\n *\n * @example\n * const me = useSelf();\n * if (me !== null) {\n *   const { x, y } = me.presence.cursor;\n * }\n */\nfunction _useSelf(): User<DP, DU> | null;\n/**\n * Extract arbitrary data based on the current user.\n *\n * The selector function will get re-evaluated any time your presence data\n * changes.\n *\n * The component that uses this hook will automatically re-render if your\n * selector function returns a different value from its previous run.\n *\n * By default `useSelf()` uses strict `===` to check for equality. Take extra\n * care when returning a computed object or list, for example when you return\n * the result of a .map() or .filter() call from the selector. In those\n * cases, you'll probably want to use a `shallow` comparison check.\n *\n * Will return `null` while Liveblocks isn't connected to a room yet.\n *\n * @example\n * const cursor = useSelf(me => me.presence.cursor);\n * if (cursor !== null) {\n *   const { x, y } = cursor;\n * }\n *\n */\nfunction _useSelf<T>(\n  selector: (me: User<DP, DU>) => T,\n  isEqual?: (prev: T, curr: T) => boolean\n): T | null;\nfunction _useSelf(...args: any[]) {\n  return useSelf(...(args as []));\n}\n\n/**\n * Gets the current user once it is connected to the room.\n *\n * @example\n * const me = useSelf();\n * const { x, y } = me.presence.cursor;\n */\nfunction _useSelfSuspense(): User<DP, DU>;\n/**\n * Extract arbitrary data based on the current user.\n *\n * The selector function will get re-evaluated any time your presence data\n * changes.\n *\n * The component that uses this hook will automatically re-render if your\n * selector function returns a different value from its previous run.\n *\n * By default `useSelf()` uses strict `===` to check for equality. Take extra\n * care when returning a computed object or list, for example when you return\n * the result of a .map() or .filter() call from the selector. In those\n * cases, you'll probably want to use a `shallow` comparison check.\n *\n * @example\n * const cursor = useSelf(me => me.presence.cursor);\n * const { x, y } = cursor;\n *\n */\nfunction _useSelfSuspense<T>(\n  selector: (me: User<DP, DU>) => T,\n  isEqual?: (prev: T, curr: T) => boolean\n): T;\nfunction _useSelfSuspense(...args: any[]) {\n  return useSelfSuspense(...(args as []));\n}\n\n/**\n * Returns the mutable (!) Storage root. This hook exists for\n * backward-compatible reasons.\n *\n * @example\n * const [root] = useStorageRoot();\n */\nconst _useStorageRoot: TypedBundle[\"useStorageRoot\"] = useStorageRoot;\n\n/**\n * useUpdateMyPresence is similar to useMyPresence but it only returns the function to update the current user presence.\n * If you don't use the current user presence in your component, but you need to update it (e.g. live cursor), it's better to use useUpdateMyPresence to avoid unnecessary renders.\n *\n * @example\n * const updateMyPresence = useUpdateMyPresence();\n * updateMyPresence({ x: 0 });\n * updateMyPresence({ y: 0 });\n *\n * // At the next render, the presence of the current user will be equal to \"{ x: 0, y: 0 }\"\n */\nconst _useUpdateMyPresence: TypedBundle[\"useUpdateMyPresence\"] =\n  useUpdateMyPresence;\n\nexport {\n  _RoomProvider as RoomProvider,\n  _useAddReaction as useAddReaction,\n  useAddRoomCommentReaction,\n  useAttachmentUrl,\n  useAttachmentUrlSuspense,\n  _useBroadcastEvent as useBroadcastEvent,\n  useCanRedo,\n  useCanUndo,\n  _useCreateComment as useCreateComment,\n  useCreateRoomComment,\n  useCreateRoomThread,\n  useCreateTextMention,\n  _useCreateThread as useCreateThread,\n  useDeleteComment,\n  useDeleteRoomComment,\n  useDeleteRoomThread,\n  useDeleteTextMention,\n  _useDeleteThread as useDeleteThread,\n  _useEditComment as useEditComment,\n  _useEditCommentMetadata as useEditCommentMetadata,\n  useEditRoomComment,\n  useEditRoomCommentMetadata,\n  useEditRoomThreadMetadata,\n  _useEditThreadMetadata as useEditThreadMetadata,\n  _useEventListener as useEventListener,\n  useHistory,\n  useHistoryVersionData,\n  _useHistoryVersions as useHistoryVersions,\n  _useHistoryVersionsSuspense as useHistoryVersionsSuspense,\n  _useIsInsideRoom as useIsInsideRoom,\n  useLostConnectionListener,\n  useMarkRoomThreadAsRead,\n  useMarkRoomThreadAsResolved,\n  useMarkRoomThreadAsUnresolved,\n  useMarkThreadAsRead,\n  useMarkThreadAsResolved,\n  useMarkThreadAsUnresolved,\n  useMentionSuggestionsCache,\n  _useMutation as useMutation,\n  _useMyPresence as useMyPresence,\n  _useOther as useOther,\n  _useOthers as useOthers,\n  useOthersConnectionIds,\n  useOthersConnectionIdsSuspense,\n  _useOthersListener as useOthersListener,\n  _useOthersMapped as useOthersMapped,\n  _useOthersMappedSuspense as useOthersMappedSuspense,\n  _useOthersSuspense as useOthersSuspense,\n  _useOtherSuspense as useOtherSuspense,\n  useRedo,\n  useRemoveReaction,\n  useRemoveRoomCommentReaction,\n  useReportTextEditor,\n  useResolveMentionSuggestions,\n  _useRoom as useRoom,\n  useRoomAttachmentUrl,\n  useRoomPermissions,\n  _useRoomSubscriptionSettings as useRoomSubscriptionSettings,\n  _useRoomSubscriptionSettingsSuspense as useRoomSubscriptionSettingsSuspense,\n  useRoomThreadSubscription,\n  _useSearchComments as useSearchComments,\n  _useSelf as useSelf,\n  _useSelfSuspense as useSelfSuspense,\n  useStatus,\n  _useStorage as useStorage,\n  _useStorageRoot as useStorageRoot,\n  _useStorageSuspense as useStorageSuspense,\n  useSubscribeToRoomThread,\n  useSubscribeToThread,\n  _useThreads as useThreads,\n  _useThreadsSuspense as useThreadsSuspense,\n  useThreadSubscription,\n  useUndo,\n  useUnsubscribeFromRoomThread,\n  useUnsubscribeFromThread,\n  _useUpdateMyPresence as useUpdateMyPresence,\n  useUpdateRoomSubscriptionSettings,\n  useYjsProvider,\n};\n","import type { BaseMetadata } from \"@liveblocks/client\";\nimport { useEffect } from \"react\";\n\nimport type { ThreadsAsyncResult } from \"./types\";\n\nfunction handleScrollToCommentOnLoad(\n  shouldScrollOnLoad: boolean,\n  state: ThreadsAsyncResult<BaseMetadata, BaseMetadata>\n) {\n  if (shouldScrollOnLoad === false) return;\n\n  if (!state.threads) return;\n\n  const isWindowDefined = typeof window !== \"undefined\";\n  if (!isWindowDefined) return;\n\n  const hash = window.location.hash;\n  const commentId = hash.slice(1);\n\n  // If the hash is not a comment ID, we do not scroll to it\n  if (!commentId.startsWith(\"cm_\")) return;\n\n  // If a comment with the ID does not exist in the DOM, we do not scroll to it\n  const comment = document.getElementById(commentId);\n  if (comment === null) return;\n\n  const comments = state.threads.flatMap((thread) => thread.comments);\n  const isCommentInThreads = comments.some(\n    (comment) => comment.id === commentId\n  );\n\n  // If the comment is not in the threads for this hook, we do not scroll to it\n  if (!isCommentInThreads) return;\n\n  comment.scrollIntoView();\n}\n\n/**\n * Scroll to the comment with the ID in the hash of the URL based on whether\n * the query is loading and whether the hook should scroll to the comment on load.\n */\nexport function useScrollToCommentOnLoadEffect(\n  shouldScrollOnLoad: boolean,\n  state: ThreadsAsyncResult<BaseMetadata, BaseMetadata>\n) {\n  useEffect(\n    () => {\n      handleScrollToCommentOnLoad(shouldScrollOnLoad, state);\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps -- We only want to run this effect once\n    [state.isLoading]\n  );\n}\n"],"names":["useEffect","RegisterAiKnowledge","useEffect","layerKey","RegisterAiTool","useEffect","useRef","nextSelection","console","DefaultMap","kInternal","raise","shallow","useCallback","useEffect","useMemo","useState","useSyncExternalStore","useMemo","useMemo","batch","getSubscriptionKey","kInternal","MutableSignal","nanoid","MutableSignal","MutableSignal","autoRetry","MutableSignal","getSubscriptionKey","updates","batch","kInternal","nanoid","threads","existingComment","existingReaction","identity","useEffect","kInternal","console","DefaultMap","useInboxNotificationThread","useMarkInboxNotificationAsRead","useMarkAllInboxNotificationsAsRead","useDeleteInboxNotification","useDeleteAllInboxNotifications","useUpdateNotificationSettings","LiveblocksProvider","shallow","useCallback","raise","settings","useMemo","useSyncExternalStore","useClient","useSyncStatus","useState","shallow","assert","console","DefaultMap","getSubscriptionKey","HttpError","kInternal","makePoller","stableStringify","useCallback","useEffect","useMemo","useRef","useState","useSyncExternalStore","useEffect","comment","jsx","noop","identity","kInternal","_extras","_bundles","HttpError","console","DefaultMap","makePoller","useState","useCallback","useEffect","room","useSyncExternalStore","useRef","shallow","other","rootOrNull","useMemo","stableStringify","result","metadata","comment","inboxNotification","getSubscriptionKey","assert"],"mappings":"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"}},
    {"offset": {"line": 4746, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/MAHARSHI%20NATH/OneDrive/Documents/sudoku/node_modules/%40liveblocks/react/src/version.ts","file:///C:/Users/MAHARSHI%20NATH/OneDrive/Documents/sudoku/node_modules/%40liveblocks/react/src/ClientSideSuspense.tsx"],"sourcesContent":["declare const __VERSION__: string;\ndeclare const TSUP_FORMAT: string;\n\nexport const PKG_NAME = \"@liveblocks/react\";\nexport const PKG_VERSION = typeof __VERSION__ === \"string\" && __VERSION__;\nexport const PKG_FORMAT = typeof TSUP_FORMAT === \"string\" && TSUP_FORMAT;\n","import type { ReactNode } from \"react\";\nimport { Suspense, useEffect, useState } from \"react\";\n\ntype Props = {\n  fallback: ReactNode;\n  children: (() => ReactNode | undefined) | ReactNode | undefined;\n};\n\n/**\n * Almost like a normal <Suspense> component, except that for server-side\n * renders, the fallback will be used.\n *\n * The child props will have to be provided in a function, i.e. change:\n *\n *   <Suspense fallback={<Loading />}>\n *     <MyRealComponent a={1} />\n *   </Suspense>\n *\n * To:\n *\n *   <ClientSideSuspense fallback={<Loading />}>\n *     <MyRealComponent a={1} />\n *   </ClientSideSuspense>\n *\n */\nexport function ClientSideSuspense(props: Props) {\n  const [mounted, setMounted] = useState(false);\n\n  useEffect(() => {\n    // Effects are never executed on the server side. The point of this is to\n    // delay the flipping of this boolean until after hydration has happened.\n    setMounted(true);\n  }, []);\n\n  return (\n    <Suspense fallback={props.fallback}>\n      {mounted\n        ? typeof props.children === \"function\"\n          ? props.children()\n          : props.children\n        : props.fallback}\n    </Suspense>\n  );\n}\n"],"names":[],"mappings":";;;;;;;;;;;ACCA,SAAS,UAAU,WAAW,gBAAgB;AAkC1C;;ADhCG,IAAM,WAAW;AACjB,IAAM,cAAiD;AACvD,IAAM,aAAgD;;;ACoBtD,SAAS,mBAAmB,KAAA,EAAc;IAC/C,MAAM,CAAC,SAAS,UAAU,CAAA,OAAI,iNAAA,EAAS,KAAK;IAE5C,IAAA,kNAAA,EAAU,MAAM;QAGd,WAAW,IAAI;IACjB,GAAG,CAAC,CAAC;IAEL,OACE,aAAA,GAAA,IAAA,8NAAA,EAAC,iNAAA,EAAA;QAAS,UAAU,MAAM,QAAA;QACvB,UAAA,UACG,OAAO,MAAM,QAAA,KAAa,aACxB,MAAM,QAAA,CAAS,IACf,MAAM,QAAA,GACR,MAAM,QAAA;IAAA,CACZ;AAEJ"}}]
}